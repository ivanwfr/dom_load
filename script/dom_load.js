javascript: (function () { /* eslint-disable-line no-labels, no-unused-labels */
"use strict";
/* jshint esversion: 9, boss:true {{{*/
/* globals send_IPC dom_ipc t_load */
/* globals console, alert, window, document, setTimeout */
/* eslint-disable no-unused-labels */
/* eslint-disable no-alert */
/* eslint-disable no-unused-vars */
/*}}}*/
/* DOM_LOAD_ID {{{*/
let DOM_LOAD_ID         = "dom_load";
let DOM_LOAD_TAG        =  DOM_LOAD_ID +" (221201:14h:53)";
let DOM_HOST_CSS_ID     = "dom_host_css";
let DOM_TOOLS_CSS_ID    = "dom_tools_css";
let DOM_GRID_CSS_ID     = "dom_grid_css";
let DOM_TOOLS_HTML_ID   = "dom_tools_html";
/*}}}*/
/* TOOLS ALREADY LOADED {{{*/
if((typeof DOM_TOOLS_JS_ID) != "undefined") {
    let   msg = "*** TOOLS ALREADY LOADED";
    try { msg += "\n*** DOM_TOOLS_JS_ID\n*** "+DOM_LOAD_ID ; alert(msg); } catch(ex) { console.log(msg); }
    return null;
}
/*}}}*/
/* CONSOLE TEMPLATE TO BE IMPLEMENTED BY EMBEDDING LAYER {{{*/
let   DOUBLE_QUOTE  = String.fromCharCode(34);
let   LF            = String.fromCharCode(10);
let   CR            = String.fromCharCode(13);
let   BACKSLASH     = String.fromCharCode(92);
let   FORESLASH     = String.fromCharCode(47);
let   CS            = "font-size:150%; font-weight:900; border:1px solid gray; color:yellow; background-color:navy; padding:0 .5em 0 .5em; border-radius:1em 1em 1em 1em; background:linear-gradient(to bottom, #000 0%, #223 50%, #000 100%);";
let   console_clear = function(  msg=null) { try { console.clear(); if(msg) console.warn("%c=== CLEARED BY: "+msg,CS);                 } catch(ex) {} };
let   console_dir   = function(o,msg=null) { try {                  if(msg) console.log (          "%c"+msg      ,CS); console.dir(o); } catch(ex) {} };
let   console_log   = function(  msg     ) { try {                          console.log (               msg         );                 } catch(ex) {} };
let   console_warn  = function(  msg=null) { try {                          console.warn(               msg         );                 } catch(ex) {} };
/*}}}*/

  /**    1 TOOLS  HTML dom_tools_html_data {{{*/
/*
../script/dom_tools.html
*/
let dom_tools_html_data = `
<!--INLINE{{{-->
<!DOCTYPE html>
 <span id = "dom_tools_html_tag" style="display:none">dom_tools_html (221124:17h:59)</span>

 <!-- hotspot {{{-->
 <div   id="hotspot"       class="hotspot_frame"            title="hotspot">
  <div  id="hotwave"       class="hotwave">
   <div id="hotring"       class="hotring">&nbsp;</div>
  </div>
  <div id="hotspot_c">&#x00BB;</div>
 </div>
 <!--}}}-->
 <!-- headsup {{{ -->
 <div id="headsup"         class="transcript hidden"        title="headsup">

  <em  id="user_lang"      class="toolbag_button cc9"       title="user_lang">&nbsp;</em>
  <em  id="dom_freeze"     class="toolbag_button cc9"       title="dom_freeze">&#x2744;</em>

  <em  id="thumb_p"                                         title="thumb_p">&#x0020;</em>
  <em  id="theme_dark"     class="toolbag_button cc8"       title="theme_dark">LIGHT</em>
  <em  id="wording"        class="toolbag_button cc3"       title="wording">WORDING</em>
  <em  id="anchor_freeze"  class="toolbag_button cc9"       title="anchor_freeze">&#x26D4;</em>
  <em  id="containers_hi"  class="toolbag_button cc9"       title="containers_hi">&#x00A7;</em>
  <em  id="overflow_visi"  class="toolbag_button cc9"       title="overflow_visi">&nbsp;</em>
  <em  id="scroll_smooth"  class="toolbag_button cc9"       title="scroll_smooth">&nbsp;</em>

  <em  id="details_close"  class="toolbag_button cc9"       title="details_close">&#x25B2;</em>
  <em  id="details_open"   class="toolbag_button cc9"       title="details_open" >&#x25BC;</em>
  <em  id="details_radio"  class="toolbag_button cc9"       title="details_radio">&nbsp;</em>

  <em  id="tools_tier2"    class="toolbag_button cc9"       title="tools_tier2">&#x2630;</em>

<!--{{{
  <em  id="show_seekzone"  class="toolbag_button cc9"       title="show_seekzone">&nbsp;</em>
  <em  id="pin_seekspot"   class="toolbag_button cc9"       title="pin_seekspot">&nbsp;</em>
  <em  id="log_seekspot"   class="toolbag_button cc9"       title="log_seekspot">&nbsp;</em>
}}}-->

  <em  id="remove_ads"     class="toolbag_button cc9"       title="remove_ads">&nbsp;</em>
  <em  id="split_wot"      class="toolbag_button cc9"       title="split_wot">&nbsp;</em>
  <em  id="lines_wot"      class="toolbag_button cc9"       title="lines_wot">&nbsp;</em>

 </div>
 <!-- }}} -->

 <!-- pat_bag {{{ -->
  <div id="pat_bag"           class="transcript hidden bag" title="PAT BAG"></div>
 <!-- }}} -->
 <!-- headsup_w {{{ -->
 <div    id="headsup_w"       class="transcript hidden"     title="headsup_w">
  <input id="words_filter"    type="text"                   title="words_filter"/>
  <em    id="words_exact"     class="toolbag_button cc3"    title="words_exact">&#x2261;</em>
  <em    id="words_segment"   class="toolbag_button cc4"    title="words_segment">&#x2282;</em>
  <em    id="words_head_tail" class="toolbag_button cc5"    title="words_head_tail">&#x2208;</em>
  <em    id="words_opcycle"   class="toolbag_button cc9"    title="words_opcycle">&#x27F3;</em>
  <em    id="words_recycle"   class="toolbag_button cc7"    title="words_recycle">&#x267B;</em>
  <em    id="words_bag_rot"   class="toolbag_button cc0"    title="words_bag_rot">&#x2026;</em>
  <em    id="words_drop_case" class="toolbag_button cc8"    title="words_drop_case">&nbsp;</em>
  <em    id="words_drop_ing"  class="toolbag_button cc8"    title="words_drop_ing">&nbsp;</em>
  <em    id="words_drop_s"    class="toolbag_button cc8"    title="words_drop_s">&nbsp;</em>
  <div   id="words_regex"     class="txt_log"               >words_regex</div>
 </div>
 <!-- }}} -->
 <!-- sel_bag {{{ -->
  <div id="sel_bag"           class="transcript hidden bag" title="sel_bag"><span class="seeker_handle"></span></div>
 <!-- }}} -->

 <!-- headsup_ds {{{ -->
 <div id="headsup_ds"         class="transcript hidden"     title="headsup_ds">
  <em  id="tools_trap"        class="toolbag_button"        title="tools_trap">&#x00BB;</em>
  <em  id="tools_scroll"      class="toolbag_button"        title="tools_scroll">&#x2693;</em>
  <em  id="site_or_page"      class="toolbag_button cc9"    title="site_or_page">&nbsp;</em>
  <em  id="mask_or_hide"      class="toolbag_button cc9"    title="mask_or_hide">&nbsp;</em>
  <em  id="edit_or_stage"     class="toolbag_button cc9"    title="edit_or_stage">&nbsp;</em>
  <em  id="dom_hide1_reset"   class="toolbag_button cc9"    title="dom_hide1_reset">&nbsp;</em>
  <em  id="dom_hide1_undo"    class="toolbag_button cc9"    title="dom_hide1_undo">…</em>
  <em  id="deny_or_allow"     class="toolbag_button cc8"    title="deny_or_allow">&nbsp;</em>
<!--{{{
  <em  id="targeteer"         class="toolbag_button cc9"    title="targeteer">&nbsp;</em>
  <em  id="target_01"         class="toolbag_button cc1"    title="target_01">&nbsp;</em>
  <em  id="target_02"         class="toolbag_button cc2"    title="target_02">&nbsp;</em>
  <em  id="target_03"         class="toolbag_button cc3"    title="target_03">&nbsp;</em>
}}}-->
 </div>
 <!-- }}} -->
 <!-- headsup_bw {{{ -->
 <div id="headsup_bw"          class="transcript hidden"    title="headsup_bw">
  <em id="headsup_bw_value"    class="cc10">BODY WIDTH</em><br>
  <em class="cc1"> 480</em><em class="cc2"> 640</em><em class="cc3"> 780</em><br>
  <em class="cc4"> 960</em><em class="cc5">1024</em><em class="cc6">1200</em><br>
  <em class="cc7">1440</em><em class="cc8">1600</em><em class="cc9">1980</em><br>
 </div>
 <!-- }}} -->
 <!-- headsup_bz {{{ -->
 <div id="headsup_bz"          class="transcript hidden"    title="headsup_bz">
  <em id="headsup_bz_value"     class="cc10">BODY ZOOM</em><br>
  <em class="cc1">  70%</em><em class="cc2" >  80%</em><em class="cc3">  90%</em><br>
  <em class="cc1"> 100%</em><em class="cc2" > 110%</em><em class="cc3"> 120%</em><br>
  <em class="cc1"> 130%</em><em class="cc2" > 150%</em><em class="cc3"> 160%</em><br>
  <em class="cc1"> 180%</em><em class="cc2" > 200%</em><em class="cc3"> 220%</em><br>
 </div>
 <!-- }}} -->
 <!-- headsup_fs {{{ -->
 <div id="headsup_fs"          class="transcript hidden"    title="headsup_fs">
  <em id="headsup_fs_value"     class="cc10">BODY FONT SIZE</em><br>
  <em class="cc1">  70%</em><em class="cc2" >  80%</em><em class="cc3">  90%</em><br>
  <em class="cc1"> 100%</em><em class="cc2" > 110%</em><em class="cc3"> 120%</em><br>
  <em class="cc1"> 130%</em><em class="cc2" > 140%</em><em class="cc3"> 150%</em><br>
  <em class="cc1"> 160%</em><em class="cc2" > 170%</em><em class="cc3"> 180%</em><br>
  <em class="cc1"> 190%</em><em class="cc2" > 200%</em><em class="cc3"> 210%</em><br>
 </div>
 <!-- }}} -->

 <!-- dom_traversal {{{ -->
 <div id="dom_traversal"   class="transcript hidden"        title="dom_traversal">
 <!-- NodeIterator TreeWalker childNodes tagNodes {{{ -->
  <em class = "toolbag_button cc5">NodeIterator</em><br>
  <em class = "toolbag_button cc6">TreeWalker</em><br>
  <em class = "toolbag_button cc7">childNodes</em><br>
  <em class = "toolbag_button cc7">tagNodes</em><br>

  <em  id="show_seekzone"  class="toolbag_button cc9"       title="show_seekzone">&nbsp;</em>
  <em  id="pin_seekspot"   class="toolbag_button cc9"       title="pin_seekspot">&nbsp;</em>
  <em  id="log_seekspot"   class="toolbag_button cc9"       title="log_seekspot">&nbsp;</em>
  <!-- }}} -->
  <!-- tools_node {{{ -->
  <table>
   <tr>
    <th>node</th>
    <td>
     <input id="tools_node"     type="text"                title="tools_node"/>
     <span class="cc2">html</span>
     <span class="cc3">head</span>
     <span class="cc4">body</span>
    </td>
   </tr>
  </table>
  <!-- }}} -->
 </div>
 <!-- }}} -->
 <!-- test_panel: RELOAD CLEAR t_log_regex t_log_behavior - (onclick would not care for has_moved) {{{ -->
 <div id="test_panel"      class="transcript hidden"     title="test_panel">
  <em id="CLEAR"           class="toolbag_button cc1"    title="CLEAR"     > CLEAR      </em>
  <em id="BEHAVIOR"        class="toolbag_button cc2"    title="BEHAVIOR"  > BEHAVIOR   </em>
  <em id="HIGHLIGHT"       class="toolbag_button cc3"    title="HIGHLIGHT" > HIGHLIGHT  </em>
  <em id="REGEX"           class="toolbag_button cc4"    title="REGEX"     > REGEX      </em>
  <em id="EXPORT"          class="toolbag_button cc6"    title="EXPORT"    > EXPORT     </em>
  <em id="IMPORT"          class="toolbag_button cc5"    title="IMPORT"    > IMPORT     </em>
  <em id="RELOAD"          class="toolbag_button cc7"    title="RELOAD"    >&#x21BB;<br>RELOAD<br>&#x21BB;</em>
 </div>
 <!-- }}} -->

  <!-- dev_log_map {{{-->
  <div id="dev_log_map"    class="transcript hidden"     title="dev_log_map"
   >
   dev_log_map placeholder:<br>
   <i class="todo">..should have been populated by <em>dom_tools.sync_logging</em> with the value of logging</i>

  </div>
  <!-- }}} -->
 <!-- dom_load_tags (placeholder) {{{ -->
 <div id="dom_load_tags"   class="transcript hidden"     title="dom_load_tags"
  >
  dom_load_tags placeholder:<br />
  <i class="todo">...should have been populated by <em>dom_tools.show_tags</em> with the value of DOM_LOAD_TAG</i>

 </div>
 <!-- }}} -->

 <!-- transcript1 {{{ -->
 <div id="transcript1"     class="transcript hidden cleardiv"  title="transcript1"></div>
 <!-- }}} -->
 <!-- transcript2 {{{ -->
 <div id="transcript2"     class="transcript hidden cleardiv"  title="transcript2"></div>
 <!-- }}} -->

 <!-- pivspot {{{-->
 <div   id="pivspot"       class="hidden"                      title="pivspot">
   <div id="pivspot_c">&#x00BB;</div>
 </div>
 <!--}}}-->
 <!-- seeker {{{-->
 <div  id = "seeker_PU"    class="seeker_P"                    title="seeker_PU"><div id="seeker_CU" >seeker up    </div></div>
 <div  id = "seeker_PD"    class="seeker_P"                    title="seeker_PD"><div id="seeker_CD" >seeker_thumbs</div></div>

 <div id = "seekspot_U"                                                        ></div>
 <div id = "seekzone"      class="hotspot_frame"               title="seekzone"></div>
 <div id = "seekspot_A"                                                >&#x2191;</div>
 <div id = "seekspot_D"                                                        ></div>
 <!--}}}-->
<!--INLINE}}}-->
`
;
/*}}}*/

  /**    2 HOST     CSS  dom_host_css_data .. ESCAPE=[OR HOST CSS WONT WORK]  {{{*/
/*
../stylesheet/dom_host.css
 */
let dom_host_css_data ="data:text/css,"+ escape(`
/*INLINE{{{*/
@charset "utf-8";
#dom_host_css_tag   { content: "dom_host_css (220916:18h:32)"; }


.dark * { background : rgba(17,17,17,0.5); color: rgba(221,221,221,0.5); }

body.dimmed {
    filter : blur(2px) grayscale(100%) !important;
}
body.dimmed { transition : filter 250ms; }

                            *::selection { color:white; background: black           ; }
.selection_progress         *::selection { color:black; background: yellow          ; }
.selection_ending           *::selection { color: pink; background:   red !important; }
.cannot_expand_to_selection *::selection { color:white; background:   red !important; }


.doc_tool           { border : 5px solid rgba(000,000,102,0.33) !important; }

#doc_tools a        { cursor : pointer !important; }




.anchor_node, .anchor_node *     { color      : black              !important; }
.anchor_node:nth-of-type( odd)   { background : linear-gradient(to right, rgba(170,170,170,0.5), rgba(34,0,0,0.5)) !important; }
.anchor_node:nth-of-type(even)   { background : linear-gradient(to left , rgba(170,170,170,0.5), rgba(34,0,0,0.5)) !important; }
.anchor_node>*:nth-of-type( odd) { background : linear-gradient(to right, rgba(170,170,170,0.5), rgba(34,0,0,0.5)) !important; }
.anchor_node>*:nth-of-type(even) { background : linear-gradient(to left , rgba(170,170,170,0.5), rgba(34,0,0,0.5)) !important; }



body.anchor_node             { outline : 3px double #FF0000 !important; }

    .anchor_node             { outline : 2px ridge          !important; }
    .anchor_node.anchor_back { outline : 5px double #FF00FF !important; }

.anchor_child0,
.anchor_child1,
.anchor_child2,
.anchor_child3,
.anchor_child4,
.anchor_child5,
.anchor_child6,
.anchor_child7,
.anchor_child8,
.anchor_child9,
.anchor_child    { outline      : 5px solid; }

.anchor_child0   { outline-color: #000000 !important; }
.anchor_child1   { outline-color: #964B00 !important; }
.anchor_child2   { outline-color: #FF0000 !important; }
.anchor_child3   { outline-color: #FFA500 !important; }
.anchor_child4   { outline-color: #FFFF00 !important; }
.anchor_child5   { outline-color: #9ACD32 !important; }
.anchor_child6   { outline-color: #6495ED !important; }
.anchor_child7   { outline-color: #EE82EE !important; }
.anchor_child8   { outline-color: #A0A0A0 !important; }
.anchor_child9   { outline-color: #FFFFFF !important; }


.anchor_closest    { animation  :           200ms forwards glowing; }
@keyframes glowing {
    0%   { box-shadow : 0   0   0px   0px   red; }
    2%   { box-shadow : 0   0   0px  48px   red; }
    100% { box-shadow : 0   0   0px   5px black; }

}


.anchor_child0,
.anchor_child1,
.anchor_child2,
.anchor_child3,
.anchor_child4,
.anchor_child5,
.anchor_child6,
.anchor_child7,
.anchor_child8,
.anchor_child9,
.anchor_child      { transition : all       250ms !important; }



.anchor_node       { transition : all       250ms !important; }




.overflow_visi *    { overflow-x       : visible !important; }
.overflow_visi *    { width            : unset !important; }








.wall_of_text_split                   { border        : 0                !important; }
.wall_of_text_split                   { padding       : 0                !important; }
.wall_of_text_split                   { margin        : 0                !important; }
.wall_of_text_split                   { white-space   : pre-wrap         !important; }
.wall_of_text_split                   { word-wrap     : break-word       !important; }


.wall_of_text_split.wall_of_text_fold { border-radius : 0em 1em 1em 0em            ; }
.wall_of_text_split.wall_of_text_fold { border        : 3px outset red             ; }
.wall_of_text_split.wall_of_text_fold { border-left   : 1em solid rgba(255,0,0,0.3); }
.wall_of_text_split.wall_of_text_fold { margin-left   :-1em                        ; }
.wall_of_text_split.wall_of_text_fold { padding       : 0.2em                      ; }


html { box-sizing    : border-box !important; }
.line_num {
    position         : absolute;
    left             : 0;
    margin-right     : 1em;

    font-family      : monospace;
    user-select      : none;
    pointer-events   : none;
    background-color : rgba(192,192,192,0.4)        !important;
    padding-right    : 1em;
}



details                                 .line_num { border-right: 0.0em solid rgba(000,000,000,0.3); }
details details                         .line_num { border-right: 0.5em solid rgba(000,000,000,0.3); }
details details details                 .line_num { border-right: 1.0em solid rgba(000,000,000,0.3); }
details details details details         .line_num { border-right: 2.0em solid rgba(000,000,000,0.3); }
details details details details details .line_num { border-right: 2.5em solid rgba(000,000,000,0.3); }



.wall_of_text_parent                  { border        : 0                !important; }
.wall_of_text_parent                  { margin        : 0 0 0 6em        !important; }
.wall_of_text_parent                  { padding       : 0                !important; }



.wall_of_text_parent details                  > pre           { display: inline-block; margin:0; padding-left: 5px; border-radius: 0 0 1em 1em; }

.wall_of_text_parent details:nth-of-type( 1n) > pre           { background : rgba(150, 75,  0,0.2); box-shadow: inset 0px 0px 2px 2px rgb(150, 75,  0); }
.wall_of_text_parent details:nth-of-type( 2n) > pre           { background : rgba(255,  0,  0,0.2); box-shadow: inset 0px 0px 2px 2px rgb(255,  0,  0); }
.wall_of_text_parent details:nth-of-type( 3n) > pre           { background : rgba(255,165,  0,0.2); box-shadow: inset 0px 0px 2px 2px rgb(255,165,  0); }
.wall_of_text_parent details:nth-of-type( 4n) > pre           { background : rgba(255,255,  0,0.2); box-shadow: inset 0px 0px 2px 2px rgb(255,255,  0); }
.wall_of_text_parent details:nth-of-type( 5n) > pre           { background : rgba(154,205, 50,0.2); box-shadow: inset 0px 0px 2px 2px rgb(154,205, 50); }
.wall_of_text_parent details:nth-of-type( 6n) > pre           { background : rgba(100,149,237,0.2); box-shadow: inset 0px 0px 2px 2px rgb(100,149,237); }
.wall_of_text_parent details:nth-of-type( 7n) > pre           { background : rgba(238,130,238,0.2); box-shadow: inset 0px 0px 2px 2px rgb(238,130,238); }
.wall_of_text_parent details:nth-of-type( 8n) > pre           { background : rgba(160,160,160,0.2); box-shadow: inset 0px 0px 2px 2px rgb(160,160,160); }
.wall_of_text_parent details:nth-of-type( 9n) > pre           { background : rgba(255,255,221,0.2); box-shadow: inset 0px 0px 2px 2px rgb(255,255,221); }
.wall_of_text_parent details:nth-of-type(10n) > pre           { background : rgba(192,192,192,0.2); box-shadow: inset 0px 0px 2px 2px rgb(192,192,192); }

.wall_of_text_parent details:nth-of-type( 1n) > pre .line_num { background : rgba(150, 75,  0,0.1) !important; }
.wall_of_text_parent details:nth-of-type( 2n) > pre .line_num { background : rgba(255,  0,  0,0.1) !important; }
.wall_of_text_parent details:nth-of-type( 3n) > pre .line_num { background : rgba(255,165,  0,0.1) !important; }
.wall_of_text_parent details:nth-of-type( 4n) > pre .line_num { background : rgba(255,255,  0,0.1) !important; }
.wall_of_text_parent details:nth-of-type( 5n) > pre .line_num { background : rgba(154,205, 50,0.1) !important; }
.wall_of_text_parent details:nth-of-type( 6n) > pre .line_num { background : rgba(100,149,237,0.1) !important; }
.wall_of_text_parent details:nth-of-type( 7n) > pre .line_num { background : rgba(238,130,238,0.1) !important; }
.wall_of_text_parent details:nth-of-type( 8n) > pre .line_num { background : rgba(160,160,160,0.1) !important; }
.wall_of_text_parent details:nth-of-type( 9n) > pre .line_num { background : rgba(255,255,221,0.1) !important; }
.wall_of_text_parent details:nth-of-type(10n) > pre .line_num { background : rgba(192,192,192,0.1) !important; }

.wall_of_text_parent details:nth-of-type( 1n) > pre .line_num { margin-left : 0.1em !important; }
.wall_of_text_parent details:nth-of-type( 2n) > pre .line_num { margin-left : 0.2em !important; }
.wall_of_text_parent details:nth-of-type( 3n) > pre .line_num { margin-left : 0.3em !important; }
.wall_of_text_parent details:nth-of-type( 4n) > pre .line_num { margin-left : 0.4em !important; }
.wall_of_text_parent details:nth-of-type( 5n) > pre .line_num { margin-left : 0.5em !important; }
.wall_of_text_parent details:nth-of-type( 6n) > pre .line_num { margin-left : 0.6em !important; }
.wall_of_text_parent details:nth-of-type( 7n) > pre .line_num { margin-left : 0.7em !important; }
.wall_of_text_parent details:nth-of-type( 8n) > pre .line_num { margin-left : 0.8em !important; }
.wall_of_text_parent details:nth-of-type( 9n) > pre .line_num { margin-left : 0.9em !important; }
.wall_of_text_parent details:nth-of-type(10n) > pre .line_num { margin-left : 1.0em !important; }


.wall_of_text_block {
    border-radius    : 0.25em                       !important;
    text-align       : left                         !important;
    background       : linear-gradient(to left,rgba(0,0,0,0.3), rgba(0,0,0,0.5) 50%, rgba(255,255,255,0.5) 98%, rgba(0,0,0,0.7) 99%, rgba(255,0,0,0.7)) !important;
    background-color : rgba(0,255,0,0.5)            !important;
    padding          : 0.1em 0.5em 0.1em 0.5em      !important;
}

.wall_of_text_block.region   {
    background-color : rgba(0,0,255,0.5)            !important;

}
.wall_of_text_block.function {
    background-color : rgba(255,0,0,0.5)            !important;

}


.show_seekzone .wall_of_text_split    { outline : 1px solid black; }
.show_seekzone .wall_of_text_parent   { outline : 1px solid black; }
.show_seekzone .text_line             { outline : 1px solid black; }





DETAILS.wall_of_text_split                       { margin-left      : 1em !important;                      }
DETAILS.wall_of_text_split                       { width            : max-content;                         }
DETAILS.wall_of_text_split:not([open])           { opacity          : 0.8;                                 }


DETAILS.wall_of_text_split       SUMMARY         { cursor           : pointer;                             }
DETAILS.wall_of_text_split       SUMMARY         { border           : 2px solid rgba(255,255,255,0.8);     }
DETAILS.wall_of_text_split       SUMMARY         { box-shadow       : 1px 1px 0 3px rgba(000,000,000,0.1); }
DETAILS.wall_of_text_split       SUMMARY         { border-radius    : 1.0em;                               }
DETAILS.wall_of_text_split       SUMMARY         { padding          : 0 0.5em;                             }
                                 SUMMARY::marker { font-size        : 150%;                                }
DETAILS.wall_of_text_split[open]>SUMMARY::marker { color            : red; background-color: black;        }
DETAILS.wall_of_text_split[open]>SUMMARY         { border-radius    : 1em 1em 0 0;                         }
DETAILS.wall_of_text_split       SUMMARY         { background       : linear-gradient(to bottom , rgba(000,000,255,0.3)                            , rgba(000,000,000,0.0)) !important; }
DETAILS.wall_of_text_split[open]>SUMMARY         { background       : linear-gradient(to bottom , rgba(255,000,000,1.0) , rgba(255,000,000,0.3) 5px, rgba(000,000,000,0.0)) !important; }



DETAILS.wall_of_text_split>SPAN                  { vertical-align   : top;                                 }

DETAILS[open] > * {
  animation       : sweep_animation 500ms ease-in-out;
}
@keyframes sweep_animation {
  0%    { opacity: 0; transform: translateX(-10px); }
  100%  { opacity: 1; transform: translateX(  0  ); }
}



.collapsed {
    height           : 2em;
    transform-origin : 0 0;
    transform        : scale(.8,.8);
    overflow         : hidden;
    filter           : blur(2px);
    cursor           : pointer;
}
.collapsed:hover {
    height           : 4em;
    transform        : scale(1,1);
    filter           : none;
}
.collapse_pin {
    position         : relative; top : -.5em; left : 10%;
    cursor           : pointer;
    background-color : transparent;
    font-size        : 200%;
    color            : red;
}
.collapse_pin:hover {
    box-shadow       : 0 0 .5em black;
}



.node_to_hide_mask             { z-index             : 2147483646                           !important; }
.node_to_hide_mask.last_hidden { z-index             : 2147483647                           !important; }
.node_to_hide_mask             { cursor              : pointer                              !important; }
.node_to_hide_mask             { user-select         : none                                 !important; }
.node_to_hide_mask             { position            : absolute                             !important; }
.node_to_hide_mask             { overflow            : hidden                               !important; }
.node_to_hide_mask             { margin              : 0                                    !important; }
.node_to_hide_mask             { padding             : 0                                    !important; }
.node_to_hide_mask             { box-shadow          : 3px 3px 3px inset  rgba(255,255,255) !important; }
.node_to_hide_mask             { background-color    :                rgba(200,200,255,0.9) !important; }
.node_to_hide_mask.last_hidden { background-color    :                rgba(255,200,200,0.9) !important; }
.node_to_hide_mask             { transition-duration : 200ms;                                           }



.node_to_hide_mask     {
    color          : #AAA                     !important;
    font-size      : 100%                     !important;
    font-weight    : 900                      !important;

}
.node_to_hide_mask>*   {
    position       : absolute                 !important;
    top            : 0                        !important;
    left           : 0                        !important;
    margin:0 !important;
    padding:0 !important;
    line-height: 1em !important;

}





.node_to_hide_not_visible      { display      : none !important; }



.last_hidden                   { transition-duration : 100ms;                                           }
.last_hidden                   { outline             : 5px rgba(255,000,000,0.3) solid   !important;    }
.last_hidden                   { cursor              : pointer   !important;                            }
.last_hidden                   { user-select         :    none;                                         }




.marked_to_hide    { user-select      : none                                 !important; }
.marked_to_dimm    { transition       : opacity    500ms                               ; }
.marked_to_hide    { transition       : opacity    500ms                               ; }
.marked_to_dimm    { transition       : outline    0ms                          100ms  ; }


.marked_to_dimm    { outline          : 3px dashed rgba(68,000,255,1)        !important; }
.marked_to_dimm    { opacity          : 0.3                                  !important; }
.marked_to_dimm    { background-color : pink                                 !important; }
.marked_to_dimm    { user-select      : none                                 !important; }
.marked_to_dimm    { box-shadow       : 0   0 16px 8px    rgba(  0,255,  0, .8);         }




.containers_hi .viewable { outline             : red 5px solid !important; }
.containers_hi .viewable { transition-duration : 500ms; }


.zoom_70  { zoom :  70%; }
.zoom_80  { zoom :  80%; }
.zoom_90  { zoom :  90%; }

.zoom_100 { zoom : 100%; }
.zoom_110 { zoom : 110%; }
.zoom_120 { zoom : 120%; }

.zoom_130 { zoom : 130%; }
.zoom_150 { zoom : 150%; }
.zoom_160 { zoom : 160%; }

.zoom_180 { zoom : 180%; }
.zoom_200 { zoom : 200%; }
.zoom_220 { zoom : 220%; }



.font_size_70  p, .font_size_70  pre, .font_size_70  code { font-size :  70% !important; }
.font_size_80  p, .font_size_80  pre, .font_size_80  code { font-size :  80% !important; }
.font_size_90  p, .font_size_90  pre, .font_size_90  code { font-size :  90% !important; }

.font_size_100 p, .font_size_100 pre, .font_size_100 code { font-size : 100% !important; }
.font_size_110 p, .font_size_110 pre, .font_size_110 code { font-size : 110% !important; }
.font_size_120 p, .font_size_120 pre, .font_size_120 code { font-size : 120% !important; }

.font_size_130 p, .font_size_130 pre, .font_size_130 code { font-size : 130% !important; }
.font_size_140 p, .font_size_140 pre, .font_size_140 code { font-size : 140% !important; }
.font_size_150 p, .font_size_150 pre, .font_size_150 code { font-size : 150% !important; }

.font_size_160 p, .font_size_160 pre, .font_size_160 code { font-size : 160% !important; }
.font_size_170 p, .font_size_170 pre, .font_size_170 code { font-size : 170% !important; }
.font_size_180 p, .font_size_180 pre, .font_size_180 code { font-size : 180% !important; }

.font_size_190 p, .font_size_190 pre, .font_size_190 code { font-size : 190% !important; }
.font_size_200 p, .font_size_200 pre, .font_size_200 code { font-size : 200% !important; }
.font_size_210 p, .font_size_210 pre, .font_size_210 code { font-size : 210% !important; }






.pat_div {
    display       : inline-block !important;
    margin        : 1em;
    border-radius : 1ex;
    border        : 3px solid #aaa;
    padding       : 1em;
}



#shadow_host {
    position : absolute;
    left     : 0;
    top      : 0;
    margin   : 0;
    border   : 0;
    padding  : 0;
    width    : 0px;
    height   : 0px;
}






input       { border  : 6px #eee solid;        }
input:focus { outline : 0;                     }
input:focus { border  : 6px solid transparent; }



.cc1 , .select1 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc2 , .select2 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc3 , .select3 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc4 , .select4 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc5 , .select5 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc6 , .select6 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc7 , .select7 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc8 , .select8 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc9 , .select9 { box-shadow: 0.0em 0.3em 0.3em rgba(0, 0, 0, 0.3) inset; }
.cc0 , .select0 { box-shadow: 0.0em 0.1em 0.1em #FFF               inset; }



.cc1 , .select1 , .select1 em { color: #FFF !important; background-color:#964B00 !important; padding:0 !important; }
.cc2 , .select2 , .select2 em { color: #FFF !important; background-color:#FF0000 !important; padding:0 !important; }
.cc3 , .select3 , .select3 em { color: #000 !important; background-color:#FFA500 !important; padding:0 !important; }
.cc4 , .select4 , .select4 em { color: #000 !important; background-color:#FFFF00 !important; padding:0 !important; }
.cc5 , .select5 , .select5 em { color: #000 !important; background-color:#9ACD32 !important; padding:0 !important; }
.cc6 , .select6 , .select6 em { color: #000 !important; background-color:#6495ED !important; padding:0 !important; }
.cc7 , .select7 , .select7 em { color: #000 !important; background-color:#EE82EE !important; padding:0 !important; }
.cc8 , .select8 , .select8 em { color: #000 !important; background-color:#A0A0A0 !important; padding:0 !important; }
.cc9 , .select9 , .select9 em { color: #000 !important; background-color:#FFFFFF !important; padding:0 !important; }
.cc0 , .select0 , .select0 em { color: #FFF !important; background-color:#202020 !important; padding:0 !important; }

.bg1 { background-color : rgba(150,  75,   0, .9) !important; color : #FFF !important; }
.bg2 { background-color : rgba(255,   0,   0, .9) !important; color : #FFF !important; }
.bg3 { background-color : rgba(255, 165,   0, .9) !important; color : #000 !important; }
.bg4 { background-color : rgba(255, 255,   0, .9) !important; color : #000 !important; }
.bg5 { background-color : rgba(154, 205,  50, .9) !important; color : #000 !important; }
.bg6 { background-color : rgba(100, 149, 237, .9) !important; color : #000 !important; }
.bg7 { background-color : rgba(238, 130, 238, .9) !important; color : #000 !important; }
.bg8 { background-color : rgba(160, 160, 160, .9) !important; color : #000 !important; }
.bg9 { background-color : rgba(255, 255, 255, .9) !important; color : #000 !important; }
.bg0 { background-color : rgba(128, 128, 128, .9) !important; color : #FFF !important; }

.fg1 {            color : rgba(200,  99,   0, 1) !important; }
.fg2 {            color : rgba(255,   0,   0, 1) !important; }
.fg3 {            color : rgba(255, 165,   0, 1) !important; }
.fg4 {            color : rgba(255, 255,   0, 1) !important; }
.fg5 {            color : rgba(154, 205,  50, 1) !important; }
.fg6 {            color : rgba(100, 149, 237, 1) !important; }
.fg7 {            color : rgba(238, 130, 238, 1) !important; }
.fg8 {            color : rgba(160, 160, 160, 1) !important; }
.fg9 {            color : rgba(255, 255, 255, 1) !important; }
.fg0 {            color : rgba(  0,   0,   0, 1) !important; text-shadow : 0px -1px #FFFFFF; }


.select_words_exact     { border:0px red         !important; border-radius:.5ex;                            }
.select_words_segment   { border:0px transparent !important; border-radius: 0  ;                            }
.select_words_segment   { border:0px             !important;       outline: 3px rgba(128,128,128,.5) solid; }
.select_words_head_tail { border:0px             !important; border-radius: 1ex;                            }







em.select1,
em.select2,
em.select3,
em.select4,
em.select5,
em.select6,
em.select7,
em.select8,
em.select9,
em.select0 { cursor : all-scroll !important; }

.select1,
.select2,
.select3,
.select4,
.select5,
.select6,
.select7,
.select8,
.select9,
.select0 { white-space : nowrap !important; }




.scroll_smooth { scroll-behavior  : smooth  !important; }




.containers_hi       :not(.container_light):not(.container_dark ):not(em):not(.node_to_hide_mask) { background-image: none !important; box-shadow:none !important; text-shadow:none !important; }
.containers_hi.dark                        :not(.container_dark ):not(em):not(.node_to_hide_mask) { background-color: #222 !important; color :rgba(255,255,255,0.5) !important; }
.containers_hi.light                       :not(.container_light):not(em):not(.node_to_hide_mask) { background-color: #EEE !important; color :rgba(  0,  0,  0,0.5) !important; }

.container_dark, .container_light { border        : 0px;                               }
.container_dark, .container_light { border-radius : 5px !important;                    }
.container_dark, .container_light { box-shadow    : 2px 2px 6px rgba(000,000,000,0.7); }

.container_dark                   { color         : white !important; }
.container_light                  { color         : black !important; }

.container_dark                   { background    : linear-gradient(110deg, rgba( 68, 28,  0,.3), rgba(255, 106, 26,.3)) !important; }
.container_light                  { background    : linear-gradient(110deg, rgba(255,130,  0,.3), rgba(  0,   0,  0,.3)) !important; }

.container_selected               { outline       : 1px dashed orange; }



.on_work_el_left  { outline : .5em dotted  green !important; }
.on_work_el_right { outline : .5em dotted  red   !important; }

.num_selected     { outline : .5em dotted  #A0F  !important; }




.transcript            { transform-origin     : 0% 0% 0;         }
.transcript            { cursor               : pointer;         }
.transcript            { margin               : .2em;            }
.transcript            { padding              : 1ex;             }
.transcript            { min-height           : 1em;             }

.transcript            { max-width            :  80%;            }
.transcript            { max-height           :  80%;            }

.transcript            { overflow-x           : hidden; }
#transcript1           { overflow-x           :   auto; }
#transcript2           { overflow-x           :   auto; }

.transcript::-webkit-scrollbar                       { width         :  3em; }
.transcript::-webkit-scrollbar                       { height        :  3em; }
.transcript::-webkit-scrollbar-thumb                 { border-radius : 96px; }
.transcript::-webkit-scrollbar-track                 { border-radius : 96px; }
.transcript::-webkit-scrollbar-thumb                 { box-shadow    : inset 0 0 6px rgba(0,0,0,0.5); }
.transcript::-webkit-scrollbar-track                 { box-shadow    : inset 0 0 6px rgba(0,0,0,0.3); }
.transcript::-webkit-scrollbar-thumb                 { box-shadow    : rgba(  0,  0,  0,0.5) 0 8px 24px; }
.transcript::-webkit-scrollbar-thumb                 { background    : rgba( 24, 24, 24,0.5); }
.transcript::-webkit-scrollbar-thumb:window-inactive { background    : rgba( 24, 24, 24,0.2); }
.transcript::-webkit-scrollbar-track                 { background    : rgba( 96, 96, 96,0.4); }
.transcript::-webkit-scrollbar-track:window-inactive { background    : rgba(128,128,128,0.2); }

.transcript>div        { margin               : .2em;            }

.transcript *          { user-select  : none;            }
.transcript *          { vertical-align       : middle;          }
.transcript *          { font-family          : monospace;       }

.transcript blockquote { margin               : .2em;                     }
.transcript blockquote { padding              : 1ex;                      }
.transcript blockquote { white-space          : normal !important;        }
.transcript blockquote { width                : 48em;                     }

.transcript div        { cursor               : pointer;         }

.transcript div        { display              : table-cell;      }
.transcript div        { margin               : .2em;            }
.transcript div        { overflow-x           : hidden;          }
.transcript div        { padding              : 1ex;             }

.transcript em         { line-height          : 1.50em;          }

.transcript pre        { background           : initial;         }
.transcript pre        { padding              : 0 0 0 1ex;       }
.transcript pre        { text-align           : left;            }

.transcript sub        { vertical-align       : sub;             }
.transcript sup        { color                : white;           }
.transcript sup        { vertical-align       : super;           }

.transcript table      { user-select  : none;            }
.transcript table      { margin               : 0;               }
.transcript tr.slot    { font-size            : 200%;            }
.transcript th         { font-size            : 120%;            }
.transcript th         { padding              : 1ex;             }
.transcript th         { text-align           : left;            }
.transcript th         { text-shadow          : rgba( 50, 50, 50, 0.9) 1px 1px 2px !important; }
.transcript th         { font-weight          : 700; }
.transcript hr         { height               : 5px; }

.transcript td         { padding              : 1ex;             }
.transcript td         { text-align           : left;            }

.transcript ul         { line-height          : 0.75em;          }
.transcript ul         { margin               : .2em;            }
.transcript ul         { padding              : 0 0 0 2em;       }

.transcript_msg .info  {
    box-shadow  : 2px 2px 6px rgba(000,000,000,0.7) inset;
    font-family : "Comic sans ms";
}

      .transcript_msg { color       : #200; }
.dark .transcript_msg { color       : #FA0 !important; }

#table_params *   {     text-align : right  ; }

.div_match {
    border: solid 8px black !important;
}
.div_match div {
    border:solid 1px !important;
}

.em_match {
    box-shadow    : rgba(0, 0, 0, 0.3) 0 0.3em 0.3em inset;
    font-size     : 200%;
}
.em_missing {
    color            : red;
    background-color : transparent;
    font-weight      : 700;
    box-shadow       : rgba(255, 0, 0, 0.3) 0 0.3em 0.3em inset;
}

.em_log {
    padding          : .2em;
    border-radius    : 50%;
    box-shadow       : rgba(0, 0, 0, 0.3) 0 0.3em 0.3em inset;
}
.em_log span {
    border-radius    : .5em;

}



.outlined_divs {
    position         : absolute             !important;
    pointer-events   : none                 !important;
    margin           : 0                    !important;
    border-radius    : 16px                 !important;
    border-style     : solid                !important;
    border-width     : 7px                  !important;
    padding          : 0                    !important;
    background-color : transparent          !important;
}
.outlined_dots {
    position         : absolute             !important;
    pointer-events   : none                 !important;
    margin           : 0                    !important;
    border-radius    : 1em                  !important;
    padding          : 1em                  !important;
    transform        : translate(-50%,-50%) !important;
    text-shadow      : white    1px 1px 2px !important;
}



.sentence_container {
    all           : initial;
    display       : inline-block;
    padding       : 0.5em;
    cursor        : pointer;
    user-select   : none;

}
UL.sentence_container { display: block; }
OL.sentence_container { display: block; }


.rejected {
    margin           : 0.5em;

}
.outlined {
    border           : 1px solid #F00;
    box-shadow       : 3px 3px 3px rgba(255,0,0,0.5);
    border-radius    : 0.5em;
    margin           : 0.5em;
    padding          : 0.5em;
    white-space      : pre-line;
    transition       : all 500ms ease;
}
.sentence_container.outlined {
    transition       : transform 150ms ease-in;
    transform        : rotate(1deg) scale(0.9);

    outline          : 5px #000 dashed;
    box-shadow       : 3px 3px 12px 6px rgba(0,0,0,0.5);
    border           : 5px #000 dashed;
    background-color : rgba(221,255,221,0.5);
}
.sentence { max-width   : 64ch     !important; }
.sentence { min-width   : 32ch     !important; }
.sentence { overflow    : visible  !important; }

.sentence { white-space : normal   !important; }
.sentence { text-align  : left     !important; }

.sentence_container.fs1 , .sentence_container.fs1  * { font-size :  6px; }
.sentence_container.fs2 , .sentence_container.fs2  * { font-size :  7px; }
.sentence_container.fs3 , .sentence_container.fs3  * { font-size :  9px; }
.sentence_container.fs4 , .sentence_container.fs4  * { font-size : 11px; }
.sentence_container.fs5 , .sentence_container.fs5  * { font-size : 13px; }
.sentence_container.fs6 , .sentence_container.fs6  * { font-size : 16px; }
.sentence_container.fs7 , .sentence_container.fs7  * { font-size : 20px; }
.sentence_container.fs8 , .sentence_container.fs8  * { font-size : 23px; }
.sentence_container.fs9 , .sentence_container.fs9  * { font-size : 28px; }
.sentence_container.fs10, .sentence_container.fs10 * { font-size : 34px; }
.sentence_container.fs11, .sentence_container.fs11 * { font-size : 41px; }
.sentence_container.fs12, .sentence_container.fs12 * { font-size : 49px; }

.sentence             { overflow         : visible      !important; }
.sentence, .clause    { display          : block        !important; }
.sentence, .clause    { transform        : scale(0.9)   !important; }
.sentence, .clause    { transform-origin : 0% 50%       !important; }

.sentence             { margin-top       : 0.5em        !important; }
           .clause    { margin-top       : 0            !important; }

.sentence, .clause    { padding          : 0 0.5em 0 0.5em        ; }

.sentence, .clause    { border-style     : outset                 ; }
.sentence, .clause    { border-color     : rgba(136,136,136,0.5)  ; }

           .clause    { line-height      : 1em         !important ; }

    .dark *::before   {          display : none            !important; }
    .dark *::after    {          display : none            !important; }
body.dark IMG         {           filter : brightness(50%) !important; }
body.dark .sentence   {           filter : brightness(80%) !important; }
body.dark .sentence   {            color : #FFF                      ; }
body.dark .clause     {            color : #111                      ; }

.sentence             { border-top-width    : 3px; }
.clause               { border-top-width    : 0  ; }
.sentence.last_clause { border-top-width    : 0  ; }
  .clause.last_clause { border-top-width    : 0  ; }

.sentence             { border-right-width  : 3px; }
.clause               { border-right-width  : 3px; }
.sentence.last_clause { border-right-width  : 3px; }
  .clause.last_clause { border-right-width  : 3px; }

.sentence             { border-bottom-width : 0  ; }
.clause               { border-bottom-width : 0  ; }
.sentence.last_clause { border-bottom-width : 3px; }
  .clause.last_clause { border-bottom-width : 3px; }

.sentence             { border-left-width   : 3px; }
.clause               { border-left-width   : 3px; }
.sentence.last_clause { border-left-width   : 3px; }
  .clause.last_clause { border-left-width   : 3px; }


.sentence             { border-radius    : 0.5em 0.5em 0     0    ; }
.sentence.last_clause { border-radius    : 0.5em 0.5em 0.5em 0.5em; }
  .clause.last_clause { border-radius    : 0     0     0.5em 0.5em; }












.clause   { background    : linear-gradient(to right , rgba(255,255,255,0.5), rgba(255,255,255,0.00) 90%); }












#log_popup_div {
    all              : initial;
    max-height       : 95%;
    max-width        : 95%;
    overflow         : auto;
    line-height      : 1.0em;
}

#log_popup_div       > pre::before {
    display          : block !important;
    position         :       absolute;
    content          :        "\\25C0";
    font-size        :           24px;
    background-color :    transparent;
    line-height      :            1em;
    transform-origin :       80%  20%;
    transform        : rotate( 45deg);
    left             :            0px;
    top              :            0px;
    bottom           :          unset;
}

#log_popup_div.above> pre::before {
    display          : block !important;
    transform-origin :       80%  80%;
    transform        : rotate(-45deg);
    top              :          unset;
    bottom           :            0px;
}

#log_popup_div.center> pre::before {
    display          : block !important;
    display          : none;
}

#log_popup_div em      { margin-left   : 1px;              }
#log_popup_div em      { padding       : 0px 0.5em;        }

#log_popup_div em      { border        : 1px solid white;  }
#log_popup_div em      { box-shadow    : 1px 1px 1px #888; }

#log_popup_div .xpath * { max-width     : unset  !important; }
#log_popup_div .xpath   { font-size     : 12px   !important; }
#log_popup_div .xpath   { white-space   : pre    !important; }
#log_popup_div .xpath   { overflow      : auto   !important; }
#log_popup_div .xpath   { line-height   : normal !important; }

#log_popup_div .tag    { border-radius : 0.25em 0.25em 0.25em 0.25em; }
#log_popup_div .left   { border-radius : 0.25em 0      0      0.25em; }
#log_popup_div .center { border-radius : 0      0      0      0     ; }
#log_popup_div .right  { border-radius : 0      0.25em 0.25em 0     ; }

#log_popup_div .tag    { background    : linear-gradient(to right, rgba(255,255,255,0.4), rgba(136,136,255,0.4)); }
#log_popup_div .id     { background    : linear-gradient(to right, rgba(255,000,000,0.4), rgba(255,136,136,0.4)); }
#log_popup_div .class  { background    : linear-gradient(to left , rgba(000,255,000,0.4), rgba(136,255,136,0.4)); }




#drag_cursor.onload           { transition    : all       200ms ease-out; }
#drag_cursor                  { transition    : transform 200ms ease-out; }
#drag_cursor.onload           { transform     :  rotate(360deg) scale(3); }
#drag_cursor.onload           { border-radius : 1em          !important;  }
#drag_cursor.onload::after    { content       : "splitter"   !important;  }
#drag_cursor.move_on_cooldown { content       : "\\231B"      !important; background-color:rgba(000,255,000,0.5) !important; }
#drag_cursor.not_moved_enough { content       : "\\25C4\\25BA" !important; background-color:rgba(000,000,255,0.5) !important; }


/*INLINE}}}*/
/*# sourceURL=dom_host.css */
`
)
 .replace(/\\(\\x+)/g,"\\\\$1")
;
/*}}}*/
  /**    3 GRID    CSS dom_grid_css_data {{{*/
/*
../stylesheet/dom_grid.css
*/
let dom_grid_css_data ="data:text/css,"+ `
/*INLINE{{{*/
@charset "utf-8";
#dom_grid_css_tag   { content: "dom_grid_css (200624:21h:09)"; }


#dom_grid_playground {
 border        : 1px solid #333;
 border-radius : 1em;
 padding       : .5em;
 background    : linear-gradient(to bottom, #333, #111) !important;
 position      : fixed; top:0.2em; right:5em;
 width         : 75%;
}
#dom_grid_playground.collapsed                   { width   : 25%            ; }
#dom_grid_playground.collapsed #traces_div       { display : none !important; }
#dom_grid_playground.collapsed #dom_grid_headsup { display : none           ; }

#dom_grid_headsup>div                            { display : inline-block   ; }



#dom_tools_html ol>li{
 margin-bottom: 1em;
  white-space : nowrap;
}




#traces_div>div { margin-left:1em !important; margin-top: 0em !important; }

#traces {
 border-radius : 5px;
 box-shadow    : rgba(0, 0, 0, 0.3) 0 0.3em 0.3em inset;
 border        : 3px dashed #FD8;
 width         : 50em;
 padding       : 1ex;
 overflow      : auto;

 color         : #FD4;
 background    : rgba(16,16,16,.8);
}


.note {
 background        : #fff3d4;
 border-color      : #f6b73c;
 border-left-width : 5px;
 border-left-style : solid !important;
 font-family       : "monospace";
 font-weight       : 700;
 font-size         : 100%;
 color             : #AAA;
 padding           : 1ex 1em 1ex 1em;
 display           : inline-block;
 margin            : 1ex 1ex 1ex 0;
}
.note em { padding    : 0.2em; }
.note em { line-height: 2.5em; }
.note pre { margin:0; }
.pat_div { display:none; }


.box {
    display:inline-block;
    position:relative;
    border         : 1px solid #404040      ;
    border-radius  : 5px 5px 5px 5px        ;
    color          : darkgray               ;
    font-weight    : 900                    ;
    background     : rgba(16,16,16,.8)      ;
    vertical-align : middle;
    text-align     : center;
    box-shadow     : 0 0 10px #000000 inset ;
    padding:0 !important;
}
.box  label { cursor: pointer; }


.cb_slider_pin {
    width          : 80px;
    height         : 30px;
    border-radius  : 50px;
    padding        : 0;
    box-shadow     : inset 0px 1px 1px rgba(0, 0, 0, 0.5), 0px 1px 0px rgba(255, 255, 255, 0.2);
}

.cb_slider_pin:after {
    content        : '';
    height         : 2px;
    width          : 52px;
    position       : absolute;
    top            : 14px;
    left           : 14px;
    background     : #111;
    border-radius  : 50px;
    box-shadow     : inset 0px 1px 1px rgba(0, 0, 0, 0.5), 0px 1px 0px rgba(255, 255, 255, 0.2);
}

.cb_slider_pin label {
    z-index        : 1;
    width          : 22px;
    height         : 22px;
    position       : absolute;
    top            : 4px;
    left           : 4px;
    border-radius  : 50px;
    transition     : all 0.4s ease;
    background     : #fcfff4;
    background     : linear-gradient(to top, #fcfff4 0%, #dfe5d7 40%, #b3bead 100%);
    box-shadow     : 0px 2px 5px 0px rgba(0, 0, 0, 0.3);
}

.cb_slider_pin label:after {
    content        : '';
    width          : 10px;
    height         : 10px;
    position       : absolute;
    top            : 6px;
    left           : 6px;
    background     : #333;
    border-radius  : 50px;
    box-shadow     : inset 0px 1px 1px black, 0px 1px 0px rgba(255, 255, 255, 0.9);
}

.cb_slider_pin input[type=checkbox]                       { visibility : hidden;  }
.cb_slider_pin input[type=checkbox]:checked + label       { left       : 54px;    }
.cb_slider_pin input[type=checkbox]:checked + label:after { background : #00Fe00; }



/*INLINE}}}*/
/*# sourceURL=dom_grid.css */
`

 .replace(/\\(\\x+)/g,"\\\\$1")
;
/*}}}*/
  /**   4 TOOLS   CSS dom_tools_css_data .. ESCAPE=[#dom_tools_css_tag] {{{*/
/*
../stylesheet/dom_tools.css
*/
let dom_tools_css_data ="data:text/css,"+ escape(`
/*INLINE{{{*/

#dom_tools_css_tag  { content: "dom_tools_css (220203:16h:26)"; }


.flag, .flag.checked {
 border                    : none             !important;
 border-radius             : 1.0em            !important;
 background-position       : center           !important;
 background-repeat         : no-repeat        !important;
 box-shadow                : 0px 0px 5px #666 !important;
}

.bg_FR { background-image  : url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAApVBMVEUAAAAAAP8aa6YZaaEYaaMxeKpDhbeOtNTn5+nok5nqXGPqXmPpaG//gIAAgIAZaJ/rSlH/VYAZaqPpYmcXZ53rQEYXZZjsKDAXZZjsIysXZprsMTgZaKDrSlEabKfrbXMXaqQXZJjrKTDqaW0uXbkYaaYYbapPjbZnnMOevdbp6enqoaHrfYLneX3/mZkXZJYZa6Z5qc/m5+jpgYbsHCTsHib////UQnaFAAAAL3RSTlMAAozEx+LYq4iox8SMAgbk5AampPHw/f3+/vr64+JaWYT+/oMLPz9XTTIiMT8/CvuMgHAAAAABYktHRDZHv4jRAAAAB3RJTUUH4QgIBREohK9IqAAAAHdJREFUOMtjYBgegJGJmQUIWNnYOeCAkwsMuHl4GRj4+PUhwMDQCA6MTaBAQJBBSB+fAhNhBhH8CkQZxPArEGeQwK9AclQB/RRI4VcgzSCDX4EsgxxeBabyDAwKirgVKCmDUq2KqhoQqGtoasGBtg4Y6OoNjnwFAKctfQuSIu45AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTA4LTA4VDA1OjE3OjQwKzAwOjAw3yWaFQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0wOC0wOFQwNToxNzo0MCswMDowMK54IqkAAAAASUVORK5CYII=") !important; }
.bg_EN { background-image  : url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAFbUlEQVRYhe2WfVTNdxzHX/f3u9Wtq0eirG5PN6Gkhh3OpjyEyjN5ONiZmWMY1koaDas2MxxO4+RwnHYMIxXKQ4xs2lSMaFEkDz2oGxU93up2790fm60ozDn7i/dfvz9e3/f78/t8Pud7vvBGb/S6SwIQPGmuxVvT5p3Qmpkqtp++Xtes0erbQoLU+L5EZnkHYKKXje2IimsKk6RE47ZM/ZRp6p979C1KyalQdRYmSpAs93dx6qZpKVZHrQj+6HxKnTRuXVxf9x93/WEWGSw+Dg1lcnggy/f8wsXCf330gmEfyd/fZjIp3dW19C3KaWd+vdEPU5m0f2fhyu5yNgT1QZqVhVFUJBqp0fRTGw96CgYeHseaHJxE68ZaXKPXcn/uQnYGvc362UMxNTZ8yUZ2LqkoIdjPiYQZLjSEhKMIW4ZNXSUNllZdJP2UccL+vDI76x0xFG35jlLzbnjmZ6MdGUCv40dIXxOEv5fTK4d7K8w5uewdfK6k0ThsFJ6/n6XaxJzciPUojuwjvkJ0EC7fLjMYGZnAfrUJjuknyR0/DVGnw+3AbooCp7K6fzf2LPLBzlL20sEWJgbEzHRn62A5j4Nm47JtI/IWNdfeC6DruVSyXbwZtjGTk9ce9JSiBx169qTncS6vlG8/WUT9jIk8ClmJa3kRrbNmg98EUjd/yfaMchpbtM8ND+zXnaixSvLWbcUw8QdctS2UW9igi47EYsBAZu7PI7+8/gluJLQ9XFxZy6yYY+wsacIl7SiXps9FI4p4nT5CmY8/UzQlLB/t3Gn4Ql8HIhw0qMZMpH/8LqS6VrLHBGGffoIzckcmxV5qGw6AJDoxU9+RmY2FnA983SnNyaf289XY3cgFiYTWqVMxcVPS8vX6dry4OgKtSoUu7nsErY5KhRJdVBS9RwwiKbucgoqGDouWnB88ssMC/gGAnkpHuly5CjU1AGgFEVHXfhSthkZIW5r/OmNkhCQwgIJHGp66Up71/9Wpz/MJoIdWi5VO9yLslSS8GPl/9aYASVl84gt3wExqiGbrNrSFdwDQ2isQS4rbMRrXXhjcLgSdDsHaGpMvwmlSOKLnBUvYY35sh8TEQUqigwaT/9VmlIcOItO2cN/KFoN10ZiVlSCLimzH10esRuPuwaOQVTirbtMqCNwcPh6PjWvYklHO7oxSdPpno54Zga2FnN1LAghzkVPqNw6PhL2Iei1XJ8zBMT2VRg8vbj9sfMaoqErN3a72OJ4+zNU5i2kVpLinJaMa7s8MzT2SFg1A2V3eeQGiIGGJvzdnwsYhrt+A6by5ODws466NAk38fgyDl+K//SqJl8s7bWfajUp8t1xANWk64rEUbin70aPmIbafLaFh8ackTndmVaASQ+m//y0gEfS9elqSvGIyAeoKyn0D8P7tNBpByo0FS3BOO8qmW83M2pVNcbW60/AnqlW3Ep6UT2hmLXZJ+ygMiaBGJqdfbgZ1I8bglXmKs6GDGeJiCUgeCXN8PBoPzfNFHbICh5Vh2NZXk+/YG+FoMs2TJzN63SESLtyjg/E9V+cKqhgdc4E7747C+ORxcjyGYNbcgFvsJlQzPyTW14rQUU6Vgn1zfXLlmPH0zc6gwcCQggVLcT9xkG8uFjMr5jilVXX/LfmpboQl5hOcVoHL3h0ULF9DjbEprjeyaRw7CbcHdw8LwfP9Z/9k637hmvsAzM6kUuEfyNC18SRkFrxy8NM6X1iN3+Yscr19MU9LJWfAMF2WwvPA2Dl+4U+eemxKy3OorW3y2Xm2sPhpAyNRrNPLzB8DvD/EzsqtqqSrKiGlqS1jM22C7GZX+6o9maXVzysmZJSznbG56a2PB1p3vs1v9FrpTy4ZFB6SsucBAAAAAElFTkSuQmCC") !important; }
.bg_DE { background-image  : url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAABQklEQVRYhe2TvUoDQRSFz70zk2wSjCyLi2lsNGnSKdjY2AUsLUzlE9iIjS8gvoh2Cjb2loI/WAliYyOIigaiJLvBnWsjNspWuxnB/ZppDnxnuPcCBQX/Hfp6ubWwtC6QeRC8XI2CiEguby9O9wFYarfbpZE3eQRgJVfxT47riFeVP9PcBLAxZjkAtCJRryyCrgM5AICIugzCrKsCAJoMwDgsUGKHcgCA3nvpDQgySgsZQa8i8pi1PCGJtQXChIjSgjWxwZRN5rIuAODd+QiKAkUBPb2jI4GotFA5Mm9VNs9Zy4VlqKUmnrWSeoYqVIHyTZB1AQB95yNgYiQO/U9sDD040wvOuKz0VuoC5McHkOxy2Lk6rEyYba1onKO4t2w75cXz6+/P350sez4PGr+ljTJxtU7DzPQ3jT6tHbjcvYI/xCeh6lSnMB3FTAAAAABJRU5ErkJggg==") !important; }
.bg_GR { background-image  : url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhFBMVEUAAAAZSpEYSZIaSZIZSZEZSJIZSZIaSpEYSZMYSJE6YqGXq8exvM8YSZJdfq7m5ugYSZLm6OiNo8IZSZJwjbZae65dfq9fgLA2X51ggLBkg7Hn5+jn5+jm6OjBzNuruc/Ey9oaSJIZSJMZSZIZSZLm5+h/mL0ZSZLk5ueHncC3w9T///+S8fQfAAAAJXRSTlMAXcbwwMVblZJKuMBFscCw5eTg/c3Hy8+5xLvlsa9GwEWUXO/EMIB6AwAAAAFiS0dEKyS55AgAAAAHdElNRQfkBhoWOyDukqFdAAAAlklEQVQ4y9XTSROCMAyG4U9ZxB2s+y4Yo/7/H2g7HqDTTnLmuVAm7yGHFuiHwTAherGVsifJcjcf2WM8sApgzG0wmQZmmHeCBQWWKOWgwrvztwp2YAOSA8bHIfq6z3rzt921wPIO5AX7Q8gL0tgOakAKPTgqwAoYeW5wkleocJaDC6430R14SCsU7lLWWROfNs+8J+/uB/iWXQWJFOLfAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIwLTA2LTI2VDIyOjU5OjMyKzAwOjAwA410ZgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMC0wNi0yNlQyMjo1OTozMiswMDowMHLQzNoAAAAASUVORK5CYII=") !important; }

.flag.checked.reloading {
 animation-duration        :         2000ms;
 animation-delay           :            0ms;
 animation-name            : flag_animation;
 animation-timing-function :       ease-out;
 animation-fill-mode       :           both;
}
@keyframes flag_animation {
    from { opacity   : 0; }
    30%  { transform : scale(1.0) rotate(-45deg); }
    to   { transform : scale(0.8); }
}




.display_delayed {
    opacity             : 0.1;
    transition-duration : 500ms;
    visibility : hidden !important;
    display    : none   !important;

}


#dom_tools_css_tag  {
    border        : 5px dashed #FFAA00;
    border-radius : 2em;
    margin        : 1em;
}



global-box { margin: 0 0 5px 0; }

input {
    border               : 2px solid transparent;
    user-select          : none ;
}

input:focus {
    box-shadow           : 0px 0px 3px black inset !important;
    outline              : none;
}
input.focussed {
    background-color     : rgba(0,0,0,0.3)         !important;
               color     : white                   !important;
}

em {
    border           : 1px solid #aaa;
    border-radius    : 5px;
    color            : #444;
    background-color : #fafafa;
    font-style       : normal;
}
em   sup { font-size      :   30% !important; }
em   sup { vertical-align : super !important; }
span sup { font-size      :   30% !important; }
span sup { vertical-align : super !important; }



.todo { color:red; }




.cc1 , .select1 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc2 , .select2 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc3 , .select3 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc4 , .select4 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc5 , .select5 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc6 , .select6 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc7 , .select7 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc8 , .select8 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc9 , .select9 { box-shadow: rgba(0,0,0,0.3) 0 0.3em 0.3em inset; }
.cc0 , .select0 { box-shadow: #FFF            0 0.1em 0.1em inset; }



.cc1 , .select1 , .select1 em { color: #FFF; background-color:#964B00 !important; }
.cc2 , .select2 , .select2 em { color: #FFF; background-color:#FF0000 !important; }
.cc3 , .select3 , .select3 em { color: #000; background-color:#FFA500 !important; }
.cc4 , .select4 , .select4 em { color: #000; background-color:#FFFF00 !important; }
.cc5 , .select5 , .select5 em { color: #000; background-color:#9ACD32 !important; }
.cc6 , .select6 , .select6 em { color: #000; background-color:#6495ED !important; }
.cc7 , .select7 , .select7 em { color: #000; background-color:#EE82EE !important; }
.cc8 , .select8 , .select8 em { color: #000; background-color:#A0A0A0 !important; }
.cc9 , .select9 , .select9 em { color: #000; background-color:#FFFFFF !important; }
.cc0 , .select0 , .select0 em { color: #FFF; background-color:#202020 !important; }

.bg1 { background-color : rgba(150,  75,   0, .9); color : black; }
.bg2 { background-color : rgba(255,   0,   0, .9); color : black; }
.bg3 { background-color : rgba(255, 165,   0, .9); color : black; }
.bg4 { background-color : rgba(255, 255,   0, .9); color : black; }
.bg5 { background-color : rgba(154, 205,  50, .9); color : black; }
.bg6 { background-color : rgba(100, 149, 237, .9); color : black; }
.bg7 { background-color : rgba(238, 130, 238, .9); color : black; }
.bg8 { background-color : rgba(160, 160, 160, .9); color : black; }
.bg9 { background-color : rgba(255, 255, 255, .9); color : black; }
.bg0 { background-color : rgba(128, 128, 128, .9); color : black; }

.fg1 {            color : rgba(200,  99,   0, 1) !important; }
.fg2 {            color : rgba(255,   0,   0, 1) !important; }
.fg3 {            color : rgba(255, 165,   0, 1) !important; }
.fg4 {            color : rgba(255, 255,   0, 1) !important; }
.fg5 {            color : rgba(154, 205,  50, 1) !important; }
.fg6 {            color : rgba(100, 149, 237, 1) !important; }
.fg7 {            color : rgba(238, 130, 238, 1) !important; }
.fg8 {            color : rgba(160, 160, 160, 1) !important; }
.fg9 {            color : rgba(255, 255, 255, 1) !important; }
.fg0 {            color : rgba(  0,   0,   0, 1) !important; text-shadow : 0px -1px #FFFFFF; }

.select1,
.select2,
.select3,
.select4,
.select5,
.select6,
.select7,
.select8,
.select9,
.select0 { cursor : all-scroll; }




#dom_tools_html   {                 line-height : normal;            }
#dom_tools_html * {                 user-select : none;              }
#dom_tools_html * { -webkit-tap-highlight-color : rgba(255,0,0,.05); }

 #pat_bag
,#sel_bag
,#headsup
,#dom_traversal
,#dev_log_map
,#test_panel
,#dom_load_tags
,#transcript1
,#transcript2
{
    min-width     :12em;
    min-height    :12em;
    margin-bottom : 5em;
    font-weight   : 900;
}

 #pat_bag.scrolled
,#sel_bag.scrolled
,#headsup.scrolled
,#dom_traversal.scrolled
,#dev_log_map.scrolled
,#test_panel.scrolled
,#dom_load_tags.scrolled
,#transcript1.scrolled
,#transcript2.scrolled
{
    border:1px dashed red;

}
#transcript1 { border: 3px #964B00 solid !important; }
#transcript2 { border: 3px #FF0000 solid !important; }

#pat_bag.scrolled           { background-color: rgba(255,  0,  0,.1); }
#sel_bag.scrolled           { background-color: rgba(255,  0,  0,.1); }
#headsup.scrolled           { background-color: rgba(  0,255,  0,.1); }
#dom_traversal.scrolled     { background-color: rgba(  0,255,  0,.1); }
#dev_log_map.scrolled       { background-color: rgba(  0,  0,255,.1); }
#test_panel.scrolled        { background-color: rgba(  0,  0,255,.1); }
#dom_load_tags.scrolled     { background-color: rgba(  0,  0,255,.1); }
#transcript1.scrolled       { background-color: rgba(255,255,  0,.1); }
#transcript2.scrolled       { background-color: rgba(255,255,  0,.1); }

 #pat_bag       >div
,#sel_bag       >div
,#headsup       >div
,#dom_traversal >div
{
    margin        : 0;
    padding       : 0;
    line-height   : normal;
}

 #pat_bag       label
,#sel_bag       label
,#headsup       label
,#dom_traversal label
{
    line-height   :  3em;
}

 #pat_bag>div>div
,#sel_bag>div>div
,#headsup>div>div
,#dom_traversal>div>div
{
    color         : #050505;
}

.toolbag_button {
    display       : inline-block;
    padding-left  : 1ex;
    padding-right : 1ex;
    cursor        : pointer;
}

.toolbag_button::after {
    transition    : all ease-in 250ms;
}




#pat_bag { float     : left;   }
#pat_bag { min-width : 24em;   }
#pat_bag { overflow  : hidden; }



#sel_bag { float : left; }

#sel_bag          { color                      : green; }
#sel_bag.back     { color                      : red; }

#sel_bag>div      { margin                     : 0 0 0 2em; }





.max_width_30 { max-width:30em; overflow-x:auto; overflow-y:hidden; }







#headsup {
    float          : left;
    margin         : 0 !important;


    color          : #050505;
    font-family    : Arial, Helvetica, sans-serif;

    text-shadow    : 0px -1px 0px rgba(0,0,0,0.4), 0px 1px 0px rgba(255,255,255,0.3);
    vertical-align : top;
}

#headsup>* { float:left; }

#headsup    em,
#headsup_w  em,
#headsup_ds em,
#dom_traversal {
    margin     : 0;
    padding    : 0.1em;
    min-width  : 1.5em;
}

#headsup em:hover { box-shadow : rgba(128,128,128,0.9) 0 0.1em 0.1em inset; }



#headsup>em        , #headsup_w>em        , #headsup_ds>em        , #dom_traversal>em { margin           : 3px;                  }
#headsup>em        , #headsup_w>em        , #headsup_ds>em        , #dom_traversal>em { border           : rgba(255,255,255,.9); }
#headsup>em        , #headsup_w>em        , #headsup_ds>em        , #dom_traversal>em { border-radius    : 2em;                  }
#headsup>em        , #headsup_w>em        , #headsup_ds>em        , #dom_traversal>em { transform-origin : 50% 50%;              }
#headsup>em        , #headsup_w>em        , #headsup_ds>em        , #dom_traversal>em { color            : rgba(  0,  0,  0,.7); }
#headsup>em        , #headsup_w>em        , #headsup_ds>em        , #dom_traversal>em { font-size        : 200%;                 }
#headsup>em        , #headsup_w>em        , #headsup_ds>em        , #dom_traversal>em { text-align       : center;               }



#headsup>em.checked, #headsup_w>em.checked, #headsup_ds>em.checked, #dom_traversal>em.checked { margin        : 0              ; }
#headsup>em.checked, #headsup_w>em.checked, #headsup_ds>em.checked, #dom_traversal>em.checked { background    : linear-gradient(to bottom, #AAA, #200); }
#headsup>em.checked, #headsup_w>em.checked, #headsup_ds>em.checked, #dom_traversal>em.checked { color         : #000           ; }

#anchor_freeze.checked { color         : #D00 !important; }
#containers_hi.checked { color         : #FC0 !important; }


#thumb_p {
    margin           : -.3em 1ex 0 -.3em !important;
    min-width        :   3em             !important;
    border           : 0;
    background-color : transparent;
    padding          : 0                 !important;
    color            : rgba(0,0,0,.9)    !important;
    font-size        : 200%;
}


#headsup_w em {
    border        : rgba(255,255,255,0.2) solid;
    border-radius : 2em !important;
    font-size     : 160%;
    margin        : 0 !important;
    text-align    : center;
    text-shadow   : none;
    font-weight   : 900 !important;
}




#words_drop_case         { font-size     : 120% !important; }
#words_drop_case         { padding       : .1em .5em .1em .5em !important; }
#words_drop_case::after  {
    content             : 'case';
    position            : absolute;
    transition-duration : 500ms;
}

#words_drop_case                { opacity    : 0.5; }
#words_drop_case.checked        { opacity    : 1.0; }
#words_drop_case.checked        { background : linear-gradient(to bottom, #F00, #800) !important; }

#words_drop_case::after         { transform  : translate(-60%,  5%) rotate(90deg); }
#words_drop_case.checked::after { transform  : translate(-60%,  5%) rotate( 0deg); }
#words_drop_case.checked::after { opacity    : 1.0; }



#words_drop_ing         { font-size     : 120% !important; }
#words_drop_ing         { padding       : .1em .5em .1em .5em !important; }
#words_drop_ing::after  {
    content             : 'ing';
    position            : absolute;
    transition-duration : 500ms;
}

#words_drop_ing                { opacity    : 0.5; }
#words_drop_ing.checked        { opacity    : 1.0; }
#words_drop_ing.checked        { background : linear-gradient(to bottom, #F00, #800) !important; }

#words_drop_ing::after         { transform  : translate(-60%,  5%) rotate(90deg); }
#words_drop_ing.checked::after { transform  : translate(-60%,  5%) rotate( 0deg); }
#words_drop_ing.checked::after { opacity    : 1.0; }



#words_drop_s         { font-size     : 120% !important; }
#words_drop_s         { padding       : .1em .5em .1em .5em !important; }
#words_drop_s::after  {
    content             : 'S';
    position            : absolute;
    transition-duration : 500ms;
}

#words_drop_s                { opacity    : 0.5; }
#words_drop_s.checked        { opacity    : 1.0; }
#words_drop_s.checked        { background : linear-gradient(to bottom, #F00, #800) !important; }

#words_drop_s::after         { transform  : translate(-80%,  5%) rotate(90deg); }
#words_drop_s.checked::after { transform  : translate(-80%,  5%) rotate( 0deg); }
#words_drop_s.checked::after { opacity    : 1.0; }



#words_opcycle                         { text-shadow                : 1px 1px 3px black      !important; }
#words_opcycle.checked                 { border-radius              : 50% 50% 10% 10%        !important; }
#words_opcycle.checked                 { transition-duration        : 100ms;                             }
#words_opcycle.checked                 { transition-timing-function : cubic-bezier(0.5, 0.05, 0.9, 1.2); }
#words_opcycle.checked.words_exact     { transform                  : rotate(-45deg)         !important; }
#words_opcycle.checked.words_head_tail { transform                  : rotate( 45deg)         !important; }
#words_opcycle.checked.words_segment   { transform                  : rotate(  0deg)         !important; }
#words_opcycle.freezed                 { opacity                    : 0.5                    !important; }

      #words_regex                     { color       : #000; }
.dark #words_regex                     { color       : #CCC; }
      #words_regex pre                 { padding     :    0; }
      #words_regex pre                 { margin      :    0; }
      #words_regex pre                 { font-size   :  80%; }
      #words_regex pre                 { font-weight :  900; }
      #words_regex.fg2                 { font-weight :  900 !important; }



#words_recycle {
    color         : green;
    box-shadow    : 2px 2px 4px rgba(0,0,0,0.3);
    border-radius : 1.5em;
    text-align    : center;
    font-size     : 250%;
}

#words_recycle.checked  { background : linear-gradient(to bottom, #F00, #800) !important; }


#words_bag_rot {
    padding          : 0 0.3em 0 0.3em    !important;
    background-color : rgba(136,136,136,0.5)              !important;
    text-shadow      : 1px 1px 3px black  !important;
}

#words_bag_rot div {
    pointer-events   : none               !important;
    padding          : 0                  !important;
    line-height      : 0.9                !important;
    transition       : all 500ms ease-out !important;
}


#tools_scroll {
    float : left;
    clear : left;

    background    : linear-gradient(to bottom, #FFF   , #EB0   );
    border        : 0 !important;
    border-radius : 2em;
    box-shadow    : rgba(0,0,0,0.3) 0 0.1em 0.5ex inset;
    font-size     : 300%;
    text-align    : center;
}


 #wording
,#theme_dark
{
    background    : linear-gradient(to bottom, #FFF, #FF0);
    color         : #000;
}

 #wording
,#theme_dark
{
    border        : 0;
    border-radius : 2em;
    box-shadow    : rgba(0,0,0,0.3) 0 0.1em 0.5ex inset;
    font-size     : 200%;
    text-align    : center;
}

 #wording.checked
,#theme_dark.checked {
    background    : linear-gradient(to bottom, #AAA, #200);
    color         : #FC0;
    margin        : 0   !important;
}



#tools_tier2 {
    background    : linear-gradient(to bottom,#FFF,#EB0);
    border        : 0 !important;
    border-radius : 2em;
    box-shadow    : rgba(0,0,0,0.3) 0 0.1em 0.5ex inset;
    font-size     : 150%;
    text-align    : center;
}


#scroll_smooth::after {

    content          : '\\21c9';
    position         : absolute;
    transform        : translate(-80%, 5%) scale(1.5) rotate(90deg);

}

#scroll_smooth.checked::after {
    content          : '\\2933';
    transform        : translate(-80%, 10%) scale(1.5) rotate(90deg);
}


#overflow_visi::after {


    content          : '\\2750';
    position         : absolute;
    transform        : translate(-80%, 5%) scale(1.0) rotate(90deg);
    opacity          : 0.5;

}

#overflow_visi.checked::after {
    content          : '\\25A0';
    transform        : translate(-100%, -5%) scale(1.5);
    opacity          : 1.0;
}





#details_radio::after {
    content          : '\\21C9';
    font-size        : 130%;
    line-height      : 1.2em;
    margin-left      : -0.5em;
    opacity          : 0.5;
}

#details_radio.checked::after {
    content          : '\\25B6';
    opacity          : 1.0;
}


#show_seekzone::after {
    position         : absolute;
    content          : '\\29EE';
    transform        : translate(-80%, 5%) scale(1.0) rotate(90deg);
    opacity          : 0.5;

}

#show_seekzone.checked::after {
    content          : '\\29EF';
    transform        : translate(-80%,-10%) scale(1.5) rotate( 0deg);
    opacity          : 1.0;

}


#pin_seekspot  { border-radius : 10% 10% 1em 1em !important; padding-top    :   0em !important; }
#theme_dark    { border-radius : 10% 10% 1em 1em !important; padding-top    : 0.6em !important; }
#containers_hi { border-radius : 10% 10% 1em 1em !important; padding-top    : 1.2em !important; }
#anchor_freeze { border-radius : 10% 1em 1em 10% !important; padding-left   : 1.0em !important; }
#wording       { border-radius : 10% 1em 1em 10% !important; padding-left   : 0.5em !important; }
#overflow_visi { border-radius : 1em 1em 10% 10% !important; padding-bottom : 0.5em !important; }
#details_close { border-radius : 1em 1em 10% 10% !important; padding-bottom :   0em !important; }
#details_open  { border-radius : 10% 10% 1em 1em !important; padding-bottom :   0em !important; }
#details_radio { border-radius : 10% 1em 1em 10% !important; padding-bottom :   0em !important; }
#scroll_smooth { border-radius : 1em 1em 10% 10% !important; padding-bottom : 1.0em !important; }
#remove_ads    { border-radius : 1em 1em 10% 10% !important; padding-bottom : 0.5em !important; }
#lines_wot     { border-radius : 1em 1em 10% 10% !important; padding-bottom : 0.5em !important; }
#split_wot     { border-radius : 1em 1em 10% 10% !important; padding-bottom : 1.0em !important; }



#pin_seekspot::after {
    content          : '\\2295';
    position         : absolute;
    transform        : translate(-80%,  5%) scale(0.5) rotate(90deg);
    opacity          : 0.5;

}

#pin_seekspot.checked::after {
    transform        : translate(-70%,  0%) scale(1.0) rotate(-45deg);
    opacity          : 1.0;
}


#log_seekspot     {
    transform     : scale(0.7);
}
#log_seekspot::after {
    content          : '\\33D2';
    position         : absolute;
    transform        : translate(-80%,  5%) scale(0.5) rotate(90deg);
    opacity          : 0.5;
}

#log_seekspot.checked::after {
    transform        : translate(-80%, 10%) scale(1.0) rotate( 0deg);
    opacity          : 1.0;
}


#remove_ads.checked { background    : linear-gradient(to bottom, rgba(170,170,170,0.5), rgba(255,0,0,0.7)) !important; }
#remove_ads        {
    transform     : scale(0.6);
}
#remove_ads::after {
    content       : '\\2702';
    position      : absolute;
    transform     : translate(-65%,  0%) scale(1.0) rotate(90deg);
    opacity       : 0.5;
    font-weight   : 900;
    font-size     : 150%;
}

#remove_ads.checked::after {
    transform     : translate(-80%,-10%) scale(1.0) rotate( 0deg);
    opacity       : 1.0;
}


#split_wot::after {
    content       : 'wot';
    position      : absolute;
    transform     : translate(-65%,  0%) scale(0.5) rotate(90deg);
    opacity       : 0.5;
}

#split_wot.checked::after {
    transform     : translate(-65%,  0%) scale(1.0) rotate( 0deg);
    opacity       : 1.0;
}


#lines_wot.checked { background    : linear-gradient(to bottom, rgba(170,170,170,0.5), rgba(255,0,0,0.7)) !important; }
#lines_wot        {
    transform     : scale(0.7);
}
#lines_wot::after {
    content       : '\\266F';
    position      : absolute;
    transform     : translate(-65%,  0%) scale(1.0) rotate(90deg);
    opacity       : 0.5;
    font-weight   : 900;
    font-size     : 150%;
}

#lines_wot.checked::after {
    transform     : translate(-80%,-10%) scale(1.0) rotate( 0deg);
    opacity       : 1.0;
}



#headsup_ds *::after            { transition : all ease-in 250ms; }

#site_or_page::after            { content :  'Page'; position : absolute; transform : translate(-60%,  5%) scale(0.5) rotate(-10deg); }
#site_or_page.checked::after    { content :  'Site'; color    : red;      transform : translate(-60%,  5%) scale(0.7) rotate( 10deg); }

#mask_or_hide::after            { content :  'Hide'; position : absolute; transform : translate(-60%,  5%) scale(0.5) rotate(-10deg); }
#mask_or_hide.checked::after    { content :  'Mask'; color    : red;      transform : translate(-60%,  5%) scale(0.7) rotate( 10deg); }

#deny_or_allow::after           { content : 'Allow'; position : absolute; transform : translate(-60%,  5%) scale(0.5) rotate(-10deg); }
#deny_or_allow.checked::after   { content :  'Deny'; color    : red;      transform : translate(-60%,  5%) scale(0.7) rotate( 10deg); }

#edit_or_stage::after           { font-size: 300%; }
#edit_or_stage::after           { content : '\\2699'; position : absolute; transform : translate(-60%,  5%) scale(0.5) rotate(-10deg); }
#edit_or_stage.checked::after   { content : '\\2699'; color    : red;      transform : translate(-60%,  5%) scale(0.7) rotate( 10deg); }

#dom_hide1_reset::after         { font-size: 300%; }
#dom_hide1_reset::after         { content : '\\267B'; position : absolute; transform : translate(-60%,  5%) scale(0.5) rotate(-10deg); }
#dom_hide1_reset.checked::after { content : '\\267B'; color    : red;      transform : translate(-60%,  5%) scale(0.7) rotate( 10deg); }

#dom_hide1_undo                 { font-size: 140% !important; }

#targeteer::after               { font-size: 300%; }
#targeteer::after               { content : '\\2295'; position : absolute; transform : translate(-60%,  0%) scale(0.5) rotate(-45deg); }
#targeteer.checked::after       { content : '\\2295'; color    : red;      transform : translate(-59%, -7%) scale(0.7) rotate(  0deg); }

#target_01::after               { font-size: 200%; }
#target_01::after               { content : '1'  ;   position : absolute; transform : translate(-60%,  0%) scale(0.5) rotate(-45deg); }
#target_01.checked::after       { content : '1'  ;   color    : red;      transform : translate(-59%, -7%) scale(0.7) rotate(  0deg); }

#target_02::after               { font-size: 200%; }
#target_02::after               { content : '2'  ;   position : absolute; transform : translate(-60%,  0%) scale(0.5) rotate(-45deg); }
#target_02.checked::after       { content : '2'  ;   color    : red;      transform : translate(-59%, -7%) scale(0.7) rotate(  0deg); }

#target_03::after               { font-size: 200%; }
#target_03::after               { content : '3'  ;   position : absolute; transform : translate(-60%,  0%) scale(0.5) rotate(-45deg); }
#target_03.checked::after       { content : '3'  ;   color    : red;      transform : translate(-59%, -7%) scale(0.7) rotate(  0deg); }



#headsup_bw { min-height : 8em; }




#dom_traversal {

    float       : left;
    clear       : left;
    white-space : nowrap;
}

#dom_traversal>table {
    width       : 100%;
    margin-top  :  1em;
}
#tools_node {
    outline    : 2px dashed red;
}





 #dev_log_map   em
,#test_panel    em
,#dom_load_tags em
{

    display     : inherit;
}

 #dev_log_map
,#test_panel
,#dom_load_tags
{
    float       : left;
}

 #dev_log_map
,#test_panel
{
    color       : #eee;
    font-family : "Comic sans ms";
    text-align  : left;
}
 #dev_log_map   em
,#test_panel    em
{
    text-align  : center;
}

 #dom_load_tags em
{
    text-align  : right;
}

   #transcript                      { padding       : 1em; }

 #pat_bag           em
,#sel_bag           em
,#headsup           em
,#dom_traversal     em
,#dev_log_map       em
,#test_panel        em
,#dom_load_tags     em
,#transcript1       em
,#transcript2       em
{
    white-space    : nowrap;
    margin-top     : 2px;
}

#dom_load_tags em
{
    min-width      : 8em;
    padding-right  : 1em;
    vertical-align : super;
}

#dom_load_tags.dark {
    color          : orange;
}



.tiny  { font-size :  50% !important; vertical-align : middle; }
.small { font-size :  80% !important; vertical-align : middle; }
.big   { font-size : 200% !important; vertical-align : middle; }

.info,
.error {
    opacity           : 1 !important;
    border-radius     : 0.5em;
    font-family       : monospace;
}

.error { border       : red   groove 5px; }
.info  { border       : green groove 5px; }

.error { background-color  : white; }
.info  { background-color  : lightblue; }

.error { color        :   red; }
.info  { color        : blue; }

.error { font-size    :  150%; }
.info  { font-size    :  100%; }



.sym_showing, .sym_hiding , .sym_backing, .sym_alting
.sym_colide , .sym_dismiss, .sym_binning,
.sym_bagger , .sym_docker ,
.sym_update , .sym_staged , .sym_result
{
    font-size    : 300% !important;
    font-weight  : 900  !important;
    text-shadow  : rgba(0,0,0,0.4) .1em .1em .2em;
    line-height  : .6em;
    min-width : 1em !important;
    display : inline-block;
}

.sym_colide  { color : #F0F; }
.sym_dismiss { color : #F0F; }

.sym_update  { color : #FFA500; }
.sym_staged  { color : #6495ED; }
.sym_result  { color : #FFFF00; }

.sym_showing { color : black; text-shadow: 1px 1px 1px #FF0; font-weight:100 !important; }
.sym_hiding  { color : black; text-shadow: 1px 1px 1px #0F0; font-weight:100 !important; }
.sym_backing { color : black; text-shadow: 1px 1px 1px #F00; font-weight:100 !important; }
.sym_alting  { color : black; text-shadow: 1px 1px 1px #00F; font-weight:100 !important; }
.sym_binning { color : #444 ; text-shadow: 1px 1px 1px #DDD; font-weight:100 !important; }

.sym_bagger  { color : #58C; }
.sym_docker  { color : #C80; }





.log_num_thumb {
    color : #aaa;
}

           .log_node_toString { display : inline-block; width:24em; }
.div_match .log_node_toString { display : inline !important;        }

.log_sep_line {
    border-radius  : 5em !important;
    box-shadow     : rgba(0,0,0,0.3) 0 0.3em 0.3em inset;
    min-height     : 5em;
    min-width      : 5em;
    font-size      : 200%;
}
.log_sep_line * {
    text-align     : center !important;

}


.badge {
    position       :  relative;

    border-radius  : 8em !important;
    box-shadow     : rgba(0,0,0,0.3) 0 0.3em 0.3em !important;

    min-height     : 8em   !important;
    min-width      : 8em   !important;

    padding        : 1em    !important;

    font-size      : 200%   !important;
    line-height    : 100%   !important;

    text-align     : center !important;
    vertical-align : middle !important;
}

.badge p {
    position       : absolute;
    margin         : 0;
    margin-right   :-50%;
    top            : 50%;
    left           : 50%;
    transform      : translate(-50%,-50%);

    text-align     : center !important;
    white-space    : normal !important;
}



.checked {
    border           : black solid !important;
    box-shadow       : none !important;
}





.scrolled      >div { transition-duration        : 100ms; }
.scrolled      >div {
    box-shadow                 : 3px 3px 6px black !important;
    transition-property        : all;
    transition-timing-function : ease-in;

}




.badge                  { background       : linear-gradient(to bottom, #FC0, #FF0); }
.info                   { background       : rgba(0,0,0,0.2); }

      .current_slot_num { color:white; background:linear-gradient(to bottom, #000, #0F0) !important; }
.back .current_slot_num { color:white; background:linear-gradient(to bottom, #F00, #000) !important; }

#sel_bag>div                  { border     : 2px solid transparent !important; }

#sel_bag>div                  { opacity    :  0.7; }
#sel_bag>div.current_slot     { opacity    :  1.0; }
#sel_bag>div.current_slot     { box-shadow : rgba(0,0,0,0.3) 0 0.3em 0.3em; }
#sel_bag>div.current_slot     { border     : 4px solid black !important; }






.bag     { padding : 1em; }
.bag div { padding : 0;   }
.bag  em {

    min-width      : 9px;
    min-height     : 9px;
    width          : 9px;
    height         : 9px;

}

.bag em:nth-of-type(   1) { font-size  : 150%; }
.bag em:nth-of-type(   2) { font-size  : 140%; }
.bag em:nth-of-type(   3) { font-size  : 130%; }
.bag em:nth-of-type(   4) { font-size  : 120%; }
.bag em:nth-of-type(   5) { font-size  : 110%; }
.bag em:nth-of-type(   6) { font-size  : 100%; }
.bag em:nth-of-type(   7) { font-size  :  90%; }
.bag em:nth-of-type(   8) { font-size  :  80%; }
.bag em:nth-of-type(   9) { font-size  :  70%; }
.bag em:nth-of-type(n+10) { font-size  :  60%; }




.current_slot_num {
    box-shadow : 0px 3px 6px rgba(0,0,0,0.8) !important;
    font-size  : 150%;
}


.bag                  { border-radius : 2em; }
.transcript_msg div   { border-radius : 1ex; }
.bag div              { border-radius : 2ex; }

#headsup              { border-radius : 2em; }
#pat_bag              { border-radius : 2em; }
#sel_bag              { border-radius : 2em; }
#dom_traversal        { border-radius : 2em; }

#headsup>div>div      { border-radius : 2em; }
#headsup>div>div      { border        : 5px solid #000000; }
#headsup>div>div div  { border-radius : 1em; }

#dom_traversal>div>div     { border-radius : 2em; }
#dom_traversal>div>div     { border        : 5px solid #000000; }
#dom_traversal>div>div div { border-radius : 1em; }

#pat_bag>div>div     { border-radius : 2em; }
#pat_bag>div>div     { border        : 5px solid #000000; }
#pat_bag>div>div div { border-radius : 1em; }
#sel_bag>div>div     { border-radius : 2em; }
#sel_bag>div>div     { border        : 5px solid #000000; }
#sel_bag>div>div div { border-radius : 1em; }




.eso_div { transition-duration         : 900ms !important; }
.eso_div { transition-delay            :   0ms !important; }
.eso_div {
    display       : inline-block           !important;
    border        : 1px solid #404040      !important;
    border-radius : 5px 5px 5px 5px        !important;
    box-shadow    : 0 0 10px #000000 inset !important;
    background    : rgba(16,16,16,0.5)     !important;
    min-width     : 8em;
    min-height    : 8em;

    color         : orange !important;
    font-weight   : 700;

    transition-property : all !important;
}



.pulse_in { transition-duration         : 500ms !important; }
.pulse_in { transition-delay            :   0ms !important; }
.pulse_in {
    transform                   : translate(-10px, 10px) scale(2.0) !important;
    transition-property         :   all !important;
    transition-timing-function  :  ease !important;
}

.pulse_out { transition-duration         : 500ms !important; }
.pulse_out { transition-delay            :   0ms !important; }
.pulse_out {
    transform                   : scale(1) rotate(0) !important;
    transition-property         :   all !important;
    transition-timing-function  :  ease !important;
}




li:nth-child( 5n+0) { margin-bottom:.5em !important; }
li:nth-child(10n+0) { margin-bottom:.8em !important; }
li { white-space: nowrap; }



#headsup_l {
 clear          : left;
 white-space    : nowrap;
 cursor         : pointer;
 user-select    : none;
}

#dom_grid_playground_grid_sized {
 white-space    : nowrap;
 cursor         : pointer;
 user-select    : none;
}

#headsup_l_check {
 cursor         : pointer;
}





#headsup    { min-width : 23em; min-height:13em; }
#headsup_w  { min-width : 17em; min-height:13em; }
#headsup_ds { min-width : 14em; min-height: 9em; }






.grid_caption {
    cursor              : pointer;
    border-radius       : 16px;
    background          : rgba(32,32,64,0.9);
    text-align          : center;
    transform-origin    : 0 0 !important;

}
.grid_caption.pressed { transform : none !important; }
.grid_caption em {
    padding        : 0 1ex 0 1ex;

    background     : rgba(255,192,192,0.2);
    color          : rgba(  0,  0,  0,1.0);
    border-radius  : 1em;

    font-family    : "Comic sans ms";
    font-weight    : 700;
    font-size      : 100%;

    white-space    : nowrap;
}
.grid_caption               { opacity : 0.8; }
.grid_caption_see_through * { opacity : 0.2; }

.grid_caption>em              {
    position    : absolute;
    top         : 50%;
    left        : 50%;
}
.grid_caption>em:nth-child(1) { transform : translate(-50%,-3em); }
.grid_caption>em:nth-child(2) { transform : translate(-50%,-1em); }
.grid_caption>em:nth-child(3) { transform : translate(-50%,+1em); }





.grid_caption_hide { animation-duration        : 250ms; }
.grid_caption_hide { animation-delay           : 250ms; }
.grid_caption_hide {
                     transform-origin          : 0% 0% 0;
                     animation-name            : grid_caption_hide;
                     animation-timing-function : ease-out;
                     animation-fill-mode       : both;
}

@keyframes grid_caption_hide {
    100% { top       :        0; }
    100% { left      :        0; }
    100% { opacity   :       .1; }
    100% { transform : scale(.5) translate(-100%,-100%); }
}


.grid_caption_show  {
    animation : 1000ms cubic-bezier(0,1,0.5,0.8) forwards grid_caption_show
    ,     250ms 2000ms                           forwards grid_caption_show_restore_opacity
    ;
}

@keyframes grid_caption_show {

     from { transform : scale(0.5); }
     99%  { transform : scale(0.5); }

     from { top       :       0   ; }
     from { left      :       0   ; }
     97%  { top       :       0   ; }
     80%  { left      :       0   ; }

      to  { opacity   :       1.0 ; }
}

@keyframes grid_caption_show_restore_opacity {
    from { opacity   :       1.0 ; }
}


.grid_caption_see_through { transition-duration : 200ms; }
.grid_caption_see_through {
    background          : rgba(192,192,192,0.1);
}


   @keyframes on_grid_enter {
    100%       { transform    :  scale(0.9 ); }
}




.index {
    font-size     : 180%;
    border-radius : 1em;
    padding-left  : .4em;
    padding-right : .4em;
    width         : 2em;
}









.pivot_panel { box-shadow : 4px 4px 12px rgba(0,0,48,0.7) !important; }



.pinned      { transform-origin : 50% 50%                    ; }

.pivot_panel { animation : 250ms ease-out none     forwarding; }

@keyframes forwarding    {
      0% { transform   : scale(0.96,0.96); }
     10% { transform   : scale(0.97,0.97); }
    100% { transform   : scale(1.00,1.00); }
}


.pinned       {           filter : none                            !important; }
.pivot_panel  {           filter : none                            !important; }
.fully_spread {           filter : grayscale(80%) brightness( 90%) !important; }
.on_grid      {           filter : none                            !important; }

.dimmed_panel {           opacity : 0.3; }


.dimmed_panel { transition : opacity  300ms ease-out; }









.standby                 { background : linear-gradient(to bottom, #666, #222) !important; }
#sel_bag.standby         { background : linear-gradient(to bottom, #F00, #400) !important; }
#sel_bag.standby::before { content    : '\\2699'; }




  .dimmed_panel INPUT { pointer-events      :        none; }
  .dimmed_panel INPUT { cursor              :     inherit; }

  .on_grid      INPUT { pointer-events      :        none; }
  .on_grid      INPUT { cursor              :     inherit; }






#pivspot   {
    pointer-events   : none;
    position         : fixed;
    transform        : translate(-50%,-50%);
    transform-origin : 50% 50% 0;

}
#pivspot.hidden { opacity : 0; }


#pivspot_c {
    border-radius    : 50%;
    border           : 2px solid white;
    text-shadow      : rgba( 0, 0, 0,0.8) 1px 1px 3px;
    box-shadow       : rgba( 0, 0, 0,0.2) 2px 2px 16px 5px;
    background       : rgba(32,32,32,0.2);
    color            : white;
    font-size        : 42px;
    width            : 32px;
    height           : 32px;
}



#hotspot               { background      : none      !important; }
#hotspot               { transform       : translate(-50%,-50%); }
#hotspot               { align-items     : center;               }
#hotspot               { box-sizing      : border-box;           }
#hotspot               { cursor          : pointer;              }
#hotspot               { justify-content : center;               }

#hotspot      *:after  { background      : #777;                 }
#hotspot.dark *:after  { background      : #AAA;                 }

#hotspot.move_on_cooldown:before { font-size: 24px; content: "\\231B"     ; position: absolute; transform: translate(2em,0); border-radius:1em; padding:0.2em 0.5em; background-color:rgba(000,255,000,0.5); box-shadow:-1px -1px 3px #888 inset; }
#hotspot.not_moved_enough:after  { font-size: 24px; content: "\\25C4\\25BA"; position: absolute; transform: translate(2em,0); border-radius:1em; padding:0.2em 0.5em; background-color:rgba(000,000,255,0.5); box-shadow:-1px -1px 3px #888 inset; }

.page_items_all_removed                   { background : #F00 !important; }
.page_items_has_pat_csv   .hotwave::after { background : #080 !important; }
.page_items_has_bak_csv   .hotwave::after { background : #800 !important; }
.page_items_has_alt_csv   .hotwave::after { background : #008 !important; }
.page_items_hidden_panels .hotwave::after { background : #F0F !important; }
.page_items_off_gutter    .hotwave::after { background : #000 !important; }
.page_items_all_removed   .hotwave::after { background : #000 !important; }

.page_items_has_pat_csv   .hotring        { border : 3px dotted #080 !important; }
.page_items_has_bak_csv   .hotring        { border : 3px dotted #F00 !important; }
.page_items_has_alt_csv   .hotring        { border : 3px dotted #00F !important; }
.store_update_pending     .hotring        { border : 3px  solid #000 !important; }





#hotspot_c { pointer-events   : none;                             }
#hotspot_c { box-shadow       : rgba(0,0,0,0.2) 2px 2px 16px 5px; }


              #hotspot_c { border-radius : 50%;                          }
              #hotspot_c { border        : 2px solid   white           ; }
.store_count1 #hotspot_c { border        : 9px solid #964B00 !important; }
.store_count2 #hotspot_c { border        : 9px solid #FF0000 !important; }
.store_count3 #hotspot_c { border        : 9px solid #FFA500 !important; }

#hotspot.store_count1::after,
#hotspot.store_count2::after,
#hotspot.store_count3::after {
    content           : '\\2714';
    font-size         : 64px;
    transform-origin  : 50% 50%;
    position          : absolute;
    margin-top        : -1em;

}
#hotspot.store_count1::after { color : #964B00; }
#hotspot.store_count2::after { color : #FF0000; }
#hotspot.store_count3::after { color : #FFA500; }

#hotspot.store_count1::after,
#hotspot.store_count2::after,
#hotspot.store_count3::after { animation :  250ms none store_count_check; }
@keyframes store_count_check {

     from { transform         : scale(0.1) translate(0.5em,  0    ); }
      10% { transform         : scale(1.1) translate(0.5em,  0    ); }
      50% { transform         : scale(1.0) translate(0.5em, -0.5em); }
       to { transform         : scale(0.1) translate(0    ,  1.0em); }

     from { opacity           :       0.1 ; }
      80% { opacity           :       1.0 ; }
      to  { opacity           :       0.1 ; }
}

#hotspot_c { margin-left      : 14px;                             }
#hotspot_c { margin-top       : 14px;                             }
#hotspot_c { width            : 12px;                             }
#hotspot_c { height           : 12px;                             }

#hotspot_c { font-weight      : 100;                              }
#hotspot_c { font-size        : 12px;                             }
#hotspot_c { text-shadow      : rgba( 0, 0, 0,0.8) 1px 1px 3px;   }
#hotspot_c { background       : rgba(32,32,32,0.2);               }



#hotspot_c::after { position         : absolute;                    }
#hotspot_c::after { left             :   0px;                       }
#hotspot_c::after { top              :  -13px;                      }
#hotspot_c::after { font-size        :   9px;                       }
#hotspot_c::after { text-shadow      : rgba(0,0,0,0.8) 1px 1px 3px; }
#hotspot_c::after { background-color : transparent;                 }



      #hotspot_c        { color : #000; }
.dark #hotspot_c        { color : #FFF; }
      #hotspot_c::after { color : #000; }
.dark #hotspot_c::after { color : #FFF; }



#hotspot_c.rotate_NE::after { content : " NE"; }
#hotspot_c.rotate_SE::after { content : " SE"; }
#hotspot_c.rotate_SW::after { content : " SW"; }
#hotspot_c.rotate_NW::after { content : " NW"; }

#hotspot_c          >* { display    : inline-block;      }
#hotspot_c          >* { text-align : center;            }
#hotspot_c          >* { transition : all 900ms ease-in; }
#hotspot_c.rotate_NE>* { transform  : rotate(  40deg);   }
#hotspot_c.rotate_SE>* { transform  : rotate( -40deg);   }
#hotspot_c.rotate_SW>* { transform  : rotate( 220deg);   }
#hotspot_c.rotate_NW>* { transform  : rotate(-220deg);   }

.rotate_NE { transform : rotate( -45deg); }
.rotate_SE { transform : rotate( +45deg); }
.rotate_SW { transform : rotate(+135deg); }
.rotate_NW { transform : rotate(-135deg); }

.rotate_NE { background-color : rgba(150, 75,  0,0.7) !important; color:#964B00; }
.rotate_SE { background-color : rgba(255,  0,  0,0.7) !important; color:#FF0000; }
.rotate_SW { background-color : rgba(255,165,  0,0.7) !important; color:#FFA500; }
.rotate_NW { background-color : rgba(255,255,  0,0.7) !important; color:#FFFF00; }

.rotate_NE { transition-delay           : 100ms; }
.rotate_SE { transition-delay           : 100ms; }
.rotate_SW { transition-delay           : 100ms; }
.rotate_NW { transition-delay           : 100ms; }

.rotate_NE { transition-duration        : 300ms; }
.rotate_SE { transition-duration        : 300ms; }
.rotate_SW { transition-duration        : 300ms; }
.rotate_NW { transition-duration        : 300ms; }

.rotate_NE { transition-timing-function : cubic-bezier(0.5, 0.05, 0.9, 1.2); }
.rotate_SE { transition-timing-function : cubic-bezier(0.5, 0.05, 0.9, 1.2); }
.rotate_SW { transition-timing-function : cubic-bezier(0.5, 0.05, 0.9, 1.2); }
.rotate_NW { transition-timing-function : cubic-bezier(0.5, 0.05, 0.9, 1.2); }



#tools_trap {
    background    :             rgba( 32, 32, 32,0.3)  !important;
    box-shadow    : 0px 3px 3px rgba(000,000,000,0.5)  !important;
    border-radius : 50%                                !important;
    border        : 0                                  !important;
    text-align    : right                              !important;
    font-size     : 500%                               !important;
    font-weight   : 900                                !important;
    padding       : .1em                               !important;
    line-height   : 50%                                !important;
    min-width     : initial                            !important;
}
#tools_trap.scrolled { box-shadow    : none            !important; }
#tools_trap.dark     { color         : #888            !important; }




#tools_trap.trapped  { border-radius : 10% 50% 50% 10% !important; }

#hotspot_c.trapped   { border-radius : 10% 50% 50% 10% !important; }
#hotspot_c.trapped   { border-radius : 50% 10% 10% 50% !important; }

#pivspot_c.trapped   { border-radius : 10% 50% 50% 10% !important; }







.hotwave {
    position           : absolute;
    background         : none;

}

.hotwave::before {
    border-radius      : 50%;
    border             : .15em solid rgba(255,255,255, .9);
    content            : '';
    height             : 100%;
    left               : 0;
    top                : 0;
    opacity            : 0;
    position           : absolute;
    transform          : scale(2);
    transition         : transform .25s, opacity .2s;
    width              : 100%;
}

.hotwave::after {
    border-radius      : 50%;
    content            : '';
    height             : 100%;
    left               : 0;
    position           : absolute;
    top                : 0;
    width              : 100%;

}



.pulse_in    { animation-name            : flyUp;  }
.pulse_in    { animation-duration        : 3s;     }
.pulse_in    { animation-timing-function : linear; }

.pulsing     { border     : #444 3px dotted;                 }
.pulsing     { background : rgba(255,000,000,.8) !important; }

@keyframes flyUp {
      0% { transform : translate(100%, -100%) scale(2.5); }
    100% { transform : translate(100%, -400%) scale(1.0); }
     10% { opacity   :.9; }
    100% { opacity   : 0; }
}


#hotspot       .hotring        { background         : linear-gradient(to bottom, #FF0, #FB0); }
#hotspot.dark  .hotring        { background         : linear-gradient(to bottom, #443, #211); }

.hotwave:hover .hotring::after { opacity            : 0;                                }
.hotwave:hover .hotring::after { opacity            : 1;                                }
.hotwave:hover .hotring::after { transform          : translate(-50%, 0) scale(1);      }

         .hotwave::after              { animation            : 3s infinite ease-out       normal  wave; }
         .hotring                     { animation            : 3s infinite linear         normal pulse; }
#hotspot.hiding_tools>div>div         { animation            : 12s -11s infinite steps(2) normal flash; }


        .hiding_tools .hotwave::after { animation-play-state : paused;                                  }
        .hiding_tools .hotring        { animation-play-state : paused;                                  }

        .hiding_tools>*               { color                : transparent    !important;               }
#hotspot.hiding_tools>div>div         { border               : 3px #000 solid !important;               }




   @keyframes pulse {
      0%       { transform    : scale(1.0 ); }
      2%       { transform    : scale(0.95); }
     10%       { transform    : scale(1.1 ); }
    100%       { transform    : scale(1.0 ); }
}


   @keyframes wave {
      2%       { transform    : scale(1  ); }
    100%       { transform    : scale(2  ); }
      0%       { opacity      : 1;          }
    100%       { opacity      : 0;          }
}


   @keyframes flash {
      0%       { box-shadow : 0 0 3em .5em black; }
    100%       { box-shadow : 0 0 3em .5em white; }
}


   @keyframes borderColor {
      0%       { border-color : #888;       }
    100%       { border-color : #000;       }
}




       .layout_NE>div  { margin:   0   32em    0   -32em !important; }
       .layout_NW>div  { margin:   0     0     0     0   !important; }
       .layout_SE>div  { margin:   0     0     0     0   !important; }
       .layout_SW>div  { margin:   0   32em    0   -32em !important; }

.gutter.layout_NE>div  { margin:   0     0     0     0   !important; }
.gutter.layout_NW>div  { margin:   0   32em    0   -32em !important; }
.gutter.layout_SE>div  { margin:  20em   0   -20em   0   !important; }
.gutter.layout_SW>div  { margin:  20em 32em  -20em -32em !important; }



                       .dom_editing #hotring          { opacity             : 0.0                           ; }
                       .dom_editing #hotring          { width               : 2em                           ; }
                       .dom_editing #hotring          { height              : 2em                           ; }

                                    .hotwave::before  { transition-duration : 500ms                         ; }
                       .dom_editing .hotwave::before  { transition-duration : 500ms                         ; }
                       .dom_editing .hotwave::before  { opacity             : 1                   !important; }

                       .dom_editing #hotspot_c::after { text-align          : center              !important; }
                       .dom_editing #hotspot_c::after { font-size           : 16px                          ; }
                       .dom_editing #hotspot_c::after { font-weight         : 700                           ; }
                       .dom_editing #hotspot_c::after { opacity             : 1                             ; }







                       .dom_editing .hotwave::before  { border              : 2px solid            #DDD       ; }

                       .dom_editing #hotspot_c::after { color               :                      #00F       ; }
                 .site_localstorage #hotspot_c::after { color               :                      #E00       ; }

                       .dom_editing #hotspot_c::after { text-shadow         : -1px -1px 1px        #FFF       ; }
                 .site_localstorage #hotspot_c::after { text-shadow         : -1px -1px 1px        #FFF       ; }

                       .dom_editing .hotwave::before  { background-color    :                      #AAF       ; }
                  .marked_to_hide   .hotwave::before  { background-color    :                      #FFF       ; }

                       .dom_editing .hotwave::before  { box-shadow          : 1px 1px  1px     1px #FFF inset ; }
                  .marked_to_hide   .hotwave::before  { box-shadow          : 1px 1px  1px     1px #FFF inset ; }

                       .dom_editing                   { transition-duration : 250ms; }
                       .dom_editing #hotspot_c::after { margin              : 0em  0   0  -1em !important; }
                       .dom_editing #hotspot_c        { transform           : rotate(-15deg)             ; }
     .site_localstorage.dom_editing #hotspot_c        { transform           : rotate( 15deg)   !important; }

                       .dom_editing                   #hotspot_c::after { content : "PAGE\\AMASK"; }
        .marked_to_hide.dom_editing                   #hotspot_c::after { content : "PAGE\\AHIDE"; }
                       .dom_editing.site_localstorage #hotspot_c::after { content : "SITE\\AMASK"; }
        .marked_to_hide.dom_editing.site_localstorage #hotspot_c::after { content : "SITE\\AHIDE"; }






#hotring {
    position           : relative;
    width              : 3em;
    height             : 3em;
    border-radius      : 50%;
    box-shadow         : 0 2px 10px rgba(0,0,0, .2);
    font-weight        : 600;
    font-size          : 12px;
    justify-content    : center;
    text-align         : center;

}


#hotring.u   { border-radius    :  0   0 50% 2em !important; }
#hotring.u.r { border-radius    :  0   0   0 50% !important; }
#hotring.r   { border-radius    :50%   0   0 2em !important; }
#hotring.r.d { border-radius    :50%   0   0   0 !important; }
#hotring.d   { border-radius    :50% 2em   0   0 !important; }
#hotring.d.l { border-radius    :  0 50%   0   0 !important; }
#hotring.l   { border-radius    :  0 50% 2em   0 !important; }
#hotring.l.u { border-radius    :  0   0 50%   0 !important; }

.hotring>* {

    text-align         : initial;


    transition         : background .3s;
}

.hotring>*  { transform : translate(0,-15em) scale(1.0); }





#fly_div             {
    border-radius    :                 0.5em;
    background       : rgba(000,000,255,0.1);
    display          :          inline-table;
    position         :                 fixed;
    top              :                   1em;
    right            :                   1em;


}
#fly_div.magnified   { transform : scale(2); }

#fly_div .closepin   { position : relative; }
#fly_div .pressed    { transform        : none  !important; }
#fly_div .pressed    { opacity          : 1     !important; }

#fly_div pre         { margin           :   1em; }
#fly_div pre         { padding          : 0.5em; }
#fly_div pre         { max-height       : 50em;  }
#fly_div pre         { max-width        : 50em;  }
#fly_div pre         { overflow-x       : auto;  }
#fly_div pre         { overflow-y       : auto;  }

#fly_div div         { overflow-x       : auto;  }

#fly_div em          {
    border           : none;

    background       : black;
    box-shadow       : 0.1em 0.1em 0.1em rgba(0,0,0,0.8);
}






.floatlog>div {

    box-sizing : initial    !important;
    max-width  : 48em;
    padding    : .3em;
}
.floatlog>div { box-shadow : rgba(0,0,0,.5) .2em .2em .9em !important; }
.floatlog em  { font-size            : 80%;                    }
.floatlog>*   { white-space          : nowrap;                 }
.floatlog>*   { transform-origin     : 0 0 0;                  }



.stage_1_input , .stage_1_missed, .stage_1_more { background :linear-gradient(to top   , rgba(0,0,0,.6) 0%, rgba(0,0,0,.4) 50%, rgba(0,0,0,.5) 80%, rgba(0,0,0,.5) 95%, #111 100%); }
.stage_2_action, .stage_2_missed                { background :linear-gradient(to top   , rgba(0,0,0,.6) 0%, rgba(0,0,0,.4) 50%, rgba(0,0,0,.5) 80%, rgba(0,0,0,.5) 95%, #111 100%); }
.stage_3_result, .stage_3_missed, .stage_3_more { background :linear-gradient(to bottom, rgba(0,0,0,.6) 0%, rgba(0,0,0,.4) 50%, rgba(0,0,0,.5) 80%, rgba(0,0,0,.5) 95%, #111 100%); }

.floatlog>div.stage_1_input  { border-top                 : 2px solid #AAA              ; }
.floatlog>div.stage_1_input  { border-left                : 1px solid #AAA              ; }
.floatlog>div.stage_1_input  { border-right               : 1px solid #AAA              ; }
.floatlog>div.stage_1_input  { border-bottom              : 0         #AAA              ; }
.floatlog>div.stage_1_missed { border-top                 : 2px solid #AAA    !important; }

.floatlog>div.stage_2_action { border-top                 : 0         #AAA              ; }
.floatlog>div.stage_2_action { border-left                : 1px solid #AAA              ; }
.floatlog>div.stage_2_action { border-right               : 1px solid #AAA              ; }
.floatlog>div.stage_2_action { border-bottom              : 0         #AAA              ; }
.floatlog>div.stage_2_missed { border                     : 1px solid #AAA    !important; }

.floatlog>div.stage_3_result { border-top                 : 0         #AAA              ; }
.floatlog>div.stage_3_result { border-left                : 1px solid #AAA              ; }
.floatlog>div.stage_3_result { border-right               : 1px solid #AAA              ; }
.floatlog>div.stage_3_result { border-bottom              : 2px solid #AAA              ; }
.floatlog>div.stage_3_missed { border-bottom              : 2px solid #AAA    !important; }

.floatlog>div.stage_1_input  { border-top-left-radius     : 1em                          ; }
.floatlog>div.stage_1_input  { border-top-right-radius    : 1em                          ; }
.floatlog>div.stage_1_missed { border-top-left-radius     : 1em                !important; }
.floatlog>div.stage_1_missed { border-top-right-radius    : 1em                !important; }
.floatlog>div.stage_1_more   { border-top-left-radius     : 0                  !important; }
.floatlog>div.stage_1_more   { border-top-right-radius    : 0                  !important; }

.floatlog>div.stage_3_result { border-bottom-left-radius  : 1em                          ; }
.floatlog>div.stage_3_result { border-bottom-right-radius : 1em                          ; }
.floatlog>div.stage_3_missed { border-bottom-left-radius  : 1em                !important; }
.floatlog>div.stage_3_missed { border-bottom-right-radius : 1em                !important; }

.floatlog>div.stage_3_more   { border-bottom-left-radius  : 0                  !important; }
.floatlog>div.stage_3_more   { border-bottom-right-radius : 0                  !important; }

.floatlog>div.stage_3_more   { border-bottom              : 2px solid #888    !important; }
.floatlog>div.stage_3_more   { padding-bottom             : 2px                !important; }




.stage_0_log        { background     : linear-gradient(to left, #000 0%, rgb(62, 62, 62) 5px, #888); }
.stage_0_log        { box-shadow     : 3px 3px 10px 0px black;                                     }

.stage_0_log        { color          : white            ; }
.stage_0_log        { text-shadow    : #000 1px 1px 0px ; }

.stage_0_log        { padding        : .5em             ; }
.stage_0_log        { font-weight    : 100              ; }
.stage_0_log        { border-bottom  : 2px solid #AAA   ; }
.stage_0_log        { border-left    : 1px solid #AAA   ; }
.stage_0_log        { border-right   : 1px solid #AAA   ; }
.stage_0_log        { border-top     : 2px solid #AAA   ; }
.stage_0_log        { border-radius  : 1em              ; }
.stage_0_log        { max-width      : 64em             ; }

.stage_0_log.fading { animation      : none   !important; }
.stage_0_log>*      { margin-right   : .1em             ; }





.pause_animation       { animation          : none !important; }



         .floatlog>*   { animation           : 2s    ease-out forwards stacking; }
.stacking.floatlog>*   { animation-duration  : 1s   !important;                  }

@keyframes stacking {
       0% { opacity   :.1; }
      20% { opacity   :.5; }
     100% { opacity   : 1; }
       0% { transform : translate(-25em, 13em) scale(0.5 ); }
      10% { transform : translate( -5em,  5em) scale(0.9 ); }

      20% { transform : translate(-.5em,  2em) scale(1.03); }
      40% { transform : translate(-.5em,  1em) scale(1.03); }
      80% { transform : translate(-.5em, .3em) scale(1.03); }
     100% { transform : translate(  0em,  0em) scale(1.0 ); }
}



.removing              {             opacity : .1; }
.removing              { transform           : translate(  0em, 12em) scale(1.0); }
.removing              { transition-property : transform;                         }
.removing              { transition-duration : 500ms;                                }

.removing              { animation           : 1s 500ms  ease-out forwards removing; }
@keyframes removing    {
    100% { opacity   : 0; }
    100% { border    : 0; }
    100% { height    : 0; }
    100% { padding   : 0; }
}



.fading      { transition-duration : 500ms;                          }
.fading      { animation           : 2s 500ms ease-out forwards fading; }

.fading      { transition-duration : 3s;                          }
.fading      { animation           : 5s ease-out forwards fading; }

@keyframes fading {
      0% { height    : 1em; }
     90% { height    : 1em; }
    100% { height    :.2em; }



    100% { padding   :   0; }
    100% { border    :   0; }
}




.standby {
    box-shadow    : 0 0 1em 1em #FDD !important;

}
.standby::before {
    position      : absolute;
    right         : .5em;
    top           : .1em;
    color         : black;
    font-size     : 300%;
    text-shadow   : #AAA 1px 1px 1px;
}
.standby::before { transform-origin   : 50% 55% 0; }
.standby::before { animation-name     : cycle;  }
.standby::before { animation-duration : 1s;     }


   @keyframes cycle {
      0% { transform : rotate(  0deg); }
    100% { transform : rotate(360deg); }
}



.panel_pressed_glowing { transition-duration         :   1750ms; }
.panel_pressed_glowing { transition-delay            :   1250ms; }
.panel_pressed_glowing {
    box-shadow                  : 0 0 1em 0em #FFF !important;
    transform                   : scale(2.1);

    transition-property         : transform, box-shadow;
    transition-timing-function  : ease-in  , ease-in   ;
}

.panel_magnifying_glass::before {
    position      : absolute;
    right         : .5em;
    top           : .1em;
    color         : black;
    font-size     : 500%;
    content       : '\\1f50D';
    text-shadow   : #AAA 1px 1px 1px;
}







#dimm_mask {
    cursor              : not-allowed;
    background-color    : rgba(64,64,64,0.4);
    overflow            : auto;
    transition          : background-color 500ms;
}

.dimm_light { background : linear-gradient(to left,rgba(0,0,0,0.3), rgba(64,64,64,0.5) 50%, rgba(032,032,032,0.8)); }
.dimm_dark  { background : linear-gradient(to left,rgba(0,0,0,0.8), rgba(64,64,64,0.9) 50%, rgba(032,032,032,1.0)); }




#dimm_mask          >EM      { cursor           : pointer;                   }
#dimm_mask          >EM      { pointer-events   : auto;                      }
#dimm_mask          >EM      { transition       : all 250ms ease-out;        }

#dimm_mask          >EM      { border           : none;                      }
#dimm_mask          >EM      { font-size        : 80px;                      }

#dimm_mask          >EM      { opacity          : 0.3;                       }
#dimm_mask          >EM      {            color : black;                     }
#dimm_mask          >EM      { background-color : transparent;               }


#dimm_mask          >EM.left { background-color : rgba(0,0,0,0.2) !important; }




 .button_prev              { display:none; position:fixed; top:160px; bottom:unset; left:unset; right: 40px; margin:0 0 0 0; }
 .button_next              { display:none; position:fixed; top:280px; bottom:unset; left:unset; right: 40px; margin:0 0 0 0; }

 .button_prev.left         { display:none; position:fixed; top:unset; bottom:240px; left:  0px; right:unset; margin:0 0 0 -40px; width:80px; padding-right:30px; }
 .button_next.left         { display:none; position:fixed; top:unset; bottom:120px; left:  0px; right:unset; margin:0 0 0 -40px; width:80px; padding-left :30px; }

 .button_mono              { display:none; position:fixed; top:360px;  left:unset; right: 40px; margin:0 0 0 0; }

 .button_next.left         { border-radius    :  0px 40px 40px  0px; }
 .button_prev.left         { border-radius    : 40px  0px  0px 40px; }

 .button_prev              { transform        : rotate(180deg) translate( 0px,0px) !important; }
 .button_prev.pressed      { transform        : rotate(190deg) translate(10px,0px) !important; }
 .button_next              { transform        : rotate(  0deg) translate( 0px,0px) !important; }
 .button_next.pressed      { transform        : rotate( 10deg) translate(10px,0px) !important; }

 .button_prev.left         { transform        : rotate(180deg) translate( 0px,0px) !important; }
 .button_prev.left.pressed { transform        : rotate(180deg) translate(10px,0px) !important; }
 .button_next.left         { transform        : rotate(  0deg) translate( 0px,0px) !important; }
 .button_next.left.pressed { transform        : rotate(  0deg) translate(10px,0px) !important; }

 .button_mono              { transform        : rotate(  0deg) !important; }
 .button_mono.pressed      { transform        : rotate(180deg) !important; }








#div_slot_containers {
    display               : grid;
    box-shadow            : 2px 2px 32px rgba(0,0,0,0.2) !important;
    margin                : 0 !important;
    padding               : 0 !important;
    user-select           : none;
    cursor                : copy;
    background-color      : rgba(64,64,64,1.0);

    grid-template-columns : repeat(3, 1fr);


}
#div_slot_containers a              { font-size: 200%; color: red; pointer-events:all !important; cursor: pointer !important; }
#div_slot_containers.fullscreen     { position:fixed; }
#div_slot_containers.fullscreen     { grid-template-columns : auto; }
#div_slot_containers.fullscreen     {
    opacity          : 1     !important;
    background       : #AAA  !important;
    transition       : all 250ms ease-out;
}





#div_slot_containers>div {

    min-width             : 8em;
    margin                : 1ex 1ex 1ex 1em;

    border-radius         : 0 1em 1em 0;
    border-left-style     : solid;
    border-left-width     : .5em;

    padding               : 1ex 1em 1ex 1em;

    opacity               : 0.8;
    color                 : #000;
    overflow              : hidden;
    font-weight           : 700;
    font-weight           : 600;
}

#div_slot_containers   .button_copy   { display          : inline-block; }
#div_slot_containers   .button_copy   { cursor           : pointer;      }
#div_slot_containers   .button_copy   { padding          : 0.2em;        }
#div_slot_containers   .button_copy   { border           : 1px outset;   }
#div_slot_containers            div   { cursor           : all-scroll;   }
#div_slot_containers.fullscreen>div   { cursor           : grab;         }

.fullscreen_prev { transform-origin :   0% 0;  animation : 250ms ease-in translate_left_to_right; }
.fullscreen_next { transform-origin : 100% 0;  animation : 250ms ease-in translate_right_to_left; }
@keyframes translate_left_to_right {
      0% { transform : translate(-100%, 0%); }
    100% { transform : translate(   0%, 0%); }
}
@keyframes translate_right_to_left {
      0% { transform : translate( 100%, 0%); }
    100% { transform : translate(   0%, 0%); }
}

.fullscreen_last                   { transform-origin : 0 0;  animation : 550ms ease-in translate_shift_from_top                 ; }
.fullscreen_last.fullscreen_left   { transform-origin : 0 0;  animation : 550ms ease-in translate_shift_from_top_right !important; }
.fullscreen_last.fullscreen_right  { transform-origin : 0 0;  animation : 550ms ease-in translate_shift_from_top_left  !important; }
@keyframes translate_shift_from_top_left  { from { transform : translate(-10%, -10%); } 80% { transform : translate(-8%, -1%); } to { transform : translate(0,0); } }
@keyframes translate_shift_from_top       { from { transform : translate(  0%, -10%); } 80% { transform : translate( 0%, -8%); } to { transform : translate(0,0); } }
@keyframes translate_shift_from_top_right { from { transform : translate( 10%, -10%); } 80% { transform : translate( 8%, -2%); } to { transform : translate(0,0); } }

.button_copy em                     { pointer-events : none; }
.button_copy em                     { padding-left:1em; padding-right:1em; color:white; background:rgba(0,0,0,0.5); }

#div_slot_containers>div {             color : black; }

#div_slot_containers                    { transform-origin : 50% 100%; }
#div_slot_containers.scrolled_over_view { animation : 1000ms ease-in scrolled_over_view_anim; }
@keyframes scrolled_over_view_anim {

    from { box-shadow : 0 0 20px 30px rgba(255,000,000,0.53) inset; }
    to   { box-shadow : 0 0 10px  0   rgba(255,000,000,0.00) inset; }
}

                  .note1 {  background-color : rgba(150,075,000,0.2); border-color : #964B00;                      }
                  .note2 {  background-color : rgba(255,000,000,0.2); border-color : #FF0000;                      }
                  .note3 {  background-color : rgba(255,165,000,0.2); border-color : #FFA500;                      }
                  .note4 {  background-color : rgba(255,255,000,0.2); border-color : #FFFF00;                      }
                  .note5 {  background-color : rgba(154,205,050,0.2); border-color : #9ACD32;                      }
                  .note6 {  background-color : rgba(100,149,237,0.2); border-color : #6495ED;                      }
                  .note7 {  background-color : rgba(238,130,238,0.2); border-color : #EE82EE;                      }
                  .note8 {  background-color : rgba(160,160,160,0.2); border-color : #A0A0A0;                      }
                  .note9 {  background-color : rgba(221,221,221,0.2); border-color : #DDDDDD; border-style:double; }
                  .note0 {  background-color : rgba(128,128,128,0.2); border-color : #202020; border-style:double; }



#div_slot_containers>.container_selected { box-shadow       : 0 0 20px 3px #333 inset;                               }
#div_slot_containers>.container_selected { opacity          :    1.0;                                                }
#div_slot_containers>.container_selected { color            :   #000;                                                }
#div_slot_containers>.container_selected { border-width     :  0.9em;  border-style :  solid;                        }
#div_slot_containers>.fullscreen_last    { outline-width    :  0.5em; outline-style : dashed; outline-color : black; }


.content_is_too_big                      {       font-style : italic;               }
.content_is_too_big                      {            color : #888  !important;     }
.content_is_too_big                      { background-color : #DDD  !important;     }


            .button_magnify { pointer-events   : auto    !important; }
.fullscreen .button_magnify { pointer-events   : none    !important; }

            .button_magnify { cursor           : pointer !important; }
            .button_magnify { border           : none;               }
            .button_magnify { float            : right;              }
            .button_magnify { margin-right     : 0;                  }
            .button_magnify { margin-top       : 0;                  }

            .button_magnify { font-size        : 80px    !important; }
            .button_magnify {            color : black   !important; }
            .button_magnify { background-color : transparent;        }
            .button_magnify { opacity          : 0.8;                }

.fullscreen .button_magnify { transform        : rotate(90deg);      }
            .button_magnify { transition       : all 250ms 500ms ease-out;  }







.button_COPY       { display          : inline;          }
.button_COPY       { margin           : 0                            !important; }
.button_COPY       { cursor           : copy                         !important; }
.button_COPY       { opacity          : 0.3; }
.button_COPY       { background-color : white;                                   }
.button_COPY       { color            : #444                         !important; }
.button_COPY       { border-radius    : 0 1em 1em 0;                             }
.button_COPY       { padding          : 0.1em                        !important; }

.button_COPY:hover { opacity          : 1.0; }
.button_COPY:hover { box-shadow       : 2px 2px 32px rgba(0,0,0,0.9);            }





.div_copy_content         { pointer-events   : none; }

.div_copy_content         { margin           : 0.5em 80px .5em 1em !important; }









#bag_rot           { font-size     :  80%; }
#bagopen           { font-size     :  80%; }
#bag_rot>*         { font-size     : 520%; }
#bagopen>*         { font-size     : 520%; }

#pat_sort          { font-size     : 120%; }
#fly_log           { font-size     : 150%; }
#bag_rot span      { font-size     : 500% !important; }
#bag_rot           { font-weight   :  900 !important; }
#pat_sort          { font-weight   :  900;            }


#bag_rot>sup,
#bag_rot>sub       { opacity       :  0.3; }



          #bag_rot       { letter-spacing :0em; }
@media only screen and (min-resolution : 120dpi) {
          #bag_rot       { letter-spacing :-1em; }
}
.open_bag #bag_rot       { letter-spacing : 3em; }
          #bagopen       { letter-spacing :-1em; }



#pat_bag                  { padding-bottom : 11em; }
#pat_bag {
    border-top    : 1px solid rgba(255,255,255,1 );
    border-left   : 3px solid rgba(255,255,255,.5);
}
#pat_bag.dark {
    border-top    : 1px solid rgba(255,255,192,.3);
    border-left   : 3px solid rgba(255,255,192,.1);
}



#bot_div { position  : absolute; bottom:0;  left:.5em !important; width:100% !important;   }
#bot_div   { overflow  : visible !important; }
#bot_div>* { display:inline !important; }



#bag_rot           { position      : absolute; left : 1em; right:1.5em; bottom:  1em; }
#bagopen           { position      : absolute;             right:0.1em; bottom:  1em; }


#pat_sort          { position      : absolute; right:3.8em; bottom: 0  ; }
#fly_log           { position      : absolute; right:0.1em; bottom: 0  ; }



#bag_rot           { margin        :  0      5.0em  2.5em 0 !important; }
#bagopen           { margin        :  0      0.1em  2.2em 0 !important; }
#fly_log           { margin        :  0      0     -0.3em 0 !important; }
#pat_sort          { margin        : -0.7em -0.3em  0     0 !important; }




#bag_rot           { border        : none                !important; }
#pat_sort          { border        : none                !important; }
#fly_log           { border        : none                !important; }

#bag_rot           { border-radius : 0.5em               !important; }
#bagopen           { border-radius : 0.5em               !important; }
#pat_sort          { border-radius : 0.9em               !important; }
#fly_log           { border-radius : 1.8em   0    0   0  !important; }



#pat_bag            { padding-right  : 1.5em; }
#pat_bag.wide_panel { padding-right  : 4.5em; }

#bag_rot           { line-height   :  6.0em              !important; }
#bag_rot           { padding       :  0    1em    0  1em !important; }

#pat_sort          { padding       : .3em .5em .3em .5em !important; }
#fly_log           { padding       : .6em                !important; }




#bagopen           { border        : 0                  !important; }
#bagopen           { padding       : 0 1em 0 0          !important; }
#bagopen:hover     { box-shadow    : 0 0 .3em .2em #F00 !important; }

#bagopen>*         { padding       : 0                  !important; }
#bagopen>*         { text-shadow   : black 1px 1px 2px; }


          #bagopen   { transform  : rotate(  0deg); }
.open_bag #bagopen   { transform  : rotate(180deg); }
          #bagopen   { transition : transform 250ms ease-in 250ms !important; }
.open_bag #bagopen   { transition : transform 250ms ease-in 250ms !important; }



#bag_rot           { min-width      :    5em; }
#pat_sort          { min-width      :  1.7em; }

#bag_rot           { text-align     : center; }
#pat_sort          { text-align     : center; }
#pat_sort          { white-space    :   pre;  }
#pat_sort          { line-height    : 0.7em;  }


#bag_rot  *        { pointer-events : none                 !important; }
#bagopen  *        { pointer-events : none                 !important; }



#bot_div   { vertical-align: bottom !important;}
#bot_div>* { vertical-align: bottom !important;}



.txt_log {
    position       : absolute; left : .1em; bottom : .1em;
    pointer-events : none;

    border         : none             !important;
    padding        : 0 1em 0 1em      !important;

    font-family    : "Comic sans ms"  !important;
    font-style     : oblique          !important;
    font-weight    : 100              !important;
    white-space    : pre;

}
.txt_log em {
    border      : none            !important;
    padding     : 0 0.5em 0 0.5em !important;
    font-size   : 100%            !important;
    font-family : monospace       !important;
}




.txt_log          { background : linear-gradient(to top, rgba(255,255,255,.1) 2%, transparent 25%, rgba(  0,  0,  0,.1) 80%, rgba(255,255,255,.1) 100%); }

#bag_rot          { background : linear-gradient(to top, rgba(  0,  0,  0,.1) 20%, rgba(  0,  0,  0,.3) 80%, rgba(  0,  0,  0,.9) 100%); }
#bag_rot.checked  { background : linear-gradient(to top, rgba(255,  0,  0,.1) 20%, rgba(255,  0,  0,.3) 80%, rgba(255,255,255,.9) 100%); }

#pat_sort         { background : linear-gradient(to top, rgba(  0,  0,  0,.1) 20%, rgba(  0,  0,  0,.3) 80%, rgba(  0,  0,  0,.9) 100%); }
#pat_sort.checked { background : linear-gradient(to top, rgba(255,  0,  0,.1) 20%, rgba(255,  0,  0,.3) 80%, rgba(255,255,255,.9) 100%); }
#pat_sort.sort_off{ opacity    :  0.2; }
#pat_sort.user_set{ background : none; }


#fly_log          { background : linear-gradient(to top, rgba(  0,  0,  0,.1) 20%, rgba(  0,  0,  0,.3) 80%, rgba(255,255,255,.3) 100%); }
#fly_log.checked  { background : linear-gradient(to top, rgba(255,  0,  0,.1) 20%, rgba(255,  0,  0,.3) 80%, rgba(255,255,255,.3) 100%); }



      #bot_div>*{ color : #000 !important; }
.dark #bot_div>*{ color : #CCC !important; }

      #bag_rot  { color : #000 !important; }
.dark #bag_rot  { color : #FFF !important; }

      #pat_sort { color : #000 !important; }
.dark #pat_sort { color : #CCC !important; }

      #fly_log  { color : #000 !important; }
.dark #fly_log  { color : #CCC !important; }



#bag_rot:hover           { box-shadow : 0 0 .3em .2em #F00 !important; }
#bagopen:hover           { box-shadow : 0 0 .3em .2em #F00 !important; }
#pat_sort:hover          { box-shadow : 0 0 .3em .2em #F00 !important; }
#fly_log:hover           { box-shadow : 0 0 .3em .2em #F00 !important; }

#bag_rot.disabled        { background : rgba(128,128,128,.2)        !important; }
#pat_sort.disabled       { background : rgba(128,128,128,.2)        !important; }
#fly_log.disabled        { background : rgba(255, 64, 64,.5)        !important; }

#XXXbag_rot         {
background         : url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsSAAALEgHS3X78AAAFeklEQVRIiYWUXYxVVxXHf2vvfe49d+6dD4YZemeqdQpTHwwxjUYSeBCwYupbQ1uLCUqqTxWSStTEYmJiVCZ+tLVvfj3IA5HUFKVgaSOVGm1rx4K0UhVIrQxgNTMwc7/m3nvO2Xv5cO7cDproyjknOTtZ67/+//VfW1gdYkE9bPkRbNgN3RsgFkFRVybOapy4cD/rzWVu/dwihaEUMg+Sp2cB3CA8MCM8+bIyUR3HAVCaKDH2ofcSUiVrQTwOvp2DEUCsYf6Vt2Roum4Fq0GUSAOipcwzLSYHCAFI0M3T6s69xZWL/5xfyAHGN21kxy9mpdsAiSBr5gDGgfqAKRouHbrn4TE5NhXe1kY31oVnh/WWe+dvsyXOaBeHoM4iSRv/+U9hM8NXv3RIvp4D+C50m+jyIgQD1gJmpXlRF/HhaGnrg0vP1zulybIpeG7MVjppyvTYliVTnkigJ5Q1QBvqDYqgPYlEQC0jQ07Hhgq0OgGASmxYbGYstLzuWxvtLzaG9jdUsQCDnvqZQdL5gk7vu6p4QHuPAWdQIAcwAiFRtm9Edm0JTI6VsASuLHR55kyXQ78t0kZUNKiYvBBBsHHAxcEsd8EGiByo5ky05xvXH04sHD/r+flzCV/+TMSgafKVH2dE4xHEBoKKGCuq5FWsJc2U4QGYOQYfvB3u+Tik/1hVPRe6Fwo4CwNFjLXgHJSKSK8tjOAbdYwIEkWE5Sb07JN4eO1vcOIkXG8BUZ7SZ0B/RNpHF1VQRVGwhrDcovLRuzE77sOhtE/9kuTkrxHjUIUXL0Aa4Aen4PjXctlvZrBKuKD52z9TxRhL11huPHWE9NWXKe/6NFkIGAHv4cGPwDe+CMbApTehHK9iICK5tj1Ua8CZFSr5R1WJCwUqd22DpIMmSV6t11A7AVJodnKX3ySRqqoIaACKhpf+skyBBOI4PzO5XIOf2M2Vx77H6JoR7J0fQEMgKJRj4ae/g5cuQnUE1m+A5m/y1lxBoFAeKDQ9+CAQKadfU6AIseCD5sO0jus/+SFjD+0nefsqi6++QlQeYKmZ8shupb4NLs/Dxg197T2A2/XJezftfviJn33sW/+iVIooFCLssAGFdqcDGugkNd79+PeJvnsf85+9H1eIMAID0SAhC+DKrF0DE+tgqQW0lbYplUBxXoqVHZtunbj4+CIiwtzcHGma4FzE1O1TRC4iTVPeVR3m4uB7aJQXsJUKXqGUNvnr8vvZ/+y3kZChCiJYK55aNPoF3vfE3533IQB6x21rpFarcdeuu6nVanS7XbZu3cqxp49TjIdBA/smvsmLd3SolAwhgIjSSSOSxmg+zb7zQqBYMWh3YsWmApBmnnY348mnjvH6Gxc4e+48T5842XOKsuxG8dE6GtE4zcI4ddZxy+Qok+MpaIIxCbLykgJk7ywaYI3gvef5U79icnIS7zPWjAznQxPBaAaaYhHStnLnBsdD21L+8Kbn0O8tqa7QkL6/bwIAMMZw+PBhrl27xoEDB9i+fXuPo6C9RFUBK9TagdfnlMg5nAmk2Tu71K+3+kdVcc5x+vRp9uzZw+zsLNZatL+FPqDeg/cE70uR9+VC8OvXdryTxKPei3qPeo9mQAhO8+ygquq9J0kSWq0WMzMzTE1NcfToUXbu3EmSdAmmYokNIcpX9M/zUD+XUm96GhpDqbfBGoSoDLYUOWutW2EyMjLCwYMHqVarVKtVjhw5grUWgEKhSOXGMy/wxqU5qRQjQr79V1PJL1Wrq1ykio1jrv/xvGzevHl67969jzSbzcg5p3Ec0263CSFQqVRIkoROp6sDpWL0nUcfe/T8ZXfWlIdNCD70RrPqElYwESz+CToLgMh/jOT/hFjzX1P8X6Eh/Bs7TJStHjqCxQAAAABJRU5ErkJggg==") !important;
background-repeat  : no-repeat !important;
background-position: center    !important;
background-size    : 100% 100% !important;
}
#XXXbag_rot::before {
    content            : 'X';
    position           : relative;
    top                : 50%;
    left               : 50%;
    margin             : -50% 0 0 -50%;

    font-size          : 32px;
    text-align         : center;
}


#bag_rot_clone           { text-shadow    : black 0.2px 0.2px 0px; }
#bag_rot_clone           { opacity        : 0.3; }

#bag_rot_clone.cloning   { transition     : all 250ms ease-in;  }


#bag_rot.disabled:hover  { background : transparent        !important; }
#bag_rot.disabled:hover  { box-shadow : none               !important; }
#pat_sort.disabled:hover { background : transparent        !important; }
#pat_sort.disabled:hover { box-shadow : none               !important; }
#fly_log.disabled:hover  { background : transparent        !important; }
#fly_log.disabled:hover  { box-shadow : none               !important; }



#sel_bag .pat_div               { display      : block; }
#sel_bag .pat_div .data_pattern { margin-right : 0.5em; }



.pat_span          { float : left; clear  : left; }



.bags    , .want    , .have    , .done     { background       : linear-gradient(to bottom, rgba(034,034,034,0) 0%, rgba(034,034,034,0.6) 20%, rgba(034,034,034,0) 88%) !important; }
.bags.cc1, .want.cc1, .have.cc1, .done.cc1 { background-color : #964B00 !important; }
.bags.cc2, .want.cc2, .have.cc2, .done.cc2 { background-color : #FF0000 !important; }
.bags.cc3, .want.cc3, .have.cc3, .done.cc3 { background-color : #FFA500 !important; }
.bags.cc4, .want.cc4, .have.cc4, .done.cc4 { background-color : #FFFF00 !important; }
.bags.cc5, .want.cc5, .have.cc5, .done.cc5 { background-color : #9ACD32 !important; }
.bags.cc6, .want.cc6, .have.cc6, .done.cc6 { background-color : #6495ED !important; }
.bags.cc7, .want.cc7, .have.cc7, .done.cc7 { background-color : #EE82EE !important; }
.bags.cc8, .want.cc8, .have.cc8, .done.cc8 { background-color : #A0A0A0 !important; }
.bags.cc9, .want.cc9, .have.cc9, .done.cc9 { background-color : #FFFFFF !important; }
.bags.cc0, .want.cc0, .have.cc0, .done.cc0 { background-color : #202020 !important; }

#off_bag .pat_span .cc0         { background-color : rgba(  0, 32,  0,0.90) !important; }
#bak_bag .pat_span .cc0         { background-color : rgba(032,  0,  0,0.90) !important; }
#alt_bag .pat_span .cc0         { background-color : rgba(  0,  0, 32,0.90) !important; }



#off_bag .pat_span .cc0         { font-weight      : 100                    !important; }
#bak_bag .pat_span .cc0         { font-weight      : 300                    !important; }
#alt_bag .pat_span .cc0         { font-weight      : 300                    !important; }

#off_bag .pat_span .cc0         { box-shadow       : .05em .05em    0      rgba(255,255,255,0.7)       !important; }
#bak_bag .pat_span .cc0         { box-shadow       : .05em .05em    0      rgba(255,255,255,0.7)       !important; }
#alt_bag .pat_span .cc0         { box-shadow       : .05em .05em    0      rgba(255,255,255,0.7)       !important; }

.want { border : 1px dashed white  !important; }
.have { border : 1px solid  white !important; }
.want, .have {
    border-top-left-radius     : .8em;
    border-top-right-radius    : .8em;
    border-bottom-left-radius  : .3em;
    border-bottom-right-radius : .3em;
    padding-top                : .1em;
    padding-bottom             : .0em;
}


.bags {
    border-top-left-radius     : .3em;
    border-top-right-radius    : .3em;
    border-bottom-left-radius  : .8em;
    border-bottom-right-radius : .8em;
    padding-top                : .1em;
    padding-bottom             : .3em;
}


.done {
    border-top-left-radius     : .1em;
    border-bottom-left-radius  : .1em;
    border-top-right-radius    : 1em;
    border-bottom-right-radius : 1em;
    border: .1em solid white !important;
}






        .num_em { pointer-events   : none;                 }
        .num_em { margin           : .1em;                 }
        .num_em { border-radius    : .3em;                 }
        .num_em { background-color : rgba(192,192,192,.1); }
        .num_em {            color : black;                }
.dark   .num_em {            color : white;                }
        .num_em { padding          : .1em;                 }
        .num_em { font-family      : monospace;            }



            .place_holder { display    : none;                            }
            .place_holder { opacity    : 0;                               }






#mov_div { position      : absolute; }
#mov_div { top           :        0; }
#mov_div { left          :        0; }
#mov_div { border-radius :    0.5em; }
#mov_div { background    :     #F00; }
#mov_div { padding       : 0.3em 0.4em 0.2em 0.4em; }
#mov_div { box-shadow    : 2px 2px 2px 0px rgba(000,000,000,0.53); }


#mov_div.moving     { transition-duration :  500ms; }
.pat_span.moving    { width               :   100%; }

.pat_span.moving    { border-radius       :    1em; }
.pat_span.moving    { border-width        :    2px; }
.pat_span.moving    { border-style        : outset; }

#mov_div.grayed_out { opacity             :         0.3 ; }
#mov_div.grayed_out { transform           : scale(  0.5); }
#mov_div.grayed_out { transition-duration :       100ms ; }



.mov_src {
    background : linear-gradient(to bottom, rgba(  0,  0,  0,.9) 20%, rgba(  0,  0,  0,.7) 80%, rgba(  0,  0,  0,.9) 100%);
    color: gray !important;


}





#hov1 { position : absolute; display:none; color: #00F; font-size:12px; transform: translate( -85%,-70%); margin:0; padding:0; }
#hov2 { position : absolute; display:none; color: #F40; font-size:12px; transform: translate( -10%,-33%); margin:0; padding:0; }
#hov3 { position : absolute; display:none; color: #F00; font-size:12px; transform: translate( -85%,-70%); margin:0; padding:0; }
#hov4 { position : absolute; display:none; color: #40F; font-size:12px; transform: translate( -10%,-33%); margin:0; padding:0; }




.dimmed>.pat_span { opacity    : .2    !important;  }



#pat_bag.standby::before  { content          : '\\267B';         }
#pat_bag.standby          { background       : linear-gradient(to bottom, #F00, #400) !important; }
#pat_bag.standby em       { background-color : #F88 !important; }
#pat_bag.standby em       { color            : #000;            }
#pat_bag.standby em       { box-shadow       : none;            }




#pat_bag.grid_bag   { display               : grid;        }
#pat_bag            { grid-template-columns : 1fr 0   0  ; }
#pat_bag.open_bag   { grid-template-columns : 1fr 1fr 1fr; }

#pat_bag.pinned.open_bag { transform-origin :  0   0; }

          #bak_bag  { display               : none;  }
          #alt_bag  { display               : none;  }
.open_bag #bak_bag  { display               : block; }
.open_bag #alt_bag  { display               : block; }

          #alt_bag  { min-width             :  7em; }
          #bak_bag  { min-width             :  7em; }
          #off_bag  { min-width             :  7em; }

.open_bag #alt_bag  { width                 : 14em; }
.open_bag #bak_bag  { width                 : 14em; }
.open_bag #off_bag  { width                 : 14em; }






          .grid_bag #off_bag  { border-radius         : 1em 1em 1em 1em;    }
          .grid_bag #bak_bag  { border-radius         : 1em 1em 1em 1em;    }
          .grid_bag #alt_bag  { border-radius         : 1em 1em 1em 1em;    }

          .grid_bag           { grid-gap              :    0;               }
          .grid_bag           { grid-auto-columns     : minmax(12em, auto); }


.grid_bag>.pat_span                 { grid-column-start     :  1;                      }
      span.pat_span:nth-of-type( 1) {                             grid-row-start :  1; }
      span.pat_span:nth-of-type( 2) {                             grid-row-start :  2; }
      span.pat_span:nth-of-type( 3) {                             grid-row-start :  3; }
      span.pat_span:nth-of-type( 4) {                             grid-row-start :  4; }
      span.pat_span:nth-of-type( 5) {                             grid-row-start :  5; }
      span.pat_span:nth-of-type( 6) {                             grid-row-start :  6; }
      span.pat_span:nth-of-type( 7) {                             grid-row-start :  7; }
      span.pat_span:nth-of-type( 8) {                             grid-row-start :  8; }
      span.pat_span:nth-of-type( 9) {                             grid-row-start :  9; }
      span.pat_span:nth-of-type(10) {                             grid-row-start : 10; }

          #off_bag                  { grid-column-start     :  1; grid-row-start : 11; grid-row-end : 12; }
          #alt_bag                  { grid-column-start     :  2; grid-row-start :  1; grid-row-end : 12; }
          #bak_bag                  { grid-column-start     :  3; grid-row-start :  1; grid-row-end : 12; }





          #off_bag          { float   : left; clear : left; }
          #bak_bag          { float   : left; clear : left; }
          #alt_bag          { float   : left; clear : left; }

          #off_bag          { padding : .5em !important;    }
          #bak_bag          { padding : .5em !important;    }
          #alt_bag          { padding : .5em !important;    }













          #off_bag          { border-radius    : 1em 1em 0 0;                      }
          #alt_bag          { border-radius    : 0 0 1em 1em;                      }
          #bak_bag          { border-radius    : 0 0 1em 1em;                      }

          #off_bag          { margin           : 0.5em;                            }
          #alt_bag          { margin           : 0.5em;                            }
          #bak_bag          { margin           : 0.5em;                            }



          #off_bag          { border-top       : 3px solid rgba(034,034,034,0.07); }
          #off_bag          { border-left      : 2px solid rgba(034,034,034,0.07); }
          #off_bag          { border-right     : 2px solid rgba(034,034,034,0.07); }
          #off_bag          { border-bottom    : 1px solid rgba(034,034,034,0.07); }

          #bak_bag          { border-top       : 1px solid rgba(034,034,034,0.07); }
          #bak_bag          { border-left      : 2px solid rgba(034,034,034,0.07); }
          #bak_bag          { border-right     : 2px solid rgba(034,034,034,0.07); }
          #bak_bag          { border-bottom    : 3px solid rgba(034,034,034,0.07); }

          #alt_bag          { border-top       : 1px solid rgba(034,034,034,0.07); }
          #alt_bag          { border-left      : 2px solid rgba(034,034,034,0.07); }
          #alt_bag          { border-right     : 2px solid rgba(034,034,034,0.07); }
          #alt_bag          { border-bottom    : 3px solid rgba(034,034,034,0.07); }





#off_bag { background       : linear-gradient(to bottom, rgba(034,034,034,0.07) 0%, rgba(034,034,034,0.53) 98%, rgba(034,034,034,0.07) 100%); }
#alt_bag { background       : linear-gradient(to bottom, rgba(034,034,034,0.07) 0%, rgba(034,034,034,0.53) 98%, rgba(034,034,034,0.07) 100%); }
#bak_bag { background       : linear-gradient(to bottom, rgba(034,034,034,0.07) 0%, rgba(034,034,034,0.53) 98%, rgba(034,034,034,0.07) 100%); }

#off_bag { background-color : rgba(000,224,000,0.3); }
#alt_bag { background-color : rgba(000,000,255,0.3); }
#bak_bag { background-color : rgba(255,000,000,0.3); }



#pat_bag.rotating        { display   : block !important; }
#pat_bag.rotating.hidden { display   : none  !important; }
#pat_bag.rotating        { min-width : unset;            }

#off_bag.rotating ,
#alt_bag.rotating ,
#bak_bag.rotating {
    display    : inline-block !important;
    position   : absolute;
}
          #off_bag.rotating { animation : 1500ms ease-out                     forwards off_bag_open_anim; }
          #alt_bag.rotating { animation : 1500ms ease-out                     forwards alt_bag_open_anim; }
          #bak_bag.rotating { animation : 1500ms ease-in                      forwards bak_bag_open_anim; }
.open_bag #off_bag.rotating { animation : 1500ms cubic-bezier(.5,0.5,.02,1.1) forwards off_bag_open_rotating_anim !important; }
.open_bag #alt_bag.rotating { animation : 1500ms cubic-bezier(.5,0.3,.02,1.1) forwards alt_bag_open_rotating_anim !important; }
.open_bag #bak_bag.rotating { animation : 1500ms cubic-bezier(.5,0.1,.02,1.1) forwards bak_bag_open_rotating_anim !important; }
.open_bag #bak_bag.rotating { transform-origin :  50%  50%; }



@keyframes off_bag_open_anim {
      0% { transform        : translate(   0 , 0);              }
     10% { transform        : translate(  50%, 0);              }
     80% { transform        : translate(  55%, 0);              }
    100% { transform        : translate( 150%, 0);              }

      0% { opacity          : 1.0;                              }
     80% { opacity          : 0.8;                              }
    100% { opacity          : 0.0;                              }

      0% { background-color : rgba(000,000,000,0.0);            }
     60% { background-color : rgba(000,000,224,0.5);            }
    100% { background-color : rgba(000,000,224,0.9);            }
}
@keyframes alt_bag_open_anim {
      0% { opacity          : 0.0;                              }
    100% { opacity          : 0.0;                              }
}
@keyframes bak_bag_open_anim {
      0% { transform        : translate(200%, 0) scale(1  , 1); }
     20% { transform        : translate(200%, 0) scale(1  , 1); }
     30% { transform        : translate(  0%, 0) scale(1  , 1); }
    100% { transform        : translate(  0%, 0) scale(1  , 1); }

     35% { background-color : rgba(224,000,000,0.5);            }
     65% { background-color : rgba(000,224,000,0.1);            }
    100% { background-color : rgba(000,000,000,0.0);            }

      0% { opacity          : 0.0;                              }
     20% { opacity          : 0.9;                              }
    100% { opacity          : 1.0;                              }
}


@keyframes off_bag_open_rotating_anim  {
     10% { transform        : translate(  -5%, 0);               }
     15% { transform        : translate(   5%, 0) scale(0.9, 1); }
     40% { transform        : translate(   5%, 0) scale(0.9, 1); }
    100% { transform        : translate( 100%, 0);               }

     50% { background-color : rgba(000,224,000,0.3);             }
     80% { background-color : rgba(000,000,224,0.3);             }
    100% { background-color : rgba(000,000,224,0.3);             }
}
@keyframes alt_bag_open_rotating_anim {
     15% { transform        : translate(   0 , 0);               }
     25% { transform        : translate(   9%, 0);               }
     40% { transform        : translate(   2%, 0);               }
    100% { transform        : translate( 100%, 0);               }

     50% { background-color : rgba(000,000,224,0.3);             }
     80% { background-color : rgba(224,000,000,0.3);             }
    100% { background-color : rgba(224,000,000,0.3);             }
}
@keyframes bak_bag_open_rotating_anim {
     15% { transform        : translate(   0 , 0);               }
     25% { transform        : translate(  10%, 0) scale(0.8,0.9);}
     50% { transform        : translate(  20%, 0) scale(0.8,0.9);}
     70% { transform        : translate(-200%, 0) scale(0.8,0.9);}
    100% { transform        : translate(-200%, 0)               ;}

     70% { background-color : rgba(224,000,000,0.3);             }
     90% { background-color : rgba(000,224,000,0.3);             }
    100% { background-color : transparent          ;             }


     90% { background       : linear-gradient(to bottom, rgba(034,034,034,0.07) 0%, rgba(034,034,034,0.53) 98%, rgba(034,034,034,0.07) 100%); }
    100% { background       : linear-gradient(to bottom, rgba(034,034,034,0.01) 0%, rgba(034,034,034,0.01) 98%, rgba(034,034,034,0.01) 100%); }

}










        .nearing { transition-duration : 250ms; }
#pat_bag.nearing { box-shadow          : 0 0 .3em .3em rgba(000,000,000,0.4) inset !important; }
#off_bag.nearing { background-color    :               rgba(000,224,000,1.0)                 ; }
#bak_bag.nearing { background-color    :               rgba(255,000,000,1.0)                 ; }
#alt_bag.nearing { background-color    :               rgba(000,000,255,1.0)                 ; }

          #off_bag { transform-origin    : 50% 100%;                          }
          #bak_bag { transform-origin    : 50%   0%;                          }
.grid_bag #bak_bag { transform-origin    : 50%  50%;                          }
          #alt_bag { transform-origin    : 50%   0%;                          }
.grid_bag #alt_bag { transform-origin    : 50%  50%;                          }

          #off_bag.nearing { animation : 400ms ease-out forwards squeezing; }
          #bak_bag.nearing { animation : 400ms ease-out forwards squeezing; }
          #alt_bag.nearing { animation : 400ms ease-out forwards squeezing; }

@keyframes squeezing    {
     10% { transform  : scale(1,1.008); }
     30% { transform  : scale(1,1.015); }
    100% { transform  : scale(1,1.020); }
}


        .outline  { transition-duration : 500ms; }

#pat_bag.hovering {          outline    : black 8px dashed !important; }
#off_bag.hovering {          outline    : green 8px dashed !important; }
#bak_bag.hovering {          outline    : red   8px dashed !important; }
#alt_bag.hovering {          outline    : blue  8px dashed !important; }







.pressed { transform        : scale(0.95); }
.pressed { opacity          :       0.8  ; }



#dom_tools_html.pressed { opacity          :    1; }



#div_slot_containers>.pressed {
    transform        : none  !important;
    opacity          : 1     !important;
    background       : #AAA  !important;
    transition       : all 250ms ease-out;
}




.div_match {
    border: solid 8px black !important;
}
.div_match div {
    border:solid 1px !important;
}


.str      {
    outline : 3px #AAA;
}
.em_match {
    box-shadow    : rgba(0, 0, 0, 0.3) 0 0.3em 0.3em inset;
    font-size     : 200%;
}
.em_missing {
    color            : red;
    background-color : transparent;
    font-weight      : 700;
    box-shadow       : rgba(255, 0, 0, 0.3) 0 0.3em 0.3em inset;
}

.em_log {
    padding          : .2em;
    border-radius    : 50%;
    box-shadow       : rgba(0, 0, 0, 0.3) 0 0.3em 0.3em inset;
}
.em_log span {
    border-radius    : .5em;

}




.transcript            { display              : inline-block;    }


.transcript *          { vertical-align       : middle;          }



.transcript            { cursor               : pointer;         }
.transcript div        { cursor               : pointer;         }


.transcript            { border-color           : #444             }
.transcript            { border-radius          : 1em;             }
.transcript ul         { border                 : 0px;             }
.transcript>div        { border                 : 0px;             }
.transcript div        { border                 : 0px;             }
.transcript pre        { border                 : 0px;             }
.transcript tr         { border-bottom          : 2px black solid; }
.transcript td         { border-radius          : 2em;             }



.transcript            { box-shadow                 : 3px 3px 6px rgba(000,000,000,0.5);        }


.transcript            { min-height           :  4em; }
.transcript            { min-width            : 10em; }


         .transcript         { filter : contrast(25%) brightness(125%); }
         .transcript.dark    { filter : contrast(50%) brightness( 35%); }
.pressed .transcript         { filter : none !important; }
         .transcript.tooltip { filter : none !important; }


.transcript          { background-color : rgba(224,224,224,0.9); }
.transcript.dark     { background-color : rgba(224,224,224,0.9); }

.transcript          { background    : linear-gradient(to bottom, #FF0, #FB0); }
.transcript.dark     { background    : linear-gradient(to bottom, #443, #211); }



#headsup.dark        { background    : linear-gradient(to bottom, #443, #211); }
#dom_traversal.dark  { background    : linear-gradient(to bottom, #443, #211); }
#dev_log_map.dark    { background    : linear-gradient(to bottom, #443, #211); }
#test_panel.dark     { background    : linear-gradient(to bottom, #443, #211); }
#dom_load_tags.dark  { background    : linear-gradient(to bottom, #443, #211); }


.transcript            { padding              : 1ex;             }
.transcript pre        { padding              : 0 0 0 1ex;       }
.transcript ul         { padding              : 0 0 0 2em;       }



.transcript>*          { font-family          : "Comic sans ms";       }


.transcript em         { line-height          : 1.50em;          }
.transcript ul         { line-height          : 0.75em;          }



*::-webkit-scrollbar                               { width         : 2em; }
*::-webkit-scrollbar                               { height        : 2em; }
*::-webkit-scrollbar                               { max-height    : 20px;}
*::-webkit-scrollbar                               { max-width     : 20px;}
*::-webkit-scrollbar-corner                        { background    : transparent; }
*::-webkit-scrollbar-thumb                         { border-radius : 2em; }
*::-webkit-scrollbar-track                         { border-radius : 2em; }
*::-webkit-scrollbar-thumb                         { box-shadow    : inset 0 0 6px rgba(0,0,0,0.5); }
*::-webkit-scrollbar-track                         { box-shadow    : inset 0 0 6px rgba(0,0,0,0.3); }
*::-webkit-scrollbar-thumb                         { box-shadow    : rgba(  0,  0,  0,0.5) 0 8px 24px; }
*::-webkit-scrollbar-thumb                         { background    : rgba( 24, 24, 24,0.3); }
*::-webkit-scrollbar-thumb:-webkit-window-inactive { background    : rgba( 24, 24, 24,0.2); }
*::-webkit-scrollbar-track                         { background    : rgba( 96, 96, 96,0.4); }
*::-webkit-scrollbar-track:-webkit-window-inactive { background    : rgba(128,128,128,0.2); }



.transcript *          { user-select  : none;            }
.transcript table      { user-select  : none;            }


.transcript            { transform-origin     : 0% 0% 0;         }




.transcript                       { transition : transform 300ms cubic-bezier(0.080, 1.015, 0.055, 0.930), padding 150ms ease-in; }


              .transcript.on_grid { transition :       all 300ms ease-out 200ms;                  }
.slow_regroup .transcript         { transition :       all 300ms cubic-bezier(0.3,1.1 , 0.8,0.7); }

.slow_regroup #hotspot            { transition :       all 500ms cubic-bezier(1,.21,.37,.98); }



.transcript.on_grid {
    display                    : inline-block  !important;

    border-radius              : 16px          !important;
    margin                     : 0             !important;
    transform                  : rotate(0deg);

    padding                    : 0             !important;
    margin-bottom              : 0             !important;

    overflow                   : hidden        !important;




}


.transcript>div        { margin               : 0;            }
.transcript div        { margin               : 0;            }
.transcript div        { display              : table-cell;   }
.transcript div        { overflow             : hidden;       }
.transcript div        { padding              : 1ex;          }




.transcript blockquote { margin      : .2em;              }
.transcript blockquote { width       : 48em;              }
.transcript blockquote { border      : 0px;               }
.transcript blockquote { padding     : 1ex;               }
.transcript blockquote { white-space : normal !important; }


.transcript table      { margin               : 0;               }
.transcript tr.slot    { font-size            : 200%;            }
.transcript th         { font-size            : 120%;            }
.transcript th         { padding              : 1ex;             }
.transcript th         { text-align           : left;            }
.transcript th         { text-shadow          : rgba( 50, 50, 50, 0.9) 1px 1px 2px !important; }
.transcript th         { font-weight          : 700; }
.transcript hr         { height               : 5px; }

.transcript td         { padding              : 1ex;             }
.transcript td         { text-align           : left;            }


.transcript pre        { background           : initial;         }
.transcript pre        { text-align           : left;            }



.transcript ul         { margin               : .2em;            }







.transcript_msg .info  {
    box-shadow  : 2px 2px 6px rgba(000,000,000,0.7) inset;
    font-family : "Comic sans ms";
}

      .transcript_msg { color       : #200; }
.dark .transcript_msg { color       : #FA0 !important; }


#transcript1,#transcript2 { max-width  :  80%; }
#transcript1              { max-height :  18%; }
             #transcript2 { max-height :  78%; }
#transcript1,#transcript2 { overflow   : auto; }
#transcript1 {
    float : left;
}
#transcript2 {
    float : left;
    clear : left;
}
#table_params * { text-align : right; }


.update_count { float         : right; }

.update_count { padding-left  : 0.5em; }
.update_count { padding-right : 0.5em; }




.push_pin { position : absolute; top:0.1em; right:0.1em; display:none; }
.closepin { position : absolute; top:0.1em; right:0.1em; display:none; }
.scalepin { position : absolute; top:0.1em; right:0.1em; display:none; }
.clearpin { position : absolute; top:0.1em; right:0.1em; display:none; }


            .push_pin  { margin-right           : 0.0em               !important; }
            .push_pin  { margin-top             : 0.0em               !important; }
            .push_pin  { min-width              : 1.5em               !important; }
            .push_pin  { min-height             : 1.5em               !important; }

            .closepin  { margin-right           : 0.0em               !important; }
            .closepin  { margin-top             : 0.0em               !important; }
            .closepin  { min-width              : 1.5em               !important; }
            .closepin  { min-height             : 1.5em               !important; }

            .scalepin  { margin-right           : 0.0em               !important; }
            .scalepin  { margin-top             : 0.0em               !important; }
            .scalepin  { min-width              : 1.5em               !important; }
            .scalepin  { min-height             : 1.5em               !important; }

            .clearpin  { margin-right           : 0.0em               !important; }
            .clearpin  { margin-top             : 0.0em               !important; }
            .clearpin  { min-width              : 1.5em               !important; }
            .clearpin  { min-height             : 1.5em               !important; }



            .push_pin  { padding                : 0                   !important; }
            .closepin  { padding                : 0                   !important; }
            .scalepin  { padding                : 0                   !important; }
            .clearpin  { padding                : 0                   !important; }




            .push_pin  { border                    : none                    !important; }
            .closepin  { border                    : none                    !important; }
            .scalepin  { border                    : none                    !important; }
            .clearpin  { border                    : none                    !important; }


            .push_pin  { border-radius             : 0.3em   1em 0.3em 0.3em !important; }
            .closepin  { border-radius             : 1em                     !important; }
            .scalepin  { border-radius             : 1em                     !important; }
            .clearpin  { border-radius             : 1em                     !important; }



                .push_pin       { box-shadow     : none;                                         }
.pinned       em.push_pin       { box-shadow     : 1px -2px 3px 0px rgba(000,000,000,0.2) inset; }
.pinned.dark  em.push_pin       { box-shadow     : 1px -2px 3px 0px rgba(255,255,255,0.2) inset; }
.pinned         .push_pin:hover { box-shadow     : none  !important;                             }

                .closepin       { box-shadow     : none  !important; }
                .scalepin       { box-shadow     : none  !important; }
                .clearpin       { box-shadow     : none  !important; }




            .push_pin                { color    : #AAA                !important; }
            .push_pin:hover          { color    : #800                !important; }
            .push_pin:hover .pressed { color    : #F00                !important; }
.pinned     .push_pin:hover          { color    : #F00                !important; }
.pinned     .push_pin                { color    : #F00                !important; }
            .closepin                { color    : #000                !important; }
            .closepin:hover          { color    : #888                !important; }
            .closepin:hover .pressed { color    : #FFF                !important; }
.pinned     .closepin:hover          { color    : #BBB                !important; }
.pinned     .closepin                { color    : #FFF                !important; }

            .scalepin                { color    : #000                !important; }
            .scalepin:hover          { color    : #888                !important; }
            .scalepin:hover .pressed { color    : #FFF                !important; }
.pinned     .scalepin:hover          { color    : #BBB                !important; }
.pinned     .scalepin                { color    : #FFF                !important; }

            .clearpin                { color    : #000                !important; }
            .clearpin:hover          { color    : #888                !important; }
            .clearpin:hover .pressed { color    : #FFF                !important; }
.pinned     .clearpin:hover          { color    : #BBB                !important; }
.pinned     .clearpin                { color    : #0A0                !important; }


                .push_pin       { background-color  : transparent           !important; }
                .closepin       { background-color  : transparent           !important; }
                .scalepin       { background-color  : transparent           !important; }
                .clearpin       { background-color  : transparent           !important; }


.pinned         .push_pin       { background        : linear-gradient(-45deg, rgba(000,000,000,0.07), rgba(255,255,255,0.40) 50%, rgba(000,000,000,0.07)) !important; }
.pinned.dark    .push_pin       { background        : linear-gradient(-45deg, rgba(000,000,000,0.07), rgba(255,255,255,0.13) 50%, rgba(000,000,000,0.07)) !important; }
.pinned         .push_pin:hover { background        : rgba(136,136,136,0.3) !important; }

.pinned         .closepin       { background        : linear-gradient(-45deg, rgba(000,000,000,0.07), rgba(255,255,255,0.40) 50%, rgba(000,000,000,0.07)) !important; }
.pinned.dark    .closepin       { background        : linear-gradient(-45deg, rgba(000,000,000,0.07), rgba(255,255,255,0.13) 50%, rgba(000,000,000,0.07)) !important; }
.pinned         .closepin:hover { background        : rgba(136,136,136,0.3) !important; }

.pinned         .scalepin       { background        : linear-gradient(-45deg, rgba(000,000,000,0.07), rgba(255,255,255,0.40) 50%, rgba(000,000,000,0.07)) !important; }
.pinned.dark    .scalepin       { background        : linear-gradient(-45deg, rgba(000,000,000,0.07), rgba(255,255,255,0.13) 50%, rgba(000,000,000,0.07)) !important; }
.pinned         .scalepin:hover { background        : rgba(136,136,136,0.3) !important; }

.pinned         .clearpin       { background        : linear-gradient(-45deg, rgba(000,000,000,0.07), rgba(255,255,255,0.40) 50%, rgba(000,000,000,0.07)) !important; }
.pinned.dark    .clearpin       { background        : linear-gradient(-45deg, rgba(000,000,000,0.07), rgba(255,255,255,0.13) 50%, rgba(000,000,000,0.07)) !important; }
.pinned         .clearpin:hover { background        : rgba(136,136,136,0.3) !important; }



                .push_pin       { text-align             : center           !important; }
                .closepin       { text-align             : center           !important; }
                .scalepin       { text-align             : center           !important; }
                .clearpin       { text-align             : center           !important; }



            .push_pin           { font-size              : 200%             !important; }
            .push_pin           { font-weight            :  100             !important; }

            .closepin           { font-size              : 200%             !important; }
            .closepin           { font-weight            :  100             !important; }

            .scalepin           { font-size              : 200%             !important; }
            .scalepin           { font-weight            :  100             !important; }

            .clearpin           { font-size              : 200%             !important; }
            .clearpin           { font-weight            :  100             !important; }



.pinned   em.push_pin           { text-shadow       : black 1px 1px 2px               ; }
.pinned   em.push_pin:hover     { text-shadow       : none                  !important; }

.pinned   em.closepin           { text-shadow       : black 1px 1px 2px               ; }
.pinned   em.closepin:hover     { text-shadow       : none                  !important; }

.pinned   em.scalepin           { text-shadow       : black 1px 1px 2px               ; }
.pinned   em.scalepin:hover     { text-shadow       : none                  !important; }

.pinned   em.clearpin           { text-shadow       : black 1px 1px 2px               ; }
.pinned   em.clearpin:hover     { text-shadow       : none                  !important; }



.wide_panel.pin_on_panel { padding-right : 3em; }
.tall_panel.pin_on_panel { padding-top   : 3em; }

.pin_on_panel>.push_pin,
.pin_on_panel>.closepin,
.pin_on_panel>.scalepin,
.pin_on_panel>.clearpin   { display       : inline !important; }





.push_pin,
.closepin,
.scalepin,
.clearpin {
                       transform-origin    :     50% 50%;
}

.wide_panel .closepin,
.tall_panel .closepin,
.wide_panel .scalepin,
.tall_panel .scalepin,
.wide_panel .clearpin,
.tall_panel .clearpin {
    animation-delay           : 200ms;
    animation-duration        : 150ms;
    animation-timing-function : ease-out;
    animation-fill-mode       : forwards;
    opacity                   : 0;
}

.tall_panel .closepin { animation-name : wide_to_tall_closepin; }
.wide_panel .closepin { animation-name : tall_to_wide_closepin; }
.tall_panel .scalepin { animation-name : wide_to_tall_scalepin; }
.wide_panel .scalepin { animation-name : tall_to_wide_scalepin; }
.tall_panel .clearpin { animation-name : wide_to_tall_clearpin; }
.wide_panel .clearpin { animation-name : tall_to_wide_clearpin; }

@keyframes tall_to_wide_closepin {
     50% { opacity   : .5;                      }
    100% { opacity   :  1;                      }

    100% { transform :  translate( 0   , 100%); }
}
@keyframes wide_to_tall_closepin {
     50% { opacity   : .5;                      }
    100% { opacity   :  1;                      }

    100% { transform :  translate(-100%,    0); }
}

@keyframes tall_to_wide_scalepin {
     50% { opacity   : .5;                      }
    100% { opacity   :  1;                      }
    100% { transform :  translate( 0  ,  200%); }
}
@keyframes wide_to_tall_scalepin {
     50% { opacity   : .5;                      }
    100% { opacity   :  1;                      }
    100% { transform :  translate(-200%,    0); }
}

@keyframes tall_to_wide_clearpin {
     50% { opacity   : .5;                      }
    100% { opacity   :  1;                      }
    100% { transform :  translate(    0, 300%); }
}
@keyframes wide_to_tall_clearpin {
     50% { opacity   : .5;                      }
    100% { opacity   :  1;                      }
    100% { transform :  translate(-300%,    0); }
}



           .scalepin::after { content : '\\1F50D'; }
.magnified .scalepin::after { content : '\\1F50E'; }
.magnified .scalepin::after { color   :      red; }



.on_grid                 { padding-right : 0em; }
.on_grid                 { padding-top   : 0em; }
.on_grid                 { border-radius : 2em  !important; }
.on_grid                 { border-style  : none !important; }
.on_grid                 { border-width  : 0    !important; }

.on_grid>.push_pin,
.on_grid>.closepin,
.on_grid>.scalepin,
.on_grid>.closepin       { display       : none  !important; }




@media only screen and (min-resolution : 120dpi) {
}



#div_slot_containers.fullscreen             >div { font-size : 100%; }
#div_slot_containers.fullscreen.magnified_0 >div { font-size :  50%; }
#div_slot_containers.fullscreen.magnified_1 >div { font-size :  75%; }
#div_slot_containers.fullscreen.magnified_2 >div { font-size : 100%; }
#div_slot_containers.fullscreen.magnified_3 >div { font-size : 125%; }
#div_slot_containers.fullscreen.magnified_4 >div { font-size : 150%; }
#div_slot_containers.fullscreen.magnified_5 >div { font-size : 200%; }
#div_slot_containers.fullscreen.magnified_6 >div { font-size : 300%; }
#div_slot_containers.fullscreen.magnified_7 >div { font-size : 350%; }
#div_slot_containers.fullscreen.magnified_8 >div { font-size : 400%; }
#div_slot_containers.fullscreen.magnified_9 >div { font-size : 450%; }

#div_slot_containers.button_monospace       >div { font-family : monospace !important; }
#div_slot_containers.button_monospace          * { white-space : pre-wrap  !important; }


.button_mono.button_monospace                    { opacity     : 1.0    !important; }
.button_mono.button_monospace                    { color       : green  !important; }
.button_mono.button_monospace                    { font-weight : 900    !important; }
.button_mono.button_monospace                    { text-shadow : 2px 2px 2px white; }



#sel_bag.back     { color                      : red; }
#sel_bag.back>div { border-color               : red; }

.back .current_slot_num { color:white; background:linear-gradient(to bottom, #F00, #000) !important; }
          .standby .seeker_handle.back { transform  : rotate(-165deg) !important; }
.back        .seeker_handle                { color                       :     red !important; }
             .seeker_handle.back           { transform                   : translate(0, 20%) rotate(-180deg); }
             .seeker_handle.right.back     { transform                   : translate(0, 20%) rotate( 180deg); }
             .seeker_handle.back           { transition-duration         : 200ms; }
             .seeker_handle.back           { transition-delay            :   0ms; }
             .seeker_handle.left.back      { transition-delay            : 200ms; }
             .seeker_handle.right.back     { transition-delay            : 400ms; }
             .seeker_handle.back           { transition-timing-function  : ease-out; }
             .seeker_handle.back           { transition-property         : all; }
.seeker_handle.back         { transition-delay     :    0ms; }
.seeker_handle.back         { transition-duration  :  100ms; }
.seeker_handle.left.back    { transition-delay     :  100ms; }
.seeker_handle.right.back   { transition-delay     :  100ms; }
.seeker_handle.bottom.back  { transition-delay     :  100ms; }
.seeker_handle.top.back     { transition-delay     :  100ms; }






.magnified                  { transition          : transform 250ms ease-in, font-size 250ms ease-in; }
#pat_bag                    { transition          : transform 250ms ease-in, font-size 250ms ease-in !important; }




.hidden                     { display             : none !important       ; }





@media only screen and (max-resolution :  96dpi) {
    #pat_bag          { transition : height 500ms ease-in, width 500ms ease-in, padding 250ms ease-in; }
    #pat_bag>*        { transition : height 500ms ease-in, width 500ms ease-in                       ; }
    #pat_bag.open_bag { transition : top    100ms ease-in, left  100ms ease-in                       ; }
    #pat_bag.closing  { transition : top    100ms ease-in, left  100ms ease-in             !important; }
}


    #pat_bag.capped   { outline                   : black dotted 8px;   }
    #pat_bag.capped   { animation-duration        :  500ms;             }
    #pat_bag.capped   { animation-fill-mode       : both;               }
    #pat_bag.capped   { animation-name            : outline_BLACK_FADE; }
    #pat_bag.capped   { animation-timing-function : ease-in;            }
@keyframes outline_BLACK_FADE {
      0% { outline-color:rgba(0,0,000,0.9); }
     80% { outline-color:rgba(0,0,000,0.8); }
    100% { outline-color:rgba(0,0,000,0  ); }
}

    #pat_bag.closing  { outline                   : red   solid  8px;   }
    #pat_bag.closing  { animation-delay           :  500ms;             }
    #pat_bag.closing  { animation-duration        : 1000ms;             }
    #pat_bag.closing  { animation-fill-mode       : both;               }
    #pat_bag.closing  { animation-name            : outline_RED_FADE;   }
    #pat_bag.closing  { animation-timing-function : ease-in;            }
@keyframes outline_RED_FADE {
      0% { outline-color:rgba(255,0,0,0.9); }
     80% { outline-color:rgba(255,0,0,0.8); }
    100% { outline-color:rgba(255,0,0,0  ); }
}




.open_bag #bak_bag            { transition : opacity 500ms ease-in                       !important; }




.exp_bag                        { margin           : 0.5em;                            }
.exp_bag                        { border-radius    : 1em 1em 1em 1em;                  }
.exp_bag                        { border-top       : 1px solid rgba(034,034,034,0.07); }
.exp_bag                        { border-left      : 2px solid rgba(034,034,034,0.07); }
.exp_bag                        { border-bottom    : 3px solid rgba(034,034,034,0.07); }
.exp_bag                        { border-right     : 2px solid rgba(034,034,034,0.07); }

.exp_bag                        { padding          : 0.5em;                            }
.exp_bag.pat_arr                { background-color : rgba(192,192,000,0.3); }
.exp_bag.off_arr                { background-color : rgba(000,224,000,0.3); }
.exp_bag.alt_arr                { background-color : rgba(000,000,255,0.3); }
.exp_bag.bak_arr                { background-color : rgba(224,000,000,0.3); }

.tooltip                        { background       : linear-gradient(to left, #FF0 10%, #FF0 30%, #FB0); }
.tooltip.dark                   { background       : linear-gradient(to left, #443 10%, #443 30%, #211); }
.tooltip                        { color            : #000; }
.tooltip.dark                   { color            : #DDD; }
.tooltip                        { font-weight      :  900; }
.tooltip.dark                   { font-weight      :  100; }
.tooltip                        { text-shadow      : 2px 2px 2px white; }
.tooltip.dark                   { text-shadow      : 2px 2px 2px black; }






.pinned.dragged { opacity    : 0.7;                   }




.pinned.bordering:not(.on_grid).u   { border-radius    :  0   0 2em 2em !important; }
.pinned.bordering:not(.on_grid).u.r { border-radius    :  0   0   0 2em !important; }
.pinned.bordering:not(.on_grid).r   { border-radius    :2em   0   0 2em !important; }
.pinned.bordering:not(.on_grid).r.d { border-radius    :2em   0   0   0 !important; }
.pinned.bordering:not(.on_grid).d   { border-radius    :2em 2em   0   0 !important; }
.pinned.bordering:not(.on_grid).d.l { border-radius    :  0 2em   0   0 !important; }
.pinned.bordering:not(.on_grid).l   { border-radius    :  0 2em 2em   0 !important; }
.pinned.bordering:not(.on_grid).l.u { border-radius    :  0   0 2em   0 !important; }

.pinned.bordering     { border-color     : #A00  !important; }


.pinned.bordering.u   { border-width     : 0.5em 0.2em 0.2em 0.2em !important; }
.pinned.bordering.u.r { border-width     : 0.5em 0.5em 0.2em 0.2em !important; }
.pinned.bordering.r   { border-width     : 0.2em 0.5em 0.2em 0.2em !important; }
.pinned.bordering.r.d { border-width     : 0.2em 0.5em 0.5em 0.2em !important; }
.pinned.bordering.d   { border-width     : 0.2em 0.2em 0.5em 0.2em !important; }
.pinned.bordering.d.l { border-width     : 0.2em 0.2em 0.5em 0.5em !important; }
.pinned.bordering.l   { border-width     : 0.2em 0.2em 0.2em 0.5em !important; }
.pinned.bordering.l.u { border-width     : 0.5em 0.2em 0.2em 0.5em !important; }

.pinned.bordering     { border-style        : groove; }
.pinned.bordering.u   { border-top-style    :  ridge; }
.pinned.bordering.u.r { border-top-style    :  ridge; }
.pinned.bordering.u.r { border-right-style  :  ridge; }
.pinned.bordering.r   { border-right-style  :  ridge; }
.pinned.bordering.r.d { border-right-style  :  ridge; }
.pinned.bordering.r.d { border-bottom-style :  ridge; }
.pinned.bordering.d   { border-bottom-style :  ridge; }
.pinned.bordering.d.l { border-bottom-style :  ridge; }
.pinned.bordering.d.l { border-left-style   :  ridge; }
.pinned.bordering.l   { border-left-style   :  ridge; }
.pinned.bordering.l.u { border-left-style   :  ridge; }
.pinned.bordering.l.u { border-top-style    :  ridge; }

.pinned.corner_l_u    { transform-origin :   0%   0% !important; }
.pinned.corner_u_r    { transform-origin : 100%   0% !important; }
.pinned.corner_r_d    { transform-origin : 100% 100% !important; }
.pinned.corner_d_l    { transform-origin :   0% 100% !important; }





#import_clipboard {
    cursor     : copy                   !important;
    border     : ridge 3px              !important;
    background : rgba( 32,192, 32,0.80) !important;
    color      : black                  !important;
    min-height : 10em                   !important;
    max-height : 10em                   !important;
    min-width  : 30em                   !important;
    font-size  : 10px                   !important;

}
#import_clipboard:focus {
    border     : 2px solid black        !important;
    background : #008800                !important;
    color      : #00FF00                !important;
}




@media only screen and (max-resolution :  96dpi) {

}
@media only screen and (min-resolution : 120dpi) {

}
@media only screen and (min-resolution : 120dpi) {



}






.open_bag                       { z-index :100 !important; }

#hotspot                        { z-index : 99; }
#fly_div                        { z-index : 99; }
#seekzone                       { z-index : 99; }

#pivspot                        { z-index : 80; }
#seekspot_A                     { z-index : 80; }
#seeker_PU                      { z-index : 80; }
#seeker_PD                      { z-index : 80; }

.pinned.on_grid                 { z-index : 50;              }
.pinned.work_panel              { z-index : 80   !important; }
       .work_panel              {  filter : none !important; }

.hotwave::after                 { z-index : -1; }
#bot_div                        { z-index : -1; }
#seeker_CD .seeker_handle       { z-index :  1; }
#seekspot_U, #seekspot_D        { z-index : -1; }

.clearpin                       { z-index :  0; }
.closepin                       { z-index :  0; }
.panel_magnifying_glass::before { z-index :  2; }
.push_pin                       { z-index :  0; }
.scalepin                       { z-index :  0; }
.txt_log                        { z-index :  2; }
.mov_src                        { z-index :  1; }
#hov1                           { z-index :  2; }
#hov2                           { z-index :  2; }
#hov3                           { z-index :  2; }
#hov4                           { z-index :  2; }

#transcript2                 em { z-index :  1; }
#transcript1                 em { z-index :  1; }
#test_panel                  em { z-index :  1; }
#sel_bag                     em { z-index :  1; }
#pat_bag                     em { z-index :  1; }
#headsup                     em { z-index :  1; }
#dom_traversal               em { z-index :  1; }
#dom_load_tags               em { z-index :  1; }
#dev_log_map                 em { z-index :  1; }



 #pat_bag           em
,#sel_bag           em
,#headsup           em
,#dom_traversal     em
,#dev_log_map       em
,#test_panel        em
,#dom_load_tags     em
,#transcript1       em
,#transcript2       em
{
    z-index        :  1;
}
#tools_tier2 {
    z-index        :  2 !important;
}

.transcript.on_grid {
    z-index        : 51 !important;
}





#seeker_PD           { opacity             :         1.0; }

#seeker_PD           { transform-origin    :     50% 0 0; }
#seeker_PD           { transform           : scale(0.33); }
#seeker_PD.magnified { transform           : scale(1   ); }

#seeker_PD           { transition-duration :       200ms; }
#seeker_PD.magnified { transition-duration :       200ms; }






#seekzone    { display          : none;             }
#seekzone    { position         : fixed;            }
#seekzone    { pointer-events   : none;             }
#seekzone    { padding          : 0     !important; }


#seekzone             { transition : all 250ms cubic-bezier(.21,.38,.74,.36); }




#seekzone.on_container { transform        : translate(   0,  0 ); }
#seekzone.gutter       { transform        : translate(   0,  0 ); }

#seekzone              { transform-origin :            50% 50%  ; }
#seekzone.pressed      { animation        :     750ms both pressed_SCALE; }
@keyframes pressed_SCALE  {
      0% { transform: scale(1.5); background-color : rgba(  0,  0,  0,0.1); }
     45% { transform: scale(1  ); background-color : rgba(  0,  0,  0,0.5); }
     50% { transform: scale(1  ); background-color : rgba(000,255,000,1  ); }
     55% { transform: scale(1  ); background-color : rgba(000,000,000,1  ); }
    100% { transform: scale(1  ); background-color : rgba(255,000,255,0.3); }
}


#seekzone.anchor_node::before {
    font-size        : 64px;
    content          : '\\2693';
    position         : absolute;
    left             : 50%;
    top              : 50%;
    transform        : translate(-50%,-50%);
}

#seekzone.anchor_node.anchor_left::before {

    animation        :     500ms cubic-bezier(1.0   ,  0.21 , 0.37  ,  1.2  ) both woble_left;
}
#seekzone.anchor_node.anchor_right::before {

    animation        :     500ms cubic-bezier(1.0   ,  0.21 , 0.37  ,  1.2  ) both woble_right;
}
@keyframes woble_left {
    from { transform : translate(-50%,-50%) rotate( 30deg); }

    to   { transform : translate(-50%,-50%) rotate(  0deg); }
}

@keyframes woble_right {
    from { transform : translate(-50%,-50%) rotate(-30deg); }

    to   { transform : translate(-50%,-50%) rotate(  0deg); }
}









#seekzone.gutter.marked_to_hide { box-shadow    : 0 0 9px 9px rgba( 32, 32, 32, 0.5) inset; }
#seekzone.gutter                { box-shadow    : 0 0 2px 2px rgba(068,000,255, 0.9) inset; }
#seekzone.gutter                { border-radius : 0px !important; }


#seekzone>EM { position:absolute; top :-2em; white-space : nowrap; }



#seekzone                    { border-radius :   2em           ; }
#seekzone.misclick           { border-radius :   2em !important; }






#seekzone.misclick                 { box-shadow : none !important; }

#seekzone.container_selected       { box-shadow : 0  0  5px 5px   rgba( 32, 32, 32, 0.5) inset; }
#seekzone.container_selected.dark  { box-shadow : 0  0  5px 5px   rgba(128,128,128, 0.5) inset; }




#seekzone.misclick                 { opacity    : 0.7; }





#seekzone.pressed         { margin-left   : -4em;             }
#seekzone.pressed         { margin-top    : -4em;             }
#seekzone.pressed         { border-radius :  4em  !important; }
#seekzone.pressed         { width         :  8em  !important; }
#seekzone.pressed         { height        :  8em  !important; }
#seekzone.pressed         { box-shadow    : none  !important; }
#seekzone.pressed         { opacity       : 0.7;              }



#seekzone.gutter    { background          : transparent !important; }
#seekzone.misclick  { background-color    : green ; }
#seekzone.misclick3 { background-color    : yellow; }
#seekzone.misclick2 { background-color    : orange; }
#seekzone.misclick1 { background-color    : red   ; }

#seekzone.dblclick  { background-color    : rgba(000,000,255,0.13)  ; }


#seekzone.bordering            { transition    : all 250ms ease-out;         }
#seekzone.bordering            { border        : 2px solid  #F0F;            }
#seekzone.bordering            { animation     : 2000ms ease-out flash;      }

#seekzone.bordering.corner_l_u { border-radius : 50%  0%  0%  0% !important; }
#seekzone.bordering.corner_u_r { border-radius :  0% 50%  0%  0% !important; }
#seekzone.bordering.corner_r_d { border-radius :  0%  0% 50%  0% !important; }
#seekzone.bordering.corner_d_l { border-radius :  0%  0%  0% 50% !important; }













#seeker_PU                                  { display          : none;            }
#seeker_PU.seek_above                       { transform-origin : 50% 100%;        }
#seeker_PU.seek_bellow                      { transform-origin : 50%   0%;        }
#seeker_PU.fading                           { transform        : none !important; }
#seeker_PU.seek6_onSticky                   { transform        : scale(0.3);      }
#seeker_PU.quick_move>*                     { border           : 9px dotted red;  }




#seeker_PU               { border-radius    : 50%; }

#seeker_PU               { position         : absolute; top:10em; left:14em; }
#seeker_PU               { vertical-align   : middle; }
#seeker_PU.show_seekzone { transform-origin : 50% 100%; }



#seeker_PD               { border-radius    : 50%; }
#seeker_PD               { display          : none; }
#seeker_PD               { position         : absolute; top: 5em; left:14em; }
#seeker_PD               { vertical-align   : middle; }












.seeker_P           { background       : transparent; }
.seeker_P           { margin           : 0; }
.seeker_P           { cursor           : pointer; }
.seeker_P:hover     { color            : red; }
.seeker_P:hover     { font-weight      : bold; }


.seeker_P      >div { position         : relative; }
.seeker_P      >div { transform-origin : 50% 100%; }
.seeker_P      >div { margin           : 0; }
.seeker_P      >div { border           : none; }
.seeker_P      >div { border-radius    : 1em; }

.seeker_P      >div { width            : 120px; }
.seeker_P      >div { padding          : 0; }
.seeker_P      >div { font-size        : 500%; }
.seeker_P      >div { font-weight      : 800; }
.seeker_P      >div { height           : 120px; }
.seeker_P      >div { line-height      : 120px; }
.seeker_P      >div { text-align       : center; }
.seeker_P      >div { background       : linear-gradient(to bottom, rgba(255,255,255,.8), rgba(255,172,  0,.1)); }
.seeker_P.dark >div { background       : linear-gradient(to bottom, rgba( 64, 64, 48,.8), rgba( 32, 16, 16,.1)); }



#seeker_PD.standby                     { background : linear-gradient(to bottom, rgba(255,0,0,1), #400) !important; }
#seeker_PU.standby                     { background : linear-gradient(to bottom, rgba(255,0,0,1), #400) !important; }

          .standby .seeker_handle      { transform  : rotate( -15deg) !important; }
          .standby .seeker_handle.back { transform  : rotate(-165deg) !important; }



#seeker_PD                              { box-shadow : 12px 12px  24px        rgba(  0,  0,  0,0.5); }
.seeker_P               >div            { box-shadow : -3px  -3px  6px    0px rgba(  0,  0,  0,0.5) inset; }
.seeker_P.scroll_smooth >div            { box-shadow :  0px   0px  2px    8px rgba(255,255,255,0.5) inset; }







.seeker_PU2_look_up                     { box-shadow :   0px -32px  0px   32px !important; }
.seeker_PU3_look_right                  { box-shadow :  32px   0px  0px   32px !important; }
.seeker_PU4_look_down                   { box-shadow :   0px  32px  0px   32px !important; }
.seeker_PU5_look_left                   { box-shadow : -32px   0px  0px   32px !important; }






#seeker_PU                  { color      : rgba(064,064,064,0.1); }


#seeker_PU.slot_color1      { color      : rgba(150,075,000,0.5) !important; }
#seeker_PU.slot_color2      { color      : rgba(255,000,000,0.5) !important; }
#seeker_PU.slot_color3      { color      : rgba(255,165,000,0.5) !important; }
#seeker_PU.slot_color4      { color      : rgba(255,255,000,0.5) !important; }
#seeker_PU.slot_color5      { color      : rgba(154,205,050,0.5) !important; }
#seeker_PU.slot_color6      { color      : rgba(100,149,237,0.5) !important; }
#seeker_PU.slot_color7      { color      : rgba(238,130,238,0.5) !important; }
#seeker_PU.slot_color8      { color      : rgba(160,160,160,0.5) !important; }
#seeker_PU.slot_color9      { color      : rgba(255,255,255,0.5) !important; }
#seeker_PU.slot_color0      { color      : rgba(032,032,032,0.5) !important; }







#seeker_PU                        { transition : transform  500ms    , top  250ms         , left 250ms        ; }
#seeker_PU.scroll_smooth          { transition :                       top  250ms ease-out, left 500ms cubic-bezier(0.080, 1.015, 0.055, 0.930); }
#seeker_PU.show_seekzone          {              transform: scale(0.5); }







    .fading *        { transform-origin           : 50%  120%;                             }
    .fading *        { transform                  : scale(0.20);                           }
    .fading *::after { transform                  : scale(0.50) rotate(-90deg) !important; }

    .fading *        { transition-delay           : 600ms;                                 }
    .fading *        { transition-duration        : 300ms;                                 }
    .fading *::after { transition-duration        : 300ms                      !important; }

    .fading *        { transition-timing-function : ease-in;                               }
    .fading *::after { transition-timing-function : ease-in;                               }

    .fading .error   { transform                  : none                       !important; }
    .fading .info    { transform                  : none                       !important; }


      #seeker_CU                       { color          : #40D;     }
.dark #seeker_CU                       { color          : pink;     }

      #seeker_CU sup                   { font-size      :  30%;     }
      #seeker_CU sup                   { pointer-events : none;     }

      #seeker_CU sub                   { font-size      :  30%;     }
      #seeker_CU sub                   { pointer-events : none;     }

      #seeker_CU sub                   { vertical-align : baseline; }



      #seeker_CD                       { width          : 360px; }
      #seeker_CD                       { height         : 360px; }
      #seeker_CD                       { line-height    : 360px !important; }
      #seeker_CD                       { border-radius  : 50%; }

      #seeker_CD em                    { line-height : 150%;  }
      #seeker_CD em                    { font-size   : 36px;  }
      #seeker_CD .seeker_handle        { font-size   : 192px; }
      #seeker_CD .seeker_handle.left   { font-size   : 192px; }
      #seeker_CD .seeker_handle.right  { font-size   : 192px; }
      #seeker_CD .seeker_handle.top    { font-size   :  48px; }
      #seeker_CD .seeker_handle.bottom { font-size   :  48px; }





#seeker_thumbs         {
    display          : inline-block;
    position         : absolute;
    margin           : 0;
    margin-right     :-50%;
    top              : 50%;
    left             : 50%;
    transform        : translate(-50%,-50%);

    font-weight      : 900;
    font-size        : 16px;
    line-height      : 28px;
    vertical-align   : middle;

    border-radius    : 2em;
    background       : transparent;

}
#seeker_thumbs * {
    vertical-align   : middle;
}
#seeker_thumbs .ellipsis {
    display          : block;
}
.ellipsis {
    margin-left      : 0.2em;
    margin-right     : 0.2em;
}




#sel_bag     .seeker_handle                { position   : absolute;    top :  0  ;     left : 0;                 }
#seeker_CD   .seeker_handle.left           { position   : absolute;    top :-.2em;     left : 0;                 }
#seeker_CD   .seeker_handle.right          { position   : absolute;    top :-.2em;    right : 0;                 }
#seeker_CD   .seeker_handle.top            { position   : absolute;    top : 1em; transform : translate(-50%,0); }
#seeker_CD   .seeker_handle.bottom         { position   : absolute; bottom : 1em; transform : translate(-50%,0); }

#seeker_CD   .seeker_handle.bottom  {
    border-width : 2px 0 2px 0 !important;
    border-style : dashed      !important;
    width        : 2em         !important;
    line-height  : 1em         !important;
}

#seeker_CD   .seeker_handle.top     {
    border       : 0           !important;
    line-height  : 1em         !important;
}

             .seeker_handle                { color                       :   green !important; }
.back        .seeker_handle                { color                       :     red !important; }
             .seeker_handle.bottom         { color                       :    gray !important; }
             .seeker_handle.bottom.checked { color                       :     red !important; }
             .seeker_handle.bottom.checked { border-color                :     red !important; }
             .seeker_handle.top            { color                       :   black !important; }
             .seeker_handle.top.checked    { color                       :    navy !important; }
             .seeker_handle.top.checked    { border-color                :    navy !important; }

             .seeker_handle                { font-size                   :    64px; }
             .seeker_handle                { font-weight                 :     300; }
             .seeker_handle                { margin                      :       0; }
             .seeker_handle                { padding                     :       0; }

             .seeker_handle                { transform-origin            : 50% 50% 0; }
             .seeker_handle.back           { transform                   : translate(0, 20%) rotate(-180deg); }
             .seeker_handle.right.back     { transform                   : translate(0, 20%) rotate( 180deg); }

             .seeker_handle                { transition-duration         : 200ms; }
             .seeker_handle.back           { transition-duration         : 200ms; }

             .seeker_handle                { transition-delay            :   0ms; }
             .seeker_handle.back           { transition-delay            :   0ms; }
             .seeker_handle.left           { transition-delay            : 200ms; }
             .seeker_handle.left.back      { transition-delay            : 200ms; }
             .seeker_handle.right          { transition-delay            : 400ms; }
             .seeker_handle.right.back     { transition-delay            : 400ms; }
             .seeker_handle.bottom         { transition-delay            : 600ms; }
             .seeker_handle.bottom.checked { transition-delay            : 600ms; }
             .seeker_handle.top            { transition-delay            : 600ms; }
             .seeker_handle.top.checked    { transition-delay            : 600ms; }

             .seeker_handle                { transition-timing-function  : ease-in;  }
             .seeker_handle.back           { transition-timing-function  : ease-out; }

             .seeker_handle.back           { transition-property         : all; }



#seeker_PU.on_hidden_node { transition-duration : 500ms; }
#seeker_PU.on_hidden_node { transform           : rotate(-25deg) !important; }

#seeker_PD.on_hidden_node { transition-duration : 500ms; }
#seeker_PD.on_hidden_node { transform           : rotate(-25deg) !important; }



#seeker_CU::after { content          : "?"; }

#seeker_CU::after { position         : absolute; }
#seeker_CU::after { font-size        :  50%; }
#seeker_CU::after { text-align       : center !important; }
#seeker_CU::after { vertical-align   : middle !important; }
#seeker_CU::after { padding          : 0      !important; }
#seeker_CU::after { margin           : 0      !important; }
#seeker_CU::after { transform-origin : -100% 50% 0; }
#seeker_CU::after { content          : '\\2699'; }
#seeker_CU::after { opacity          : 0.5; }
#seeker_CU::after { text-shadow      : rgba(0,0,0,0.5) .02em .02em .1em !important; }
#seeker_CU::after { transition-duration        : 500ms; }
#seeker_CU::after { transition-timing-function : cubic-bezier(.22,1.39,.02,1.22); }



#seeker_CU.num1::after  { transform : rotate( -60deg); }
#seeker_CU.num2::after  { transform : rotate( -30deg); }
#seeker_CU.num3::after  { transform : rotate(   0deg); }
#seeker_CU.num4::after  { transform : rotate(  30deg); }
#seeker_CU.num5::after  { transform : rotate(  60deg); }
#seeker_CU.num6::after  { transform : rotate(  90deg); }
#seeker_CU.num7::after  { transform : rotate( 120deg); }
#seeker_CU.num8::after  { transform : rotate( 150deg); }
#seeker_CU.num9::after  { transform : rotate( 180deg); }
#seeker_CU.num10::after { transform : rotate( 210deg); }
#seeker_CU.num11::after { transform : rotate( 240deg); }
#seeker_CU.num12::after { transform : rotate( 270deg); }



          .seek2_onSlotEL #seeker_CU    { border-radius  : 50%  50%  45%  45% !important; }
          .seek1_onResume #seeker_CU    { border-radius  : 50%  50%  45%  45% !important; }
          .seek4_onJumpEL #seeker_CU    { border-radius  : 0                  !important; }
          .seek5_onSeeker #seeker_CU    { border-radius  : 50%  50%  25%  25% !important; }
          .seek6_onSticky #seeker_CU    { border-radius  : 50%  50%  45%  45% !important; }



#seeker_CU::after                { line-height   : 1.5em; }
#seeker_CU::after                { padding       : 0; }

#seeker_CU.long_press_arm::after { content       : '\\25A4'; }
#seeker_CU.long_press_arm::after { border-radius : 0 .2em .2em 0     !important; }
#seeker_CU.long_press_arm::after { border        : .07em solid black !important; }

#seeker_CU.long_press_arm::after { transition    : transform 250ms       , line-height  250ms   150ms, color  500ms  500ms, padding ease-in 1750ms  250ms, background-color 1000ms 0ms; }
#seeker_CU.long_press_arm::after {                                                                                                                         background-color:#BAB;    }
#seeker_CU.long_press_arm::after {                                                                                          padding: 0 1em 0 1em !important; }
#seeker_CU.long_press_arm::after {                                                                     color:#000;       }
#seeker_CU.long_press_arm::after {                                         line-height:  1em;       }
#seeker_CU.long_press_arm::after {                 transform:rotate(0); }






#seekspot_U, #seekspot_D { display          :  none; }
#seekspot_U, #seekspot_D { pointer-events   :  none; }
#seekspot_U, #seekspot_D { position         : fixed; }
#seekspot_U, #seekspot_D { left             :     0; }
#seekspot_U, #seekspot_D { color            : white; }

#seekspot_U              { top              :     0; }
             #seekspot_D { bottom           :     0; }
#seekspot_U, #seekspot_D { width            :   99%; }
#seekspot_U, #seekspot_D { height           : 100px; }

#seekspot_U>*              { position:absolute; left:1.3em; bottom:0; margin:0; padding: 1em; }
             #seekspot_D>* { position:absolute; left:1.3em;    top:0; margin:0; padding: 1em; }



#seekspot_A { position       : fixed;                           }
#seekspot_A { display        : none;                            }
#seekspot_A { pointer-events : none;                            }

#seekspot_A { transform      : translate(-50%,-36%) !important; }
#seekspot_A { font-size      : 100px                !important; }
#seekspot_A { color          : red                  !important; }








#seekspot_U>*              { border-radius : 0em 3em 0em 0em; }
             #seekspot_D>* { border-radius : 0em 0em 3em 0em; }

#seekspot_U >*              { box-shadow       : rgba( 0, 0, 0, 0.2) 5px -5px 16px 0px; }
             #seekspot_D >* { box-shadow       : rgba( 0, 0, 0, 0.2) 5px  5px 16px 0px; }


#seekspot_U                   { background : linear-gradient(to bottom, rgba( 64, 64, 64,.7) 50%, rgba( 64, 64, 64,.1)); }
             #seekspot_D      { background : linear-gradient(to top   , rgba( 64, 64, 64,.7) 50%, rgba( 64, 64, 64,.1)); }
#seekspot_U.dark              { background : linear-gradient(to bottom, rgba(  0,  0,  0,.7) 50%, rgba(  0,  0,  0,.1)); }
             #seekspot_D.dark { background : linear-gradient(to top   , rgba(  0,  0,  0,.7) 50%, rgba(  0,  0,  0,.1)); }

#seekspot_U>*                 { background : linear-gradient(to left, rgba( 96,128, 96,.8) 10%, rgba( 96,128, 96,.9)); }
             #seekspot_D>*    { background : linear-gradient(to left, rgba( 96, 96,255,.8) 10%, rgba( 96, 96,255,.9)); }




.seek_above  #seeker_CU::before { font-size: 32px; content:'\\261F'; position:absolute; bottom: 0.7em; transition: all 500ms ease-in; margin:   0em 0em -2em 1.0em;  }
.seek_bellow #seeker_CU::before { font-size: 32px; content:'\\261F'; position:absolute; bottom: 0.7em; transition: all 500ms ease-in; margin:   0em 0em -2em 1.3em; transform: rotate(-180deg); transform-origin: 0em 0.5em; }

.seek_above  #seeker_CD::before {                  content:'\\261F'; position:absolute;    top:   0em; transition: all 500ms ease-in; margin: 2.5em 0em -5em 0.0em;  }
.seek_bellow #seeker_CD::before {                  content:'\\261F'; position:absolute;    top:   0em; transition: all 500ms ease-in; margin: 2.5em 0em -5em 0.0em; transform: rotate(-180deg); transform-origin: 0em 0.5em; }




.data_pattern.words_exact     { border-color  : #FFA500         !important; }
.data_pattern.words_segment   { border-color  : #FFFF00         !important; }
.data_pattern.words_head_tail { border-color  : #9ACD32         !important; }

.data_pattern.words_exact     { border-radius : 0.3em           !important; }
.data_pattern.words_segment   { border-radius : 0               !important; }
.data_pattern.words_head_tail { border-radius : 1.0em           !important; }

.data_pattern.words_exact     { border-style  : solid           !important; }
.data_pattern.words_segment   { border-style  : solid           !important; }
.data_pattern.words_head_tail { border-style  : solid           !important; }

.data_pattern.words_exact     { border-width  : 0 0.4em 0 0.4em !important; }
.data_pattern.words_exact     { padding       : 0 0.6em 0 0.6em !important; }

.data_pattern.words_segment   { border-width  : 0 0.2em 0 0.2em !important; }
.data_pattern.words_segment   { padding       : 0 0.8em 0 0.8em !important; }

.data_pattern.words_head_tail { border-width  : 0 0.8em 0 0.8em !important; }
.data_pattern.words_head_tail { padding       : 0 0.2em 0 0.2em !important; }

      input.data_pattern { box-shadow         : 0   0.1em 0.3em black; }
.dark input.data_pattern { box-shadow         : 1px   1px   0px   red; }




.sticky_raised .sticky_pad { box-shadow : 9px 9px 20px black; }


.sticky_pad         { z-index : 1; }
.sticky_hand        { z-index : 2; }

.sticky_hand::after { z-index : 2; }

.sticky_rotate      { z-index : 2; }
.sticky_fix         { z-index : 3; }
.sticky_pen         { z-index : 3; }
.sticky_msg_edit    { z-index : 4; }
.sticky_refont      { z-index : 4; }
.sticky_reflow      { z-index : 4; }
.sticky_resize      { z-index : 5; }






.sticky_msg_edit {
    outline      : 2px dotted red;
    box-shadow  : rgba(000,000,000,0.5) 6px 2px  7px 0px;



}








.sticky                     { user-select    : none; }

.sticky                     { pointer-events : none; }




              .sticky_hand_mov    { display :  none; }
.pressed      .sticky_hand_mov    { display : block; }
.fixed        .sticky_hand_mov    { display : block; }



              .sticky_fix         { display :  none; }
.pressed      .sticky_fix         { display :  none; }
.fixed        .sticky_fix         { display : block; }

              .sticky_pen         { display :  none; }
.pressed      .sticky_pen         { display :  none; }
.fixed        .sticky_pen         { display : block; }

              .sticky_refont      { display :  none; }
.pressed      .sticky_refont      { display :  none; }
.fixed        .sticky_refont      { display : block; }

.sticky_ring  .sticky_fix         { display : block; }
.sticky_ring  .sticky_pen         { display :  none; }
.sticky_ring  .sticky_refont      { display :  none; }

.sticky_ring.collapsing .sticky_fix        { display :  none; }






                 .sticky_fix          { border-radius : 50%;             }
                 .sticky_hand_mov     { border-radius : 50%;             }
                 .sticky_pen          { border-radius : 25%;             }
                 .sticky_pen          { text-align    : center;          }


.sticky.pinned.bordering              { border        : none !important; }


















.sticky                        .weight3             { font-weight :  900; }
.sticky                        .weight2             { font-weight :  500; }
.sticky                        .weight1             { font-weight :  100; }

                               .sticky_fix          { font-size   : 32px; }
                               .sticky_hand_mov     { font-size   : 32px; }
                               .sticky_pen          { font-size   : 32px; }
                               .sticky_refont       { font-size   : 32px; }
.sticky_ring                   .sticky_fix          { font-size   : 64px; }


.sticky .size1                                      { font-size   :  8px; }
.sticky .size2                                      { font-size   : 12px; }
.sticky .size3                                      { font-size   : 18px; }
.sticky .size4                                      { font-size   : 40px; }
.sticky .size5                                      { font-size   : 48px; }




.sticky                  { line-height :   1em; }
.sticky *                { line-height : 0.8em; }
        .sticky_hand_mov { line-height :   1em; }
        .sticky_fix      { line-height :   1em; }





.sticky         .sticky_hand_mov    { position: absolute; }

.sticky         .sticky_fix         { position: absolute; }
.sticky         .sticky_pen         { position: absolute; }
.sticky         .sticky_refont      { position: absolute; }






.sticky          .sticky_hand_mov    {    top :    50%; right :     0 ; }















.sticky                      { transform-origin :  0px 36px !important; }

.sticky  .sticky_hand_mov    { transform        : translate( 50%, -50%); }



.sticky          .sticky_fix         { transform        : translate( 1em, -0.2em); }
.sticky.point_EE .sticky_fix         { transform        : translate(-1em, -0.2em); }
.sticky.point_NE .sticky_fix         { transform        : translate(-1em, -0.2em); }
.sticky.point_NW .sticky_fix         { transform        : translate( 1em, -0.2em); }
.sticky.point_SE .sticky_fix         { transform        : translate(-1em, -0.2em); }
.sticky.point_SW .sticky_fix         { transform        : translate( 1em, -0.2em); }
.sticky.point_WW .sticky_fix         { transform        : translate( 1em, -0.2em); }

.sticky          .sticky_pen         { transform        : translate( 2em, -0.2em); }
.sticky.point_EE .sticky_pen         { transform        : translate(-2em, -0.2em); }
.sticky.point_NE .sticky_pen         { transform        : translate(-2em, -0.2em); }
.sticky.point_NW .sticky_pen         { transform        : translate( 2em, -0.2em); }
.sticky.point_SE .sticky_pen         { transform        : translate(-2em, -0.2em); }
.sticky.point_SW .sticky_pen         { transform        : translate( 2em, -0.2em); }
.sticky.point_WW .sticky_pen         { transform        : translate( 2em, -0.2em); }

.sticky          .sticky_refont      { transform        : translate( 0.2em, 0.0em); }
.sticky.point_EE .sticky_refont      { transform        : translate(-0.2em,-0.0em); }
.sticky.point_NE .sticky_refont      { transform        : translate(-0.2em, 0.0em); }
.sticky.point_NW .sticky_refont      { transform        : translate( 0.2em, 0.0em); }
.sticky.point_SE .sticky_refont      { transform        : translate(-0.2em, 0.0em); }
.sticky.point_SW .sticky_refont      { transform        : translate( 0.2em,-0.0em); }
.sticky.point_WW .sticky_refont      { transform        : translate( 0.2em,-0.0em); }

.sticky                      { transform        : rotate(   0   ); }
.sticky.point_EE             { transform        : rotate(   0   ); }
.sticky.point_NE             { transform        : rotate( -45deg); }
.sticky.point_NW             { transform        : rotate(-135deg); }
.sticky.point_SE             { transform        : rotate(  45deg); }
.sticky.point_SW             { transform        : rotate( 135deg); }
.sticky.point_WW             { transform        : rotate(-180deg); }




.flipped                     { transform        : rotate(180deg); display:inline-block; }



.sticky                               { width : 128px; height : 72px; }






.sticky          .sticky_hand_mov     {  width :  32px; height : 32px; }
.sticky          .sticky_fix          {  width :   1em; height :  1em; }
.sticky          .sticky_pen          {  width :   2em; height :  1em; }
.sticky          .sticky_refont       {  width :  100%; height :  1em; }



.sticky_ring     .sticky_fix          {  width : 66px !important; height : 66px !important; }
.sticky_ring     .sticky_pen          {  width : 66px !important; height : 66px !important; }
.sticky_ring     .sticky_refont       {  width : 66px !important; height : 66px !important; }




.sticky *                      { vertical-align : bottom; }

.sticky       .sticky_fix      { text-align : center; }
.sticky       .sticky_hand_mov { text-align : center; }



.sticky.big12_note>div           { height      : 12em; }
.sticky.big18_note>div           { height      : 18em; }
.sticky            pre           { margin      :  0  ; }
.sticky            pre           { padding     :  0  ; }


.sticky            pre.show_seekzone   { background  :  #222 !important; }
.sticky            pre.show_seekzone   { padding     :   1em !important; }
.sticky            pre.show_seekzone   { line-height : 1.2em !important; }
.sticky            pre.show_seekzone * { line-height : 1.2em !important; }



@keyframes swinging {
    from { transform : rotate(  0deg); }
    to   { transform : rotate(360deg); }
}



@keyframes retracting {
    from { transform : translate(  0%); }
     2%  { transform : translate( 20%); }
    90%  { transform : translate( 10%); }
    to   { transform : translate(  0%); }
}




  .sticky_pad_num    { position         : absolute;    top:16px;  left: 4px; }
  .sticky_pad_num    { font-family      : 'Lucida Console';    }
  .sticky_pad_num    { font-size        : 64px;                }
  .sticky_pad_num    { color            : rgb(0,0,0,0.2);      }



  .sticky_pad_dat    { position         : absolute; bottom: 1px; right: 16px; }
  .sticky_pad_dat    { color            : rgba(255,0,0,0.9);   }
  .sticky_pad_dat    { border-radius    : 10px 10px 0 0;       }
  .sticky_pad_dat    { padding          : 0  8px 0 8px;        }
  .sticky_pad_dat    { font-family      : 'monospace';         }





                   .sticky_pad { display    : block; }
.sticky_ring       .sticky_pad { display    : block; }

                   .sticky_pad { color      : #222; }



                   .sticky_pad { transition   : transform 150ms ease-out;   }
.sticky.point_WW   .sticky_pad { transition   : transform 300ms ease-out;   }



              .sticky_pad    { box-shadow     : rgba(000,000,000,0.5) 6px 2px  7px 0px; }
.dark         .sticky_pad    { box-shadow     : rgba(128,128,128,0.5) 2px 2px  2px 0px; }
              .sticky_pad    { pointer-events : auto; }
.paste_target .sticky_pad    { outline        : 4px rgba(000,000,255,0.53) dashed; }



              .sticky_pad    { border-left   : 10px solid rgba(0,0,0,0.2); }

              .sticky_pad    { border-radius : 0    0    0    0;           }
.point_EE     .sticky_pad    { border-radius : 0    0    0    0;           }
.point_NE     .sticky_pad    { border-radius : 0    0    0  8px;           }
.point_NW     .sticky_pad    { border-radius : 0    0    8px  0;           }
.point_SE     .sticky_pad    { border-radius : 8px  0    0    0;           }
.point_SW     .sticky_pad    { border-radius : 0    8px  0    0;           }
.point_WW     .sticky_pad    { border-radius : 0    0    0    0;           }


              .sticky_pad    { min-width  :  5em; }
              .sticky_pad    { min-height :  5em; }


.sticky_ring  .sticky_pad    { min-width  : 16em !important; }



              .sticky_pad    { margin-top       : 25%;      }
              .sticky_pad    { position         : relative; }
              .sticky_pad    { transform-origin : top left; }

.point_EE     .sticky_pad    { transform        : rotate(   0   ) translate(   0 , -50%); }
.point_NE     .sticky_pad    { transform        : rotate(  45deg) translate(   0 ,-100%); }
.point_NW     .sticky_pad    { transform        : rotate( 135deg) translate(-100%,-100%); }
.point_SE     .sticky_pad    { transform        : rotate( -45deg) translate(   0 ,   0 ); }
.point_SW     .sticky_pad    { transform        : rotate(-135deg) translate(-100%,   0 ); }
.point_WW     .sticky_pad    { transform        : rotate( 180deg) translate(-100%, -50%); }

.point_EE     .sticky_pad    { margin-left      : 59%; margin-top : 28%; }
.point_NE     .sticky_pad    { margin-left      : 47%; margin-top : 28%; }
.point_NW     .sticky_pad    { margin-left      : 47%; margin-top : 28%; }
.point_SE     .sticky_pad    { margin-left      : 47%; margin-top : 28%; }
.point_SW     .sticky_pad    { margin-left      : 47%; margin-top : 28%; }
.point_WW     .sticky_pad    { margin-left      : 59%; margin-top : 28%; }



.pressed         .sticky_pad_msg    { opacity        : 1.0 !important; }
                 .sticky_pad_msg    { position       : absolute; top: 1px; left:48px; }

                 .sticky_pad_msg    { min-height     :  max-content; }
                 .sticky_pad_msg    { min-width      :  2em;         }

                 .sticky_pad_msg    { margin-top     : 5px      !important; }
                 .sticky_pad_msg    { padding-bottom : 0.1em    !important; }

                 .sticky_pad_msg    { overflow-x     : auto; overflow-y :   auto; }
.ws_pre          .sticky_pad_msg    { overflow-x     : auto; overflow-y :   auto; }
.ws_pre_wrap     .sticky_pad_msg    { overflow-x     : auto; overflow-y :   auto; }
.ws_break_spaces .sticky_pad_msg    { overflow-x     : auto; overflow-y :   auto; }
.ws_pre_line     .sticky_pad_msg    { overflow-x     : auto; overflow-y :   auto; }
.ws_normal       .sticky_pad_msg    { overflow-x     : auto; overflow-y :   auto; }
.ws_nowrap       .sticky_pad_msg    { overflow-x     : auto; overflow-y : hidden; }

.scrolling       .sticky_pad_msg    { outline-style  : inset         ; }
.scrolling       .sticky_pad_msg    { outline-color  :  lightgray    ; }
.scrolling       .sticky_pad_msg    { outline-width  :            3px; }

                 .sticky_pad_msg    { font-family    : monospace; }
                 .sticky_pad_msg    { font-size      : 12px;      }
                 .sticky_pad_msg    { line-height    :  1em;      }
                 .sticky_pad_msg em { white-space    : nowrap;    }

                 .sticky_pad_msg,
.ws_pre_wrap     .sticky_pad_msg    { white-space    : pre-wrap    ; }
.ws_pre          .sticky_pad_msg    { white-space    : pre         ; }
.ws_break_spaces .sticky_pad_msg    { white-space    : break-spaces; }
.ws_pre_line     .sticky_pad_msg    { white-space    : pre-line    ; }
.ws_normal       .sticky_pad_msg    { white-space    : normal      ; }
.ws_nowrap       .sticky_pad_msg    { white-space    : nowrap      ; }




.sticky_ring.point_EE .sticky_fix  {    top :    20%; right :   -70%; }
.sticky_ring.point_NE .sticky_fix  {    top :    20%; right :   -70%; }
.sticky_ring.point_NW .sticky_fix  {    top :    20%; left  :   -70%; }
.sticky_ring.point_SE .sticky_fix  {    top :    20%; right :   -70%; }
.sticky_ring.point_SW .sticky_fix  {    top :    20%; left  :   -70%; }
.sticky_ring.point_WW .sticky_fix  {    top :    20%; left  :   -70%; }



.sticky.point_00                   { opacity    : 0.5;         }
.sticky.point_00                   { transform  : scale(0.01); }





     .point_NW .sticky_fix           { bottom : -0.8em; left  :   0em; }
     .point_NW .sticky_pen           { bottom : -0.8em; left  :   0em; }
     .point_NW .sticky_refont        { top    : -1.8em; right : 0.5em; }

     .point_WW .sticky_fix           { top    : -0.8em; left  :   0em; }
     .point_WW .sticky_pen           { top    : -0.8em; left  :   0em; }
     .point_WW .sticky_refont        { bottom : -1.8em; right : 0.5em; }

     .point_SW .sticky_fix           { top    : -0.8em; left  :   0em; }
     .point_SW .sticky_pen           { top    : -0.8em; left  :   0em; }
     .point_SW .sticky_refont        { bottom : -1.8em; right : 0.5em; }


     .point_NE .sticky_fix           { bottom : -0.8em; right : 0.5em; }
     .point_NE .sticky_pen           { bottom : -0.8em; right : 0.5em; }
     .point_NE .sticky_refont        { top    : -1.8em;  left : 0.5em; }

     .point_EE .sticky_fix           { top    : -0.8em; right : 0.5em; }
     .point_EE .sticky_pen           { top    : -0.8em; right : 0.5em; }
     .point_EE .sticky_refont        { bottom : -1.8em;  left : 0.5em; }

     .point_SE .sticky_fix           { top    : -0.8em; right : 0.5em; }
     .point_SE .sticky_pen           { top    : -0.8em; right : 0.5em; }
     .point_SE .sticky_refont        { bottom : -1.2em;  left : 0.5em; }



             .sticky_rotate  { position         : relative; }
             .sticky_rotate  { pointer-events   : auto;     }

             .sticky_rotate  { display :  block; }

             .sticky_rotate  { background       : transparent; }



.sticky_ring .sticky_rotate  { display :  none; }


             .sticky_rotate  { line-height      :  1em; }

             .sticky_rotate  { width            :  6em; }
             .sticky_rotate  { height           : 100%; }

             .sticky_rotate,
.point_EE    .sticky_rotate,
.point_NE    .sticky_rotate,
.point_SE    .sticky_rotate  { top : 0%;  right : -100%; }
.point_WW    .sticky_rotate,
.point_NW    .sticky_rotate,
.point_SW    .sticky_rotate  { top : 0%;  left  :  -7em; }

             .sticky_rotate,
.point_EE    .sticky_rotate,
.point_NE    .sticky_rotate,
.point_SE    .sticky_rotate  { border-radius    : 0 50% 50% 0; }
.point_WW    .sticky_rotate,
.point_NW    .sticky_rotate,
.point_SW    .sticky_rotate  { border-radius    : 50% 0 0 50%; }



             .sticky_rotate_dir { position      : relative; }
             .sticky_rotate_dir { transform     : translate( 0%,-70%) rotate(90deg); }

             .sticky_rotate_dir { display       :     none; }
.fixed       .sticky_rotate_dir { display       :    block; }
.pressed     .sticky_rotate_dir { display       :    block; }

             .sticky_rotate_dir { border-radius : 50%;             }
             .sticky_rotate_dir { color         : rgba(0,0,0,0.50); }

             .sticky_rotate_dir { font-size     : 32px; }
             .sticky_rotate_dir { text-align    : center; }
             .sticky_rotate_dir { white-space   : nowrap; }
             .sticky_rotate_dir { line-height   :   1em; }

             .sticky_rotate_dir { height        : 32px; }
             .sticky_rotate_dir { width         : 32px; }

             .sticky_rotate_dir { top           : 50%; }
             .sticky_rotate_dir,
.point_EE    .sticky_rotate_dir,
.point_NE    .sticky_rotate_dir,
.point_SE    .sticky_rotate_dir  { right        : -50%; }
.point_WW    .sticky_rotate_dir,
.point_NW    .sticky_rotate_dir,
.point_SW    .sticky_rotate_dir  { left         :  10%; }



                            .sticky_reflow          { position      : absolute; }
                            .sticky_reflow::after   { position      : absolute; }
                            .sticky_reflow::after   { white-space   : nowrap;   }
                            .sticky_reflow          { border-radius : 50%;      }
                            .sticky_reflow          { font-size     : 24px;     }

                            .sticky_reflow::after,
.ws_pre_wrap                .sticky_reflow::after   { content     :'1/6 .. pre-wrap'    ; }
.ws_pre                     .sticky_reflow::after   { content     :'2/6 .. pre'         ; }
.ws_break_spaces            .sticky_reflow::after   { content     :'3/6 .. break-spaces'; }
.ws_pre_line                .sticky_reflow::after   { content     :'4/6 .. pre-line'    ; }
.ws_normal                  .sticky_reflow::after   { content     :'5/6 .. normal'      ; }
.ws_nowrap                  .sticky_reflow::after   { content     :'6/6 .. nowrap'      ; }

                            .sticky_reflow::after,
.point_EE                   .sticky_reflow::after,
.point_NE                   .sticky_reflow::after,
.point_SE                   .sticky_reflow::after  { transform : translate(   0%,0%); margin-right :  0em; }
.point_WW                   .sticky_reflow::after,
.point_NW                   .sticky_reflow::after,
.point_SW                   .sticky_reflow::after  { transform : translate(-100%,0%); margin-left  : -1em; }



                            .sticky_reflow          { display       :  none;    }
.pressed                    .sticky_reflow          { display       :  none;    }
.fixed                      .sticky_reflow          { display       : block;    }
.sticky_ring                .sticky_reflow          { display       :  none;    }

                            .sticky_reflow          { height        : 1em;             }
                            .sticky_reflow          { width         : 1em;             }

.sticky_ring                .sticky_reflow          { height        : 66px !important; }
.sticky_ring                .sticky_reflow          { width         : 66px !important; }



                            .sticky_reflow          { transform        : translate( 0.2em, 0.4em); }
.point_EE                   .sticky_reflow          { transform        : translate(-0.2em,-0.2em); }
.point_NE                   .sticky_reflow          { transform        : translate(-0.2em, 0.4em); }
.point_NW                   .sticky_reflow          { transform        : translate( 0.2em, 0.4em); }
.point_SE                   .sticky_reflow          { transform        : translate(-0.2em, 0.4em); }
.point_SW                   .sticky_reflow          { transform        : translate( 0.2em,-0.2em); }
.point_WW                   .sticky_reflow          { transform        : translate( 0.2em,-0.2em); }



.point_NW                   .sticky_reflow          { top    : -0.8em; right :  0.5em; }
.point_WW                   .sticky_reflow          { bottom : -0.8em; right :  0.5em; }
.point_SW                   .sticky_reflow          { bottom : -0.8em; right :  0.5em; }

.point_NE                   .sticky_reflow          { top    : -0.8em;  left :  0.5em; }
.point_EE                   .sticky_reflow          { bottom : -0.8em;  left :  0.5em; }
.point_SE                   .sticky_reflow          { bottom : -0.2em;  left :  0.5em; }




.point_WW                   .sticky_reflow,
.point_NW                   .sticky_reflow,
.point_SW                   .sticky_reflow,
.point_WW.ws_pre            .sticky_reflow,
.point_NW.ws_pre            .sticky_reflow,
.point_SW.ws_pre            .sticky_reflow          { right : 1em; }

.point_WW.ws_pre_wrap       .sticky_reflow,
.point_NW.ws_pre_wrap       .sticky_reflow,
.point_SW.ws_pre_wrap       .sticky_reflow          { right : 2em;  }

.point_WW.ws_break_spaces   .sticky_reflow,
.point_NW.ws_break_spaces   .sticky_reflow,
.point_SW.ws_break_spaces   .sticky_reflow          { right : 3em;  }

.point_WW.ws_pre_line       .sticky_reflow,
.point_NW.ws_pre_line       .sticky_reflow,
.point_SW.ws_pre_line       .sticky_reflow          { right : 4em;  }

.point_WW.ws_normal         .sticky_reflow,
.point_NW.ws_normal         .sticky_reflow,
.point_SW.ws_normal         .sticky_reflow          { right : 5em;  }

.point_WW.ws_nowrap         .sticky_reflow,
.point_NW.ws_nowrap         .sticky_reflow,
.point_SW.ws_nowrap         .sticky_reflow          { right : 6em;  }




.point_EE                   .sticky_reflow,
.point_NE                   .sticky_reflow,
.point_SE                   .sticky_reflow,
.point_EE.ws_pre            .sticky_reflow,
.point_NE.ws_pre            .sticky_reflow,
.point_SE.ws_pre            .sticky_reflow          { left : 1.5em; }

.point_EE.ws_pre_wrap       .sticky_reflow,
.point_NE.ws_pre_wrap       .sticky_reflow,
.point_SE.ws_pre_wrap       .sticky_reflow          { left : 2.0em;  }

.point_EE.ws_break_spaces   .sticky_reflow,
.point_NE.ws_break_spaces   .sticky_reflow,
.point_SE.ws_break_spaces   .sticky_reflow          { left : 2.5em;  }

.point_EE.ws_pre_line       .sticky_reflow,
.point_NE.ws_pre_line       .sticky_reflow,
.point_SE.ws_pre_line       .sticky_reflow          { left : 3.0em;  }

.point_EE.ws_normal         .sticky_reflow,
.point_NE.ws_normal         .sticky_reflow,
.point_SE.ws_normal         .sticky_reflow          { left : 3.5em;  }

.point_EE.ws_nowrap         .sticky_reflow,
.point_NE.ws_nowrap         .sticky_reflow,
.point_SE.ws_nowrap         .sticky_reflow          { left : 4.0em;  }







             .sticky               *::after         { transition : background-color 150ms ease-out;            }
             .sticky.pressed                        { transition : transform        150ms ease-in;             }
             .sticky.resize_cap    *                { transition : transform        500ms          !important; }
             .sticky.resizing      *                { transition : width              0ms;                     }
             .sticky.show_seekzone *                { transition : none !important;                   }
                    .sticky_ring                    { transition : all              400ms cubic-bezier(.21,.38,.94,.36); }

.slow_layout .sticky                                { transition : all              300ms ease-in;    }




              .sticky_paste { display     :   none; }
.sticky_ring  .sticky_paste { display     :   none; }
.paste_target .sticky_paste { display     :  block; }

.paste_target .sticky_paste { position    : absolute; top:-0.5em; left:0; }
.paste_target .sticky_paste { width       :     100%; }


              .sticky_paste { text-align  : center; }
              .sticky_paste { font-size   :   72px; }
              .sticky_paste { line-height :    1em; }




             .sticky_resize { position         : absolute; }

             .sticky_resize { display          :  none; }
.fixed       .sticky_resize { display          : block; }
.sticky_ring .sticky_resize { display          :  none; }

             .sticky_resize { border-radius    : 50%;   }


             .sticky_resize { font-size        : 32px;  }

             .sticky_resize { width            : 1.5em; }
             .sticky_resize { height           : 1.5em; }

.sticky_ring .sticky_resize { height           : 66px !important; }
.sticky_ring .sticky_resize { width            : 66px !important; }

             .sticky_resize { border-radius    : 50% !important; }



             .sticky_resize_dir { position      : relative; }

             .sticky_resize_dir { display       :     none; }
.fixed       .sticky_resize_dir { display       :    block; }
.pressed     .sticky_resize_dir { display       :    block; }

             .sticky_resize_dir { color         : rgba(0,0,0,0.2); }


             .sticky_resize_dir { font-size     : 32px; }
             .sticky_resize_dir { text-align    : center; }
             .sticky_resize_dir { white-space   : nowrap; }

             .sticky_resize_dir { height        : 32px; }
             .sticky_resize_dir { width         : 32px; }

             .sticky_resize_dir { top           : 50%; }



           .sticky_resize.point_NE                    { top       : -1em; right : -1.0em; background-color : rgba(136,000,000,0.3); }
           .sticky_resize.point_SE                    { bottom    : -1em; right : -1.0em; background-color : rgba(000,136,000,0.3); }
           .sticky_resize.point_NW                    { top       : -1em; left  : -1.3em; background-color : rgba(000,000,136,0.3); }
           .sticky_resize.point_SW                    { bottom    : -1em; left  : -1.3em; background-color : rgba(102,000,102,0.3); }

.point_NE  .sticky_resize.point_SW                    { bottom    : -2em; left  : -2.3em; background-color : rgba(102,000,102,0.3); transition : all 100ms 200ms ease-in; }
.point_SE  .sticky_resize.point_NW                    { top       : -2em; left  : -2.3em; background-color : rgba(102,000,102,0.3); transition : all 100ms 200ms ease-in; }
.point_NW  .sticky_resize.point_SE                    { bottom    : -2em; right : -2.3em; background-color : rgba(102,000,102,0.3); transition : all 100ms 200ms ease-in; }
.point_SW  .sticky_resize.point_NE                    { top       : -2em; right : -2.3em; background-color : rgba(102,000,102,0.3); transition : all 100ms 200ms ease-in; }


           .sticky_resize          .sticky_resize_dir { transition : all 500ms; }

           .sticky_resize.point_NE .sticky_resize_dir { transform : translate( 0%,-80%) rotate(-45deg); }
           .sticky_resize.point_SE .sticky_resize_dir { transform : translate(50%,-70%) rotate(+45deg); }
           .sticky_resize.point_NW .sticky_resize_dir { transform : translate(50%,-70%) rotate(+45deg); }
           .sticky_resize.point_SW .sticky_resize_dir { transform : translate( 0%,-80%) rotate(-45deg); }

.ws_nowrap .sticky_resize.point_NE .sticky_resize_dir { transform : translate( 0%,-80%) rotate(0); }
.ws_nowrap .sticky_resize.point_SE .sticky_resize_dir { transform : translate(50%,-70%) rotate(0); }
.ws_nowrap .sticky_resize.point_NW .sticky_resize_dir { transform : translate(50%,-70%) rotate(0); }
.ws_nowrap .sticky_resize.point_SW .sticky_resize_dir { transform : translate( 0%,-80%) rotate(0); }




.sticky.resizing                { opacity    : 1.0;                           }
.sticky.dimmed.scrolling        { opacity    : 0.5              !important;   }


.sticky.dimmed                  { opacity    : 0.2              !important;   }
.sticky.dimmed                  { transition : opacity 500ms;                 }
.sticky.dimmed_off              { opacity    : 1.0              !important;   }
.sticky.dimmed_off              { transition : opacity 250ms;                 }





.sticky_pad_num            { text-shadow : none;             }
.sticky_fix                { text-shadow : #FFF 1px 1px 1px; }
.sticky_pen                { text-shadow : #FFF 1px 1px 1px; }
.sticky_reflow             { text-shadow : #FFF 1px 1px 1px; }
.sticky_refont             { text-shadow : #FFF 1px 1px 1px; }
.sticky_resize             { text-shadow : #FFF 1px 1px 1px; }


              .sticky_pad    { transition : box-shadow 200ms ease-out;       }
              .sticky_pad    { transition : width      200ms ease-out;       }
              .sticky_pad *  { transition : visibility 200ms 200ms ease-out; }
.dimmed       .sticky_pad *  { visibility : hidden               !important; }
.dimmed       .sticky_pad    { box-shadow : none;                            }
.sticky.dimmed_off           { opacity    : 1.0                  !important; }



                        .sticky_hand         { display          :    block; }
                        .sticky_hand         { pointer-events   :     auto; }
                        .sticky_hand         { position         : absolute; top:30px; left:2px; }
                        .sticky_hand         { transform-origin : 100% 50%; }
                        .sticky_hand         { width            :     74px; }
                        .sticky_hand         { height           :      1px; }
                        .sticky_hand         { border-radius    : 50% 0 0 50%;     }
                        .sticky_hand         { border           : 3px solid transparent; }
                        .sticky_hand         { background       : linear-gradient(to bottom       , rgba(0,0,0,.6) 0%, rgba(0,0,0,.4) 50%, rgba(0,0,0,.5) 80%, rgba(0,0,0,.5) 95%, #111 100%); }
                        .sticky_hand         { background       : linear-gradient(to right, rgba(000,000,255,1.00) 0%, rgba(000,000,000,1.00) 30%, rgba(128,128,255,0.5) 30%, rgba(000,000,000,1.00) 100%); }
                        .sticky_hand         { padding          : 0.2em 0 0.2em 0; }

                        .sticky_hand::after  {    top :    50%; left  :    50%; }
                        .sticky_hand::after  {  width  : 72px; height : 72px; }
                        .sticky_hand::after  { border-radius : 50%;             }
                        .sticky_hand::after  { content : "";      }
                        .sticky_hand::after  { display : block; }
                        .sticky_hand::after  { line-height : 1em; }
                        .sticky_hand::after  { pointer-events : auto; }
                        .sticky_hand::after  { position: absolute; }
                        .sticky_hand::after  { transform        : translate(  0 , -50%); }

.anchor_not_found       .sticky_hand         { animation                 : 1000ms   swinging; }
.anchor_not_found       .sticky_hand         { animation-direction       :         alternate; }
.anchor_not_found       .sticky_hand         { animation-iteration-count :          infinite; }



.anchor_detached        .sticky_hand         { animation                 :  900ms retracting; }
.anchor_detached        .sticky_hand         { animation-direction       :            normal; }
.anchor_detached        .sticky_hand         { animation-iteration-count :                 1; }
.anchor_detached        .sticky_hand         { animation-fill-mode       :          forwards; }

.anchor_unset           .sticky_hand         { animation                 :  500ms   swinging; }
.anchor_unset           .sticky_hand         { animation-direction       :            normal; }
.anchor_unset           .sticky_hand         { animation-iteration-count :          infinite; }

.bordering              .sticky_hand         { background       : red                !important; }

.dark                   .sticky_hand         { background       : linear-gradient(to right, rgba(136,136,136,1.00) 0%, rgba(136,136,136,1.00) 30%, rgba(136,136,136,0.3) 30%, rgba(136,136,136,1.00) 100%); }

.fixed                  .sticky_hand         { border        : 1px solid red;         }
.fixed                  .sticky_hand::after  { display : block; }

.point_EE               .sticky_hand         { width : 74px; }
.point_NE               .sticky_hand         { width : 62px; }
.point_NW               .sticky_hand         { width : 62px; }
.point_SE               .sticky_hand         { width : 62px; }
.point_SW               .sticky_hand         { width : 62px; }
.point_WW               .sticky_hand         { width : 74px; }



.pressed                .sticky_hand::after  { display : block; }

.sticky_ring            .sticky_hand         { display : block; }
.sticky_ring            .sticky_hand         { height :  6px; }
.sticky_ring            .sticky_hand         { position: absolute; }
.sticky_ring            .sticky_hand         { text-align : center; }

.sticky_ring.collapsing .sticky_hand         { display :  none; }

.sticky_ring            .sticky_hand         { border-radius : 50%;             }

                        .sticky_hand::before { color   : red    !important; }
.anchor_not_found       .sticky_hand::before { color   : blue   !important; }
.anchor_unset           .sticky_hand::before { color   : orange !important; }



.fixed.touched          .sticky_hand::before { font-size   : 32px !important; }
.anchor_detached        .sticky_hand::before { font-size   : 64px !important; }










                    .sticky_reflow::after   {            color : rgba(  0,   0,   0,0.2); }
                    .sticky_reflow::after   { background-color : rgba(255,   0,   0,0.5); }

                    .sticky_reflow,
.ws_pre             .sticky_reflow          {            color : rgba(150,  75,   0,1  ); }
.ws_pre_wrap        .sticky_reflow          {            color : rgba(255,   0,   0,1  ); }
.ws_break_spaces    .sticky_reflow          {            color : rgba(255, 165,   0,1  ); }
.ws_pre_line        .sticky_reflow          {            color : rgba(255, 255,   0,1  ); }
.ws_normal          .sticky_reflow          {            color : rgba(154, 205,  50,1  ); }
.ws_nowrap          .sticky_reflow          {            color : rgba(100, 149, 237,1  ); }

                    .sticky_fix             {            color : rgba(  0,  0,  0,0.90); }
                    .sticky_hand_mov        {            color : rgba(  0,  0,  0,0.50); }
                    .sticky_msg_edit        {            color : #EEE        !important; }
                    .sticky_msg_edit *      {            color : #EEE        !important; }
                    .sticky_pen             {            color : rgba(  0,  0,  0,0.90); }
                    .sticky_refont          {            color : rgba(  0,  0,128,0.90); }





       .sticky_pad_dat                                      { background-color : #EEE;            }

       .sticky_fix                                          { background-color : rgba(128,128,128,0.50);            }
       .sticky_msg_edit                                     { background       : rgba( 64, 64, 64,1.00) !important; }
       .sticky_pen                                          { background-color : rgba(128,128,128,0.50);            }
       .sticky_refont                                       { background-color : rgba(128,128,128,0.50);            }

.fixed .sticky_rotate                                       { background-color : rgba(  0,  0,  0,0.07);            }
.fixed .sticky_fix         , .pressed .sticky_fix           { background-color : rgba(255,  0,  0,0.50);            }
.fixed .sticky_hand::after , .pressed .sticky_hand::after   { background-color : rgba(255,  0,  0,0.50);            }
.fixed .sticky_pen         , .pressed .sticky_pen           { background-color : rgba(255,  0,  0,0.50);            }
.fixed .sticky_reflow      , .pressed .sticky_reflow        { background-color : rgba(255,  0,  0,0.50);            }
.fixed .sticky_refont      , .pressed .sticky_refont        { background-color : rgba(255,  0,  0,0.50);            }
.fixed .sticky_resize      , .pressed .sticky_resize        { background-color : rgba(255,  0,  0,0.50);            }
.fixed .sticky_rotate      , .pressed .sticky_rotate        { background-color : rgba(255,  0,  0,0.50);            }

.resize_cap                           .sticky_pad           { background-color : transparent !important; }

                                      .sticky.pressed       { opacity          : 1.0         !important; }
.pressed                              .sticky_pad_msg       { background-color : white       !important; }
        .has_focus                    .sticky_pad_msg       { background-color : black       !important; }

.resize_cap                           .sticky_reflow        { border : 1px solid #FF0 !important; }
.resize_cap                           .sticky_refont        { border : 1px solid #FF0 !important; }
.resize_cap                           .sticky_resize        { border : 1px solid #FF0 !important; }

.resize_cap                           .sticky_reflow        { transform        : scale(1.5) !important; }
.resize_cap                           .sticky_refont        { transform        : scale(1.5) !important; }
.resize_cap                           .sticky_resize        { transform        : scale(1.5) !important; }

.resize_cap                           .sticky_fix           { opacity: 0.1            !important; }
.resize_cap                           .sticky_hand::after   { opacity: 0.1            !important; }
.resize_cap                           .sticky_pad_msg       { opacity: 0.1            !important; }
.resize_cap                           .sticky_pad_num       { opacity: 0.1            !important; }
.resize_cap                           .sticky_pen           { opacity: 0.1            !important; }
.resize_cap                           .sticky_reflow::after { opacity: 0.1            !important; }
.resize_cap                           .sticky_rotate        { opacity: 0.1            !important; }








/*INLINE}}}*/
/*# sourceURL=dom_tools.css */
`
)
 .replace(/\\(\\x+)/g,"\\\\$1")
;
/*}}}*/
  /**    5 DATA     JS dom_data_js_data {{{*/
/*
../script/dom_data.js
*/
let dom_data_js_data ="data:text/javascript;charset='utf-8',"+ `
/*INLINE{{{*/







const DOM_DATA_JS_ID        = "dom_data_js";
const DOM_DATA_JS_TAG       = DOM_DATA_JS_ID  +" (221124:17h:57)";

let dom_data    = (function() {
"use strict";



const APOS          = String.fromCharCode(39);
const DOUBLE_QUOTE  = String.fromCharCode(34);
const TAB           = String.fromCharCode( 9);
const LF            = String.fromCharCode(10);
const CR            = String.fromCharCode(13);






const SYMBOL_FUNCTION               = "\u0083";
const SYMBOL_SECTION                = "\u00A7";
const SYMBOL_LEFT_DBL_ANGLE         = "\u00AB";
const SYMBOL_PARAGRAPH              = "\u00B6";
const SYMBOL_RIGHT_DBL_ANGLE        = "\u00BB";


const SYMBOL_ELLIPSIS               = "\u2026";
const SYMBOL_DBL_EXCLAM             = "\u203C";
const SYMBOL_EXCLAM_QUESTION        = "\u2049";
const SYMBOL_LEFT_ARROW             = "\u2190";
const SYMBOL_UP_ARROW               = "\u2191";
const SYMBOL_RIGHT_ARROW            = "\u2192";
const SYMBOL_DOWN_ARROW             = "\u2193";
const SYMBOL_LEFT_RIGHT_ARROW       = "\u2194";
const SYMBOL_UP_DOWN_ARROW          = "\u2195";
const SYMBOL_NW_ARROW               = "\u2196";
const SYMBOL_UP_LEFT_ARROW          = "\u2196";
const SYMBOL_LEFT_ARROW_HOOK        = "\u21A9";
const SYMBOL_RIGHT_ARROW_HOOK       = "\u21AA";
const SYMBOL_DOWN_LEFT_ARROW        = "\u21B5";
const SYMBOL_CLOCKWISE_OPEN_CIRCLE  = "\u21BB";
const SYMBOL_RIGHT_LEFT_ARROW       = "\u21C4";
const SYMBOL_UP_AND_DOWN_ARROW      = "\u21C5";
const SYMBOL_RIGHT_PAIR_ARROW       = "\u21C9";
const SYMBOL_CIRCLED_PLUS           = "\u2295";
const SYMBOL_WATCH                  = "\u231A";
const SYMBOL_ERASE_RIGHT            = "\u2326";
const SYMBOL_ERASE_LEFT             = "\u232B";
const SYMBOL_CIRCLE                 = "\u233E";
const SYMBOL_NOT_CHECKED            = "\u237B";

const SYMBOL_CLEAR_SCREEN           = "\u239A";
const SYMBOL_EMPTY                  = "\u23D8";
const SYMBOL_HOURGLASS              = "\u23F3";
const SYMBOL_BACKSPACE              = "\u2408";
const SYMBOL_DOUBLE_VBAR            = "\u2590\u2590";
const SYMBOL_LIGHT_SHADE            = "\u2591";
const SYMBOL_BLACK_SQUARE           = "\u25A0";
const SYMBOL_WHITE_SQUARE           = "\u25A1";
const SYMBOL_SQUARE_HFILL           = "\u25A4";
const SYMBOL_VERTICAL_RECT          = "\u25AE";
const SYMBOL_UP                     = "\u25B2";
const SYMBOL_RIGHT                  = "\u25B6";
const SYMBOL_DOWN                   = "\u25BC";
const SYMBOL_LEFT                   = "\u25C0";
const SYMBOL_BLACK_CIRCLE           = "\u25CF";
const SYMBOL_LOWER_RIGHT            = "\u25E2";
const SYMBOL_UPPER_LEFT             = "\u25E4";
const SYMBOL_LEFT_HALF_BLACK        = "\u25E7";
const SYMBOL_RIGHT_HALF_BLACK       = "\u25E8";
const SYMBOL_WHITE_MEDIUM_SQUARE    = "\u25FB";
const SYMBOL_BLACK_MEDIUM_SQUARE    = "\u25FC";
const SYMBOL_WHITE_SMALL_SQUARE     = "\u25FD";
const SYMBOL_BLACK_SMALL_SQUARE     = "\u25FE";
const SYMBOL_BLACK_SUN              = "\u2600";
const SYMBOL_CLOUD                  = "\u2601";
const SYMBOL_BALLOT_CHECK           = "\u2611";
const SYMBOL_BLACK_L_HAND           = "\u261A";
const SYMBOL_BLACK_R_HAND           = "\u261B";
const SYMBOL_LEFT_POINTING          = "\u261C";
const SYMBOL_WHITE_L_HAND           = "\u261C";
const SYMBOL_UP_POINTING            = "\u261D";
const SYMBOL_RIGHT_POINTING         = "\u261E";
const SYMBOL_DOWN_POINTING          = "\u261F";
const SYMBOL_MENU                   = "\u2630";
const SYMBOL_FROWNING_FACE          = "\u2639";
const SYMBOL_WHITE_SMILEY           = "\u263A";
const SYMBOL_BLACK_SMILEY           = "\u263B";
const SYMBOL_MOON                   = "\u263D";
const SYMBOL_RECYCLE                = "\u267B";
const SYMBOL_RELOAD                 = "\u21BB";
const SYMBOL_ANCHOR                 = "\u2693";
const SYMBOL_CROSSED_SWORDS         = "\u2694";
const SYMBOL_GEAR                   = "\u2699";
const SYMBOL_THEME                  = "\u262F";
const SYMBOL_WARNING                = "\u26A0";
const SYMBOL_WHITE_CIRCLE           = "\u26AA";
const SYMBOL_BLMED_CIRCLE           = "\u26AB";
const SYMBOL_PARTNERSHIP            = "\u26AF";
const SYMBOL_NO_ENTRY               = "\u26D4";
const SYMBOL_EURO                   = "\u20AC";
const SYMBOL_TRUCK                  = "\u26DF";
const SYMBOL_SAILBOAT               = "\u26F5";
const SYMBOL_SCISSORS               = "\u2702";
const SYMBOL_WRITING_HAND           = "\u270D";
const SYMBOL_PENCIL                 = "\u270E";
const SYMBOL_CHECK_MARK_LIGHT       = "\u2713";
const SYMBOL_CHECK_MARK             = "\u2714";
const SYMBOL_HEAVY_BALLOT           = "\u2718";
const SYMBOL_SNOWFLAKE              = "\u2744";
const SYMBOL_RIGHT_ANGLE_BRACKET    = "\u276F";
const SYMBOL_HEAVY_RIGHT_ARROW      = "\u2794";
const SYMBOL_ROUND_RIGHT_ARROW      = "\u279C";
const SYMBOL_BLACK_RIGHT_ARROW      = "\u27A1";
const SYMBOL_LEFT_CHEVRON           = "\u27EA";
const SYMBOL_RIGHT_DBL_A_BRK        = "\u27EB";
const SYMBOL_CIRCLE_ARROW           = "\u27F3";
const SYMBOL_RIGHT_WAVE_ARROW       = "\u2933";
const SYMBOL_R_CLOS_ARROW           = "\u2941";
const SYMBOL_STAR                   = "\u2B50";
const SYMBOL_LARGE_CIRCLE           = "\u2B55";

const SYMBOL_DIRECT_HIT             = "\uD83C\uDFAF";
const SYMBOL_BULB                   = "\uD83D\uDCA1";
const SYMBOL_CLIPBOARD              = "\uD83D\uDCCB";
const SYMBOL_MAILBOX                = "\uD83D\uDCEC";
const SYMBOL_MAGNIFY_LEFT           = "\uD83D\uDD0D";
const SYMBOL_MAGNIFY_RIGHT          = "\uD83D\uDD0E";
const SYMBOL_WASTEBASKET            = "\uD83D\uDDD1";
const SYMBOL_TRAFFIC_LIGHT          = "\uD83D\uDEA6";
const SYMBOL_TRAFFIC                = "\uD83D\uDEA6";
const SYMBOL_CONSTRUCTION           = "\uD83D\uDEA7";
const SYMBOL_REPLACEMENT_CHAR       = "\uFFFD";





const SYMBOL_DELETE                 = SYMBOL_ERASE_RIGHT;
const SYMBOL_EYE                    = SYMBOL_BULB;
const SYMBOL_STAGE1_INPUT           = SYMBOL_DOWN_POINTING;
const SYMBOL_STAGE2_ACTION          = SYMBOL_CIRCLE_ARROW;
const SYMBOL_STAGE3_RESULT          = SYMBOL_HEAVY_RIGHT_ARROW;
const SYMBOL_THEME_DARK_IS_OFF      = SYMBOL_BLACK_SUN;
const SYMBOL_THEME_DARK_IS_ON       = SYMBOL_MOON;
const SYMBOL_TOOLS_TIER2_OFF        = SYMBOL_RIGHT_DBL_A_BRK;
const SYMBOL_TOOLS_TIER2_ON         = SYMBOL_LEFT_CHEVRON;

const SYMBOL_WORDING_IS_OFF         = "w";
const SYMBOL_WORDING_IS_ON          = "W";
const SYMBOL_FONT_SIZE              = "Aa";
const SYMBOL_RESIZE                 = "+";

const SAL                           = "\u2190";
const SAU                           = "\u2191";
const SAR                           = "\u2192";
const SAD                           = "\u2193";

const SYN                           = "\u25CF";
const SBS                           = "\u2605";
const SHV                           = "\u26A1";

const SD1                           = "\u2460";
const SD2                           = "\u2461";
const SD3                           = "\u2462";
const SD4                           = "\u2463";
const SD5                           = "\u2464";
const SD6                           = "\u2465";
const SD7                           = "\u2466";
const SD8                           = "\u2467";
const SD9                           = "\u2468";
const SDA                           = "\u2469";
const SDB                           = "\u246A";
const SDC                           = "\u246B";
const SDD                           = "\u246C";
const SDE                           = "\u246D";
const SDF                           = "\u246E";
const SD0                           = "\u24EA";

const SDX = [ SD0 ,SD1 ,SD2 ,SD3 ,SD4 ,SD5 ,SD6 ,SD7 ,SD8 ,SD9 ,SDA ,SDB ,SDC ,SDD ,SDE ,SDF ];

const SYMBOL_E                      = "\u2026";
const SYMBOL_LF                     = "\u21B5";
const SYMBOL_U                      = "\u25B2";
const SYMBOL_R                      = "\u25B6";
const SYMBOL_D                      = "\u25BC";
const SYMBOL_L                      = "\u25C0";
const SYMBOL_CLOSEPIN               = "\u2715";
const SYMBOL_CR                     = "\u2943";
const SYMBOL_PUSH_PIN               = "\uD83D\uDCCC";
const SYMBOL_TOFU                   = "\uFFFD";





const SYMBOL_SEL                  = "<span class='sym_showing'>"+ SYMBOL_CHECK_MARK       +"</span> show";
const SYMBOL_HID                  = "<span class='sym_hiding' >"+ SYMBOL_CLEAR_SCREEN     +"</span> hide";
const SYMBOL_BAK                  = "<span class='sym_backing'>"+ SYMBOL_SQUARE_HFILL     +"</span> save";
const SYMBOL_ALT                  = "<span class='sym_alting'>" + SYMBOL_WHITE_SQUARE     +"</span> save";

const SYMBOL_COLIDE               =   "<em class='sym_colide' >"+ SYMBOL_WARNING          +"</em> SELECTED";
const SYMBOL_DISMISS              =   "<em class='sym_dismiss'>"+ SYMBOL_LEFT_RIGHT_ARROW +"</em> DISMISS" ;

const SYMBOL_CLEAR_BAK            =   "<em class='sym_backing'>"+ SYMBOL_BLACK_CIRCLE     +"</em> <em class='want cc2'>CLRBAK</em>";
const SYMBOL_CLEAR_BIN            =   "<em class='sym_binning'>"+ SYMBOL_BLACK_CIRCLE     +"</em> <em class='want cc0'>CLRBIN</em>";

const SYMBOL_UPDATE               =   "<em class='sym_update' >"+ SYMBOL_EXCLAM_QUESTION  +"</em> <em class='want cc3'>ASSIGN</em>";
const SYMBOL_STAGE                =   "<em class='sym_staged' >"+ SYMBOL_DBL_EXCLAM       +"</em> <em class='have cc6'>STAGED</em>";
const SYMBOL_RESULT               =   "<em class='sym_result' >"+ SYMBOL_CONSTRUCTION     +"</em> <em class='have cc4'>RESULT</em>";

const SYMBOL_BAGGER               =   "<em class='sym_bagger' >"+ SYMBOL_BLACK_SMILEY     +"</em>";
const SYMBOL_DOCKER               =   "<em class='sym_docker' >"+ SYMBOL_BLACK_SMILEY     +"</em>";



const SYMBOL_STICKY_FIX           = SYMBOL_HEAVY_BALLOT;
const SYMBOL_STICKY_PASTE         = SYMBOL_DOWN_ARROW;
const SYMBOL_STICKY_PEN           = SYMBOL_PENCIL;
const SYMBOL_STICKY_REFLOW        = SYMBOL_BLMED_CIRCLE;
const SYMBOL_STICKY_REFONT        = SYMBOL_FONT_SIZE;
const SYMBOL_STICKY_RESIZE        = SYMBOL_RESIZE;




const CSS_CC1                   = "cc1";
const CSS_CC2                   = "cc2";
const CSS_CC3                   = "cc3";
const CSS_CC4                   = "cc4";
const CSS_CC5                   = "cc5";
const CSS_CC6                   = "cc6";
const CSS_CC7                   = "cc7";
const CSS_CC8                   = "cc8";
const CSS_CC9                   = "cc9";
const CSS_CC0                   = "cc0";

const CCX_CLASSLIST = [
      CSS_CC1
    , CSS_CC2
    , CSS_CC3
    , CSS_CC4
    , CSS_CC5
    , CSS_CC6
    , CSS_CC7
    , CSS_CC8
    , CSS_CC9
    , CSS_CC0
];


const CSS_DBLCLICK        = "dblclick";
const CSS_LONGPRESS       = "longpress";
const CSS_MISCLICK        = "misclick";
const CSS_MISCLICK1       = "misclick1";
const CSS_MISCLICK2       = "misclick2";
const CSS_MISCLICK3       = "misclick3";

const CSS_HAS_FOCUS             = "has_focus";
const CSS_SELECTION_ENDING      = "selection_ending";
const CSS_SELECTION_PROGRESS    = "selection_progress";

const CSS_DATA_PATTERN          = "data_pattern";

const CSS_ANCHOR_BACK           = "anchor_back";
const CSS_ANCHOR_CHILD          = "anchor_child";
const CSS_ANCHOR_CLOSEST        = "anchor_closest";
const CSS_ANCHOR_DETACHED       = "anchor_detached";
const CSS_ANCHOR_LEFT           = "anchor_left";
const CSS_ANCHOR_NODE           = "anchor_node";
const CSS_ANCHOR_NOT_FOUND      = "anchor_not_found";
const CSS_ANCHOR_RIGHT          = "anchor_right";
const CSS_ANCHOR_UNSET          = "anchor_unset";

const CSS_CORNER_U_R            = "corner_u_r";
const CSS_CORNER_R_D            = "corner_r_d";
const CSS_CORNER_D_L            = "corner_d_l";
const CSS_CORNER_L_U            = "corner_l_u";

const CSS_BOTTOM                = "bottom";
const CSS_CHECKED               = "checked";
const CSS_DOC_TOOL              = "doc_tool";
const CSS_GUTTER                = "gutter";
const CSS_LEFT                  = "left";
const CSS_LINE_NUM              = "line_num";
const CSS_RIGHT                 = "right";
const CSS_SLOW_LAYOUT           = "slow_layout";
const CSS_SLOW_REGROUP          = "slow_regroup";
const CSS_STICKY_RAISED         = "sticky_raised";
const CSS_TOP                   = "top";

const CSS_EVENT_LOG             = "event_log";
const CSS_STICKY_LOG            = "sticky_log";
const CSS_SCROLLING             = "scrolling";

const CSS_MAILTO                = "mailto";
const CSS_FLY_CLIPBOARD         = "import_clipboard";

const DOM_EDITING               = "dom_editing"   ;
const EDIT_OR_STAGE             = "edit_or_stage" ;
const HOTSPOT_RADIUS            = 18;
const TOOLS_SCROLL              = "tools_scroll";



const CSS_DARK                  = "dark";

const CSS_DEFERED               = "defered";
const CSS_HIDDEN                = "hidden";
const CSS_HIDING                = "hiding";
const CSS_ON_GRID               = "on_grid";
const CSS_VIEWABLE              = "viewable";

const CSS_BORDERING             = "bordering";
const CSS_HOVERING              = "hovering";
const CSS_NEARING               = "nearing";

const CSS_COLLAPSING            = "collapsing";
const CSS_DIMMED                = "dimmed";
const CSS_DIMMED_OFF            = "dimmed_off";
const CSS_FIXED                 = "fixed";
const CSS_ON_CONTAINER          = "on_container";
const CSS_PASTE_TARGET          = "paste_target";
const CSS_PINNED                = "pinned";
const CSS_PRESSED               = "pressed";
const CSS_PULSING               = "pulsing";
const CSS_QUICK_MOVE            = "quick_move";
const CSS_RESIZE_CAP            = "resize_cap";
const CSS_RESIZING              = "resizing";
const CSS_SEEK_TARGET           = "seek_target";
const CSS_STICKY_MSG_EDIT       = "sticky_msg_edit";
const CSS_STICKY_RING           = "sticky_ring";
const CSS_TOUCHED               = "touched";
const CSS_WORK_PANEL            = "work_panel";

const CSS_TRAPPED               = "trapped";


const TOOLS_MAX                = 30;
const ZINDEX_SHADOW_HOST       = 2147483647;

const FONT_SIZE_SHADOW_HOST    = "12px";

const ZINDEX_STICKY_TOOL_ZERO  =                                          10;
const ZINDEX_PINNED_PANEL_ZERO =                                          20;
const ZINDEX_TOOL_PANEL_ZERO   = ZINDEX_PINNED_PANEL_ZERO + TOOLS_MAX;
const ZINDEX_BELOW_TOOLS       = ZINDEX_TOOL_PANEL_ZERO              ;
const ZINDEX_ABOVE_TOOLS       = ZINDEX_BELOW_TOOLS + TOOLS_MAX      ;
const ZINDEX_ON_GRID           = ZINDEX_ABOVE_TOOLS                  ;


const CSS_CAPTION_D             = "caption_D";
const CSS_CAPTION_U             = "caption_U";

const CSS_SEEKER_HANDLE         = "seeker_handle";

const CSS_SEEKER_PU2_LOOK_UP    = "seeker_PU2_look_up";
const CSS_SEEKER_PU3_LOOK_RIGHT = "seeker_PU3_look_right";
const CSS_SEEKER_PU4_LOOK_DOWN  = "seeker_PU4_look_down";
const CSS_SEEKER_PU5_LOOK_LEFT  = "seeker_PU5_look_left";

const CSS_ON_HIDDEN_NODE        = "on_hidden_node";
const CSS_STICKY_TOOL           = "sticky";




const FLOATLOG                  = "FLOATLOG";

const USER_LANG                 = "user_lang";
const DOM_FREEZE                = "dom_freeze";

const ANCHOR_FREEZE             = "anchor_freeze";
const CONTAINERS_HI             = "containers_hi";
const SCROLL_SMOOTH             = "scroll_smooth";

const FLY_DIV_MAGNIFIED         = "fly_div_magnified";
const PIVOT_MAGNIFIED           = "pivot_magnified";

const THEME_DARK                = "theme_dark"  ;

const TOOLS_TIER2               = "tools_tier2";


const TOOLS_TRAP                = "tools_trap";


const PIN_SEEKSPOT              = "pin_seekspot" ;
const SHOW_SEEKZONE             = "show_seekzone";
const LOG_SEEKSPOT              = "log_seekspot" ;

const REMOVE_ADS                = "remove_ads"   ;
const SPLIT_WOT                 = "split_wot"    ;
const LINES_WOT                 = "lines_wot"    ;

const OVERFLOW_VISI             = "overflow_visi";

const DETAILS_CLOSE             = "details_close";
const DETAILS_OPEN              = "details_open" ;
const DETAILS_RADIO             = "details_radio";


const SEL_BACK                  = "sel_back";


const WORDING                   = "wording"        ;
const WORDS_BAG_ROT             = "words_bag_rot"  ;
const WORDS_DROP_CASE           = "words_drop_case";
const WORDS_DROP_ING            = "words_drop_ing" ;
const WORDS_DROP_S              = "words_drop_s"   ;
const WORDS_EXACT               = "words_exact"    ;
const WORDS_FILTER              = "words_filter"    ;
const WORDS_HEAD_TAIL           = "words_head_tail";
const WORDS_OPCYCLE             = "words_opcycle"  ;
const WORDS_RECYCLE             = "words_recycle"  ;
const WORDS_SEGMENT             = "words_segment"  ;


const SQUEEZE_CYCLE             = "squeeze_cycle";
const SQUEEZE_CYCLE_CLASSLIST   = ["squeezed_1_0","squeezed_0_5","squeezed_0_1"];



const STICKY_TOOL_MARGIN_U = 128;
const STICKY_TOOL_MARGIN_R = 255;
const STICKY_TOOL_MARGIN_D = 128;
const STICKY_TOOL_MARGIN_L = 255;

const SCROLLBAR_WIDTH = 16;
const VIEWPORT_MARGIN =
    {     top    : 16
        , left   : 16
        , right  : 16 + SCROLLBAR_WIDTH
        , bottom : 32 + SCROLLBAR_WIDTH
    };




const DENY_OR_ALLOW         = "deny_or_allow" ;
const DOM_HIDE1_RESET       = "dom_hide1_reset";
const DOM_HIDE1_UNDO        = "dom_hide1_undo";
const MARKED_TO_HIDE        = "marked_to_hide";
const MASK_OR_HIDE          = "mask_or_hide"  ;
const SITE_OR_PAGE          = "site_or_page"  ;



const CLICK_DURATION       =                500;
const MISCLICK_TOUCH_MS    = CLICK_DURATION / 4;
const MISCLICK_MOUSE_MS    = CLICK_DURATION / 4;

const DBLCLICK_DELAY       = CLICK_DURATION;
const DBLTOUCH_DELAY       = CLICK_DURATION / 2;

const MODAL_CLICK_EARLY_MS = CLICK_DURATION * 4;

const LONG_PRESS_DURATION  = CLICK_DURATION * 2;

const DRAG_MAX_MS          = CLICK_DURATION * 2;
const DRAG_MIN_MS          = CLICK_DURATION / 4;

const T_STANDBY1_DELAY      = 1.5 * CLICK_DURATION;

const WORDS_SUFFIXES          = ["s", "ing", "case" ];
const WORDS_SUFFIXE_MIN_LEN   = { s:3      ,  ing:6 };
const WORDS_MUST_NOT_END_WITH = { s:"ss"            };

const DOC_TOOLS_ID            = "doc_tools";




    return {

        DOM_DATA_JS_ID , DOM_DATA_JS_TAG
        , DOC_TOOLS_ID
        , WORDS_SUFFIXES
        , WORDS_SUFFIXE_MIN_LEN
        , WORDS_MUST_NOT_END_WITH

        , APOS
        , DOUBLE_QUOTE
        , TAB
        , LF
        , CR



        , CCX_CLASSLIST

        , CSS_DBLCLICK
        , CSS_LONGPRESS
        , CSS_MISCLICK
        , CSS_MISCLICK1
        , CSS_MISCLICK2
        , CSS_MISCLICK3

        , CSS_HAS_FOCUS
        , CSS_SELECTION_ENDING
        , CSS_SELECTION_PROGRESS
        , CSS_DATA_PATTERN

        , CSS_ANCHOR_BACK
        , CSS_ANCHOR_CHILD
        , CSS_ANCHOR_CLOSEST
        , CSS_ANCHOR_DETACHED
        , CSS_ANCHOR_LEFT
        , CSS_ANCHOR_NODE
        , CSS_ANCHOR_NOT_FOUND
        , CSS_ANCHOR_RIGHT
        , CSS_ANCHOR_UNSET

        , CSS_CORNER_U_R
        , CSS_CORNER_R_D
        , CSS_CORNER_D_L
        , CSS_CORNER_L_U

        , CSS_BOTTOM
        , CSS_CHECKED
        , CSS_DOC_TOOL
        , CSS_GUTTER
        , CSS_LEFT
        , CSS_RIGHT
        , CSS_SLOW_LAYOUT
        , CSS_SLOW_REGROUP
        , CSS_STICKY_RAISED
        , CSS_TOP

        , CSS_EVENT_LOG
        , CSS_STICKY_LOG
        , CSS_SCROLLING

        , CSS_CAPTION_D
        , CSS_CAPTION_U
        , CSS_ON_HIDDEN_NODE
        , CSS_SEEKER_HANDLE
        , CSS_SEEKER_PU2_LOOK_UP
        , CSS_SEEKER_PU3_LOOK_RIGHT
        , CSS_SEEKER_PU4_LOOK_DOWN
        , CSS_SEEKER_PU5_LOOK_LEFT
        , CSS_STICKY_TOOL

        , CSS_LINE_NUM

        , DOM_EDITING
        , EDIT_OR_STAGE
        , HOTSPOT_RADIUS
        , TOOLS_SCROLL

        , TOOLS_MAX
        , ZINDEX_SHADOW_HOST
        , FONT_SIZE_SHADOW_HOST
        , ZINDEX_STICKY_TOOL_ZERO
        , ZINDEX_PINNED_PANEL_ZERO
        , ZINDEX_TOOL_PANEL_ZERO
        , ZINDEX_BELOW_TOOLS
        , ZINDEX_ABOVE_TOOLS
        , ZINDEX_ON_GRID




        , SAU
        , SAR
        , SAD
        , SAL

        , SHV
        , SYN
        , SBS

        , SD0
        , SD1
        , SD2
        , SD3
        , SD4
        , SD5
        , SD6
        , SD7
        , SD8
        , SD9
        , SDA
        , SDB
        , SDC
        , SDD
        , SDE
        , SDF
        , SDX


        , SYMBOL_U
        , SYMBOL_R
        , SYMBOL_D
        , SYMBOL_L
        , SYMBOL_E
        , SYMBOL_LF
        , SYMBOL_CR
        , SYMBOL_TOFU
        , SYMBOL_PUSH_PIN
        , SYMBOL_CLOSEPIN



        , SYMBOL_STICKY_FIX
        , SYMBOL_STICKY_PASTE
        , SYMBOL_STICKY_PEN
        , SYMBOL_STICKY_REFLOW
        , SYMBOL_STICKY_REFONT
        , SYMBOL_STICKY_RESIZE



        , SYMBOL_CROSSED_SWORDS
        , SYMBOL_LEFT_DBL_ANGLE
        , SYMBOL_RIGHT_DBL_ANGLE
        , SYMBOL_ERASE_LEFT
        , SYMBOL_BACKSPACE
        , SYMBOL_DELETE
        , SYMBOL_UP_POINTING
        , SYMBOL_RIGHT_POINTING
        , SYMBOL_LEFT_POINTING

        , SYMBOL_EMPTY
        , SYMBOL_FUNCTION

        , SYMBOL_BLACK_RIGHT_ARROW
        , SYMBOL_NW_ARROW
        , SYMBOL_RIGHT_PAIR_ARROW
        , SYMBOL_RIGHT_WAVE_ARROW
        , SYMBOL_ROUND_RIGHT_ARROW
        , SYMBOL_UP_LEFT_ARROW

        , SYMBOL_ANCHOR
        , SYMBOL_BLACK_SUN
        , SYMBOL_BULB
        , SYMBOL_CHECK_MARK
        , SYMBOL_CIRCLE
        , SYMBOL_CIRCLED_PLUS
        , SYMBOL_CIRCLE_ARROW
        , SYMBOL_DIRECT_HIT
        , SYMBOL_DOUBLE_VBAR
        , SYMBOL_DOWN_ARROW
        , SYMBOL_DOWN_LEFT_ARROW
        , SYMBOL_DOWN_POINTING
        , SYMBOL_ELLIPSIS
        , SYMBOL_GEAR
        , SYMBOL_THEME
        , SYMBOL_HEAVY_RIGHT_ARROW
        , SYMBOL_LEFT_ARROW
        , SYMBOL_LEFT_ARROW_HOOK
        , SYMBOL_LEFT_CHEVRON
        , SYMBOL_LOWER_RIGHT
        , SYMBOL_MENU
        , SYMBOL_MOON
        , SYMBOL_NOT_CHECKED
        , SYMBOL_NO_ENTRY
        , SYMBOL_PARAGRAPH
        , SYMBOL_RECYCLE
        , SYMBOL_RELOAD
        , SYMBOL_RIGHT_ANGLE_BRACKET
        , SYMBOL_RIGHT_ARROW
        , SYMBOL_RIGHT_ARROW_HOOK
        , SYMBOL_RIGHT_DBL_A_BRK
        , SYMBOL_RIGHT_LEFT_ARROW
        , SYMBOL_R_CLOS_ARROW
        , SYMBOL_SAILBOAT
        , SYMBOL_SECTION
        , SYMBOL_TRAFFIC_LIGHT
        , SYMBOL_UPPER_LEFT
        , SYMBOL_UP_AND_DOWN_ARROW
        , SYMBOL_UP_ARROW
        , SYMBOL_UP_DOWN_ARROW
        , SYMBOL_VERTICAL_RECT


        , SYMBOL_CLIPBOARD
        , SYMBOL_WASTEBASKET
        , SYMBOL_SCISSORS

        , SYMBOL_TOOLS_TIER2_OFF
        , SYMBOL_TOOLS_TIER2_ON

        , SYMBOL_WORDING_IS_ON
        , SYMBOL_WORDING_IS_OFF

        , SYMBOL_THEME_DARK_IS_OFF
        , SYMBOL_THEME_DARK_IS_ON

        , SYMBOL_STAGE1_INPUT
        , SYMBOL_STAGE2_ACTION
        , SYMBOL_STAGE3_RESULT

        , SYMBOL_EYE

        , SYMBOL_BLACK_SQUARE
        , SYMBOL_SQUARE_HFILL
        , SYMBOL_WHITE_SQUARE

        , SYMBOL_LEFT_HALF_BLACK
        , SYMBOL_RIGHT_HALF_BLACK
        , SYMBOL_WHITE_MEDIUM_SQUARE
        , SYMBOL_WHITE_SMALL_SQUARE
        , SYMBOL_BLACK_MEDIUM_SQUARE
        , SYMBOL_BLACK_SMALL_SQUARE

        , SYMBOL_BALLOT_CHECK
        , SYMBOL_CLEAR_SCREEN
        , SYMBOL_CLOCKWISE_OPEN_CIRCLE
        , SYMBOL_HEAVY_BALLOT
        , SYMBOL_REPLACEMENT_CHAR

        , SYMBOL_PARTNERSHIP
        , SYMBOL_WHITE_SMILEY
        , SYMBOL_BLACK_SMILEY
        , SYMBOL_FROWNING_FACE
        , SYMBOL_TRUCK
        , SYMBOL_WRITING_HAND
        , SYMBOL_BLACK_L_HAND
        , SYMBOL_BLACK_R_HAND
        , SYMBOL_WHITE_L_HAND

        , SYMBOL_DBL_EXCLAM
        , SYMBOL_EXCLAM_QUESTION
        , SYMBOL_WARNING
        , SYMBOL_LEFT_RIGHT_ARROW

        , SYMBOL_STAR
        , SYMBOL_CLOUD
        , SYMBOL_HOURGLASS
        , SYMBOL_WATCH

        , SYMBOL_BLACK_CIRCLE
        , SYMBOL_BLMED_CIRCLE
        , SYMBOL_LARGE_CIRCLE
        , SYMBOL_WHITE_CIRCLE

        , SYMBOL_UP
        , SYMBOL_RIGHT
        , SYMBOL_DOWN
        , SYMBOL_LEFT

        , SYMBOL_MAILBOX
        , SYMBOL_TRAFFIC
        , SYMBOL_MAGNIFY_LEFT
        , SYMBOL_MAGNIFY_RIGHT
        , SYMBOL_CONSTRUCTION

        , SYMBOL_SEL
        , SYMBOL_HID
        , SYMBOL_BAK
        , SYMBOL_ALT

        , SYMBOL_COLIDE
        , SYMBOL_DISMISS

        , SYMBOL_CLEAR_BAK
        , SYMBOL_CLEAR_BIN

        , SYMBOL_UPDATE
        , SYMBOL_STAGE
        , SYMBOL_RESULT

        , SYMBOL_BAGGER
        , SYMBOL_DOCKER



        , CSS_DARK

        , CSS_DEFERED
        , CSS_HIDDEN
        , CSS_HIDING
        , CSS_ON_GRID
        , CSS_VIEWABLE

        , CSS_BORDERING
        , CSS_HOVERING
        , CSS_NEARING

        , CSS_COLLAPSING
        , CSS_FIXED
        , CSS_PINNED
        , CSS_STICKY_MSG_EDIT
        , CSS_STICKY_RING
        , CSS_TOUCHED
        , CSS_WORK_PANEL

        , CSS_DIMMED
        , CSS_DIMMED_OFF
        , CSS_ON_CONTAINER
        , CSS_PASTE_TARGET
        , CSS_PRESSED
        , CSS_PULSING
        , CSS_QUICK_MOVE
        , CSS_RESIZE_CAP
        , CSS_RESIZING
        , CSS_SEEK_TARGET

        , CSS_TRAPPED

        , CSS_MAILTO
        , CSS_FLY_CLIPBOARD




        , FLOATLOG

        , DOM_FREEZE

        , USER_LANG
        , ANCHOR_FREEZE
        , CONTAINERS_HI
        , SCROLL_SMOOTH

        , FLY_DIV_MAGNIFIED
        , PIVOT_MAGNIFIED

        , THEME_DARK

        , TOOLS_TIER2


        , TOOLS_TRAP


        , PIN_SEEKSPOT
        , SHOW_SEEKZONE
        , LOG_SEEKSPOT

        , REMOVE_ADS
        , SPLIT_WOT
        , LINES_WOT

        , OVERFLOW_VISI

        , DETAILS_CLOSE
        , DETAILS_OPEN
        , DETAILS_RADIO


        , SEL_BACK


        , WORDING
        , WORDS_BAG_ROT
        , WORDS_DROP_CASE
        , WORDS_DROP_ING
        , WORDS_DROP_S
        , WORDS_EXACT
        , WORDS_FILTER
        , WORDS_HEAD_TAIL
        , WORDS_OPCYCLE
        , WORDS_RECYCLE
        , WORDS_SEGMENT


        , SQUEEZE_CYCLE
        , SQUEEZE_CYCLE_CLASSLIST


        , STICKY_TOOL_MARGIN_U
        , STICKY_TOOL_MARGIN_R
        , STICKY_TOOL_MARGIN_D
        , STICKY_TOOL_MARGIN_L


        , DENY_OR_ALLOW
        , DOM_HIDE1_RESET
        , DOM_HIDE1_UNDO
        , MARKED_TO_HIDE
        , MASK_OR_HIDE
        , SITE_OR_PAGE

        , SCROLLBAR_WIDTH
        , VIEWPORT_MARGIN


        , CLICK_DURATION
        , DBLCLICK_DELAY
        , DBLTOUCH_DELAY
        , DRAG_MAX_MS
        , DRAG_MIN_MS
        , LONG_PRESS_DURATION
        , MISCLICK_MOUSE_MS
        , MISCLICK_TOUCH_MS
        , MODAL_CLICK_EARLY_MS
        , T_STANDBY1_DELAY


    };


}());
/*INLINE}}}*/
//@ sourceURL=dom_data.js
`
 .replace(/\\/g,"\\\\")

 .replace(/%u/g,"\\u")
;

/*}}}*/

  /**   6 LOG      JS dom_log_js_data .. ESCAPE=[linear-gradient(to bottom, #555)] {{{*/
/*
../script/dom_log.js
*/
let dom_log_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/

















const DOM_LOG_JS_ID         = "dom_log_js";
const DOM_LOG_JS_TAG        = DOM_LOG_JS_ID  +" (220207:18h:58)";

let dom_log     = (function() {
"use strict";
let   DOM_LOG_LOG           = false;
let   DOM_LOG_TAG           = false;






let t_data     = {}        ;

let t_util     = {}        ;






















let t_log_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;

    t_util    = dom_util   ;























    log_INTERN();

    DOM_LOG_LOG = DOM_LOG_LOG || localStorage_getItem("DOM_LOG_LOG");
    DOM_LOG_TAG = DOM_LOG_TAG || localStorage_getItem("DOM_LOG_TAG");


if(log_this) log("%c 06 log", lbH+lf6);
};





let   L_CHK  =         "✔ ";
let   L_NEW  =         "☀ ";

let   L_ARD  =         "↓ ";
let   L_ARL  = "        ← ";
let   L_ARR  =         "→ ";
let   L_ARU  =         "↑ ";

let   L_CLR  =         "✘ ";
let   L_FNC  =         "f ";
let   L_WRN  =         "‼ ";


let add_el_class                = function( ) {  };
let del_el_class                = function( ) {  };
let get_n_lbl                   = function(n) { return (n ? n.tagName : "null_node"); };
let get_id_or_tag;
let get_id_or_tag_and_className;
let mPadStart                   = function(s) { return s; };
let mPadEnd                     = function(s) { return s; };
let strip_HTML                  = function(t) { return t; };
let strip_console_formatting    = function(t) { return t; };
let strip_pat                   = function(t) { return t; };


let   log_INTERN = function()
{


    L_ARD =                       dom_data.SYMBOL_DOWN_ARROW   +" ";
    L_ARL =         dom_data.TAB+ dom_data.SYMBOL_LEFT_ARROW   +" ";
    L_ARR =                       dom_data.SYMBOL_RIGHT_ARROW  +" ";
    L_ARU =                       dom_data.SYMBOL_UP_ARROW     +" ";

    L_CHK =                       dom_data.SYMBOL_CHECK_MARK   +" ";
    L_CLR =                       dom_data.SYMBOL_HEAVY_BALLOT +" ";
    L_FNC =                       dom_data.SYMBOL_FUNCTION     +" ";
    L_NEW =                       dom_data.SYMBOL_BLACK_SUN    +" ";
    L_WRN =                       dom_data.SYMBOL_WARNING      +" ";





    add_el_class                = t_util.add_el_class;
    del_el_class                = t_util.del_el_class;
    get_n_lbl                   = t_util.get_n_lbl;
    get_id_or_tag               = t_util.get_id_or_tag;
    get_id_or_tag_and_className = t_util.get_id_or_tag_and_className;


    mPadStart                   = t_util.mPadStart;
    mPadEnd                     = t_util.mPadEnd;
    strip_HTML                  = t_util.strip_HTML;
    strip_console_formatting    = t_util.strip_console_formatting;
    strip_pat                   = t_util.strip_pat;


};


let localStorage_setItem = function(key,val) { if(val) localStorage.setItem   (key,val); else localStorage.removeItem(key); };
let localStorage_getItem = function(key    ) { return  localStorage.getItem   (key    ); };
let localStorage_delItem = function(key    ) { localStorage.removeItem(key    ); };




let log_IMPORT = function()
{
 let d = "  defined";
    let  s;                                    let l;        let n;          let r;  let u = "undefined";

 s = (typeof dom_data    !== "undefined");  n="DATA   ";  l=s ? 5:2;  r=s ? d:u;  log("%c 05 %c"+n+"%c"+r, lfX[5], lbH+lfX[5], lfX[l]);
 s = (typeof dom_log     !== "undefined");  n="LOG    ";  l=s ? 5:2;  r=s ? d:u;  log("%c 06 %c"+n+"%c"+r, lfX[6], lbH+lfX[6], lfX[l]);
 s = (typeof dom_util    !== "undefined");  n="UTIL   ";  l=s ? 5:2;  r=s ? d:u;  log("%c 07 %c"+n+"%c"+r, lfX[7], lbH+lfX[7], lfX[l]);
 s = (typeof dom_prop    !== "undefined");  n="PROP   ";  l=s ? 5:2;  r=s ? d:u;  log("%c 08 %c"+n+"%c"+r, lfX[8], lbH+lfX[8], lfX[l]);
 s = (typeof dom_store   !== "undefined");  n="STORE  ";  l=s ? 5:2;  r=s ? d:u;  log("%c 09 %c"+n+"%c"+r, lfX[9], lbH+lfX[9], lfX[l]);
 s = (typeof dom_fly     !== "undefined");  n="FLY    ";  l=s ? 5:2;  r=s ? d:u;  log("%c 10 %c"+n+"%c"+r, lfX[0], lbH+lfX[0], lfX[l]);

 s = (typeof dom_wording !== "undefined");  n="WORDING";  l=s ? 5:2;  r=s ? d:u;  log("%c 11 %c"+n+"%c"+r, lfX[1], lbH+lfX[1], lfX[l]);
 s = (typeof dom_select  !== "undefined");  n="SELECT ";  l=s ? 5:2;  r=s ? d:u;  log("%c 12 %c"+n+"%c"+r, lfX[2], lbH+lfX[2], lfX[l]);
 s = (typeof dom_wot     !== "undefined");  n="WOT    ";  l=s ? 5:2;  r=s ? d:u;  log("%c 12 %c"+n+"%c"+r, lfX[2], lbH+lfX[2], lfX[l]);
 s = (typeof dom_slot    !== "undefined");  n="SLOT   ";  l=s ? 5:2;  r=s ? d:u;  log("%c 13 %c"+n+"%c"+r, lfX[3], lbH+lfX[3], lfX[l]);

 s = (typeof dom_hide    !== "undefined");  n="HIDE   ";  l=s ? 5:2;  r=s ? d:u;  log("%c 14 %c"+n+"%c"+r, lfX[4], lbH+lfX[4], lfX[l]);
 s = (typeof dom_view    !== "undefined");  n="VIEW   ";  l=s ? 5:2;  r=s ? d:u;  log("%c 15 %c"+n+"%c"+r, lfX[5], lbH+lfX[5], lfX[l]);
 s = (typeof dom_sticky  !== "undefined");  n="STICKY ";  l=s ? 5:2;  r=s ? d:u;  log("%c 16 %c"+n+"%c"+r, lfX[6], lbH+lfX[6], lfX[l]);
 s = (typeof dom_seek    !== "undefined");  n="SEEK   ";  l=s ? 5:2;  r=s ? d:u;  log("%c 17 %c"+n+"%c"+r, lfX[7], lbH+lfX[7], lfX[l]);
 s = (typeof dom_share   !== "undefined");  n="SHARE  ";  l=s ? 5:2;  r=s ? d:u;  log("%c 18 %c"+n+"%c"+r, lfX[8], lbH+lfX[8], lfX[l]);

 s = (typeof dom_grid    !== "undefined");  n="GRID   ";  l=s ? 5:2;  r=s ? d:u;  log("%c 19 %c"+n+"%c"+r, lfX[9], lbH+lfX[9], lfX[l]);
 s = (typeof dom_gutter  !== "undefined");  n="GUTTER ";  l=s ? 5:2;  r=s ? d:u;  log("%c 20 %c"+n+"%c"+r, lfX[0], lbH+lfX[0], lfX[l]);

 s = (typeof dom_ipc     !== "undefined");  n="IPC    ";  l=s ? 5:2;  r=s ? d:u;  log("%c 21 %c"+n+"%c"+r, lfX[1], lbH+lfX[1], lfX[l]);
 s = (typeof dom_tools   !== "undefined");  n="TOOLS  ";  l=s ? 5:2;  r=s ? d:u;  log("%c 22 %c"+n+"%c"+r, lfX[2], lbH+lfX[2], lfX[l]);

};



const dom_log_STRING
    = {   L_ARL
        , L_ARR
        , L_CHK
        , L_NEW
    };



const lbA  = "background-color:inherit;   color:inherit;";

const lbF  = "font-size:120%; font-weight:500; border:2px solid white;";
const lbb  = "font-size:150%; font-weight:100; margin:0 0 0 0;";
const lbB  = "font-size:300%; font-weight:100; margin:0 0 0 0;";
const lbS  = "font-size:500%; font-weight:100; margin:0 0 0 0;";

const lbH  = "font-weight:900; line-height:1.5em; border:1px solid gray; margin:   0 1ex 1ex   0; padding:0 .5em 0 .5em; border-radius:1em 1em 1em 1em; background:linear-gradient(to bottom, #555 0%, #223 80%, #454 100%);";
const lbL  = "font-weight:900; line-height:1.5em; border:1px solid gray; margin:   0   0   0 1ex; padding:0 .5em 0 .5em; border-radius:1em   0   0 1em; background:linear-gradient(to   left, #333 0%           ,#445 100%);";
const lbR  = "font-weight:900; line-height:1.5em; border:1px solid gray; margin:   0 1ex   0   0; padding:0 .5em 0 .5em; border-radius:  0 1em 1em   0; background:linear-gradient(to  right, #333 0%           ,#544 100%);";
const lbC  = "font-weight:900; line-height:1.5em; border:1px solid gray; margin:   0   0   0   0; padding:0 .5em 0 .5em; border-radius:  0   0   0   0;";

const lb1  = "background-color:#964B00; color:black;";
const lb2  = "background-color:#FF0000; color:black;";
const lb3  = "background-color:#FFA500; color:black;";
const lb4  = "background-color:#FFFF00; color:black;";
const lb5  = "background-color:#9ACD32; color:black;";
const lb6  = "background-color:#6495ED; color:black;";
const lb7  = "background-color:#EE82EE; color:black;";
const lb8  = "background-color:#A0A0A0; color:black;";
const lb9  = "background-color:#FFFFFF; color:black;";
const lb0  = "background-color:#000000; color:gray;";
const lbX = [ lb0 ,lb1 ,lb2 ,lb3 ,lb4 ,lb5 ,lb6 ,lb7 ,lb8 ,lb9 ];

const lf1  = "color:#964B00;";
const lf2  = "color:#FF0000;";
const lf3  = "color:#FFA500;";
const lf4  = "color:#FFFF00;";
const lf5  = "color:#9ACD32;";
const lf6  = "color:#6495ED;";
const lf7  = "color:#EE82EE;";
const lf8  = "color:#A0A0A0;";
const lf9  = "color:#FFFFFF;";
const lf0  = "color:#707070; text-shadow:#000 2px 2px 1px;";
const lfX = [ lf0 ,lf1 ,lf2 ,lf3 ,lf4 ,lf5 ,lf6 ,lf7 ,lf8 ,lf9 ];

const dom_log_CSS
    = {   LOG_BG_CSS : { lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX }
        , LOG_FG_CSS : { lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX }
        , LOG_XX_CSS : { lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           }
    };


const BACKSLASH = String.fromCharCode(92);
const FORESLASH = String.fromCharCode(47);
const LF        = String.fromCharCode(10);
const CS        = "color:#666; background:#111; border:0px solid #445; border-radius:1em;";

const dom_log_CHAR
    = {   BACKSLASH
        , FORESLASH
        , LF
        , CS
    };



const console_clear = function(  msg=null) { console.clear(); if(msg) console.log ("%c.. by "+msg,CS);                   };
const console_dir   = function(a1,a2=null) {
    let o   = (a2) ? a2 : a1;
    let msg = (a2) ? a1 : null;
    if( msg )
        console.log ("%c"+msg+":",CS);
    console.dir  (o);
};
const console_table = function(o,msg=null) {                  if(msg) console.log ("%c"+msg+":"  ,CS); console.table(o); };
const console_log   = function(  msg     ) {                          console.log (     msg         );                   };
const console_warn  = function(  msg=null) {                          console.warn(     msg         );                   };

const CONSOLE_CLEAR_COOLDOWN_DELAY = 1000;

let console_clear_cooldown_timeout;

let console_clear_post = function(msg=null)
{
    if( console_clear_cooldown_timeout )
    {
        log("%c CONSOLE CLEARED BY "+msg+" %c LOG PRESERVED FOR "+CONSOLE_CLEAR_COOLDOWN_DELAY+"ms", lbb+lbH+lf8, lbb+lbH+lf9);
    }
    else {
        log();
        console_clear( msg );
        console_clear_cooldown_timeout
            = setTimeout( function() { console_clear_cooldown_timeout = null; }
                        , CONSOLE_CLEAR_COOLDOWN_DELAY);
    }
};

const dom_log_console
    = {   console_clear
        , console_clear_post
        , console_dir
        , console_log
        , console_table
        , console_warn
    };



let logSD0 = function(          format, ...args) { _logSD(dom_data.SD0, lf0, format, ...args); };
let logSD1 = function(          format, ...args) { _logSD(dom_data.SD1, lf1, format, ...args); };
let logSD2 = function(          format, ...args) { _logSD(dom_data.SD2, lf2, format, ...args); };
let logSD3 = function(          format, ...args) { _logSD(dom_data.SD3, lf3, format, ...args); };
let logSD4 = function(          format, ...args) { _logSD(dom_data.SD4, lf4, format, ...args); };
let logSD5 = function(          format, ...args) { _logSD(dom_data.SD5, lf5, format, ...args); };
let logSD6 = function(          format, ...args) { _logSD(dom_data.SD6, lf6, format, ...args); };
let logSD7 = function(          format, ...args) { _logSD(dom_data.SD7, lf7, format, ...args); };
let logSD8 = function(          format, ...args) { _logSD(dom_data.SD8, lf8, format, ...args); };
let logSD9 = function(          format, ...args) { _logSD(dom_data.SD9, lf9, format, ...args); };
let _logSD = function(sym, lfx, format, ...args) { console.log("%c "+sym+"%c"+format, lbS+lfx, lbA, ...args); };

const dom_log_SYM_DIGIT
    = {   logSD0
        , logSD1
        , logSD2
        , logSD3
        , logSD4
        , logSD5
        , logSD6
        , logSD7
        , logSD8
        , logSD9
    };




let log_caller = function(level_max)
{
    let stack_trace = get_callers( level_max );

    if( stack_trace.includes(LF) ) console.log("%c"+stack_trace.replace(LF,"%c"+LF), lbH+lf6, lf8);
    else                         { console.log("%c"+stack_trace                    , lf6+lbF     ); console.trace(); }
};
let get_callers = function(level_max)
{
    let xx, ex_stack;
    try {   xx.raise(); } catch(ex) { ex_stack = parse_ex_stack_FUNC_FILE_LINE_COL(ex.stack, level_max); }
    return  ex_stack;
};





let parse_ex_stack_FUNC_FILE_LINE_COL = function(text, level_max=10)
{
    let  result = "";
    let   lines = text.split(LF);
    let     sym = L_ARL;
    let line_match;
    for(let i=2; i<=(2+level_max); ++i)
    {
        if( String(lines[i]).includes("at log_caller") ) continue;

        if( line_match = get_ex_stack_line_match(lines[i]) )
            result    += (result ? LF : "") + sym+" "+line_match;
        sym = L_ARU;
    }

    if( !result.includes(LF) ) result += LF + sym +" ... (async)";

    return result;
};



const regexp_FUNC_FILE_LINE_COL = new RegExp("\\s*at\\s*([^\\(]+)\\s+\\((?:[^\\/]*\\/)*(\..+?):(\\d+?):(\\d+?)");


let get_ex_stack_line_match = function(ex_stack_line)
{
    let matches = regexp_FUNC_FILE_LINE_COL.exec(ex_stack_line);

    if(!matches ) return "";

    let func = matches[1].replace("Object.","");
    let file = matches[2];
    let line = matches[3];
    let col  = matches[4];
    let match= mPadStart(func, 48)+".. "+file+" "+line+":"+col;


    return match;
};




const LOG_MAP = {

    EV0_LISTEN     : false,
    EV1_DOWN       : false,
    EV2_MOVE       : false,
    EV3_UP         : false,
    EV4_LONG_PRESS : false,
    EV5_TOOL_CB    : false,
    EV6_CHANGED    : false,
    EV7_DISPATCH   : false,
    EV8_FLOATLOG   : false,

    S0_PATTERN     : false,
    S1_RANGE       : false,
    S2_SELECT      : false,
    S3_SLOT        : false,
    T0_STORE       : false,

    T1_DOM_LOAD    : false,
    T2_GRID        : false,
    T3_LAYOUT      : false,
    T4_PIVOT       : false,
    T5_SPREAD      : false,
    T6_SLOT        : false,
    T7_SHARE       : false,
    T8_TOOLBAR     : false,

    IPC_LOG        : false

   };


let logging_load_LOG_MAP = function()
{
    if(typeof dom_store   === "undefined") return;

let get = dom_store.t_store_getBool;

    LOG_MAP.EV0_LISTEN     = get( "EV0_LISTEN"     );
    LOG_MAP.EV1_DOWN       = get( "EV1_DOWN"       );
    LOG_MAP.EV2_MOVE       = get( "EV2_MOVE"       );
    LOG_MAP.EV3_UP         = get( "EV3_UP"         );
    LOG_MAP.EV4_LONG_PRESS = get( "EV4_LONG_PRESS" );
    LOG_MAP.EV5_TOOL_CB    = get( "EV5_TOOL_CB"    );
    LOG_MAP.EV6_CHANGED    = get( "EV6_CHANGED"    );
    LOG_MAP.EV7_DISPATCH   = get( "EV7_DISPATCH"   );
    LOG_MAP.EV8_FLOATLOG   = get( "EV8_FLOATLOG"   );

    LOG_MAP.S0_PATTERN     = get( "S0_PATTERN"     );
    LOG_MAP.S1_RANGE       = get( "S1_RANGE"       );
    LOG_MAP.S2_SELECT      = get( "S2_SELECT"      );
    LOG_MAP.S3_SLOT        = get( "S3_SLOT"        );

    LOG_MAP.T0_STORE       = get( "T0_STORE"       );
    LOG_MAP.T1_DOM_LOAD    = get( "T1_DOM_LOAD"    );
    LOG_MAP.T2_GRID        = get( "T2_GRID"        );
    LOG_MAP.T3_LAYOUT      = get( "T3_LAYOUT"      );
    LOG_MAP.T4_PIVOT       = get( "T4_PIVOT"       );
    LOG_MAP.T5_SPREAD      = get( "T5_SPREAD"      );
    LOG_MAP.T6_SLOT        = get( "T6_SLOT"        );
    LOG_MAP.T7_SHARE       = get( "T7_SHARE"       );
    LOG_MAP.T8_TOOLBAR     = get( "T8_TOOLBAR"     );

    LOG_MAP.IPC_LOG        = get( "IPC_LOG"        );
};


let logging_toggle = function(keyword)
{
let caller = "logging_toggle("+keyword+")";
log(caller);

    if(typeof dom_store  === "undefined") return false;

    let changed = ""; let set = dom_store.t_store_set_state;

    switch( keyword ) {

        case "EV0_LISTEN"      : LOG_MAP.EV0_LISTEN     = !LOG_MAP.EV0_LISTEN     ; set("EV0_LISTEN"         , LOG_MAP.EV0_LISTEN     ); changed = keyword+"="+LOG_MAP.EV0_LISTEN    ; break;
        case "EV1_DOWN"        : LOG_MAP.EV1_DOWN       = !LOG_MAP.EV1_DOWN       ; set("EV1_DOWN"           , LOG_MAP.EV1_DOWN       ); changed = keyword+"="+LOG_MAP.EV1_DOWN      ; break;
        case "EV2_MOVE"        : LOG_MAP.EV2_MOVE       = !LOG_MAP.EV2_MOVE       ; set("EV2_MOVE"           , LOG_MAP.EV2_MOVE       ); changed = keyword+"="+LOG_MAP.EV2_MOVE      ; break;
        case "EV3_UP"          : LOG_MAP.EV3_UP         = !LOG_MAP.EV3_UP         ; set("EV3_UP"             , LOG_MAP.EV3_UP         ); changed = keyword+"="+LOG_MAP.EV3_UP        ; break;
        case "EV4_LONG_PRESS"  : LOG_MAP.EV4_LONG_PRESS = !LOG_MAP.EV4_LONG_PRESS ; set("EV4_LONG_PRESS"     , LOG_MAP.EV4_LONG_PRESS ); changed = keyword+"="+LOG_MAP.EV4_LONG_PRESS; break;
        case "EV5_TOOL_CB"     : LOG_MAP.EV5_TOOL_CB    = !LOG_MAP.EV5_TOOL_CB    ; set("EV5_TOOL_CB"        , LOG_MAP.EV5_TOOL_CB    ); changed = keyword+"="+LOG_MAP.EV5_TOOL_CB   ; break;
        case "EV6_CHANGED"     : LOG_MAP.EV6_CHANGED    = !LOG_MAP.EV6_CHANGED    ; set("EV6_CHANGED"        , LOG_MAP.EV6_CHANGED    ); changed = keyword+"="+LOG_MAP.EV6_CHANGED   ; break;
        case "EV7_DISPATCH"    : LOG_MAP.EV7_DISPATCH   = !LOG_MAP.EV7_DISPATCH   ; set("EV7_DISPATCH"       , LOG_MAP.EV7_DISPATCH   ); changed = keyword+"="+LOG_MAP.EV7_DISPATCH  ; break;
        case "EV8_FLOATLOG"    : LOG_MAP.EV8_FLOATLOG   = !LOG_MAP.EV8_FLOATLOG   ; set("EV8_FLOATLOG"       , LOG_MAP.EV8_FLOATLOG   ); changed = keyword+"="+LOG_MAP.EV8_FLOATLOG  ; break;


        case "S0_PATTERN"      : LOG_MAP.S0_PATTERN     = !LOG_MAP.S0_PATTERN     ; set("S0_PATTERN"         , LOG_MAP.S0_PATTERN     ); changed = keyword+"="+LOG_MAP.S0_PATTERN    ; break;
        case "S1_RANGE"        : LOG_MAP.S1_RANGE       = !LOG_MAP.S1_RANGE       ; set("S1_RANGE"           , LOG_MAP.S1_RANGE       ); changed = keyword+"="+LOG_MAP.S1_RANGE      ; break;
        case "S2_SELECT"       : LOG_MAP.S2_SELECT      = !LOG_MAP.S2_SELECT      ; set("S2_SELECT"          , LOG_MAP.S2_SELECT      ); changed = keyword+"="+LOG_MAP.S2_SELECT     ; break;
        case "S3_SLOT"         : LOG_MAP.S3_SLOT        = !LOG_MAP.S3_SLOT        ; set("S3_SLOT"            , LOG_MAP.S3_SLOT        ); changed = keyword+"="+LOG_MAP.S3_SLOT       ; break;


        case "T0_STORE"        : LOG_MAP.T0_STORE       = !LOG_MAP.T0_STORE       ; set("T0_STORE"           , LOG_MAP.T0_STORE       ); changed = keyword+"="+LOG_MAP.T0_STORE      ; break;
        case "T1_DOM_LOAD"     : LOG_MAP.T1_DOM_LOAD    = !LOG_MAP.T1_DOM_LOAD    ; set("T1_DOM_LOAD"        , LOG_MAP.T1_DOM_LOAD    ); changed = keyword+"="+LOG_MAP.T1_DOM_LOAD   ; break;
        case "T2_GRID"         : LOG_MAP.T2_GRID        = !LOG_MAP.T2_GRID        ; set("T2_GRID"            , LOG_MAP.T2_GRID        ); changed = keyword+"="+LOG_MAP.T2_GRID       ; break;
        case "T3_LAYOUT"       : LOG_MAP.T3_LAYOUT      = !LOG_MAP.T3_LAYOUT      ; set("T3_LAYOUT"          , LOG_MAP.T3_LAYOUT      ); changed = keyword+"="+LOG_MAP.T3_LAYOUT     ; break;
        case "T4_PIVOT"        : LOG_MAP.T4_PIVOT       = !LOG_MAP.T4_PIVOT       ; set("T4_PIVOT"           , LOG_MAP.T4_PIVOT       ); changed = keyword+"="+LOG_MAP.T4_PIVOT      ; break;
        case "T5_SPREAD"       : LOG_MAP.T5_SPREAD      = !LOG_MAP.T5_SPREAD      ; set("T5_SPREAD"          , LOG_MAP.T5_SPREAD      ); changed = keyword+"="+LOG_MAP.T5_SPREAD     ; break;
        case "T6_SLOT"         : LOG_MAP.T6_SLOT        = !LOG_MAP.T6_SLOT        ; set("T6_SLOT"            , LOG_MAP.T6_SLOT        ); changed = keyword+"="+LOG_MAP.T6_SLOT       ; break;
        case "T7_SHARE"        : LOG_MAP.T7_SHARE       = !LOG_MAP.T7_SHARE       ; set("T7_SHARE"           , LOG_MAP.T7_SHARE       ); changed = keyword+"="+LOG_MAP.T7_SHARE      ; break;
        case "T8_TOOLBAR"      : LOG_MAP.T8_TOOLBAR     = !LOG_MAP.T8_TOOLBAR     ; set("T8_TOOLBAR"         , LOG_MAP.T8_TOOLBAR     ); changed = keyword+"="+LOG_MAP.T8_TOOLBAR    ; break;


        case "IPC_LOG"         : LOG_MAP.IPC_LOG        = !LOG_MAP.IPC_LOG        ; set("IPC_LOG"            , LOG_MAP.IPC_LOG        ); changed = keyword+"="+LOG_MAP.IPC_LOG       ; break;
    }

log_TR_LAYOUT_add("<em class='big'>TOGGLE LOGGING ["+ keyword +"] changed=["+changed+"]</em>");
    return changed;
};


let logging_something = function()
{


    return  LOG_MAP.EV0_LISTEN
        ||  LOG_MAP.EV1_DOWN
        ||  LOG_MAP.EV2_MOVE
        ||  LOG_MAP.EV3_UP
        ||  LOG_MAP.EV4_LONG_PRESS
        ||  LOG_MAP.EV5_TOOL_CB
        ||  LOG_MAP.EV6_CHANGED
        ||  LOG_MAP.EV7_DISPATCH




        ||  LOG_MAP.S1_RANGE
        ||  LOG_MAP.S2_SELECT
        ||  LOG_MAP.S3_SLOT



        ||  LOG_MAP.T1_DOM_LOAD
        ||  LOG_MAP.T2_GRID
        ||  LOG_MAP.T3_LAYOUT
        ||  LOG_MAP.T4_PIVOT
        ||  LOG_MAP.T5_SPREAD
        ||  LOG_MAP.T6_SLOT
        ||  LOG_MAP.T7_SHARE
        ||  LOG_MAP.T8_TOOLBAR

        ||  LOG_MAP.IPC_LOG
    ;
};


const dom_LOG_MAP
    = {   LOG_MAP

        , logging_load_LOG_MAP
        , logging_toggle
        , logging_something
    };



const LF_HEAD = LF+"    ";
let log_key_val       = function(name, o, lxx       ) { return log_key_val_group(name, o, lxx, false); };
let log_key_val_group = function(name, o, lfx=7, group=true)
{
    let lxx = (typeof lfx == "number")
        ?         lfX[lfx]
        :             lfx;

    if(!o) {
        log(name+": %c null object ", (lxx || lb0));
        return "";
    }



    name = mPadEnd(name, 60);
    if(group) console.groupCollapsed("  %c"+ name+" ...", ((lbH+lxx) || lb0));
    else      console.log           ("  %c"+ name       , ((lbH+lxx) || lb0));

    let result = "";

    if( Array.isArray(o) )
    {
        console.table(o);

        Array.from(o).forEach(
                              (value,index) => {
                                  result += (index ? LF:"")
                                      +      index +" .. "
                                      +((value.key && value.val)
                                        ?    "{ key:"+mPadEnd(value.key,32)
                                        +    ", val:"+value.val
                                        +    "}"
                                        :    value.toString()
                                       );
                              });
    }
    else {

        let n = 1;
        Object.keys(o).forEach(
                                function(key) {
                                    let   val = o[key];
                                    let   lfv = lf2;
                                    try { lfv =        (val          ==  null        ) ?     lb0
                                              :        (val          ==  undefined   ) ?     lb0
                                              :        (val          ==  "null_node" ) ?     lb0
                                              :        (val          ==  "NO"        ) ?     lf3
                                              :        (val          ==  "[]"        ) ?     lf3
                                              :        (val          ==  false       ) ?     lf2
                                              :        (val          ==  true        ) ?     lb5
                                              :        (typeof val   == "object"     ) ?     lf3
                                              :  String(val).startsWith( L_NEW       ) ? lbH+lf9
                                              :  String(val).startsWith( L_CHK       ) ?     lf8
                                              :  String(val).includes  ( LF          ) ? lbF+lf5
                                              :  String(val).includes  ( " "         ) ? lbH+lf5
                                              :                                              lf4
                                        ;
                                    } catch(ex) { val = LF+ex.message; lfv = lbb+lb2; }

                                    let ovf = log_object_val_format(val, lxx);

                                    let lfo = ovf.includes("%c") ? lxx : " ";

                                    log(     " %c|||%c "+mPadStart(   key, 36) +" %c"+ovf
                                             , lb0 ,(lxx || lb0)                ,lfv ,lfo);

                                    result +=   "||| "  +             key      +" <em class='cc"+(++n)+"'>"+ ovf   +"</em><br>"+LF       ;
                                }
                              );
    }
    if(group) console.groupEnd();
    return result;
};



const TEXT_LENGTH_MAX = 96;
const regexp_LF = new RegExp("\\n", "g");


let log_object_val_format = function(val,lxx)
{
    let text;
    try    { text = String(val); } catch(ex)         { text = LF+ex.message; }
    if     (                                   !text ) text = "[]";

    if(       text.includes(        L_ARU           )) text = text.replace(L_ARU, " %c");
    if(      !text.includes(        LF              )
         &&   text.length > TEXT_LENGTH_MAX          ) text = t_util.ellipsis(text, TEXT_LENGTH_MAX);

    if     (               val instanceof HTMLElement) text = get_id_or_tag_and_className(val);
    else if( Array.isArray(val)                      ) text = "ARRAY["+val.length+"] "+  t_util.ellipsis(val.toString().replace(/,/g," _ "), TEXT_LENGTH_MAX);
    else if(        typeof val   == "object"         ) text = log_json(val, lxx);
    else if(        typeof val   == "function"       ) text = L_FNC +" "+ (val.name || "anonymous");
    else if(  text.includes(        LF              )) text = L_ARD+LF+text.replace(regexp_LF, LF);

    return    text;
};



const regexp_BRACES = new RegExp("^{|}$"                    , "g");
const regexp_BSLASH = new RegExp("\\\\"                     , "g");
const regexp_COMMA  = new RegExp(" *, *"                    , "g");
const regexp_QUOTE  = new RegExp("[\\u0022\\u0027]"         , "g");
const regexp_URL_64 = new RegExp('"url":"([^"]{1,64})[^"]*"', "g");


let log_json = function(val,lxx)
{
    if(val == null     ) return "null";
    if(val == undefined) return "undefined";
    if(val.id          ) return "#"+val.id+(val.className ? ("."+val.className.replace(/ /g,".")) : "");
    if(val.tagName     ) return     val.tagName;

    let result = "";
    try {
        result
            = JSON.stringify(val);

        if( result.length > 64)
            result
                = result
                .   replace(regexp_URL_64, '"url":"$1..."')
        ;
        result
            = result
            . replace(regexp_BRACES , "")
            . replace(regexp_QUOTE  , "")
            . replace(regexp_BSLASH , "")
            . trim()
        ;

        result
            = (". "+result)
            .  replace(regexp_COMMA    ,        LF_HEAD+". ")
        ;

        result
            = result
            .  replace(/\. *([^:]*):{/g, ".$1:"+LF_HEAD+". ")
            .  replace(/}/g            , ""                 )
        ;

        result
            =(LF_HEAD+ result)
            .  replace(/^( *\. *)([^:]*):(.*)$/gm, mpad)
        ;

        result
            = LF_HEAD+"┌───────────────────────────────────┐"
            +          result
            + LF_HEAD+"└───────────────────────────────────┘"
        ;

    } catch(ex) { result = LF+ex.message; }

    if( lxx )
        result = "%c"+ result;

    return result;
};

let mpad = function(match, p1, p2, p3, offset, string)
{
    return mPadStart(p1+p2,39) +" : "+ p3;
};



let log_json_one_liner = function(val)
{
    if(val == null     ) return "null";
    if(val == undefined) return "undefined";
    if(val.id          ) return "#"+val.id;
    if(val.tagName     ) return     val.tagName;

    let result = JSON.stringify(val)
        .        replace(regexp_URL_64 , '"url":"$1..."')
        .        replace(regexp_BRACES , "")
        .        replace(regexp_QUOTE  , "")
        .        replace(regexp_BSLASH , "")
        .        trim();

    result = result.replace(regexp_COMMA, " .. ");

    return result;
};





const STYLE_TOP = "font-weight:900; border:0px #000 solid; border-radius:2em 2em .1em .1em; padding:  0 1em 1em 2em; overflow:visible;";
const STYLE_BOT = "color:#FFF;      border:0px #000 solid; border-radius:.1em .1em 2em 2em; padding:1em 1em 0em 2em; overflow:visible;";
const STYLE_ERR = "color:#F00; font-size:200%; font-weight:900; background-color:#400; border:1px #F00 solid; border-radius:1em; padding:.1em; overflow:visible;";

const STYLE_BG_TOP=[];
      STYLE_BG_TOP [1] = " background:linear-gradient(to bottom, #964B0080 0%, #2222 100%);";
      STYLE_BG_TOP [2] = " background:linear-gradient(to bottom, #FF000080 0%, #2222 100%);";
      STYLE_BG_TOP [3] = " background:linear-gradient(to bottom, #FFA50080 0%, #2222 100%);";
      STYLE_BG_TOP [4] = " background:linear-gradient(to bottom, #FFFF0080 0%, #2222 100%);";
      STYLE_BG_TOP [5] = " background:linear-gradient(to bottom, #9ACD3280 0%, #2222 100%);";
      STYLE_BG_TOP [6] = " background:linear-gradient(to bottom, #6495ED80 0%, #2222 100%);";
      STYLE_BG_TOP [7] = " background:linear-gradient(to bottom, #EE82EE80 0%, #2222 100%);";
      STYLE_BG_TOP [8] = " background:linear-gradient(to bottom, #A0A0A080 0%, #2222 100%);";
      STYLE_BG_TOP [9] = " background:linear-gradient(to bottom, #FFFFFF80 0%, #2222 100%);";
      STYLE_BG_TOP [0] = " background:linear-gradient(to bottom, #00000080 0%, #2222 100%);";

const STYLE_BG_BOT=[];
      STYLE_BG_BOT [1] = " background:linear-gradient(to    top, #964B0080 0%, #2222 100%);";
      STYLE_BG_BOT [2] = " background:linear-gradient(to    top, #FF000080 0%, #2222 100%);";
      STYLE_BG_BOT [3] = " background:linear-gradient(to    top, #FFA50080 0%, #2222 100%);";
      STYLE_BG_BOT [4] = " background:linear-gradient(to    top, #FFFF0080 0%, #2222 100%);";
      STYLE_BG_BOT [5] = " background:linear-gradient(to    top, #9ACD3280 0%, #2222 100%);";
      STYLE_BG_BOT [6] = " background:linear-gradient(to    top, #6495ED80 0%, #2222 100%);";
      STYLE_BG_BOT [7] = " background:linear-gradient(to    top, #EE82EE80 0%, #2222 100%);";
      STYLE_BG_BOT [8] = " background:linear-gradient(to    top, #A0A0A080 0%, #2222 100%);";
      STYLE_BG_BOT [9] = " background:linear-gradient(to    top, #FFFFFF80 0%, #2222 100%);";
      STYLE_BG_BOT [0] = " background:linear-gradient(to    top, #00000080 0%, #2222 100%);";


const SLC = "\u2B55";
const SDO = [
 SLC
,SLC
,SLC+SLC
,SLC+SLC+SLC
,SLC+SLC+SLC+SLC
,SLC+SLC+SLC+SLC+SLC
,SLC+SLC+SLC+SLC+SLC+SLC
,SLC+SLC+SLC+SLC+SLC+SLC+SLC
,SLC+SLC+SLC+SLC+SLC+SLC+SLC+SLC
,SLC+SLC+SLC+SLC+SLC+SLC+SLC+SLC+SLC
];

let log_NUM = 0;




const LOG_MAX     = 50000;
const CLEAR       = "DEFAULT_TO_CLEAR";

let   log_HTML    =  "";
let   log_is_full = false;

let log = function(first_arg, ...args)
{
if(DOM_LOG_LOG || DOM_LOG_TAG) log_caller();

    if     (!first_arg                        ) first_arg = CLEAR;


    else if( first_arg instanceof HTMLElement ) {
        console.log("%c"+get_id_or_tag_and_className(first_arg),lbH+lf9);
        return;
    }





    let log_msg = !first_arg ? CLEAR : String(first_arg).trim();




    let log_level
        =   log_is_full              ? "warn"
        : (!log_HTML && args.length) ? args[0]

        :                              "log"
    ;




    if(    (log_msg != CLEAR)
        && ((typeof console) != "undefined")
    ) {


        switch(log_level) {
            default              : console.log            .apply(console, Array.prototype.slice.call(arguments)); break;

            case "error"         : console.error          .apply(console, Array.prototype.slice.call(arguments)); break;
            case "warn"          : console.warn           .apply(console, Array.prototype.slice.call(arguments)); break;
            case "info"          : console.info           .apply(console, Array.prototype.slice.call(arguments)); break;

            case "time"          : console.time           .apply(console, "selection"                          ); break;
            case "timeEnd"       : console.timeEnd        .apply(console, "selection"                          ); break;
            case "groupEnd"      : console.groupEnd       .apply(console                                       ); break;
            case "group"         : console.group          .apply(console, Array.prototype.slice.call(arguments)); break;
            case "groupCollapsed": console.groupCollapsed .apply(console, Array.prototype.slice.call(arguments)); break;

        }
    }


    if(log_msg == CLEAR) {
        if(log_is_full) {
            if((typeof console) != "undefined") console.warn("log_is_full");
            log_is_full = false;
        }
        log_HTML = "";
    }


    else {
        log_HTML += LF+ strip_pat(log_msg,"%c\\log_msg*");
    }


    if(log_HTML.length > LOG_MAX)
    {

        if(!log_is_full ) {
            log_is_full = true;
            if((typeof console) != "undefined") console.error("log_is_full: ...LOG_MAX=["+LOG_MAX+"]");
            if(DOM_LOG_LOG) debugger;
        }
        return;
    }

};



const LOG_WARN_COOLDOWN_DELAY = 2000;
const LOG_WARN_DIV            = "log_warn_div";
let   log_warn_timer;
let   log_warn_div;


let log_warn = function(caller, msg)
{
    console.warn("log_warn from %c"+caller+"%c .. %c"+strip_HTML(msg), lbH+lf5, lbA, lbH+lbb+lf4);

    if(!log_warn_div) {
        let parent = document.body;
        if(!parent ) return;

        log_warn_div                          = document.createElement("DIV");
        log_warn_div.id                       = LOG_WARN_DIV;
        log_warn_div.className                = "big box_panel";
        log_warn_div.style.position           = "absolute";
        log_warn_div.style.background         = "rgba(191,191,191,0.9)";
        log_warn_div.style.transitionDuration = "250ms";
        parent.insertBefore(log_warn_div, parent.firstChild);
    }


    log_warn_div.innerHTML                    = msg;
    log_warn_div.style.top                    = "0px";
    log_warn_div.style.left                   = "0px";



    if(log_warn_timer) clearTimeout(log_warn_timer);
    log_warn_timer   =   setTimeout(log_warn_handler, LOG_WARN_COOLDOWN_DELAY);


};

let log_warn_handler = function()
{
    log_warn_timer = null;
    log_warn_div.style.top  = (-2 * log_warn_div.offsetHeight)+"px"  ;
};


let logBIG = function(msg, lfx=lf7)
{
    let lxx = (typeof lfx == "number")
        ?         lbb+lbH+lfX[lfx]
        :                     lfx;

    console.log("%c "+L_NEW+" %c "+msg, lbb+lbH+lf9, lxx);
};



let logXXX_start_MS;


let logXXX = function()
{


    if((typeof dom_tools) != "undefined")
    {
        let onDown_MS = dom_tools.t_get_onDown_MS();
        let start_MS
            = (logXXX_start_MS > onDown_MS)
            ?  logXXX_start_MS
            :  onDown_MS;

        logXXX_start_MS = new Date().getTime();

        let elapsed_MS
            = start_MS
            ? (logXXX_start_MS - start_MS)
            : 0;



        arguments[0] = "XXX ["+elapsed_MS+"] "+arguments[0];
    }
    else {
        arguments[0] = "XXX "                 +arguments[0];
    }

    console.log.apply(console, Array.prototype.slice.call(arguments));
};



let log_TOP = function(arg_line, lfx)
{

    if(!arg_line) arg_line = "";
    let num = (lfx  != undefined) ? lfX.indexOf(lfx) : -1;


    if( num < 0)
    {
        log_NUM  = (log_NUM+1) % 10;
        num          = log_NUM;
    }


    let l_1 =       lbB +          lfX[num];
    let l_2 = STYLE_TOP + STYLE_BG_TOP[num];
    let sym =                      SDO[num];
    let txt =               strip_HTML(arg_line);

    console.groupCollapsed( "%c"+sym +"%c "+txt,l_1,l_2);
};


let log_BOT = function(arg_line, lfx)
{
    if(!arg_line) arg_line = "";
    let num = (lfx  != undefined) ? lfX.indexOf(lfx) : -1;
    if( num < 0) {
        num          = log_NUM;
    }

    let l_1 =       lbB +          lfX[num];
    let l_2 = STYLE_BOT + STYLE_BG_BOT[num];
    let sym =                      SDO[num];
    let txt =               strip_HTML(arg_line);

    console.groupEnd();
    console.log(            "%c"+sym +"%c "+txt,l_1 ,l_2);

    log_NUM = (log_NUM <= 0) ? 0 : ((log_NUM-1) % 10);
};


let log_CLR = function()
{
    while(log_NUM > 0) log_BOT( L_CLR );

    log( CLEAR );
};


let log_ERR = function(arg_line="")
{
    if(log_NUM > 0) log_CLR();

    console.groupEnd();
    console.groupEnd();
    console.groupEnd();
    console.groupEnd();
    console.groupEnd();

    let l_1 = lbB + lfX[2];
    let sym = L_WRN;
    let txt = strip_HTML(arg_line);
    console.log("%c"+sym+" %c "+txt+" ",l_1,STYLE_ERR);
};



let log_clear = function(caller)
{
    if((typeof dom_tools) !== "undefined")
        dom_tools.t_clear("log_clear(caller=["+caller+"])");
};


let get_log_is_full = function()
{
    return log_is_full;
};


let get_log_HTML    = function()
{
    return strip_console_formatting( log_HTML );
};


const dom_log_log
    = {   log
        , log_warn
        , logBIG
        , logXXX

        , log_TOP
        , log_BOT
        , log_CLR
        , log_ERR

        , log_clear
        , get_log_is_full
        , get_log_HTML
    };



let log_label_URDL = function(label, urdl)
{
    let { panel, u,r,d,l, x,y, w,h, near_x_min,near_y_min , near_x_max,near_y_max } = (urdl || {});

    let l_u = u ? lb2 : lf8;
    let l_r = r ? lb3 : lf8;
    let l_d = d ? lb4 : lf8;
    let l_l = l ? lb5 : lf8;

    if(!panel) {
        log("%c"+label+"%c U %c R %c D %c L"
            ,lbH       ,l_u ,l_r ,l_d ,l_l  );
    }
    else {
        let  l_x
            = (x <= near_x_min) ? lbR
            : (x >= near_x_max) ? lbL
            :                     lbH;

        let  l_y
            = (y <= near_y_min) ? lbR
            : (y >= near_y_max) ? lbL
            :                     lbH;


        let pid = get_id_or_tag(panel);

        log(  "%c"+label+"%c"+pid+"%c u %c r %c d %c l"
              +                                    "%c WH=%c"+w+".."+h
              +                                                       "%c  X=%c"+near_x_min+" < "+x+" < "+near_x_max
              +                                                       "%c  Y=%c"+near_y_min+" < "+y+" < "+near_y_max
              ,lbH       ,lbH+lf0 ,l_u ,l_r ,l_d ,l_l
              ,                                     lbA  ,lbH+lf8
              ,                                                        lbA  ,l_x+lf6
              ,                                                        lbA  ,l_y+lf7
           );
    }
};


let log_anchor_step = function(sticky, step, msg, anchor_from, anchor_to)
{

    let from =  t_util.get_node_path_tail( anchor_from);
    let   to = (anchor_to && (anchor_to != anchor_from))
        ?       t_util.get_node_path_tail( anchor_to  )
        :       null;

    let sdx     = t_data.SDX[ step    % 10];
    let lf_step =        lfX[ step    % 10];
    let lf_msg  = to   ?            lf_step : lf8;
    let lf_to   = to   ? lfX[(step+1) % 10] : lf8;

    if(to) {
        log(   "%c"+sdx
               +        "%c"+ msg
               +                  "%c"+ from
               +                             "%c ➔ %c"+ (to ? to : "...")
               , lbB+lf_step
               ,         lbH+lf_msg
               ,                   lbL+lf_step
               ,                              lbC+lbA
               ,                                   lbR+lf_to
           );
    }
    else {
        log(   "%c"+sdx
               +        "%c"+ msg
               +                  "%c"+ from
               , lbB+lf_step
               ,         lbH+lf_msg
               ,                   lbH+lf_step
           );
    }

    let new_path
        = !sticky.skipped_csv
        ?  (     " .. "+(to || from)    )
        :  (to ? " .. "+(to        ): "")
    ;

    let s = msg + new_path;

    sticky.skipped_csv = t_util.csv_add(sticky.skipped_csv, s);

};


let log_not_an_anchor_target = function(node)
{
    let result = t_util.not_an_anchor_target(node);
    if( result )
        log("%c"+t_util.get_node_path(node)+" %c"+result+" .. NOT AN ANCHOR TARGET"
           ,lf8                              ,lbb+lbH                              );
};




let log_tr1;
let log_tr2;

let log_TR_set_count = 0;


let log_TR_set_transcripts = function(transcript1, transcript2)
{
    log_tr1 = transcript1;
    log_tr2 = transcript2;
};

let _log_TR_set1       = function(msg, ...args) { if(log_tr1) _log_TR_set(log_tr1, (msg || ""), ...args); };
let _log_TR_add1       = function(msg, ...args) { if(log_tr1) _log_TR_add(log_tr1, (msg || ""), ...args); };

let _log_TR_set2       = function(msg, ...args) { if(log_tr2) _log_TR_set(log_tr2, (msg || ""), ...args); };
let _log_TR_add2       = function(msg, ...args) { if(log_tr2) _log_TR_add(log_tr2, (msg || ""), ...args); };



const TR_MARGIN = 24;
let log_TR_layout = function(tr)
{
    let x_min =          TR_MARGIN - tr.offsetWidth ; if(tr.offsetLeft < x_min) tr.style.left = x_min+"px";
    let x_max = window.innerWidth  - TR_MARGIN     ; if(tr.offsetLeft > x_max) tr.style.left = x_max+"px";

    let y_min =          TR_MARGIN - tr.offsetHeight; if(tr.offsetTop  < y_min) tr.style.top  = y_min+"px";
    let y_max = window.innerHeight - TR_MARGIN     ; if(tr.offsetTop  > y_max) tr.style.top  = y_max+"px";
};


let log_TR_RESULT_set = function(html=log_HTML)
{
    if(!html.trim()) return;


    if(   !html.startsWith("<div")
       && !html.startsWith("<pre")
       && !html.startsWith("<p")
      )
        html = "<pre id='html'>"+ html +"</pre>";

    _log_TR_set2("<hr><table>"
            +   " <tr><td>"+ html +"</td></tr>"
            +   "</table>"
    );

    log_HTML = "";
};


let _log_TR_set  = function(tr,msg, ...args)
{
    if(!msg) msg = "";
log(tr.id+": "+strip_HTML(msg));


    if(tr) {
        tr.innerHTML  = "<em class='em_log'>"
            + "<span class='cc"+(++log_TR_set_count % 10)+"'>"
            +  log_TR_set_count
            + "</span>"
            + "</em>"
        ;
    }


    if(msg) { del_el_class(tr, "empty"); _log_TR_add(tr, msg, args); }

    else    { add_el_class(tr, "empty");                            }


    log();
};


let _log_TR_add  = function(tr, msg, ...args)
{
    if(!msg) msg = "";
log(tr.id+": "+strip_HTML(msg));


    if(!tr           ) return;
    if( msg          ) del_el_class(tr, "empty");
    if(!tr.innerHTML ) _log_TR_set(tr,"");

    if(msg.trim() == "") msg = "empty msg";

    let s = "<table>";


    if(typeof dom_select  !== "undefined") {

        let mStartRange     =  dom_select.get_mStartRange();
        let mStartRange_str = (mStartRange) ? dom_select.rangeToString(mStartRange, "Start Range") : "";
        if(mStartRange) s += ""
            +" <tr><th                       >        mStartRange             </th></tr>"
            +" <tr><td                       ><pre>"+ mStartRange_str +"</pre></td></tr>"
        ;



        let mEndRange       =  dom_select.get_mEndRange();
        let mEndRange_str   = (mEndRange  ) ? dom_select.rangeToString(mEndRange  , "End Range"  ) : "";
        if( mEndRange )  s += ""
            +" <tr><th                       >        mEndRange               </th></tr>"
            +" <tr><td                       ><pre>"+ mEndRange_str   +"</pre></td></tr>"
        ;


    }
    if(msg) {
        if(msg.indexOf("subject=") < 0)
            msg = strip_console_formatting(msg);


        s += ""
            +" <tr><td class='transcript_msg'>"+ msg +"</td></tr>"
            +"</table>"
        ;
    }

    s += "<table>";

    tr.insertAdjacentHTML("beforeend", s);


};



let log_TR_EVENT_add   = _log_TR_add1;

let log_TR_LAYOUT_set  = _log_TR_set1;
let log_TR_LAYOUT_add  = _log_TR_add2;

let log_TR_SELECT_set  = _log_TR_set1;
let log_TR_SELECT_add  = _log_TR_add1;



const dom_log_transcript
    = {   log_TR_set_transcripts
        , log_TR_layout

        , log_TR_EVENT_add
        , log_TR_LAYOUT_set
        , log_TR_LAYOUT_add
        , log_TR_SELECT_set
        , log_TR_SELECT_add

        , log_TR_RESULT_set
    };





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_log"
    , logging : (state) => DOM_LOG_LOG = t_store_set_state("DOM_LOG_LOG",state)
    , tagging : (state) => DOM_LOG_TAG = t_store_set_state("DOM_LOG_TAG",state)
    , t_log_IMPORT


    , ...dom_LOG_MAP
    , ...dom_log_CHAR
    , ...dom_log_CSS
    , ...dom_log_STRING
    , ...dom_log_SYM_DIGIT
    , ...dom_log_console
    , ...dom_log_transcript
    , ...dom_log_log

    , log_IMPORT

    , get_callers
    , log_caller


    , log_json
    , log_json_one_liner
    , log_key_val
    , log_key_val_group
    , log_label_URDL
    , log_not_an_anchor_target
    , log_object_val_format
    , log_anchor_step
};



})();




/*INLINE}}}*/
//@ sourceURL=dom_log.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
  /**    7 POPUP    JS dom_popup_js_data .. ESCAPE=[color:#AAA] {{{*/
/*
../script/dom_popup.js
*/
let dom_popup_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/













const DOM_POPUP_JS_ID         = "dom_popup";
const DOM_POPUP_JS_TAG        =  DOM_POPUP_JS_ID +" (220218:15h:22)";

let dom_popup = (function() {
"use strict";






const CAPTURE_TRUE_PASSIVE_FALSE  = { capture: true , passive: false , useCapture: true };
const LOG_POPUP_DIV_DURATION      =   3000;

const LOG_POPUP_STYLE             = { backgroundColor: "rgba(255,255,0,0.9)" , fontSize: "100%" };
const LOG_POPUP_STYLE_WARN        = { backgroundColor: "rgba(255,165,0,0.8)" , fontSize: "150%" };

const THEME_STYLE_DARK  =  "color: #F00 !important; background-color: transparent; font-weight:900;";
const THEME_STYLE_LIGHT =  "color: #F00 !important; background-color: transparent; font-weight:900;";

let   log_popup_div;
let   log_popup_div_timeout;

let log_popup_warn = function(msg) { log_popup({ message_HTML: msg , style: LOG_POPUP_STYLE_WARN } ); };
let log_popup      = function(args)
{
    let { message_HTML , xy , style=LOG_POPUP_STYLE , options="" , theme_dark } = args || {};

    if(!log_popup_div)
        log_popup_div_get();



    log_popup_div.style.backgroundColor = style.backgroundColor || LOG_POPUP_STYLE.backgroundColor;
    log_popup_div.style.fontSize        = style.fontSize        || LOG_POPUP_STYLE.fontSize;



    if(!message_HTML)
    {
        log_popup_div.style.display = "none";

        return;
    }



    let   theme_style
        = theme_dark
        ? THEME_STYLE_DARK
        : THEME_STYLE_LIGHT
    ;

    log_popup_div.innerHTML
        = "<pre style='"+theme_style+"'>"
        +  message_HTML
        + "</pre>"
    ;

    log_popup_div.style.display = "block";

    log_popup_div.classList.remove("above" );
    log_popup_div.classList.remove("center");


    if( !xy ) {
        let   bcr    = log_popup_div.getBoundingClientRect();

        xy = { x: window.innerWidth/2 - bcr.width/2, y: window.innerHeight/2 - bcr.height/2 };
        log_popup_div    .classList.add("center");
    }


    if( xy )
    {
        log_popup_div.style.top  = Math.max(0, xy.y)+"px";
        log_popup_div.style.left = Math.max(0, xy.x)+"px";
    }


    if(log_popup_div_timeout) clearTimeout( log_popup_div_timeout );

    if(!options || !options.includes("fixed"))
    {
        log_popup_div_timeout
            =   setTimeout(
                           function() {
                               if( log_popup_div.style.backgroundColor != LOG_POPUP_STYLE_WARN.backgroundColor)
                                   log_popup_div.style.display = "none";

                               log_popup_div_timeout = null;
                           }
                           , LOG_POPUP_DIV_DURATION);
    }

};



const LOG_POPUP_DIV_ZINDEX = 2147483647;


let log_popup_div_get = function()
{
    if(log_popup_div) return log_popup_div;


    log_popup_div = document.createElement("DIV");
    log_popup_div.id = "log_popup_div";



    log_popup_div.style.position        = "fixed";
    log_popup_div.style.left            = (window.innerWidth/2)+"px";
    log_popup_div.style.top             = "1em";
    log_popup_div.style.zIndex          = LOG_POPUP_DIV_ZINDEX;

    log_popup_div.style.borderRadius    = "0 0.5em 0.5em 0";
    log_popup_div.style.borderStyle     = "solid";
    log_popup_div.style.borderWidth     = "2px 2px 2px 2px";
    log_popup_div.style.borderColor     = "#AAA";
    log_popup_div.style.boxShadow       =  "3px 3px 5px #888";

    log_popup_div.style.cursor          =  "pointer";
    log_popup_div.style.userSelect      =  "none";

    log_popup_div.style.padding         = "0.5em";


    log_popup_div.addEventListener("mousedown", log_popup_mouse_down_handler, CAPTURE_TRUE_PASSIVE_FALSE);


    document.documentElement.appendChild(log_popup_div);

    return log_popup_div;
};


let log_popup_mouse_down_handler = function(e)
{
if(e && e.ctrlKey) return;
if(e && e.altKey ) return;


    if( log_popup_div.style.backgroundColor != LOG_POPUP_STYLE_WARN.backgroundColor)
        log_popup_div.style.backgroundColor  = LOG_POPUP_STYLE_WARN.backgroundColor;

    else
        log_popup_hide();

};


let log_popup_hide = function()
{
    if( log_popup_div )
        log_popup_div.style.display = "none";
};


let log_popup_follow_mask_el = function(text,el)
{
    log_popup_scrollTo_el(text,el,true);
};



const MARGIN_WIDTH = 10;


let log_popup_scrollTo_el_warn = function(text,el) { log_popup_scrollTo_el(text, el, false, true, LOG_POPUP_STYLE_WARN); };
let log_popup_scrollTo_el = function(text,el,with_mask,can_scroll=true,style=LOG_POPUP_STYLE)
{

    if(!log_popup_div)
        log_popup_div_get();

    let tl_xy;
    if( el )
    {

        let w_top    = (window.scrollY                     ) + MARGIN_WIDTH;
        let w_bottom = (window.scrollY + window.innerHeight) - MARGIN_WIDTH;

        let had_to_scroll;

        let    xy    = get_el_ancestor_xy(el);
        tl_xy        = { x: window.scrollX+ xy.x , y: window.scrollY+ xy.y };

        if     (tl_xy.y > w_bottom) { window.scrollTo(window.scrollX, tl_xy.y - window.innerHeight/10); had_to_scroll = true; }
        else if(tl_xy.y < w_top   ) { window.scrollTo(window.scrollX, tl_xy.y - window.innerHeight/10); had_to_scroll = true; }
        let scrollBehavior = getComputedStyle(document.documentElement).scrollBehavior;
        if(can_scroll && had_to_scroll && (scrollBehavior == "smooth"))
        {
            log_popup_div.style.display = "none";

            setTimeout(function() { log_popup_follow_el_on_scroll_done(text,el,with_mask); }, SCROLL_SAMPLING_DELAY);

            return;
        }


        let bcr      = el.getBoundingClientRect();
        tl_xy        = { x: bcr.left , y: bcr.top };




    }


    log_popup({ message_HTML: text , xy: tl_xy , style });



    tl_xy.y -= log_popup_div.offsetHeight;



    if( tl_xy.y  < 0)
    {
        let   xy = get_el_ancestor_xy(el);
        tl_xy.y  =  xy.y + MARGIN_WIDTH;
        tl_xy.x  =  xy.x + MARGIN_WIDTH;

        let x_max = window.innerWidth - log_popup_div.offsetWidth ;
        tl_xy.x  = Math.min(tl_xy.x, x_max);

        log_popup_div.classList.remove("above");
    }
    else {
        log_popup_div.classList.add   ("above");
    }


    log_popup_div.style.top   = tl_xy.y+"px";
    log_popup_div.style.left  = tl_xy.x+"px";


    if(with_mask) div_mask_follow_el( el );
};



const SCROLL_SAMPLING_DELAY = 100;

let last_scroll_Y;

let log_popup_follow_el_on_scroll_done = function(text,el,with_mask)
{
    if(window.scrollY == last_scroll_Y)
    {
        log_popup_scrollTo_el(text,el,with_mask,false);

    }
    else {
        last_scroll_Y = window.scrollY;

        setTimeout(function() { log_popup_follow_el_on_scroll_done(text,el,with_mask); }, SCROLL_SAMPLING_DELAY);
    }
};


let log_popup_div_handles_event = function(e,_caller)
{
    let result = is_el_child_of_el(e.target, log_popup_div);

    return result;
};


let log_popup_addEventListener = function(type,handler)
{
    if( !log_popup_div_get() ) return;

    log_popup_div.addEventListener(type, handler, CAPTURE_TRUE_PASSIVE_FALSE);
};



let get_el_ancestor_xy = function(el)
{
    let     bcr = el.getBoundingClientRect();
    while(el && !bcr.width && !bcr.height)
    {
        el = el.parentElement;
        if(  el )
            bcr = el.getBoundingClientRect();
    }
    return { x: bcr.x , y: bcr.y } ;
};



let is_el_child_of_el = function(el, el_parent)
{
    while(el && el_parent && (el != el_parent) && (el = el.parentElement))
        ;
    return (el == el_parent);
};






const DIV_MASK_BG = "rgba(70,70,70,0.8)";

let   div_mask;


let div_mask_get = function()
{
    if(!div_mask)
        div_mask_create();

    return div_mask;
};


let div_mask_create = function()
{
    if(div_mask) return div_mask;

    div_mask = document.createElement("DIV");
    div_mask.id                     = "div_mask";
    div_mask.style.position         = "fixed";
    div_mask.style.cursor           = "crosshair";
    div_mask.style.zIndex           = "2147483645";

    div_mask.style.margin           = "0";
    div_mask.style.padding          = "0";

    div_mask.style.backgroundColor  = "rgba(136,136,136,0.3)";

    document.documentElement.appendChild(div_mask);


    div_mask.style.backgroundPositionX = "0";
    div_mask.style.backgroundPositionY = "0";

    return div_mask;
};


let div_mask_hide = function()
{
    if( div_mask )
        div_mask.classList.remove("displayed");

};


let div_mask_show = function()
{
    if( div_mask )
        div_mask.classList.add   ("displayed");

};


let div_mask_repeat = function()
{
    if( !div_mask_get() ) return;


    div_mask.style.backgroundImage
        =  "linear-gradient( 0deg, rgba(255,255,255,0.7) 2px, transparent 2px)"
        + ",linear-gradient(90deg, rgba(255,255,255,0.7) 2px, transparent 2px)";
    div_mask.style.backgroundRepeat = "repeat";
    div_mask.style.backgroundSize   = "3em 3em";

    div_mask_show();
};


let div_mask_follow_el = function(el)
{
    if( !div_mask_get() ) return;


    let bcr = el.getBoundingClientRect();
    let x_1 = (      bcr.left  );
    let x_2 = (x_1 + bcr.width );
    let y_1 = (      bcr.top   );
    let y_2 = (y_1 + bcr.height);



    div_mask.style.backgroundImage
        =  "linear-gradient( 90deg, "+DIV_MASK_BG+" "+x_1+"px, transparent "+x_1+"px, transparent "+x_2+"px, "+DIV_MASK_BG+" "+x_2+"px)"
        + ",linear-gradient(180deg, "+DIV_MASK_BG+" "+y_1+"px, transparent "+y_1+"px, transparent "+y_2+"px, "+DIV_MASK_BG+" "+y_2+"px)"
    ;
    div_mask.style.backgroundSize   = "100% 100%";
    div_mask.style.backgroundRepeat = "no-repeat";

    div_mask_show();

};


let div_mask_addEventListener = function(type,handler)
{
    if( !div_mask_get() ) return;

    div_mask.addEventListener(type, handler, CAPTURE_TRUE_PASSIVE_FALSE);
};



return { name : "dom_popup"


    ,    log_popup
    ,    log_popup_addEventListener
    ,    log_popup_div_get
    ,    log_popup_div_handles_event
    ,    log_popup_follow_mask_el
    ,    log_popup_hide
    ,    log_popup_scrollTo_el
    ,    log_popup_scrollTo_el_warn
    ,    log_popup_warn


    ,    div_mask_get
    ,    div_mask_hide
    ,    div_mask_repeat
    ,    div_mask_follow_el
    ,    div_mask_addEventListener
};

})();

/*INLINE}}}*/
//@ sourceURL=dom_popup.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
  /**   8 UTIL     JS dom_util_js_data .. ESCAPE case "#document"] {{{*/
/*
../script/dom_util.js
*/
let dom_util_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/























const DOM_UTIL_JS_ID        = "dom_util";
const DOM_UTIL_JS_TAG       = DOM_UTIL_JS_ID  +" (221124:17h:42)";

let dom_util    = (function() {
"use strict";
let   DOM_UTIL_LOG          = false;
let   DOM_UTIL_TAG          = false;







let t_data     = {}        ;
let t_log      = {}        ;























let t_util_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
























    util_INTERN();

    DOM_UTIL_LOG = DOM_UTIL_LOG || localStorage_getItem("DOM_UTIL_LOG");
    DOM_UTIL_TAG = DOM_UTIL_TAG || localStorage_getItem("DOM_UTIL_TAG");


if(log_this) log("%c 07 util", lbH+lf7);
};





let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let i18n_get = function(id) { return id; };


let   util_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;



    if(typeof dom_i18n !== "undefined")
    {
        i18n_get        = dom_i18n.i18n_get;

    }

};


let localStorage_setItem = function(key,val) { if(val) localStorage.setItem   (key,val); else localStorage.removeItem(key); };
let localStorage_getItem = function(key    ) { return  localStorage.getItem   (key    ); };
let localStorage_delItem = function(key    ) { localStorage.removeItem(key    ); };






const LF    = String.fromCharCode(10);






const PREVENT_RELOAD_ID   = "prevent_reload";
const PREVENT_RELOAD_DATA = "data:text/javascript;charset='utf-8',"
    +"window.onbeforeunload = function() { return 'Reload Site?'; }"
;


let t_prevent_reload = function()
{
    if(!document.getElementById( PREVENT_RELOAD_ID ) )
    {
logBIG("load_js(PREVENT_RELOAD_ID, PREVENT_RELOAD_DATA)");

        load_js(PREVENT_RELOAD_ID, PREVENT_RELOAD_DATA);
    }
};


let load_js = function(js_id, js_data)
{
    let el    = document.createElement("script");
    el.type   = "text/javascript";
    el.id     = js_id;
    el.src    = js_data;
    el.charset= "utf-8";
    el.async  = false;
    el.defer  = true;
    el.addEventListener("error", function(e) { console.log(e); } );
    document.getElementsByTagName("head")[0].appendChild(el);

    return true;
};





let get_el_xy = function(el)
{
    if(!el) return null;
    let  x = 0;
    let  y = 0;

    let cs = window.getComputedStyle(el);

    if(   (cs.position == "fixed"   )
       || (cs.position == "absolute")
      ) {

        x   = el.offsetLeft;
        y   = el.offsetTop ;
    }
    else {

        while(el) {
            x  += el.offsetLeft;
            y  += el.offsetTop ;
            el  = el.offsetParent;
        }

    }

    return { x , y };
};


let get_el_xy_computed = function(el)
{
    let cs = window.getComputedStyle(el);
    let  x = parseInt(cs.left);
    let  y = parseInt(cs.top );
    return { x , y };
};




let check_xy_in_node_rect = function(x, y, node)
{


    let   t = Math.round( node.scrollTop    );
    let   l = Math.round( node.scrollLeft   );
    let   w = Math.round( node.scrollWidth  );
    let   h = Math.round( node.scrollHeight );
    let   b = t + h;
    let   r = l + w;

    t -= t_data.VIEWPORT_MARGIN.top;
    l -= t_data.VIEWPORT_MARGIN.left;
    b += t_data.VIEWPORT_MARGIN.bottom;
    r += t_data.VIEWPORT_MARGIN.right;



    if(    (x >= l)
        && (y >= t)
        && (x <= r)
        && (y <= b)
      )
        return true;



    return false;
};


let getInPageTop = function(el)
{
    if(el.nodeType == Node.TEXT_NODE) el = el.parentElement;


    let y = el.getBoundingClientRect
        ?    Math.round(el.getBoundingClientRect().top + window.scrollY)
        :    0;


    return y;
};


let getPageHeight = function()
{

    return document.body.parentElement.scrollHeight;






};


let t_el_geometry = function(el)
{


    let w  = el.offsetWidth;
    let h  = el.offsetHeight;
    let l  = el.offsetLeft;
    let t  = el.offsetTop;

    return {  WH        : "["+( w   )+" "+( h   )+"]"
            , TOP_LEFT  : "["+( t   )+" "+( l   )+"]"
            , BOT_RIGHT : "["+( t+h )+" "+( l+w )+"]"

    };

};


let t_get_panel_scale = function(panel)
{


    let    cw = parseInt(panel.getBoundingClientRect().width);
    let    pw = parseInt(panel.offsetWidth);
    let scale = (cw && pw)
        ?        parseInt(0.5 + (cw / pw) * 100) / 100
        :        1;

    return scale;
};


let get_el_transformOrigin = function(el)
{
    let xy = [];
    let cs = window.getComputedStyle(el);
    let px = cs.transformOrigin.split(" ");
    px.forEach( (s) => xy.push(parseInt(s)) );
    return { x:xy[0] , y:xy[1] };
};


let t_adjust_panel_transform_origin = function(panel)
{

let   caller = "t_adjust_panel_transform_origin";
let log_this = LOG_MAP.T2_GRID || LOG_MAP.T1_DOM_LOAD;



    let     scale = t_get_panel_scale(panel);

    let wcX = (window.innerWidth  - t_data.SCROLLBAR_WIDTH) / 2;
    let wcY = (window.innerHeight - t_data.SCROLLBAR_WIDTH) / 2;



    let bcr = panel.getBoundingClientRect();
    let p_x =                            bcr.left  ;
    let p_y =                            bcr.top   ;
    let p_w =                            bcr.width ;
    let p_h =                            bcr.height;

    let pcX = p_x + scale * p_w / 2;
    let pcY = p_y + scale * p_h / 2;



    let l_or_r = (pcX < wcX);
    let t_or_b = (pcY < wcY);




    let u, r, d, l;
    if     (has_el_class(panel, t_data.CSS_CORNER_U_R)) { u = true;  r = true; }
    else if(has_el_class(panel, t_data.CSS_CORNER_R_D)) { r = true;  d = true; }
    else if(has_el_class(panel, t_data.CSS_CORNER_D_L)) { d = true;  l = true; }
    else if(has_el_class(panel, t_data.CSS_CORNER_L_U)) { l = true;  u = true; }



    let d_x = 0; let d_y = 0;
    if     ((pcY <  wcY) && !u) { d_y = -1; u = true; }
    else if((pcX >= wcX) && !r) { d_x =  1; r = true; }
    if     ((pcY >= wcY) && !d) { d_y =  1; d = true; }
    else if((pcX <  wcX) && !l) { d_x = -1; l = true; }



    set_el_class_on_off(panel, t_data.CSS_CORNER_U_R, u && r);
    set_el_class_on_off(panel, t_data.CSS_CORNER_R_D, r && d);
    set_el_class_on_off(panel, t_data.CSS_CORNER_D_L, d && l);
    set_el_class_on_off(panel, t_data.CSS_CORNER_L_U, l && u);



    if(scale != 1) {
        if     (d_y > 0) panel.style.top  = (p_y + p_h - panel.offsetHeight)+"px";
        else if(d_y < 0) panel.style.top  = (p_y                           )+"px";
        if     (d_x > 0) panel.style.left = (p_x + p_w - panel.offsetWidth )+"px";
        else if(d_x < 0) panel.style.left = (p_x                           )+"px";
    }


if( log_this) {
t_log.console_clear(caller);
    let cs = getComputedStyle(panel);
    log_key_val_group(    caller+"("+get_n_lbl(panel)+") .. "+panel.className
                                , { bcr
                                  , window_center_XY : wcX+" "+wcY
                                  , panel_XY         : pcX+" "+pcY
                                  , CORNER           : (t_or_b ?  "TOP":"BOTTOM")+"-"+(l_or_r ? "LEFT":"RIGHT")
                                  , URDL             : (u ? "U":"_")+ (r ? "R":"_")+ (d ? "D":"_")+ (l ? "L":"_")
                                  , className        : panel.className
                                  , transformOrigin  : cs.transformOrigin
                                  , d_x
                                  , d_y
                                }
                                , lf6, false);
}

};




let              divs_style_z_index_max;
let              b_computed_z_index_max;

let t_get_divs_style_z_index_max = function()
{

let   caller = "t_get_divs_style_z_index_max";
let log_this = DOM_UTIL_TAG || DOM_UTIL_LOG;



if( log_this) console.time(caller);

    divs_style_z_index_max =  0;
    b_computed_z_index_max =  0;
    let            bs_hist = "";
    let            bc_hist = "";


    let div_list = document.querySelectorAll("DIV");

    for(let i=0; i<div_list.length; ++i)
    {
        let child = div_list[i];
        if( child.id == "shadow_host") continue;

        let    cs = window.getComputedStyle( child );

        if( child.style.zIndex                                   ) bs_hist = "["+get_id_or_tag(child) +" "+child.style.zIndex +"] ← "+ bs_hist;
        if(          cs.zIndex > parseInt(b_computed_z_index_max)) bc_hist = "["+get_id_or_tag(child) +" "+cs.zIndex          +"] ← "+ bc_hist;

        if( child.style.zIndex > parseInt(divs_style_z_index_max)) divs_style_z_index_max = child.style.zIndex;
        if(          cs.zIndex > parseInt(b_computed_z_index_max)) b_computed_z_index_max = cs.zIndex;
    }

    let result = Math.max(divs_style_z_index_max , b_computed_z_index_max);

if(log_this) {
    log_key_val_group(caller
                      , {   div_list_length        : div_list.length
                          , divs_style_z_index_max : bs_hist
                          , b_computed_z_index_max : bc_hist
                          , return                 : result
                      }, lf9, false);
    console.timeEnd(caller);
}

    return result;
};



let get_xy_tlbr_dist = function(x, y, tlbr)
{
    let   cx = (tlbr.l + tlbr.r) / 2;
    let   cy = (tlbr.t + tlbr.b) / 2;

    let   dx = x - cx;
    let   dy = y - cy;

    return Math.round( Math.sqrt(dx*dx + dy*dy) );
};


let intersect_r1_r2 = function(r1,r2)
{

    if(r1.width  <= 0        ) return false;
    if(r1.height <= 0        ) return false;
    if(r2.width  <= 0        ) return false;
    if(r2.height <= 0        ) return false;


    if(r1.left   >  r2.right ) return false;
    if(r1.right  <  r2.left  ) return false;
    if(r1.bottom <  r2.top   ) return false;
    if(r1.top    >  r2.bottom) return false;


    let r1_T_IN  = (r1.top    >= r2.top   ) && (r1.top    <= r2.bottom);
    let r1_L_IN  = (r1.left   >= r2.left  ) && (r1.left   <= r2.right ); if(r1_T_IN && r1_L_IN) return true;
    let r1_R_IN  = (r1.right  >= r2.left  ) && (r1.right  <= r2.right ); if(r1_T_IN && r1_R_IN) return true;
    let r1_B_IN  = (r1.bottom >= r2.top   ) && (r1.bottom <= r2.bottom); if(r1_B_IN && r1_L_IN) return true;
 if(r1_B_IN && r1_R_IN) return true;

    return false;
};


let intersect_tlbr = function({p , o , gap})
{
    if(p.l > (o.r + (gap || 0))) return false;
    if(p.r < (o.l - (gap || 0))) return false;
    if(p.b < (o.t - (gap || 0))) return false;
    if(p.t > (o.b + (gap || 0))) return false;
 return  true;
};


let is_contained_by_parent = function(el,log_this)
{
    let r_CHILD  = el.              getBoundingClientRect();
    let r_PARENT = el.parentElement.getBoundingClientRect();


    if(r_CHILD .width  <= 0        ) return false;
    if(r_CHILD .height <= 0        ) return false;
    if(r_PARENT.width  <= 0        ) return false;
    if(r_PARENT.height <= 0        ) return false;


    if(r_CHILD .left   >  r_PARENT.right ) return false;
    if(r_CHILD .right  <  r_PARENT.left  ) return false;
    if(r_CHILD .bottom <  r_PARENT.top   ) return false;
    if(r_CHILD .top    >  r_PARENT.bottom) return false;


    let r_CHILD_T_IN  = (r_CHILD.top    >= r_PARENT.top ) && (r_CHILD.top    <= r_PARENT.bottom);
    let r_CHILD_L_IN  = (r_CHILD.left   >= r_PARENT.left) && (r_CHILD.left   <= r_PARENT.right );
    let r_CHILD_R_IN  = (r_CHILD.right  >= r_PARENT.left) && (r_CHILD.right  <= r_PARENT.right );
    let r_CHILD_B_IN  = (r_CHILD.bottom >= r_PARENT.top ) && (r_CHILD.bottom <= r_PARENT.bottom);


    let contained_H = r_CHILD_L_IN && r_CHILD_R_IN;
    let contained_V = r_CHILD_T_IN && r_CHILD_B_IN;

if(log_this) {
    let lfx
        = (contained_H && contained_V) ? lf7
        : (contained_H               ) ? lf4
        : (               contained_V) ? lf5
        :                                lf8;

    log_key_val_group("is_contained_by_parent("+get_id_or_tag( el )+")"
                      , {   r_PARENT             : rect_toString(r_PARENT) +"  ["+ get_id_or_tag(el              )+"]"
                          , r_CHILD              : rect_toString(r_CHILD ) +"  ["+ get_id_or_tag(el.parentElement)+"]"
                          , contained_H
                          , contained_V
                      },lbH+lfx, false);
}

    return [ contained_H , contained_V ];
};


let is_overflowing_parent = function(el,log_this)
{
    let e_bcr = el.              getBoundingClientRect();
    let p_bcr = el.parentElement.getBoundingClientRect();

    let result = intersect_r1_r2(e_bcr, p_bcr);

if(log_this)
    log_key_val_group("is_overflowing_parent("+get_id_or_tag( el )+")"
                      , {   parent          : rect_toString(p_bcr) +"  ["+ get_id_or_tag(el.parentElement)+"]"
                          , element         : rect_toString(e_bcr) +"  ["+ get_id_or_tag(el              )+"]"
                          , intersect_r1_r2 : result
                      },lfX[result ? 4:8], false);

    return result;
};


let is_el_visible = function(el)
{

let   caller = "is_el_visible";
let log_this = DOM_UTIL_LOG;


    let parent_display_none
        = get_el_parent_with_display_none(el);

    let parent_hidden
        =  !parent_display_none
        && get_el_parent_with_class(el, t_data.MARKED_TO_HIDE);

    let parent_dimmed
        =  !parent_display_none
        && !parent_hidden
        && get_el_parent_with_class(el, t_data.CSS_DIMMED);

    let parent_clipped
        =  !parent_display_none
        && !parent_hidden
        && !parent_dimmed
        && get_el_parent_clipped(el);

    let visible
        =  !parent_display_none
        && !parent_hidden
        && !parent_dimmed
        && !parent_clipped
    ;



if( log_this) {
    let reason
        = parent_display_none ? "parent_display_none"
        : parent_hidden       ? "parent_hidden"
        : parent_dimmed       ? "parent_dimmed"
        : parent_clipped      ? "parent_clipped"
        : ""
    ;
    let lfx = lfX[visible ? 5:2];
    log("%c"+caller+"("+get_id_or_tag(el)+"):%c ...return "+visible+"%c"+reason
        , lbL+lfx                           ,lbR+lfx                ,lbH+lfx   );
}


    return visible;
};




let t_set_position_fixed = function(el)
{

    let        caller = "t_set_position_fixed";

    if(  has_el_class(el, "fixed") ) return;
    else add_el_class(el, "fixed");


    let xy = get_el_xy(el, caller);
    if(!el.saved_layout) {

        el.saved_layout
            = { position : el.style.position
              , top      : el.style.top
              , left     : el.style.left
              , width    : el.style.width
              , height   : el.style.height
            };
        el.ontransitionend = position_fixed_transitionend;

    }
    else {

    }
    if(!el.saved_layout.xy) {

        el.saved_layout.xy =  xy;
    }


    el.style.position    = "fixed";
    el.style.left        =  xy.x +"px";
    el.style.top         =  xy.y +"px";


};


let t_del_position_fixed = function(el)
{


    del_el_class(el, "fixed");

    if(!el.saved_layout) return;


    if( el.saved_layout.xy )
    {
        el.style.top    = el.saved_layout.xy.y +"px";
        el.style.left   = el.saved_layout.xy.x +"px";
        el.style.width  = el.saved_layout.width;
        el.style.height = el.saved_layout.height;

    }


};


let position_fixed_transitionend = function(event)
{
    let caller = "position_fixed_transitionend";

    let el = event.target;
    if(!el.saved_layout         ) return;
    if(!el.saved_layout.xy      ) return;
    if( has_el_class(el, "fixed") ) return;

    let    xy    = get_el_xy(el, caller);
    if(   (xy.x != el.saved_layout.xy.x)
       || (xy.y != el.saved_layout.xy.y)
      )
        return;




    el.style.position = el.saved_layout.position;
    el.style.top      = el.saved_layout.top ;
    el.style.left     = el.saved_layout.left;

    delete              el.saved_layout.xy;
};







const MOUSE_EVENT_ATTRIBUTES
= [ "onclick"
  , "ondblclick"
  , "onmousedown"
  , "onmousemove"
  , "onmouseout"
  , "onmouseover"
  , "onmouseup"
  , "onmousewheel"
  , "onwheel"
];

const KEYBOARD_EVENT_ATTRIBUTES
= [ "onkeydown"
  , "onkeypress"
  , "onkeyup"
];

const FORM_EVENT_ATTRIBUTES
= [ "onblur"
  , "onchange"
  , "onfocus"
  , "oninput"
  , "oninvalid"
  , "onreset"
  , "onsearch"
  , "onselect"
  , "onsubmit"
];

const ALL_EVENT_ATTRIBUTES
    =       MOUSE_EVENT_ATTRIBUTES
    .concat(KEYBOARD_EVENT_ATTRIBUTES)
    .concat(FORM_EVENT_ATTRIBUTES    );



let t_REMOVE_EventListeners = function()
{

let log_this = DOM_UTIL_TAG || DOM_UTIL_LOG || LOG_MAP.EV0_LISTEN;


    let removed_count = 0;
    for(let i = 0;         i <=  ALL_EVENT_ATTRIBUTES.length; ++i)
    {
        let attribute_name    =  ALL_EVENT_ATTRIBUTES[i];

        let el_array          =  Array.from( document.querySelectorAll("["+attribute_name+"]") );
if(!removed_count && el_array.length) log("%c REMOVING EVENT LISTENERS:", lb7);

        el_array.forEach((el) => {
if(log_this) log("["+attribute_name+"] .. "+get_id_or_node_path_tail(el));
                             el.removeAttribute(attribute_name);
                             removed_count += 1;
                         });
    }
    if( !removed_count ) log("%c NO EVENT LISTENERS TO REMOVE"                 , lf8);
    else                 log("%c ... "+removed_count+" event listeners removed", lf7);


    document.body.replaceWith( document.body.cloneNode(true) );
};


let get_parent_with_scrollbar = function(el)
{
    while(el && !has_scrollbar(el))
        el = el.parentElement;
    return el;
};


let get_scrollable_parent = function(el)
{
    while(el && el.parentElement && !el.parentElement.style.overflow)
        el =    el.parentElement;
    return el ? el.parentElement : null;
};



const SCROLLABLE_TEXT_MIN_LENGTH = 12;


let has_scrollbar = function(el)
{
    return has_scrollbar_x(el)
        || has_scrollbar_y(el)
    ;
};


let has_scrollbar_x = function(el)
{

let   caller = "has_scrollbar_x";
let log_this = DOM_UTIL_LOG;


    if( !el                                                ) return false;
    if( !el.scrollHeight                                   ) return false;
    if( !el.clientHeight                                   ) return false;
    if(  el.textContent.length < SCROLLABLE_TEXT_MIN_LENGTH) return false;

    let cs = window.getComputedStyle(el);

    let scrollbar_HEIGHT = el.offsetHeight
        - (  parseInt(cs.borderTopWidth   )
           + parseInt(el.clientHeight)
           + parseInt(cs.borderBottomWidth)
          );

    let is_top_el
        = ((el == document.body) || (el == document.documentElement));

    let result
        = is_top_el
        ? ((window.innerHeight  > document.documentElement.offsetHeight) &&  "WINDOW_TALLER")
        : ((    el.offsetHeight >                       el.clientHeight) && "ELEMENT_TALLER")
    ;

if( log_this) {
    let         bcr = el.getBoundingClientRect();

    log_key_val_group(caller+"( "+get_id_or_tag(el      )+" ) ...return "+result
                , { OFFSET_SCROLL_CLIENT  :  "---"
                  , el_scrollHeight       :  el.scrollHeight
                  , el_offsetHeight       :  el.offsetHeight
                  , el_clientHeight       :  el.clientHeight
                  , ELEMENT_TALLER        : (el.offsetHeight > el.clientHeight)

                  , BOUNDINGS             :  "---"
                  , bcr_height            :  bcr.height

                  , MARGIN_BORDER_PADDING :  "---"
                  , cs_margin             :  cs.margin
                  , cs_border             :  cs.border
                  , cs_padding            :  cs.padding

                  , TOP_HEIGHT_BOTTOM     :  "---"
                  , cs_marginTop          :  cs.marginTop
                  , cs_borderTop          :  cs.borderTop
                  , cs_paddingTop         :  cs.paddingTop
                  , cs_height             :  cs.height
                  , cs_paddingBottom      :  cs.paddingBottom
                  , cs_borderBottom       :  cs.borderBottom
                  , cs_marginBottom       :  cs.marginBottom

                  , SCROLLBAR             :  "---"
                  , scrollbar_HEIGHT      :  scrollbar_HEIGHT+" = [el.offsetHeight "+ parseInt(el.offsetHeight)+"] - ( [cs.borderTop "+parseInt(cs.borderTop)+"] + [el.clientHeight "+parseInt(el.clientHeight)+"] + [cs.borderBottom "+parseInt(cs.borderBottom)+"] )"

                  , WINDOW                :  "---"
                  , is_top_el
                  ,   HTML_offsetHeight   :  document.documentElement.offsetHeight
                  , WINDOW_innerHeight    :  window.innerHeight
                  , WINDOW_outerHeight    :  window.outerHeight
                  , WINDOW_TALLER         : (window.innerHeight > document.documentElement.offsetHeight)

                  , caller                :  t_log.get_callers()
                  , result                :  result+" [scrollbar_HEIGHT "+scrollbar_HEIGHT+"]"
                } ,lbH+lfX[result ? 4:8], false);
}

    return result;
};


let has_scrollbar_y = function(el)
{

let   caller = "has_scrollbar_y";
let log_this = DOM_UTIL_LOG;


    if( !el                                                ) return false;
    if( !el.scrollWidth                                    ) return false;
    if( !el.clientWidth                                    ) return false;
    if(  el.textContent.length < SCROLLABLE_TEXT_MIN_LENGTH) return false;

    let cs = window.getComputedStyle(el);

    let scrollbar_WIDTH = el.offsetWidth
        - (  parseInt(cs.borderLeftWidth  )
           + parseInt(el.clientWidth )
           + parseInt(cs.borderRightWidth )
          );

    let is_top_el
        = ((el == document.body) || (el == document.documentElement));

    let result
        = is_top_el
        ? ((window.innerWidth  > document.documentElement.offsetWidth) &&  "WINDOW_WIDER")
        : ((    el.offsetWidth >                       el.clientWidth) && "ELEMENT_WIDER")
    ;


if( log_this) {
    let         bcr = el.getBoundingClientRect();

    log_key_val_group(caller+"( "+get_id_or_tag(el      )+" ) ...return "+result
                , { OFFSET_SCROLL_CLIENT  :  "---"
                  , el_scrollWidth        :  el.scrollWidth
                  , el_offsetWidth        :  el.offsetWidth
                  , el_clientWidth        :  el.clientWidth
                  , ELEMENT_WIDER         : (el.offsetWidth > el.clientWidth)

                  , BOUNDINGS             :  "---"
                  , bcr_width             :  bcr.width

                  , MARGIN_BORDER_PADDING :  "---"
                  , cs_margin             :  cs.margin
                  , cs_border             :  cs.border
                  , cs_padding            :  cs.padding

                  , LEFT_WIDTH_RIGHT      :  "---"
                  , cs_marginLeft         :  cs.marginLeft
                  , cs_borderLeft         :  cs.borderLeft
                  , cs_paddingLeft        :  cs.paddingLeft
                  , cs_width              :  cs.width
                  , cs_paddingRight       :  cs.paddingRight
                  , cs_borderRight        :  cs.borderRight
                  , cs_marginRight        :  cs.marginRight

                  , SCROLLBAR             :  "---"
                  , scrollbar_WIDTH       :  scrollbar_WIDTH+" = [el.offsetWidth "+ parseInt(el.offsetWidth)+"] - ( [cs.borderLeft "+parseInt(cs.borderLeft)+"] + [el.clientWidth "+parseInt(el.clientWidth)+"] + [cs.borderRight "+parseInt(cs.borderRight)+"] )"

                  , WINDOW                :  "---"
                  , is_top_el
                  ,   HTML_offsetWidth    :  document.documentElement.offsetWidth
                  , WINDOW_innerWidth     :  window.innerWidth
                  , WINDOW_outerWidth     :  window.outerWidth
                  , WINDOW_WIDER          : (window.innerWidth > document.documentElement.offsetWidth)

                  , caller                :  t_log.get_callers()
                  , result                :  result+" [scrollbar_WIDTH "+scrollbar_WIDTH+"]"
                } ,lbH+lfX[result ? 4:8], false);
}

    return result;
};


let is_event_on_scrollbar = function(e)
{

let   caller = "is_event_on_scrollbar";
let log_this = DOM_UTIL_LOG;



    let event_XY = get_event_XY(e);

    let    e_target = e.path ? e.path[0] : e.target;
    if(   !e_target                 ) return false;
    if(   !e_target.scrollWidth     ) return false;
    if(   !e_target.scrollHeight    ) return false;
    if(   !has_scrollbar_x(e_target)
       && !has_scrollbar_y(e_target)) return false;


    let          bcr = e_target.getBoundingClientRect();
    let     bcr_left = (bcr.left                                ).toFixed(0);
    let     bcr_top  = (bcr.top                                 ).toFixed(0);
    let     scale = t_get_panel_scale(e_target);
    let        x_max = (bcr.left + e_target.scrollWidth  * scale).toFixed(0);
    let        y_max = (bcr.top  + e_target.scrollHeight * scale).toFixed(0);

    let    off_right = (event_XY.x  > x_max);
    let   off_bottom = (event_XY.y  > y_max);

    let on_scrollbar =   off_right || off_bottom;

if( log_this) {
    log_key_val(caller+"( "+get_id_or_tag(e_target)+" ) ...return "+on_scrollbar
                , {     e_target : get_id_or_tag(e_target)
                  ,     event_XY :           event_XY.x+" "+event_XY.y
                  ,       bcr_XY :  bcr.left.toFixed(0)+" "+bcr.top.toFixed(0)
                  ,        scale
                  ,    scroll_WH : e_target.scrollWidth+" "+e_target.scrollHeight
                  ,    offset_WH : e_target.offsetWidth+" "+e_target.offsetHeight
                  ,    client_WH : e_target.clientWidth+" "+e_target.clientHeight
                  ,            X : "[left "+bcr_left+"] .. [X "+event_XY.x+"] .. [x_max "+x_max+"] .. "+(off_right  ? "OFF-RIGHT" :"")
                  ,            Y : "[top  "+bcr_top +"] .. [Y "+event_XY.y+"] .. [y_max "+y_max+"] .. "+(off_bottom ? "OFF-BOTTOM":"")
                  , on_scrollbar
                  ,   callers : t_log.get_callers()
                } ,lbH+lfX[on_scrollbar ? 4:8]);


}
    return on_scrollbar;
};


let get_el_parent_with_any_event_handler = function(el)
{
    while(el
           && !get_el_mouse_event_handler(el)
           && !get_el_onkey_event_handler(el)
           && !get_el_input_event_handler(el)
         )
        el = el.parentElement;

    return el;
};


let get_el_mouse_event_handler = function(el)
{
    if(!el)                     return null;
    if( el.onmousedown != null) return el.onmousedown;
    if( el.onmouseup   != null) return el.onmouseup  ;
    if( el.touchstart  != null) return el.onmouseup  ;
    if( el.touchend    != null) return el.onmouseup  ;
    if( el.onclick     != null) return el.onclick    ;
    if( el.ondblclick  != null) return el.ondblclick ;
    else                        return null;
};


let get_el_onkey_event_handler = function(el)
{
    if(!el)                    return null;
    if(el.onkeydown   != null) return el.onkeydown  ;
    if(el.onkeypress  != null) return el.onkeypress ;
    if(el.onkeyup     != null) return el.onkeyup    ;
    else                       return null;
};


let get_el_input_event_handler = function(el)
{
    if(!el)                    return null;
    if(el.onchange    != null) return el.onchange   ;
    if(el.onfocus     != null) return el.onfocus    ;
    if(el.onselect    != null) return el.onselect   ;
    if(el.oninput     != null) return el.oninput    ;
    if(el.onsubmit    != null) return el.onsubmit   ;
    if(el.onblur      != null) return el.onblur     ;
    else                       return null;
};


let get_el_event_handler = function(el, _caller)
{
let log_this = LOG_MAP.EV0_LISTEN;


    if(!el) return null;

    let e_target_or_parent = get_el_parent_with_any_event_handler( el );

    if(!e_target_or_parent) return   null;


    let handler
        = (e_target_or_parent             == null) ? null
        : (e_target_or_parent.onclick     != null) ? e_target_or_parent.onclick
        : (e_target_or_parent.ondblclick  != null) ? e_target_or_parent.ondblclick
        : (e_target_or_parent.onmousedown != null) ? e_target_or_parent.onmousedown
        : (e_target_or_parent.onmouseup   != null) ? e_target_or_parent.onmouseup
        : (e_target_or_parent.onkeypress  != null) ? e_target_or_parent.onkeypress
        : (e_target_or_parent.onkeyup     != null) ? e_target_or_parent.onkeyup
        : (e_target_or_parent.onchange    != null) ? e_target_or_parent.onchange
        :                                            null;

    if(!handler) return   null;

    let label = get_el_event_handler_label(el, e_target_or_parent, handler);

if(log_this) log("%c get_el_event_handler("+get_n_lbl(el)+") .. CALLED BY ["+ _caller+"]: ...return handler=["+((handler != null) ? "function" : "null")+"]"+LF+"%c"+label,lb6,lbH+lf6);

    let bubbling = has_el_class(e_target_or_parent, "bubbling");
if(log_this && bubbling) log("...bubbling=["+bubbling+"] .. return null");
    if(bubbling) return null;

    return { handler , label };
};


let get_el_event_handler_label = function(el, e_target_or_parent, handler)
{
    let el_label
        =          ( e_target_or_parent               !=  el )
        ? get_n_lbl( e_target_or_parent )+" "+ get_n_lbl( el )
        :                                      get_n_lbl( el )
    ;

    let handler_name =                       handler.name              ;
    let handler_code = ellipsis(strip_CR_LF( handler.toString() ), 128);

    return el_label +" "+ (handler_name || handler_code);
};


let send_onchange_event_to = function(el)
{
    let caller = "send_onchange_event_to("+el.id+")";
    try {
        if("createEvent" in document)
        {
            let evt = document.createEvent("HTMLEvents");
            evt.initEvent("onchange", false, true);
            el.dispatchEvent(evt);
        }
        else {
            el.fireEvent("onchange");
        }
    }
    catch(ex) { log(caller+": "+ex, "error"); }
};


let get_event_XY = function(e)
{
    let x, y;
    if(e.changedTouches) {
        x = parseInt(e.changedTouches[0].clientX);
        y = parseInt(e.changedTouches[0].clientY);
    }
    else {
        x = parseInt(                  e.clientX);
        y = parseInt(                  e.clientY);
    }
    return { x , y };
};



let t_get_event_target_last_e;
let t_get_event_target_last_e_target;


let t_get_event_target = function(e)
{

let caller = "t_get_event_target";
let log_this = DOM_UTIL_LOG;

if( log_this) caller += "("+e.type+" on "+get_id_or_tag((e.path ? e.path[0] : e.e_target))+")";
if( log_this) log("%c"+caller, lbH+lf7);
if( log_this) console.dir(e);


    if(e === t_get_event_target_last_e)
    {

if( log_this)
    log("%c...returning last target %c"+get_id_or_tag(t_get_event_target_last_e_target), lf8, lbH+lf8);


        return t_get_event_target_last_e_target;
    }


    let e_target = e.target ? e.target  : undefined;
    let e_path_0 =  e.path  ? e.path[0] : undefined;
    let e_path_1 =  e.path  ? e.path[1] : undefined;

if( log_this ) {
    log_key_val_group("...event path and target"
                      , { e_target
                        , e_path_0
                        , e_path_1
                        , e_originalTarget         : e.originalTarget
                        , e_explicitOriginalTarget : e.explicitOriginalTarget
                        ,                  callers : t_log.get_callers()
                      }, lf7, false
                     );

}





    if     (e.path && (e_path_0.tagName != "IMG")) {  e_target = e_path_0; }
    else if(e.path &&  e_path_1                  ) {  e_target = e_path_1; }
    else if(e.originalTarget                     ) {  e_target = e.originalTarget; }
    else if(e.explicitOriginalTarget             ) {  e_target = e.explicitOriginalTarget; }
    else if(e_target                             ) { }



    let el;

if( log_this ) {
    let e_parent = e_target.parentElement;
    log_key_val_group("...skipping proxy el"
                      , { e_target_firstElementChild           : e_target ?                         e_target.firstElementChild : ""
                        , e_target_parentElement               : e_parent ?                         e_parent                   : ""
                        , e_target_htmlFor                     : e_target ?                         e_target.htmlFor           : ""
                        , e_target_htmlFor_EL                  : e_target ? document.getElementById(e_target.htmlFor)          : ""
                        , e_target_parentElement_htmlFor       : e_parent ?                         e_parent.htmlFor           : ""
                        , e_target_parentElement_htmlFor_EL    : e_parent ? document.getElementById(e_parent.htmlFor)          : ""
                      }, lf7, false
                     );
}

    e_target
        = ((el = e_target.firstElementChild) && (el.tagName == "INPUT")) ? e_target.firstElementChild
        : ((el = e_target                  ) && (el.htmlFor           )) ? (document.getElementById(el.htmlFor) || e_target)
        : ((el = e_target.parentElement    ) && (el.htmlFor           )) ? (document.getElementById(el.htmlFor) || e_target)
        :   e_target
    ;







if( log_this)
    log("%c...return %c"+get_id_or_tag(e_target), lf7, lbH+lf7);


    t_get_event_target_last_e        = e;
    t_get_event_target_last_e_target = e_target;
    return e_target;
};


let et_handled_target = function(e, e_target, log_this)
{
let caller = "get_handled_target";

    let handled_target;
    switch(e.type)
    {

        case "mousedown" :
        case "mouseup"   :
        case "touchstart":
        case "touchend"  :
        case "click"     :
        case "dblclick"  :
        if( !get_el_mouse_event_handler(e_target) ) handled_target = get_el_parent_with_any_event_handler(e_target);
        break;

        case "keydown"   :
        case "keypress"  :
        case "keyup"     :
        if( !get_el_onkey_event_handler(e_target) ) handled_target = get_el_parent_with_any_event_handler(e_target);
        break;

        case "change"    :
        case "focus"     :
        case "select"    :
        case "input"     :
        case "submit"    :
        case "blur"      :
        if( !get_el_input_event_handler(e_target) ) handled_target = get_el_parent_with_any_event_handler(e_target);
        break;

        default:
log("%c*** "+caller+": EVENT TYPE ["+e.type+"] NOT HANDLED", lbF+lb2);
        break;
    }

if( log_this) log("%c"+caller+"("+e.type+", "+get_id_or_tag(e_target)+") %c return "+get_id_or_tag(handled_target), lbL+lf4, lbR+lbX[handled_target ? 3:0]);
    return handled_target;
};




let get_shadow_root = function()
{
    let    shadow_host = document.getElementById("shadow_host");
    let    shadow_root = shadow_host ? shadow_host.shadowRoot : null;

    return shadow_root;
};


let get_tool = function(id)
{
    if( id.includes(" ") ) return null;
    let selector
        = (id.charAt(0) != ".") && (id.charAt(0) != "#")
        ?  "#"+id
        :      id;

    let el;
    try {
        let shadow_root      = get_shadow_root();
        if( shadow_root ) el = shadow_root.querySelector( selector );
        if(!el          ) el = document   .querySelector( selector );
    }
    catch(ex) { if(DOM_UTIL_LOG) { console.log("selector=["+selector+"]"); console.warn(ex); } }


    return el;
};


let get_position_absolute_children = function(el,level=1)
{

    let arr = [];
    if(!el || !el.classList)
    {

    }


    else if( el.children.length < 1)
    {
        if(el.style.position == "absolute") arr.push(el);

    }


    else if(level < 3)
    {
        for(let i = 0
            ;   i < el.children.length
            ;   i += 1
           )
        {
            let child = el.children[i];

            if( child.children.length > 0)
                arr.concat( get_position_absolute_children( child ,level+1) );

            else if(el.style.position == "absolute")
                arr.push( child );
        }
    }






    return arr;
};


let node_toString = function(node)
{
    let caller = "node_toString";
    if(!node) return "<span class='gr'>"+caller+"(null_node)</span>";

    let result = "";
    try {

        let p_str = get_p_str( node          );
        let n_str = get_n_str( node          );


        let text  = (           node.nodeType == Node.COMMENT_NODE)
            ?                   node.textContent
            :  truncate(trim_empty_lines(node.textContent))
        ;

        let em_class
            = (node.nodeType == Node.TEXT_NODE   ) ? "cc4"
            : (node.nodeType == Node.COMMENT_NODE) ? "cc8"
            :                                        "cc3" ;

        if(!text) { text = n_str; em_class = "cc2"; }
        else      { text = ellipsis   ( text , 48); }

        result = ""
            + "<span class='log_node_toString'>"+ p_str                +"</span>"
            + " <em  class='"+em_class     +"'>"+ t_get_htmlEntities( text ) +"</em>"
        ;


    }
    catch(ex) { log(caller+": "+ex, "error"); }
    return result;
};


let get_h_tag = function(node_nodeName)
{
    let symbol;
    let   name;

    switch(node_nodeName) {
    case "#document"    : { symbol = "\u2622";      name = "document"   ; } break;
    case  "HTML"        : { symbol = "\u2AFC";      name = "HTML"       ; } break;
    case   "HEAD"       : { symbol = "\u265E";      name = "head"       ; } break;
    case   "BODY"       : { symbol = "\u26AB";      name = "body"       ; } break;

    case    "SCRIPT"    : { symbol = "\u2710";      name = "script"     ; } break;

    case    "DIV"       : { symbol = "\u2610";      name = "div"        ; } break;
    case    "BLOCKQUOTE": { symbol = "\u275D";      name = "blockquote" ; } break;
    case    "SPAN"      : { symbol = "\u2799";      name = "span"       ; } break;
    case    "SUP"       : { symbol = "\u2799";      name = "sup"        ; } break;
    case    "EM"        : { symbol = "\u2794";      name = "em"         ; } break;

    case    "A"         : { symbol = "\u27A4";      name = "a"          ; } break;
    case    "BUTTON"    : { symbol = "\u274D";      name = "button"     ; } break;
    case    "INPUT"     : { symbol = "\u270B";      name = "input"      ; } break;
    case    "TEXTAREA"  : { symbol = "\u2774";      name = "textarea"   ; } break;

    case    "TABLE"     : { symbol = "TA";          name = "table"      ; } break;
    case     "THEAD"    : { symbol = "TH";          name = "thead"      ; } break;
    case     "TFOOT"    : { symbol = "TF";          name = "tfoot"      ; } break;
    case     "TBODY"    : { symbol = "TB";          name = "tbody"      ; } break;
    case      "TR"      : { symbol = "tr";          name = "tr"         ; } break;
    case      "TH"      : { symbol = "th";          name = "th"         ; } break;
    case      "TD"      : { symbol = "td";          name = "td"         ; } break;

    case    "UL"        : { symbol = "UL";          name = "ul"         ; } break;
    case    "OL"        : { symbol = "OL";          name = "ol"         ; } break;
    case    "LI"        : { symbol = "\u26AC";      name = "li"         ; } break;

    default             : { symbol = node_nodeName; name = node_nodeName; } break;
    }
    return              "<em class='cc3'>"+symbol+"<sup class='fg0'>"+name+"</sup></em>";
};


let get_n_lbl = function(node)
{
    if(!node                 ) return "null_node";
    if( node == window       ) return "window";
    if( node == document.body) return "body";



    if(node.id    ) try { return       "#"+ node.id                                                   ; } catch(ex) {}
    if(node.title ) try { return "title=["+ node.title +"]"                                           ; } catch(ex) {}

    let                          n_lbl  = null;
    try                 {        n_lbl  = node.tagName +(node.className ? ("."+ node.className) : "") ; } catch(ex) {}
    if(   n_lbl )   try {        n_lbl += " .. TEXT=["+ truncate(node.textContent,  24)+"]"           ; } catch(ex) {}
    if(   n_lbl )         return n_lbl;

    try                 { return              "TEXT=["+ truncate(node.textContent,  24)+"]"           ; } catch(ex) {}
    try                 { return                                 node.tagName                         ; } catch(ex) {}
    try                 { return                                 node.nodeType                        ; } catch(ex) {}

    return "";
};


let get_n_str = function(node)
{
    let                h_tag = get_h_tag( node.nodeName );
    let                n_str = null;


    if( !n_str ) try { n_str =            h_tag                ;                              } catch(ex) {}
    if( !n_str ) try { n_str =            node.tagName         ;                              } catch(ex) {}
    if( !n_str ) try { n_str = get_t_str( node.nodeType       );                              } catch(ex) {}
    if( !n_str )       n_str = "";
    return             n_str;
};


let get_n_txt = function(node)
{
    if(!node) return "null_node";
    return strip_CR_LF( ellipsis(node.textContent.trim(), 64) );
};


let get_p_str = function(node)
{
    let names = "";

    for(let       parent  = node.parentNode
        ;         parent != null
        ;         parent  = parent.parentNode
    ) {
        let n_str         = get_n_str(parent);
        if( n_str) names  =            n_str            + names;

    }

    return names;
};


let get_t_str = function(node_nodeType)
{
    switch(node_nodeType)
    {
        case Node.ELEMENT_NODE               : return "ELEMENT"               ;
        case Node.TEXT_NODE                  : return "TEXT"                  ;
        case Node.PROCESSING_INSTRUCTION_NODE: return "PROCESSING_INSTRUCTION";
        case Node.COMMENT_NODE               : return "COMMENT"               ;
        case Node.DOCUMENT_NODE              : return "DOCUMENT"              ;
        case Node.DOCUMENT_TYPE_NODE         : return "DOCUMENT_TYPE"         ;
        case Node.DOCUMENT_FRAGMENT_NODE     : return "DOCUMENT_FRAGMENT"     ;

        case Node.ATTRIBUTE_NODE             : return "ATTRIBUTE"             ;
        case Node.CDATA_SECTION_NODE         : return "CDATA_SECTION"         ;
        case Node.ENTITY_REFERENCE_NODE      : return "ENTITY_REFERENCE"      ;
        case Node.ENTITY_NODE                : return "ENTITY"                ;
        case Node.NOTATION_NODE              : return "NOTATION"              ;

        default: return "[TYPE="+node_nodeType+"]";
    }
};


let get_id_or_tag = function(node)
{
    return !node           ? ("null_node"                        )
        :   node.id        ? ("#"+ node.id                       )
        :   node.className ? (node.tagName+"."+ node.classList[0])
        :                    (node.tagName                       )
    ;
};


let get_id_or_tag_and_className = function(node)
{
    let result
        = !node           ? ("null_node"                        )
        :  node.id        ? ("#"+ node.id                       )
        :  node.className ? (node.tagName+"."+ node.classList[0])
        :                   (node.tagName                       )
    ;
    return result+((node && node.className) ? (" "+node.className) : "");

};


let get_parentage = function(node)
{
    let names = get_id_or_tag(node);
    while(        node
              && (node != document.body)
              && (node != document.documentElement)
         ) {
        node            = node.parentNode;
        names           = get_id_or_tag(node)+" . "+names;
    }
    return names;
};


let get_el_parent_fragment = function(el)
{
    while( el ) {
        if(el.shadowRoot                             ) return el;
        if(el.nodeType == Node.DOCUMENT_FRAGMENT_NODE) return el;
        el              = el.parentNode;
    }
    return null;
};



let has_a_fixed_parent = function(el)
{
    while( el ) {
        if(window.getComputedStyle( el ).position == "fixed") return true;
        else                        el = el.parentElement;
    }
    return false;
};



let get_document_el_at_XY = function(x,y)
{

let   caller = "get_document_el_at_XY";
let log_this = LOG_MAP.T3_LAYOUT || LOG_MAP.T7_SHARE;

if( log_this) t_log.console_clear(caller);
if( log_this) log(caller+"("+x+" , "+y+")");


    let abs_nodes = get_abs_nodes();






    let              elements = document.elementsFromPoint(x , y);
if( log_this) t_log.console_dir("get_document_el_at_XY .. abs_nodes", abs_nodes);
if( log_this) t_log.console_dir("get_document_el_at_XY .. elements" , elements );

    let           shadow_root = get_shadow_root();
    let              el_at_XY;
    for(let i=0; i < elements.length; ++i)
    {

        let     el = elements[i];
        if( el.shadowRoot    )
        {

if( log_this) log("%c"+(i+1)+" SKIP: shadow_root %c "+get_n_lbl(el), lbL+lfX[i+1], lbH+lf3);
        }


        else if(  shadow_root && is_el_or_child_of_parent_el(el, shadow_root))
        {
            el = shadow_root.elementFromPoint(x,y);

if( log_this) log("%c"+(i+1)+" SKIP: shadow_root child %c "+get_n_lbl(el), lbL+lfX[i+1], lbH+lf3);
        }


        else if( has_a_fixed_parent(el) )
        {

if( log_this) log("%c"+(i+1)+" SKIP: ....fixed element %c "+get_n_lbl(el), lbL+lfX[i+1], lbF+lf2);
        }


        else if( abs_nodes.includes(el) ) {
if( log_this) log("%c"+(i+1)+" PICK: ...ABSOLUTE CHILD %c "+get_n_lbl(el), lbb+lbL+lfX[i+1], lbb+lbH+lfX[el_at_XY ? 9:4]);

            if(!el_at_XY) el_at_XY = el;
        }


        else {
if( log_this) log("%c"+(i+1)+" PICK: ...document child %c "+get_n_lbl(el), lbL+lfX[i+1], lbH+lfX[el_at_XY ? 9:4]);

            if(!el_at_XY) el_at_XY = el;
        }

    }


    if(!el_at_XY)
    {
if( log_this) log(caller+" .. document.elementFromPoint("+x+" "+y+") returned "+get_n_lbl(el_at_XY), lbF+lf2);

        el_at_XY = document.body;
    }

if( log_this) log("...return %c"+get_n_lbl(el_at_XY), lbH+lf4);
    return el_at_XY;
};


let     abs_nodes_cache;
let get_abs_nodes = function()
{
    if(!abs_nodes_cache)
        abs_nodes_cache = Array.from( document.querySelectorAll("[style*='position:absolute']") );
    return abs_nodes_cache;
};


let get_selector_nodes = function(selector)
{
    let nodes = Array.from( document.querySelectorAll(selector) );
t_log.console_dir(selector, nodes);
    return nodes;
};


let get_viewport_nodes = function()
{
    let nodes = Array.from( document.querySelectorAll("*[style*='position:absolute']") );
    return nodes;
};




let   remove_ads_result;


let t_REMOVE_ADS = function(id, _tag)
{
    if(!remove_ads_result)
        remove_ads_result = "";

    if( _tag ) {
        remove_ads_result += remove_ads_tag( _tag );
    }
    else {
        let tag;    let result;
        tag = "SCRIPT"; result = remove_ads_tag(tag); remove_ads_result += result + (result ? LF : "");
        tag = "IFRAME"; result = remove_ads_tag(tag); remove_ads_result += result + (result ? LF : "");
        tag = "INS"   ; result = remove_ads_tag(tag); remove_ads_result += result + (result ? LF : "");
    }

    if(typeof dom_tools !== "undefined")
    {
        let el = dom_tools.t_get_tool( id );
        if( el && (typeof dom_i18n !== "undefined")) el.title = i18n_get(dom_i18n.ADS_REMOVED);
    }



};


let t_REMOVE_ADS_results = function()
{
    return remove_ads_result;
};


let   remove_ads_tag = function(tag)
{

let   caller = "remove_ads_tag";
let log_this = DOM_UTIL_TAG || DOM_UTIL_LOG || LOG_MAP.T1_DOM_LOAD;


    let removed = 0;
    for(let pass = 1; pass <= 10; ++pass)
    {

        let node_list = document.getElementsByTagName(tag);
        if(!node_list || !node_list.length) break;


        for(let i=0; i < node_list.length; ++i)
        {
            let node = node_list[i];
            if( node.parentElement ) {
                node.parentElement.removeChild( node );
                removed += 1;
            }
        }

        if(!removed) break;
    }
    let results
        = removed
        ? removed+" "+tag+" removed"
        : "";

if( log_this) log(caller+": %c"+(results || "no "+tag+" tag to remove from page"), lbH+(removed ? lf7:lf8));

    return results;
};


let t_get_e_target_proxy = function(e_target)
{
    if( e_target.htmlFor                               ) return document.getElementById( e_target.htmlFor );

    if( e_target.parentElement &&
        e_target.parentElement.htmlFor                 ) return document.getElementById( e_target.parentElement.htmlFor );

    if( e_target.firstChild.nodeType != Node.TEXT_NODE ) return                          e_target.firstChild;

 return                          e_target;
};


let t_TEXT_LINES_to_COLORED_HTML = function(text_lines)
{
    let html = "";
    let    a =   text_lines.split(LF);
    for(let i=0;  i < a.length; ++i) {
        let    line = a[i];
        let num = get_num_in_string( line );
        if( num ) html += "<span class='fg"+(num % 10)+"'>"+line+"</span>"+LF;
        else      html +=                                   line          +LF;
    }
    return html;
};


let t_replace_initial_title = function(el, title) { if(!el.initial_title) el.initial_title = el.        title; el.title = title; };
let t_restore_initial_title = function(el       ) { if( el.initial_title) el.title         = el.initial_title;                   };




let get_id_or_node_path_tail = function(node_to) { return !node_to ? "null_node" : node_to.id || get_node_path_tail(node_to); };
let get_node_path_tail       = function(node_to) { return get_node_path(node_to, true); };
let get_node_path            = function(node_to, base_name_only)
{


    if(!node_to) return "";

    let node     = node_to;
    let node_csv = "";
    do {



        let skipped = 0;
        let num;
        for(num = 1; (node.parentElement) && (num <= node.parentElement.children.length); ++num)
        {
            let                    child  = node.parentElement.children[num-1];
            if(            node == child  ) break;

            if( is_a_doc_tool_node(child) ) skipped += 1;
        }


        let tag_num_str = _dom_hide_tag_num_to_str(node, (num-skipped), skipped);

        node_csv        = csv_ins(node_csv, tag_num_str);

        node = node.parentElement;
    }
    while(    node
          && (node != document.body)
          && (node != document.documentElement)
          && !base_name_only
         );
    let node_path = comma_to_vbar( node_csv );

    return node_path;
};


let get_node_path_target = function(node_path, log_num=8)
{

let caller = "get_node_path_target";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"%c"+node_path+")", lbL+lf3, lbR+lf9);


    let args = [""]; let s = "";
    if( log_this) {
        let lfn = lfX[log_num % 10];

        s += "%c"+log_num; args.push(lfn);
    }

    let node               = document.body;
    let node_tag_num_array = node_path.split("|");
    for(let s_num = 1; s_num <= node_tag_num_array.length; ++s_num)
    {
        let         node_tag_num = _dom_hide_str_to_tag_num( node_tag_num_array[s_num-1] );
        let              tag     = node_tag_num.tag;
        let                  num = node_tag_num.num;


        let     skipped = 0;
        for(let  c_num  = 1
            ;   (c_num <  node.children.length)
             && (c_num <= (skipped + num)     )
            ;    c_num += 1
           ) {
            let child = node.children[c_num-1];
            if( is_a_doc_tool_node( child ) ) {
                skipped += 1;
            }
if( log_this) add_el_class(child, "c_num_"+c_num+"_skipped_"+skipped);
        }

        let child_num = num + skipped;

        if( !(node = node.children[child_num-1])     ) break;


if( log_this) {
    s      +=     " %c "+tag+" %c"+num +(skipped ? " ("+skipped+" skipped ➔ "+(num+skipped)+")" : "");

    let lfs = lfX[s_num % 10];
    args.push( lbL+lfs);
    args.push(            lbR+lfs);
}

    }

if( log_this ) {
    let lfs = lfX[(1 + node_tag_num_array.length) % 10];
    s      +=  "%c...return "+get_node_txt_id_or_tag_path(node); args.push(lbH+lfs);
    args[0] = s;

    console.log.apply(console,                         ...args );
}

    return node;
};


let get_node_txt_id_or_tag_path = function(node)
{
    if(!node) return "null node";

    let       txt =      "["+ ellipsis_16( get_n_txt( node ) )+"]";

    let id_or_tag =           node.id
        ?               " #"+ node.id
        :               " " + node.tagName;

    let path =          " ["+ get_node_path( node ) +"]";

    return txt + mPadEnd(id_or_tag,10) + path;

};


let _dom_hide_tag_num_to_str = function(child, num)
{

    let  child_label = get_node_id_or_tag(child              );
    let parent_label = get_node_id_or_tag(child.parentElement);

    return    num
        +" "+ child_label
        +   " of"
        +" "+ parent_label

    ;
};


let _dom_hide_str_to_tag_num = function( node_tag_num )
{
    let words = node_tag_num.split(" ");

    let num   = parseInt( words[0]);


    let tag   =           words[3] ;

    return { tag , num };
};


let get_node_id_or_tag = function(el)
{
    if(!el) return "null_node";
    return el.id || el.tagName;
};




let get_el_anchor_in_view_array = function(root=document.body)
{

let   caller = "get_el_anchor_in_view_array("+get_id_or_tag(root)+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) console.time   (caller);
    let time_start = new Date().getTime();

    let anchor_in_view_array = [];
    let node;
    if(anchor_leaf_in_view_filter(root) == NodeFilter.FILTER_ACCEPT)
    {
if( log_this) log("root is a LEAF");
        anchor_in_view_array.push(root);
    }
    else {
        let treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, anchor_leaf_in_view_filter);
        while(node = treeWalker.nextNode())
            anchor_in_view_array.push(node);
    }
    let time_end = new Date().getTime();
if( log_this) console.timeEnd(caller);
if( log_this) t_log.console_dir("anchor_in_view_array", anchor_in_view_array);
    return { anchor_in_view_array , search_ms:(time_end - time_start) };
};


let anchor_leaf_in_view_filter = function(node)
{

let log_this = LOG_MAP.T3_LAYOUT || LOG_MAP.T7_SHARE;



    let why = NodeFilter.FILTER_ACCEPT;
    let why_not;
    if     ( has_el_class(node, "transcript"   ) ) { why = NodeFilter.FILTER_REJECT;  why_not =       "transcript"; }
    else if( has_el_class(node, "doc_tool"     ) ) { why = NodeFilter.FILTER_REJECT;  why_not =         "doc_tool"; }



    else if( node.tagName    == "SCRIPT"         ) { why = NodeFilter.FILTER_REJECT;  why_not =       node.tagName; }
    else if( node.tagName    == "STYLE"          ) { why = NodeFilter.FILTER_REJECT;  why_not =       node.tagName; }
    else if( is_marked_to_hide( node )           ) { why = NodeFilter.FILTER_REJECT;  why_not =   "MARKED_TO_HIDE"; }
    else if( node.style.display == "none"        ) { why = NodeFilter.FILTER_REJECT;  why_not =     "DISPLAY_NONE"; }



    else if( node.style.position == "fixed") { why = NodeFilter.FILTER_ACCEPT; }



    else if( node.children.length > 0            ) { why = NodeFilter.FILTER_SKIP  ;  why_not =     "HAS_CHILDREN"; }



    if(why != NodeFilter.FILTER_REJECT)
    {

        let bcr = node.getBoundingClientRect();
        if(node.children.length == 0)
        {
            if     (bcr.height < 1               ) { why = NodeFilter.FILTER_REJECT;  why_not =        "NO HEIGHT"; }
            else if(bcr.width  < 1               ) { why = NodeFilter.FILTER_REJECT;  why_not =         "NO WIDTH"; }
            else if(bcr.top > window.innerHeight ) { why = NodeFilter.FILTER_REJECT;  why_not =           "BELLOW"; }
            else if(bcr.bottom < 0               ) { why = NodeFilter.FILTER_REJECT;  why_not =            "ABOVE"; }
        }

        else if(    bcr.top > window.innerHeight ) { why = NodeFilter.FILTER_REJECT;  why_not = "CONTAINER BELLOW"; }



        else if(    bcr.bottom < 0               ) {

        }
    }


if(log_this && why_not) log("anchor_leaf_in_view_filter("+get_id_or_tag(node)+"): .. "+why_not);


    return why;
};


let not_an_anchor_target = function(node)
{

let   caller = "not_an_anchor_target";
let log_this = LOG_MAP.T3_LAYOUT || LOG_MAP.T7_SHARE;


    if(!node) return false;
    let      shadow_root = get_shadow_root();           let why_not = "";                 let lfx = lf8;


    if     ( node                == document.body.parentElement   ) { why_not = "HTML"                ;            }
    else if( node                == document.body                 ) { why_not = "BODY"                ;            }
    else if( node.nodeType       != Node.ELEMENT_NODE             ) { why_not = "NOT AN ELEMENT_NODE ";            }
    else if( node.tagName        == "STYLE"                       ) { why_not = "HAS A STYLE TAG"     ;            }
    else if( node.tagName        == "SCRIPT"                      ) { why_not = "HAS A SCRIPT TAG"    ;            }
    else if( node.shadowRoot                                      ) { why_not = "HAS A SHADOWROOT "   ;            }
    else if(!node.parentElement                                   ) { why_not = "HAS NO PARENT "      ;            }

    else if( node                == shadow_root                   ) { why_not = "SHADOW_ROOT"         ; lfx = lf6; }
    else if( node.id   && node.id.startsWith("select")            ) { why_not = "SELECT_TOOL"         ; lfx = lf5; }
    else if( has_el_class(node, dom_data.CSS_DOC_TOOL)            ) { why_not = "IS_A_TOOL"           ; lfx = lf3; }
    else if( has_el_class(node, dom_data.CSS_LINE_NUM)            ) { why_not = "IS_A_LINE_NUM"       ; lfx = lf3; }




if( log_this && (why_not != "") && (lfx != lf8)) log("%c"+caller+"%c"+why_not+"%c"+get_n_lbl(node)
                                                     ,lbb+lbH+lfx,lbL+lfx     ,lbR+lfX[node.id ? 3:8]);
    return why_not;
};




let is_a_doc_tool_button = function(node)
{
    return is_el_child_of_class(node,"transcript");
};


let is_a_doc_tool_panel = function(node)
{
    return node.classList.contains("transcript");
};


let is_el_child_of_id = function(el, id)
{
    while(el && (el.id != id) && (el = el.parentElement))
        ;
    return (el != null);
};


let is_el_child_of_class = function(el, className)
{
    while(el && !el.classList.contains(className))
        el = el.parentElement;

    return  el;
};


let is_el_or_child_of_class = function(el, className)
{
    while(el && !el.classList.contains(className))
        el     = el.parentElement;

    return el;
};


let is_el_or_child_of_parent_el = function(el, parent_el)
{
    if(!parent_el) return false;

    while(el && (el != parent_el))
        el     = el.parentElement;

    return (el == parent_el);
};



let get_child_num = function(child)
{
    for(let c = 0; c < child.parentElement.children.length; ++c) {
        if(child == child.parentElement.children[c])
            return c+1;
    }
    return 0;
};


let get_el_child_with_class = function(parent,className,level=1)
{
    if(!parent) return null;

    for(let c=0; c < parent.children.length; ++c) {

        let child  = parent.children[c];
        if((child != null) && has_el_class(child, className)) {


            return child;
        }


        if(child.children.length)
        {
            if( child = get_el_child_with_class(child, className, level+1)) {


                return child;
            }
        }

    }

    return null;
};


let get_el_child_with_tag = function(parent,tag)
{
    for(let     c  = 0; c < parent.children.length; ++c) {
        let child  = parent.children[c];
        if((child != null) && (child.tagName == tag))
            return child;
    }
    return null;
};


let get_el_child_with_id = function(parent,id)
{
    for(let     c  = 0; c < parent.children.length; ++c) {
        let child  = parent.children[c];
        if((child != null) && (child.id == id))
            return child;
    }
    return null;
};


let get_el_child_with_tag_class = function(parent,tag,className)
{
    let children_with_tag = parent.getElementsByTagName( tag );

    for(let     c  = 0; c < children_with_tag.length; ++c) {
        let child  = children_with_tag[c];
        if( has_el_class(child, className) )
            return child;
    }
    return null;
};


let get_el_child_with_tag_first_word = function(parent,tag,first_word)
{


    let children = parent.querySelectorAll( tag );

    for(let     c = 0; c < children.length; ++c) {
        let child        = children[c];
        if(!child) continue;
        let child_first_word  = get_first_word(child.innerText, "get_el_child_with_tag_first_word");

        if( child_first_word == first_word)
            return child;
    }
    return null;
};



let get_el_sibling_with_tag = function(el,tag)
{
    for(let     c  = 0; c < el.parentElement.children.length; ++c) {
        let child  =        el.parentElement.children[c];
        if((child != null) && (child.tagName == tag) && (child != el))
            return child;
    }
    return null;
};



let get_el_parent_clipped = function(el)
{
    while(  el ) {
        let cs = window.getComputedStyle(el);
        if( cs.clip
        && (cs.clip     != "auto")
        && (cs.clip     != "none")) return el;

        if( cs.clipPath
        && (cs.clip     != "auto")
        && (cs.clipPath != "none")) return el;

        el = el.parentElement;
    }
    return null;
};


let get_el_parent_with_class = function(el, className)
{
    while(   el ) {
        if(  el.classList.contains( className )) return el;
        el = el.parentElement;
    }
    return null;
};


let get_el_parent_with_id = function(el,id)
{
    if(                 !el              ) return el;
    if(                 !el.parentElement) return el;
    while(               el
          && (          !el.id
              || (id && (el.id != id))
             )
         )
        el = el.parentElement;

    return el;
};


let get_el_parent_with_display_none = function(el)
{
    while(   el ) {
        if(window.getComputedStyle(el).display == "none") return el;
        el = el.parentElement;
    }
    return null;
};


let get_el_parent_with_tag = function(el,tag)
{
    if( el.nodeName == "#text")
        el     = el.parentElement;

    while(el && (el.tagName != tag))
        el     = el.parentElement;

    if(    !el                        ) return null;
    return (         tag == el.tagName) ? el : null;
};



let get_el_in_view_up_from_el = function(from_el)
{

let   caller = "get_el_in_view_up_from_el";
let log_this = LOG_MAP.S1_RANGE || LOG_MAP.S2_SELECT;

if( log_this) log("%c"+caller+"("+get_n_lbl(from_el)+")", lbH);


    let node = from_el;
    while((    node.offsetWidth  == 0)
          && ( node.offsetHeight == 0))
        node = node.parentElement;

if( log_this && (node != from_el)) log("%c parent of No-dimension Node: node=["+get_n_lbl(node)+"]", lbH+lf3);



    if( not_an_anchor_target(node) )
        node = node.parentElement;

if( log_this && (node != from_el)) log("%c parent of TOOL Node: node=["+get_n_lbl(node)+"]", lbH+lf4);


    if(node == document.body.parentElement) node = document.body;

if( log_this && (node != from_el)) log("%c HTML down to BODY: node=["+get_n_lbl(node)+"]", lbH+lf4);


    if(!node) node = from_el;

if( log_this && (node == from_el)) log("%c returning from_el", lbH+lf0);

    return node;
};


let is_a_doc_tool_node = function(node)
{

let   caller = "is_a_doc_tool_node";
let log_this = LOG_MAP.T3_LAYOUT || LOG_MAP.T7_SHARE;


    if(!node) return false;                                let result = false;     let lfx = lf8;

    if( node.id && node.id.startsWith("select")            ) { result =      "SELECT"; lfx = lf5; }

if( log_this && result) log(caller+"%c"+result+"%c"+get_n_lbl(node), lbL+lfx, lbR+lf8);
    return result;
};



let add_el_class     = function(el, className) { if(!el || !el.classList) return      ; if(   !el.classList.contains( className )) el.classList.add   ( className ); };
let del_el_class     = function(el, className) { if(!el || !el.classList) return      ; if(    el.classList.contains( className )) el.classList.remove( className ); };
let set_el_class     = function(el, className) { if(!el || !el.classList) return      ;                                            el.className       = className  ; };
let has_el_class     = function(el, className) { if(!el || !el.classList) return false; return el.classList.contains( className );                                   };

let clear_el_classList = function(el_or_id, classList) { cycle_el_classList(el_or_id, classList, true); };
let cycle_el_classList = function(el_or_id, classList, remove_only)
{
    let el = (typeof               el_or_id == "object")
        ?                          el_or_id
        :  document.getElementById(el_or_id)
    ;

    let next_picked;
    for(let i=0; i <              classList.length; ++i) {
        if(el.classList.contains( classList[i] ))
        {
            el.classList.remove ( classList[i] );
            next_picked    =      classList[i+1];
        }
    }
    if( remove_only ) return undefined;


    if(!next_picked) next_picked = classList[0];



    if( next_picked) el.classList.add( next_picked );


    return next_picked;
};

let cycle_id_classList = cycle_el_classList;


let flip_el_class = function(el_or_id, className)
{
    let el = (typeof               el_or_id == "object")
        ?                          el_or_id
        :  document.getElementById(el_or_id)
    ;
    if( has_el_class(el, className) ) del_el_class(el, className);
    else                              add_el_class(el, className);
};

let flip_id_class = flip_el_class;


let set_el_class_on_off = function(el, className, on_off)
{
    if(on_off) add_el_class(el, className);
    else       del_el_class(el, className);

};


let set_el_class_removing = function(el_or_id, class_to_add, classes_to_remove)
{
    if(       typeof      classes_to_remove != "object") classes_to_remove = [ classes_to_remove ];

    let el = (typeof               el_or_id == "object")
        ?                          el_or_id
        :  document.getElementById(el_or_id)
    ;
    if(!el) return false;

    let removed = "";
    for(let i=0; i <               classes_to_remove.length; ++i)
    {
        if( el.classList.contains( classes_to_remove[i] )) {
            el.classList.remove  ( classes_to_remove[i]  );
            removed =              classes_to_remove[i]   ;
        }
    }


    if( class_to_add )
    {
        if(!el.classList.contains( class_to_add ))
            el.classList.add     ( class_to_add );
    }

    return removed;
};


let is_marked_to_hide = function( node )
{
    return has_el_class(node, dom_data.MARKED_TO_HIDE);

};




let selectNodeContents = function(el)
{

let   caller = "selectNodeContents";
let log_this = LOG_MAP.S1_RANGE;

if( log_this) log_caller();

    try {
        let range = document.createRange();

        range.selectNodeContents( el );

        window.getSelection().addRange( range );
    }
    catch(ex) { log(caller+": "+ex, "error"); }
};


let clearSelection = function()
{
    let                       selection = window.getSelection();
    let                       selection_text = selection.toString();
    try {                     selection.removeAllRanges(); } catch(ex) { log("clearSelection: "+ex, "error"); }


    return selection_text;
};


let log_range = function(range, _caller="")
{
    if(!range) {
        log(_caller+": range=["+range+"]");
        return;
    }

    log_key_val_group(_caller
                      ,{ document_caretPositionFromPoint : typeof document.caretPositionFromPoint
                       ,    document_caretRangeFromPoint : typeof document.caretRangeFromPoint
                       ,                    typeof_range : typeof range

                       ,            range_startContainer : range.startContainer
                       ,               range_startOffset : range.startOffset
                       ,      startContainer_textContent : get_range_textContent(range.startContainer)

                       ,              range_endContainer : range.endContainer
                       ,                 range_endOffset : range.endOffset
                       ,        endContainer_textContent : get_range_textContent(range.  endContainer)

                       ,                 range_collapsed : range.collapsed
                       ,                 node_type       : get_range_node_type(range)
                       ,                range_offsetNode : range.offsetNode
                       ,                           range
                      }, lf7, false);
};

let get_range_textContent = function(node)
{
    return node
        ? strip_CR_LF( ellipsis(node.textContent.trim(), 64) )
        : ""
    ;
};

let get_range_node_type = function(range)
{
    let node = (range.startContainer || range.offsetNode);
    return node
        ? node.nodeName
        : "null node"
    ;
};







const HORIZONTAL_ELLLIPSIS = "\u2026";
const ELLIPSIS_DEFAULT_LEN = 96;
const ELLIPSIS_SHORT_LEN   = 48;

let ellipsis_16 = function(msg)
{
    return mPadEnd( ellipsis(msg, 16) , 16);
};

let ellipsis_short = function(msg)
{
    return ellipsis(msg, ELLIPSIS_SHORT_LEN);
};

let ellipsis = function(_msg, len=ELLIPSIS_DEFAULT_LEN)
{
    let msg = show_CR_LF( String(_msg) );
    return (msg.length    <= len)
        ?   msg
        :   msg.substring(0, len-3)+HORIZONTAL_ELLLIPSIS
    ;
};


let truncate = function(_msg, length=80)
{
    let msg = strip_CR_LF( String(_msg) );
    return (msg.length <= length)
        ?   msg
        :   msg.substring(0, length-3)+"..."
    ;
};


let mPadStart = function(s,l,c=" ") { s = String(s); while(s.length < l) s = c+s; return s; };

let mPadEnd   = function(s,l,c=" ") { s = String(s); while(s.length < l) s = s+c; return s; };



let isAlNum = function(s)
{
    let      cp  = s.codePointAt(0);

    return ((cp >=   48 ) && (cp <=  57))
        || ((cp >=   65 ) && (cp <=  90))
        || ((cp ==   95 )               )
        || ((cp >=   97 ) && (cp <= 122))
        || ((cp >=   192) && (cp <= 214))
        || ((cp >=   214) && (cp <= 246))
        || ((cp >=   248) && (cp <= 255))
    ;
};





let is_hex_string = function(s)
{
    for(let i = 0; i < s.length; ++i)
    {
        let cp       = s.codePointAt(i);

        if( !(   ((cp >=   48 ) && (cp <=  57))
              || ((cp >=   65 ) && (cp <=  70))
              || ((cp >=   97 ) && (cp <= 102))
             )
          )
            return false;
    }
    return true;
};


let object_label = function(object)
{
    return object.toString()
        .replace("[object ","")
        .replace(       "]","");
};



let btoa_msg = function(msg)
{
    if(!msg) return "";

    try {

        msg = btoa(unescape(encodeURIComponent(msg)));
    }
    catch(ex) {
        if(DOM_UTIL_LOG || DOM_UTIL_TAG)
        {
            log("%c btoa("+msg+"):"+LF+ex, lf3);
            log_caller();
        }
    }

    return msg;
};


let atob_msg = function(msg)
{
    if(!msg) return "";

    try {

        msg = decodeURIComponent(escape(atob(msg)));
    }
    catch(ex) {
        if(DOM_UTIL_LOG || DOM_UTIL_TAG)
        {
            log("%c"+"atob(msg):",lbH+lf3);
            log("%c"+msg         ,lb3    );
            log("%c"+ex          ,    lf3);
            log_caller();
            log("%c Returning received msg (unchanged)", lbH+lf3);
        }
    }

    return msg;
};


let unicode_to_charCode = function(u_str)
{
    return String.fromCharCode( parseInt( u_str.charCodeAt(0) ) );
};


let rect_toString = function(r)
{
    return       parseInt(r.x    ) +"@"+ parseInt(r.y     )
        +" .. "+ parseInt(r.width) +"x"+ parseInt(r.height)
    ;
};


let string_to_ms = function(s)
{
    let ms
        = (s.indexOf("ms") > 0)
        ?  parseInt(s)
        :  1000 * parseFloat(s)
    ;
    return ms;
};


let string_to_utf8 = function(s)
{
    let result      = "";
    let non_ascii;
    for(let       i = 0; i < s.length; ++i)
    {
        let      cp = s.codePointAt( i );
        let       u = (cp < 128) ? s[i] : "&#x"+cp.toString(16)+";";
        result += u;

        non_ascii = non_ascii || (cp >= 128);
    }


    return result;
};


let string_to_ascii = function(s)
{
    let non_ascii;
    let result = "";
    for(let  i = 0; i < s.length; ++i)
    {
        if(               (s[i  ] == "&")
           &&             (s[i+1] == "#"))
        {
            non_ascii   =  true;
            let hex_fmt = (s[i+2] == "x");

            let      ss =  s.substr(i);
            let     id0 =  hex_fmt ? 3 : 2;
            let     id1 =  ss.indexOf(";");
            let     str =  ss.substr(id0, id1-id0);
            let      cp =  parseInt(str, hex_fmt ? 16 : 10)
                ||         parseInt(str,           16     );

            let       c =  String.fromCodePoint( cp );
            result     +=  c;

            i          += id1;


        }
        else {
            result += s[i];
        }
    }


    return result;
};






const APOST_ASC = "'";

const APOST_HTM = "&apos;";
const regexp_APOST_ASC          = new RegExp(APOST_ASC                      , "g");
const regexp_APOST_HTM          = new RegExp(APOST_HTM                      , "g");

const COMMA_ASC = ",";

const COMMA_HTM = "&comma;";
const regexp_COMMA_ASC          = new RegExp(COMMA_ASC                      , "g");
const regexp_COMMA_HTM          = new RegExp(COMMA_HTM                      , "g");



const regexp_CR                 = new RegExp("\\r"                          , "g");
const regexp_LF                 = new RegExp("\\n"                          , "g");
const regexp_LF2                = new RegExp("\\n{2,}"                      , "g");
const regexp_AN                 = new RegExp("[^a-z_ A-Z0-9]"               , "g");
const regexp_SFX                = new RegExp("_\\d+$"                       , "g");


const regexp_PERCENT_C          = new RegExp(" ?%c ?"                       , "g");
const regexp_TAG_HOUR           = new RegExp(":\\d(\\d)h", "i");


const regexp_BACKSLASH          = new RegExp("\\\\"                         , "g");
const regexp_BRACKET_C          = new RegExp("\\]"                          , "g");
const regexp_BRACKET_O          = new RegExp("\\["                          , "g");
const regexp_COLON              = new RegExp(":"                            , "g");
const regexp_COMMA              = new RegExp(" *, *"                        , "g");
const regexp_NBSP               = new RegExp("&nbsp;"                       , "g");
const regexp_SPACE              = new RegExp(" +"                           , "g");
const regexp_UL                 = new RegExp(  "_"                          , "g");
const regexp_ULX                = new RegExp("__+"                          , "g");
const regexp_UNDERLINE          = new RegExp("_"                            , "g");
const regexp_UNDERLINE_UTF8     = new RegExp("\\{U\\+005F\\}"               , "g");
const regexp_VBAR               = new RegExp("\\|"                          , "g");
const regexp_eacute_to_char     = new RegExp("\\xE9"                        , "g"); let char_eacute = String.fromCharCode(0xE9);
const regexp_eacute_to_hex      = new RegExp(String.fromCharCode(0xE9)      , "g"); let hex_eacute = "\\xE9";
const regexp_egrave_to_char     = new RegExp("\\xE8"                        , "g"); let char_egrave = String.fromCharCode(0xE8);
const regexp_egrave_to_hex      = new RegExp(String.fromCharCode(0xE8)      , "g"); let hex_egrave = "\\xE8";
const regexp_mS                 = new RegExp("\\s{2,}"                      , "g");





const regexp_FIRST_WORD         = new RegExp("(\\w+)"                                   , "i");
const regexp_HEADS              = new RegExp("^\\w\\s"                                       );
const regexp_HLEAD              = new RegExp("\\[\\s*\\["                               , "g");
const regexp_HTAIL              = new RegExp("\\]\\s*\\]"                               , "g");
const regexp_HWORD              = new RegExp("\\b(html)\\b"                             , "g");


const regexp_NOWRD              = new RegExp("[^0-9~A-Za-z\\xC0-\\xFF]+"                , "g");


const regexp_EM_C               = new RegExp(" *</em[^>]*>"                             , "g");
const regexp_EM_O               = new RegExp("<em[^>]*> *"                              , "g");
const regexp_ENTT               = new RegExp("&\\w+;"                                   , "g");
const regexp_EOL                = new RegExp("<(ol|ul|/li|/div|br|pre)>"                , "g");
const regexp_HTML               = new RegExp("<[^>]*>"                                  , "g");




let trim_WORDS = function(text)
{
    return text

        .   replace(regexp_NOWRD  , " ")
        .trim()
    ;
};


let trim_alNum_lines = function(textContent)
{
    return trim_empty_lines(textContent, true);
};



let trim_empty_lines = function(textContent, alnum_filter=false)
{
    let caller = "trim_empty_lines";
    let text = "";
    try {
        if(textContent)
        {

            text = strip_CR_LF( textContent.trim() );


            if(alnum_filter)
                text = text
                    .  replace(regexp_AN, " ")

                    ;


            text = text
                .  replace(regexp_mS, " ")
                ;

            if(text > 32)
                text = ellipsis(text, 32);
        }
    }
    catch(ex) { log(caller+": "+ex, "error"); }
    return text.trim();
};


let trim_node_textContent = function(node)
{

    return strip_CR_LF( ellipsis(node.textContent.trim(), 64) );
};


let trim_space_lf = function(text)
{
    if(!text) return text;

    while(text.startsWith(" ") || text.startsWith(LF)) text = text.substring(1, text.length  );
    while(text.  endsWith(" ") || text.endsWith  (LF)) text = text.substring(0, text.length-1);

    return text;
};





let strip_CR_LF = function(text)
{
    return text
        .   replace(regexp_CR,  "")
        .   replace(regexp_LF, " ")
        .   trim()
    ;
};


let show_CR_LF = function(text)
{
    return text
        .   replace(regexp_CR,  "")
        .   replace(regexp_LF, t_data.SYMBOL_DOWN_LEFT_ARROW)
        .   trim()
    ;
};


let strip_el_id_suffix = function(text)
{
    return text
        .   replace(regexp_SFX,  "")
    ;
};


let strip_UL = function(text)
{
    return text
        .   replace(regexp_ULX, LF    )
        .   replace(regexp_UL , " "   )
        .   trim()
    ;
};



let strip_console_formatting = function(text)
{
    return text
        .   replace(regexp_PERCENT_C, "")
        .trim()
    ;
};



let strip_HTML = function(text)
{
    if(   !text) return "";
    return text
        .   replace(regexp_EM_O , "["         )
        .   replace(regexp_EM_C , "] "        )
        .   replace(regexp_EOL  , LF          )
        .   replace(regexp_LF2  , LF          )
        .   replace(regexp_HTML , " "         )
        .   replace(regexp_SPACE, " "         )
        .   replace(regexp_NBSP , " "         )
        .   replace(regexp_ENTT , t_data.SYMBOL_EMPTY)
        .   replace(regexp_HLEAD, "["         )
        .   replace(regexp_HTAIL, "]"         )

        .trim()
    ;
};


const regexp_BR                 = new RegExp("<br>"          , "ig");
const regexp_BR_DIV_O           = new RegExp("<br><div>"     , "ig");
const regexp_DIV_O              = new RegExp("<div>"         , "ig");
const regexp_DIV_C              = new RegExp("</div>"        , "ig");

const regexp_PRE_O              = new RegExp(  "<pre[^>]*>"  , "ig");
const regexp_PRE_C              = new RegExp("<\/pre>"       , "ig");
const regexp_SPAN_O              = new RegExp(  "<span[^>]*>", "ig");
const regexp_SPAN_C              = new RegExp("<\/span>"     , "ig");

let strip_contentEditable = function(text)
{


    if(   !text) return "";
    let result
    = text
        .   replace(regexp_BR_DIV_O , LF)
        .   replace(regexp_BR       , LF)
        .   replace(regexp_DIV_O    , LF)
        .   replace(regexp_DIV_C    , "")
        .   replace(regexp_PRE_O    , "")
        .   replace(regexp_PRE_C    , "")
        .   replace(regexp_SPAN_O   , "")
        .   replace(regexp_SPAN_C   , "")
        .trim()
    ;


    return result;
};


let strip_pat = function(text, str)
{
    if(typeof text == "undefined") return text;

    let regexp_char = new RegExp(str, "g");
    return text
        .   replace(regexp_char,  "")
        .   trim()
    ;
};


let strip_to_lines = function(text)
{
    if(!text) return text;
    return "- "+text
        .   replace(regexp_BRACKET_O, LF)
        .   replace(regexp_COMMA    , LF+"- ")
        .   replace(regexp_BRACKET_C, "")
    ;
};




let bracket_to_em = function(text)
{
    return text
        .   replace(regexp_BRACKET_O,  "<em>")
        .   replace(regexp_BRACKET_C, "</em>")
    ;
};


let comma_to_vbar = function(text)
{
    return text
        .   replace(regexp_COMMA_ASC, "|")
    ;
};



let escapeHTML_chars
    = {   "<"                   : "&lt;"
        , ">"                   : "&gt;"
        , "&"                   : "&amp;"
        , '"'                   : "&quot;"
        , "'"                   : "&apos;"
    };


let escapeHTML = function (text)
{
    let result = text.replace(/[<>&"]/g, function(character) { return escapeHTML_chars[character]; });
    return result;
};


let escape_CR_LF = function(text)
{
    return text
        .   replace(regexp_CR, t_data.SYMBOL_CR   )
        .   replace(regexp_LF, t_data.SYMBOL_LF+"<br>"+LF)
        .   trim()
    ;
};


let escape_LF_BR = function(text)
{
    return text
        .   replace(regexp_CR, ""       )
        .   replace(regexp_LF, "<br>"+LF)
        .   trim()
    ;
};


let encode_LF = function(text)
{
    return text
        .   replace(regexp_CR, "")
        .   replace(regexp_LF, t_data.SYMBOL_LF)
        .   trim()
    ;
};


let underline_from_utf8 = function(text)
{
    return text
        .   replace(regexp_UNDERLINE_UTF8, "_")
    ;
};


let underline_to_space = function(text)
{
    return text
        .   replace(regexp_UNDERLINE,  " ")
    ;
};


let vbar_to_LF = function(text, prefix="")
{
    return prefix
        +  text
        .   replace(regexp_VBAR, LF+prefix)
    ;
};


let vbar_to_QUOTED_LINES = function(text)
{
    return '"'
        +  text
        .   replace(regexp_VBAR, '"'+LF+'"')
        +  '"'
    ;
};


let vbar_to_BR = function(text, prefix="")
{
    return text
        .   replace(regexp_VBAR, "<br>"+LF+prefix)
    ;
};


let vbar_to_comma = function(text)
{
    return text
        .   replace(regexp_VBAR, ",")
    ;
};



let vbar_to_up_arrow = function(text)
{
    return text
        .   replace(regexp_VBAR, t_data.SYMBOL_UP_ARROW)
    ;
};


let comma_to_LF = function(text, prefix="")
{
    return prefix
        +  text
        .   replace(regexp_COMMA, LF+prefix)
    ;
};




let character_entities_to_char = function(text)
{
    return text
        .   replace(regexp_eacute_to_char, char_eacute)
        .   replace(regexp_egrave_to_char, char_egrave)
    ;
};


let character_entities_to_hex = function(text)
{
    return text
        .   replace(regexp_eacute_to_hex, hex_eacute)
        .   replace(regexp_egrave_to_hex, hex_egrave)
    ;
};



const regexp_HTML_ENTITIES = new RegExp("[\\u00A0-\\u9999<>\\&']", "gim");

let t_get_htmlEntities = function(str)
{

    return str.replace(regexp_HTML_ENTITIES, function(c) { return "&#"+c.charCodeAt(0)+";"; });
};




let get_first_word = function(text, _caller)
{
let log_this = LOG_MAP.S1_RANGE;

    regexp_FIRST_WORD.lastIndex = 0;

    let matches = regexp_FIRST_WORD.exec( text );

    let  result = (matches) ? matches[0] : "";

if( log_this) log("get_first_word(text=["+text+"], caller=["+_caller+"]): "+ regexp_FIRST_WORD +" .. return ["+result+"]");
    return result;
};


let get_tag_hour = function(text)
{
let log_this = LOG_MAP.S1_RANGE;

    regexp_TAG_HOUR.lastIndex = 0;

    let matches = regexp_TAG_HOUR.exec( text );

    let  result = (matches) ? matches[1] : "0";

if(log_this) log("get_tag_hour("+ text +"): "+ regexp_TAG_HOUR +" .. return ["+result+"]");
    return result;
};



let tokenize = function(text, sep=" ")
{
    return text
        .   replace(regexp_NOWRD    , sep)
        .   replace(regexp_BRACKET_O,  "")
        .   replace(regexp_BACKSLASH,  "")
        .   replace(regexp_BRACKET_C,  "")
        .   replace(regexp_HWORD    ,  "")
        .   replace(regexp_HEADS    ,  "")
        .   replace(regexp_CR       ,  "")
        .   replace(regexp_LF       , " ")
        .   trim(                        )
        .   replace(regexp_SPACE    , "_")
    ;
};




const regexp_DIGITS = new RegExp("\\d");

let get_num_in_string = function(s)
{
        let matches = s.match(regexp_DIGITS);
        return        matches ? matches[0] : 9;
};


const regexp_NUMBER = new RegExp("\\d+");

let get_int_in_string = function(s)
{
        let matches = s.match(regexp_NUMBER);
        return        matches ? matches[0] : 9;
};





let csv_add = function(csv, val)
{

    if(                     !val  ) return csv;
    val = csv_escape(val);
    if(             !csv          ) return val;
    if( csv_contains(csv,    val) ) return csv;

    return           csv+","+val;
};


let csv_ins = function(csv, val)
{

    if(                     !val  ) return csv;
    val = csv_escape(val);
    if(             !csv          ) return val;
    if( csv_contains(csv,    val) ) return csv;

    return           val+","+csv;
};


let csv_cat = function(csv1, csv2)
{
    if(  !csv1) return csv2;
    if(  !csv2) return csv1;
    let   csv = csv1;
    let     v = csv2.split(",");
    for(let i = 0; i < v.length; ++i)
    {
        if(!csv_contains(csv, v[i]) )
            csv      += "," + v[i];
    }
    return csv;
};



let csv_get = function(csv,pos)
{
    if(!csv || !pos) return "";
    let   val = "";
    let     v = csv.split(",");
    for(let i = 0; i < v.length; ++i)
        if((i+1) == pos) { val = v[i]; break; }

    val = csv_unescape(val);

    return val;
};



let csv_count = function(csv)
{
    if(!csv) return 0;

    return csv.split(",").length;
};



let csv_contains = function(csv, val)
{

    return (csv_pos(csv,val) > 0);
};


let csv_pos = function(csv,val)
{
    if(       !val) return 0;
    if(!csv       ) return 0;


    let csv_no_sfx  =            pattern_del_words_option_sfx(csv);
    let val_no_sfx  = csv_escape(pattern_del_words_option_sfx(val));
    if( val_no_sfx == csv_no_sfx) return 1;

    let a = csv.split(",");
    for(let i=0; i < a.length; ++i)
    {
        let       a_i = pattern_del_words_option_sfx(a[i]);
        if(val_no_sfx == a_i ) return (i+1);
    }

    return 0;
};



let csv_del = function(csv,val)
{
    if(       !val) return csv;
    if(!csv       ) return csv;


    let csv_no_sfx =            pattern_del_words_option_sfx(csv);
    let val_no_sfx = csv_escape(pattern_del_words_option_sfx(val));


    if( csv_no_sfx == val_no_sfx)
    {
       csv  = "";
    }
    else {
        val_no_sfx = csv_escape(val_no_sfx);


        let a = csv.split(",");
        csv = "";
        for(let i=0; i < a.length; ++i) {
            let item_no_sfx = pattern_del_words_option_sfx(a[i]);

            if(              !item_no_sfx) continue;
            if( val_no_sfx == item_no_sfx) continue;

            if(!csv)  csv  =     a[i];
            else      csv += ","+a[i];
        }
    }


    return csv;
};


let csv_del_last = function(csv)
{
    if(!csv       ) return csv;


        let a = csv.split(",");
        csv = "";
        for(let i=0; i < (a.length-1); ++i) {
            let       a_i  =     a[i];
            if(!csv)  csv  =     a_i;
            else      csv += ","+a_i;
        }


    return csv;
};


let csv_slice_head         = function(csv, length_max) { return csv_slice_head_or_tail(csv, length_max,  true); };
let csv_slice_tail         = function(csv, length_max) { return csv_slice_head_or_tail(csv, length_max, false); };
let csv_slice_head_or_tail = function(csv, length_max, head_or_tail)
{
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

    if(!csv)                    return csv;

    let a = csv.split(",");
    if( a.length <= length_max) return csv;



    let head_part = head_or_tail ?  a.length_max -length_max :               -length_max;
    let tail_part = head_or_tail ?               -length_max :  a.length_max -length_max;

    let head = a.slice(head_part);
    let tail = a.slice(tail_part);



    let head_csv = "";
    for(let i=0; i < (head.length-1); ++i) {
        if(!head_csv) head_csv  =     head[i];
        else          head_csv += ","+head[i];
    }

    let tail_csv = "";
    for(let i=0; i < (tail.length-1); ++i) {
        if(!tail_csv) tail_csv  =     tail[i];
        else          tail_csv += ","+tail[i];
    }


    let result
        = {        csv : (head_or_tail ? head_csv : tail_csv )
            , overflow : (head_or_tail ? tail_csv : head_csv )
        };


if(log_this) {
    log_key_val_group( "csv_slice_head_or_tail"
                       , {               csv
                           ,      length_max
                           ,    head_or_tail
                           ,        a_length : a.length
                           ,       head_csv
                           ,       tail_csv
                           ,      result_csv : result.csv
                           , result_overflow : result.overflow
                       }
                       , lf9
                       , false
                     );
}

    return result;

};



let csv_sort = function(csv, reverse=false)
{
    if(  !csv) return csv;


    let     v = csv.split(",");
    if(reverse) v = v.sort( function(a, b) { return a.toLowerCase() > b.toLowerCase() ? -1 : 1; } );
    else        v = v.sort( function(a, b) { return b.toLowerCase() > a.toLowerCase() ? -1 : 1; } );

    csv = "";
    for(let i = 0; i < v.length; ++i) {
        csv += (csv ? "," : "")+ v[i];
    }

    return csv;
};


let csv_reverse = function(csv)
{
    return csv_sort(csv, true);
};



let csv_escape = function(text)
{
    return text
        .   replace(regexp_COMMA_ASC, COMMA_HTM)
        .   replace(regexp_APOST_ASC, APOST_HTM)
    ;
};

let csv_unescape = function(text)
{
    return text
        .   replace(regexp_COMMA_HTM, COMMA_ASC)
        .   replace(regexp_APOST_HTM, APOST_ASC)
    ;
};


let csv_log = function(csv, title="")
{
    if(title) {
        if(csv) log("%c "+title                   , lbb+lbH+lf9         );
        else    log("%c "+title+LF+"%c IS  EMPTY ", lbb+lbH+lf9, lbA+lb8);
    }

    if(!csv) return;

    let count = csv_count(csv);

    for(let i = 0; i < count; ++i) {
        let v = csv_get(csv,i+1);
        let u = unescape(v);
        if( u == v) log(" "+(i+1)+" %c["+v+"]"                   , lbX[(i+1) % 10]     );
        else        log(" "+(i+1)+" %c["+v+"]%c unescape=["+u+"]", lbX[(i+1) % 10], lb0);
    }
};



let pattern_del_words_option_sfx = function(pattern)
{

    let result
    =   (typeof dom_tools !== "undefined")
    ?           dom_tools.t_pattern_del_words_option_sfx( pattern )
    :                                                     pattern
    ;

    return result;
};




let get_el_title = function(el)
{
    if(!el) return "";

    while( el ) {
        if(el.title                   ) return el.title;
        if(el.attributes["data-title"]) return el.attributes["data-title"].textContent;

        el =       el.parentElement;
    }

    return "";
};


let get_id_caption = function(el_id, caption)
{

let   caller = "get_id_caption";
let log_this = DOM_UTIL_TAG || DOM_UTIL_LOG || LOG_MAP.T1_DOM_LOAD;




    el_id = strip_el_id_suffix( el_id );

    let el_caption_lang = get_el_caption_lang(el_id, log_this);

    if(!el_caption_lang) {
        if(!caption && el_id) el_caption_lang = i18n_get(el_id);
    }


    if(!el_caption_lang) {
        log("%c"+caller+"("+el_id+"%c"+dom_i18n.user_lang+" %c IS MISSING", lbb+lbL+lf6, lbb+lbC+lf3, lbb+lbR+lf3);
log_caller(2);
    }


    if( caption )
        el_caption_lang += LF + caption;


if(log_this)
    log("%c"+caller+"("+el_id+", caption=["+caption+"], user_lang=["+dom_i18n.user_lang+"]): ...el_caption_lang %c"+el_caption_lang, lf7, lbH+lf7);
    return el_caption_lang;
};


let get_el_caption_lang = function(el_id, log_this)
{

let   caller = "get_el_caption_lang";


    let el_caption_lang;


    if(typeof dom_i18n === "undefined")
    {
        el_caption_lang = el_id;
    }

    else {

        if     (el_id == "pat_bag"              ) el_caption_lang = i18n_get(dom_i18n.PAT_BAG           , el_id);
        else if(el_id == "sel_bag"              ) el_caption_lang = i18n_get(dom_i18n.SEL_BAG           , el_id);

        else if(el_id == "headsup_w"            ) el_caption_lang = i18n_get(dom_i18n.HEADSUP_W         , el_id);
        else if(el_id == "headsup"              ) el_caption_lang = i18n_get(dom_i18n.HEADSUP           , el_id);
        else if(el_id == "headsup_ds"           ) el_caption_lang = i18n_get(dom_i18n.HEADSUP_DS        , el_id);
        else if(el_id == "dom_traversal"        ) el_caption_lang = i18n_get(dom_i18n.DOM_TRAVERSAL     , el_id);
        else if(el_id == "headsup_bw"           ) el_caption_lang = i18n_get(dom_i18n.HEADSUP_BW        , el_id);
        else if(el_id == "headsup_bz"           ) el_caption_lang = i18n_get(dom_i18n.HEADSUP_BZ        , el_id);
        else if(el_id == "headsup_fs"           ) el_caption_lang = i18n_get(dom_i18n.HEADSUP_FS        , el_id);
        else if(el_id == "test_panel"           ) el_caption_lang = i18n_get(dom_i18n.TEST_PANEL        , el_id);
        else if(el_id == "dev_log_map"          ) el_caption_lang = i18n_get(dom_i18n.DEV_LOG_MAP       , el_id);
        else if(el_id == "transcript1"          ) el_caption_lang = i18n_get(dom_i18n.TRANSCRIPT1       , el_id);
        else if(el_id == "transcript2"          ) el_caption_lang = i18n_get(dom_i18n.TRANSCRIPT2       , el_id);
        else if(el_id == "dom_load_tags"        ) el_caption_lang = i18n_get(dom_i18n.DOM_LOAD_TAGS     , el_id);

        else if(el_id == "alt_bag"              ) el_caption_lang = i18n_get(dom_i18n.ALT_BAG           , el_id);
        else if(el_id == "bak_bag"              ) el_caption_lang = i18n_get(dom_i18n.BAK_BAG           , el_id);
        else if(el_id == "off_bag"              ) el_caption_lang = i18n_get(dom_i18n.OFF_BAG           , el_id);
        else if(el_id == "bag_rot"              ) el_caption_lang = i18n_get(dom_i18n.BAG_ROT           , el_id);
        else if(el_id == "words_bag_rot"        ) el_caption_lang = i18n_get(dom_i18n.BAG_ROT           , el_id);
        else if(el_id == "bagopen"              ) el_caption_lang = i18n_get(dom_i18n.BAGOPEN           , el_id);
        else if(el_id == "bag_log"              ) el_caption_lang = i18n_get(dom_i18n.BAG_LOG           , el_id);
        else if(el_id == "pat_sort"             ) el_caption_lang = i18n_get(dom_i18n.SORT_SELECTION    , el_id);

        else if(el_id == "fly_log"              ) el_caption_lang = i18n_get(dom_i18n.FLY_LOG           , el_id);

        else if(el_id == "scroll_smooth"        ) el_caption_lang = i18n_get(dom_i18n.SCROLL_SMOOTH     , el_id);
        else if(el_id == "user_lang"            ) el_caption_lang = i18n_get(dom_i18n.USER_LANG         , el_id);
        else if(el_id == "dom_freeze"           ) el_caption_lang = i18n_get(dom_i18n.DOM_FREEZE        , el_id);
        else if(el_id == "anchor_freeze"        ) el_caption_lang = i18n_get(dom_i18n.ANCHOR_FREEZE     , el_id);
        else if(el_id == "containers_hi"        ) el_caption_lang = i18n_get(dom_i18n.CONTAINERS_HI     , el_id);
        else if(el_id == "deny_or_allow"        ) el_caption_lang = i18n_get(dom_i18n.DENY_OR_ALLOW     , el_id);
        else if(el_id == "dom_hide1_reset"      ) el_caption_lang = i18n_get(dom_i18n.DOM_HIDE1_RESET   , el_id);
        else if(el_id == "dom_hide1_undo"       ) el_caption_lang = i18n_get(dom_i18n.DOM_HIDE1_UNDO    , el_id);
        else if(el_id == t_data.EDIT_OR_STAGE   ) el_caption_lang = i18n_get(dom_i18n.EDIT_OR_STAGE     , el_id);
        else if(el_id == "log_seekspot"         ) el_caption_lang = i18n_get(dom_i18n.LOG_SEEKSPOT      , el_id);

        else if(el_id == "remove_ads"           ) el_caption_lang = i18n_get(dom_i18n.REMOVE_ADS        , el_id);
        else if(el_id == "split_wot"            ) el_caption_lang = i18n_get(dom_i18n.SPLIT_WALL_OF_TEXT, el_id);
        else if(el_id == "lines_wot"            ) el_caption_lang = i18n_get(dom_i18n.LINES_WALL_OF_TEXT, el_id);

        else if(el_id == "mask_or_hide"         ) el_caption_lang = i18n_get(dom_i18n.MASK_OR_HIDE      , el_id);
        else if(el_id == "overflow_visi"        ) el_caption_lang = i18n_get(dom_i18n.OVERFLOW_VISI     , el_id);
        else if(el_id == "details_close"        ) el_caption_lang = i18n_get(dom_i18n.DETAILS_CLOSE     , el_id);
        else if(el_id == "details_open"         ) el_caption_lang = i18n_get(dom_i18n.DETAILS_OPEN      , el_id);
        else if(el_id == "details_radio"        ) el_caption_lang = i18n_get(dom_i18n.DETAILS_RADIO     , el_id);

        else if(el_id == "pin_seekspot"         ) el_caption_lang = i18n_get(dom_i18n.PIN_SEEKSPOT      , el_id);
        else if(el_id == "words_recycle"        ) el_caption_lang = i18n_get(dom_i18n.WORDS_RECYCLE     , el_id);
        else if(el_id == "show_seekzone"        ) el_caption_lang = i18n_get(dom_i18n.SHOW_SEEKZONE     , el_id);
        else if(el_id == "site_or_page"         ) el_caption_lang = i18n_get(dom_i18n.SITE_OR_PAGE      , el_id);
        else if(el_id == "theme_dark"           ) el_caption_lang = i18n_get(dom_i18n.THEME_DARK        , el_id);
        else if(el_id == "tools_tier2"          ) el_caption_lang = i18n_get(dom_i18n.TOOLS_TIER2       , el_id);
        else if(el_id == "tools_scroll"         ) el_caption_lang = i18n_get(dom_i18n.TOOLS_SCROLL      , el_id);
        else if(el_id == "tools_trap"           ) el_caption_lang = i18n_get(dom_i18n.TOOLS_TRAP        , el_id);

        else if(el_id == "wording"              ) el_caption_lang = i18n_get(dom_i18n.WORDING           , el_id);
        else if(el_id == "words_exact"          ) el_caption_lang = i18n_get(dom_i18n.WORDS2_EXACT      , el_id);
        else if(el_id == "words_segment"        ) el_caption_lang = i18n_get(dom_i18n.WORDS3_SEGMENT    , el_id);
        else if(el_id == "words_head_tail"      ) el_caption_lang = i18n_get(dom_i18n.WORDS4_HEAD_TAIL  , el_id);
        else if(el_id == "words_opcycle"        ) el_caption_lang = i18n_get(dom_i18n.WORDS5_OPCYCLE    , el_id);
        else if(el_id == "words_drop_case"      ) el_caption_lang = i18n_get(dom_i18n.WORDS6_DROP_CASE  , el_id);
        else if(el_id == "words_drop_ing"       ) el_caption_lang = i18n_get(dom_i18n.WORDS7_DROP_ING   , el_id);
        else if(el_id == "words_drop_s"         ) el_caption_lang = i18n_get(dom_i18n.WORDS8_DROP_S     , el_id);






        else {
            if     ( el_id.includes("clearpin") ) el_caption_lang = i18n_get(dom_i18n.CLEAR_PANEL       , el_id);
            else if( el_id.includes("closepin") ) el_caption_lang = i18n_get(dom_i18n.CLOSE_PANEL       , el_id);
            else if( el_id.includes("push_pin") ) el_caption_lang = i18n_get(dom_i18n.PIN_PANEL         , el_id);
            else if( el_id.includes("scalepin") ) el_caption_lang = i18n_get(dom_i18n.MAGNIFY_PANEL     , el_id);
        }

    }



if( log_this)
    log("%c"+caller+"("+el_id+", user_lang=["+(dom_i18n && dom_i18n.user_lang)+"]): ...return %c"+el_caption_lang, lf6, lbH+lf6);

    return el_caption_lang;
};


let set_el_caption = function(el, caption)
{
    el.title = get_id_caption(el.id, caption);
};


let get_ex_tooltip = function(ex)
{
    return ex.message
        .   replace(regexp_COLON, LF)
    ;
};




const regex_DOMAIN   = new RegExp("^(\\w*:\/\/[^\/]+)\/?.*");
let get_url_domain = function(url)
{
    if(   !url ) return "";

    let domain
        = (url.indexOf("://" ) > 0)
        ?  url.split  (  "/" )[2]
        :  url.split  (  "/" )[0]
    ;

    return  domain.replace(regex_DOMAIN, "$1") || parseURL(url).scheme+"://";
};


const regexp_URL = new RegExp("^([^:]+):\\/\\/(?:([^@]+)@)?([^\\/:]*)?(?::([\\d]+))?(?:(\\/[^#]*)(?:#(.*))?)?$", "i");






let parseURL = function(url)
{
    let result = {};

    if(String(url).startsWith("#"))
    {
        result.fragment = String(url).substr(1);
    }
    else {
        let match  = String(url).match(regexp_URL);
        if( match ) {
            result.scheme   = match[1].toLowerCase();
            result.userinfo = match[2];
            result.host     = match[3];
            result.port     = match[4];
            result.path     = match[5] || "/";
            result.fragment = match[6];

            if(result.userinfo) {
                let               a = result.userinfo.split(":");
                result.user     = a[0];
                result.password = a[1];
            }
        }
    }

    return result;
};





let cb_textArea = null;


let t_copy_to_CLIPBOARD = function(copy_content)
{

    let caller = "t_copy_to_CLIPBOARD";
let log_this   = LOG_MAP.EV3_UP;

if( log_this) log("%c "+caller+"(copy_content):"+LF+"%c"+ellipsis(copy_content)
                  ,lbH+lf6, lbF+lf6);


    if(!cb_textArea) {
        cb_textArea     = document.createElement("TEXTAREA");
        cb_textArea.id  = "cb_textArea";
        cb_textArea.style.position        = "fixed";
        cb_textArea.style.top             = "1em";
        cb_textArea.style.left            = "1em";
        cb_textArea.style.width           =  "95%";
        cb_textArea.style.height          = "25em";
        cb_textArea.style.backgroundColor = "salmon";

        document.body.appendChild(cb_textArea);

    }


    cb_textArea.style.display = "block";
    cb_textArea.value         = copy_content;



    cb_textArea.select();
if( log_this) log("%c window.getSelection():"+LF+"%c"+ellipsis(window.getSelection())
                  ,lbH+lf8, lbF+lf8);

    if( !document.execCommand("copy") )
    {

    }
    else {
if( log_this) log("%c...COPY TO CLIPBOARD: "+cb_textArea.value.length+" characters ", lbR+lf6);

    }


    cb_textArea.style.display = "none";
    cb_textArea.value         = "";


};


let get_import_key_val_array_from_free_form_data_text = function(page_key, data_text_one_liner)
{
let log_this = DOM_UTIL_LOG || DOM_UTIL_TAG;

    let pat_arr = tokenize( data_text_one_liner ).split("_");
    let alt_arr = pat_arr.splice(10);
    let bak_arr = alt_arr.splice(10);
    let bin_arr = bak_arr.splice(10);

if(log_this && pat_arr.length) t_log.console_dir("pat_arr",pat_arr);
if(log_this && alt_arr.length) t_log.console_dir("alt_arr",alt_arr);
if(log_this && bak_arr.length) t_log.console_dir("bak_arr",bak_arr);
if(log_this && bin_arr.length) t_log.console_dir("bin_arr",bin_arr);

    let                result = [];
    if(pat_arr.length) result.push( { key : page_key+".pat_arr" , val : JSON.stringify( pat_arr )} );
    if(alt_arr.length) result.push( { key : page_key+".alt_arr" , val : JSON.stringify( alt_arr )} );
    if(bak_arr.length) result.push( { key : page_key+".bak_arr" , val : JSON.stringify( bak_arr )} );
    if(bin_arr.length) result.push( { key : page_key+".bin_arr" , val : JSON.stringify( bin_arr )} );

if(log_this) t_log.console_dir("result",result);
    return  result;
};





const TO_ERR_100 = "____________________________________________________________________________________________________";
const DIGITS_100 = "0123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789";
const DECADE_100 = "0_________1_________2_________3_________4_________5_________6_________7_________8_________9_________";


let JSON_parse = function(json_str, silent)
{


    let json_item;
    try {
        json_item = JSON.parse( json_str );
    }
    catch(ex)
    {
        if(!silent) {
            let     offset = get_int_in_string( ex.message );
            let     to_err = 100 * Math.floor(offset / 100);
            let    err_str =   json_str.substring(to_err, to_err + 100 );
            let to_err_str = TO_ERR_100.substring(0     ,          offset - to_err       );
            let digits_str = DIGITS_100.substring(0     , Math.max(offset - to_err+2, 10));
            let decade_str = DECADE_100.substring(0     , Math.max(offset - to_err+2, 10));

            log("%c➔ *** "+ex.message     , lbH+lf2);
            log("%c➔ "+    err_str        ,     lf4);
            log("%c➔ "+    to_err_str+"^_",     lf3);
            log("%c➔ "+    digits_str     ,     lf3);
            log("%c➔ "+    decade_str     ,     lf3);
            log_caller();
        }
    }
    return json_item;
};





let array_equals = function(a1, a2)
{
    if(                                  !a1                     ) return false;
    if(                                               !a2        ) return false;
    if(                                  a1.length !=  a2.length ) return false;
    for(let i=0; i < a1.length; ++i) if( a1[i]     !=  a2[i]     ) return false;
 return  true;
};





let get_nodeXPath = function(node)
{
    if(node instanceof Document) return "/";

    let  node_type_pos_array;
    for( node_type_pos_array = []
    ;    node && !(node instanceof Document)
    ;    node =   (node.nodeType == Node.ATTRIBUTE_NODE)
              ?    node.ownerElement
              :    node.parentNode
    ) {
        let node_type_pos = {};


        switch( node.nodeType ) {
            case Node.TEXT_NODE                   : node_type_pos.name =                   "text()" ; break;
            case Node.ATTRIBUTE_NODE              : node_type_pos.name =       "@" + node.nodeName  ; break;
            case Node.PROCESSING_INSTRUCTION_NODE : node_type_pos.name = "processing-instruction()" ; break;
            case Node.COMMENT_NODE                : node_type_pos.name =                "comment()" ; break;
            case Node.ELEMENT_NODE                : node_type_pos.name =             node.nodeName  ; break;
        }


        node_type_pos.position = get_nodeName_rank( node );

        node_type_pos_array.push( node_type_pos );
    }

    let nodeXPath = "";
    for(let i=node_type_pos_array.length-1; i >= 0; i -= 1)
    {
        let node_type_pos   = node_type_pos_array[i];
        nodeXPath += node_type_pos.name ? ("/"+node_type_pos.name) : ".";
        if((node_type_pos.position != null) && (node_type_pos.position != "1"))
            nodeXPath += "["+ node_type_pos.position+"]";
    }

    return nodeXPath.toLowerCase();
};


let get_nodeXPath_target = function(nodeXPath)
{
    let first_node;
    try {

        let evaluator  = new XPathEvaluator();
        let expression = evaluator.createExpression(nodeXPath);

        let result     = expression.evaluate(document, XPathResult.ORDERED_NODE_ITERATOR_TYPE);

        let node;
        while(node = result.iterateNext())
        {
            if(!first_node)
                first_node = node;
        }

    }
    catch(ex) {
        console.log(ex);
    }
    return first_node;
};


let get_nodeName_rank = function(node)
{
    if(node.nodeType == Node.ATTRIBUTE_NODE) return null;

    let rank = 1;
    for(let prev_node =      node.previousElementSibling
    ;       prev_node
    ;       prev_node = prev_node.previousElementSibling
    ) {
        if(prev_node.nodeName == node.nodeName)
            rank += 1;
    }
    return rank;
 };


let get_node_sibling_at_offset = function(node,offset)
{
    if(offset > 0)
    {
        for(let next_node  = node.nextElementSibling
            ;   next_node
            ;   next_node  = next_node.nextElementSibling
           ) {
            if( next_node.nodeName == node.nodeName) {
                if( offset ) offset -= 1;
                if(!offset ) return next_node;
            }
        }
    }
    else {
        for(let prev_node  = node.previousElementSibling
            ;   prev_node
            ;   prev_node  = prev_node.previousElementSibling
           ) {
            if( prev_node.nodeName == node.nodeName) {
                if( offset ) offset += 1;
                if(!offset ) return prev_node;
            }
        }
    }
    return null;
 };


const PREFIX = "                               \u21B3";
let get_parent_tag_id_class_chain = function(el)
{
    let array = [];

    while( el )
    {
        let e_class = (el.id || el.className) ? "left"   : ""     ;
        let i_class = (         el.className) ? "center" : "right";
        let c_class =                                      "right";

        let el_className = ellipsis_short(el.className);

        let rank         = get_nodeName_rank(el);
        let el_tagName   = el.tagName+( (rank > 1) ? "["+rank+"]":"");

        array.push(   (               "<em class='tag   "+e_class+"'>" + el_tagName   +"</em>"     )
                   +  (el.id        ? "<em class='id    "+i_class+"'>#"+ el.id        +"</em>" : "")
                   +  (el_className ? "<em class='class "+c_class+"'>."+ el_className +"</em>" : "")
                  );
        el = el.parentElement;
    }

    let parent_id_class_chain = "";

    for(let l=0, i=array.length-1; i>=0; ++l, --i)
        parent_id_class_chain
            += ((l>0) ? (LF+" "+PREFIX.slice(-l))+" " : "")
            +            array[i];

    return parent_id_class_chain;
};


let get_parent_chain = function(el)
{
    let array = [];

    while(          el.parentElement )
    {
        array.push( el.parentElement );
        el        = el.parentElement;
    }

    return array;
};






let t_store_set_state = function(label,state)
{
    if(    state != undefined)
    {
        if(state) localStorage.setItem   (label, "true");
        else      localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return    localStorage.getItem   (label        );
    }
};

return { name : "dom_util"
    , logging : (state) => DOM_UTIL_LOG = t_store_set_state("DOM_UTIL_LOG", state)
    , tagging : (state) => DOM_UTIL_TAG = t_store_set_state("DOM_UTIL_TAG", state)
    , t_util_IMPORT
    , t_util_set_state : t_store_set_state



    , get_el_event_handler
    , get_el_event_handler_label
    , get_el_input_event_handler
    , get_el_mouse_event_handler
    , get_el_onkey_event_handler
    , get_el_parent_with_any_event_handler
    , is_event_on_scrollbar
    , send_onchange_event_to
    ,    get_event_XY
    ,    t_get_event_target
    ,    t_prevent_reload



    , get_el_xy
    , get_el_xy_computed



    , check_xy_in_node_rect
    , getInPageTop
    , getPageHeight
    , get_el_transformOrigin
    , get_xy_tlbr_dist
    , get_parent_with_scrollbar
    , get_scrollable_parent
    , has_scrollbar
    , has_scrollbar_x
    , has_scrollbar_y
    , intersect_r1_r2
    , intersect_tlbr
    , is_contained_by_parent
    , is_el_visible
    , is_overflowing_parent
    , t_adjust_panel_transform_origin
    , t_del_position_fixed
    , t_el_geometry
    , t_get_panel_scale
    , t_set_position_fixed




    , get_abs_nodes
    , get_document_el_at_XY
    , get_el_anchor_in_view_array
    , get_el_parent_fragment
    , get_h_tag
    , get_id_or_node_path_tail
    , get_id_or_tag
    , get_id_or_tag_and_className
    , get_n_lbl
    , get_n_str
    , get_n_txt
    , get_node_id_or_tag
    , get_node_path
    , get_node_path_tail
    , get_node_path_target
    , get_node_txt_id_or_tag_path
    , get_p_str
    , get_parentage
    , get_position_absolute_children
    , get_selector_nodes
    , get_t_str
    , get_tool
    , get_viewport_nodes
    , has_a_fixed_parent
    , node_toString

    , t_REMOVE_EventListeners
    , t_REMOVE_ADS
    , t_REMOVE_ADS_results
    , t_TEXT_LINES_to_COLORED_HTML
    , t_get_divs_style_z_index_max
    , t_get_e_target_proxy
    , t_replace_initial_title
    , t_restore_initial_title



    , get_child_num
    , get_el_child_with_class
    , get_el_child_with_id
    , get_el_child_with_tag
    , get_el_child_with_tag_class
    , get_el_child_with_tag_first_word
    , get_el_in_view_up_from_el

    , get_el_sibling_with_tag

    , get_el_parent_clipped
    , get_el_parent_with_class
    , get_el_parent_with_display_none
    , get_el_parent_with_id
    , get_el_parent_with_tag

    , is_a_doc_tool_button
    , is_a_doc_tool_node
    , is_a_doc_tool_panel
    , is_el_child_of_class
    , is_el_child_of_id
    , is_el_or_child_of_class
    , is_el_or_child_of_parent_el

    , not_an_anchor_target



    , add_el_class
    , del_el_class
    , set_el_class
    , has_el_class

    , clear_el_classList
    , cycle_el_classList
    , cycle_id_classList
    , flip_el_class
    , flip_id_class
    , set_el_class_on_off
    , set_el_class_removing

    , is_marked_to_hide


    , clearSelection
    , selectNodeContents
    , log_range



    , get_nodeXPath
    , get_nodeXPath_target
    , get_node_sibling_at_offset
    , get_parent_tag_id_class_chain
    , get_parent_chain





    , atob_msg
    , btoa_msg
    , ellipsis
    , ellipsis_16
    , ellipsis_short
    , isAlNum
    , is_hex_string
    , mPadEnd
    , mPadStart
    , object_label
    , rect_toString
    , string_to_ascii
    , string_to_ms
    , string_to_utf8
    , truncate
    , unicode_to_charCode




    , trim_WORDS
    , trim_alNum_lines
    , trim_empty_lines
    , trim_node_textContent
    , trim_space_lf



    , show_CR_LF
    , strip_CR_LF
    , strip_HTML
    , strip_UL
    , strip_console_formatting
    , strip_contentEditable
    , strip_pat
    , strip_to_lines



    , bracket_to_em
    , comma_to_LF
    , comma_to_vbar
    , encode_LF
    , escapeHTML
    , escape_CR_LF
    , escape_LF_BR
    , underline_from_utf8
    , underline_to_space
    , vbar_to_BR
    , vbar_to_LF
    , vbar_to_QUOTED_LINES
    , vbar_to_comma
    , vbar_to_up_arrow



    , character_entities_to_char
    , character_entities_to_hex
    , t_get_htmlEntities



    , get_first_word
    , tokenize



    , get_tag_hour



    , get_num_in_string
    , get_int_in_string




    , csv_add
    , csv_cat
    , csv_ins

    , csv_get

    , csv_count
    , csv_contains
    , csv_pos

    , csv_del
    , csv_del_last
    , csv_slice_head
    , csv_slice_tail
    , csv_slice_head_or_tail

    , csv_sort
    , csv_reverse

    , csv_escape
    , csv_unescape
    , csv_log


    , get_el_title
    , get_ex_tooltip
    , get_id_caption
    , set_el_caption



    , get_url_domain
    , parseURL



    , t_copy_to_CLIPBOARD
    , get_import_key_val_array_from_free_form_data_text



    , JSON_parse





    , array_equals





};


}());



/*INLINE}}}*/
//@ sourceURL=dom_util.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
  /**    9 I18N     JS dom_i18n_js_data {{{*/
/*
../script/dom_i18n.js
*/
let dom_i18n_js_data ="data:text/javascript;charset='utf-8',"+ `
/*INLINE{{{*/














const DOM_I18N_JS_ID        = "dom_i18n_js";
const DOM_I18N_JS_TAG       = DOM_I18N_JS_ID  +" (221124:17h:20)";

let dom_i18n    = (function() {
"use strict";
let   DOM_I18N_LOG          = false;
let   DOM_I18N_TAG          = false;




const LF    = String.fromCharCode(10);







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;






















let t_i18n_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;























    util_INTERN();

    DOM_I18N_LOG = DOM_I18N_LOG || localStorage_getItem("DOM_I18N_LOG");
    DOM_I18N_TAG = DOM_I18N_TAG || localStorage_getItem("DOM_I18N_TAG");


if(log_this) log("%c 07 util", lbH+lf7);
};





let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let   util_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


};


let localStorage_setItem = function(key,val) { if(val) localStorage.setItem   (key,val); else localStorage.removeItem(key); };
let localStorage_getItem = function(key    ) { return  localStorage.getItem   (key    ); };
let localStorage_delItem = function(key    ) { localStorage.removeItem(key    ); };






let i18n_set_args = function(args)
{

let   caller = "i18n_set_args";
let log_this = DOM_I18N_TAG || DOM_I18N_LOG || LOG_MAP.T1_DOM_LOAD;

if(log_this) log_caller();


    if(                args.lang ) {
        switch(        args.lang.substr(0,2).toUpperCase() )
        {
            case "FR": user_lang = "FR"     ; break;
            case "EN": user_lang = "EN"     ; break;
            default  : user_lang = args.lang; break;
        }
    }


if(log_this)
    log_key_val(caller
        , { args
          , user_lang
        }, lf5);

};



let user_lang;


let i18n_get_user_lang = function()
{
    if(!i18n_map_FR) i18n_map_LANGUAGES();

    return user_lang;
};


let user_lang_applied;

let i18n_get = function(key,el_id)
{

let   caller = "i18n_get";
let log_this = DOM_I18N_TAG || DOM_I18N_LOG || LOG_MAP.T1_DOM_LOAD;


    if(!i18n_map_FR) i18n_map_LANGUAGES();

    if( user_lang_applied == undefined)
        user_lang_applied  = user_lang;


    let        value;
    switch(user_lang)
    {
    case "FR": value = i18n_map_FR.get(key); break;
    default  :
    case "EN": value =                 key ; break;
    }



    if(!value)
    {
        value = key;


log("%c"+ caller +"%c"+ el_id  +"%c"+ key    +"%c"+ user_lang +"%c IS MISSING"
    ,lbb+lbH+lf8  ,lbb+lbL+lf4  ,lbb+lbC+lf7  ,lbb+lbC+lf8     ,lbb+lbR+lf3   );
log_caller(2);

    }


    if( el_id )
        value += LF+ t_util.unicode_to_charCode(   t_data.SYMBOL_BLACK_SUN ) +" "+el_id;



if(log_this) log("%c"+caller+"("+el_id+" .. "+key+ ")%c...return "+ value, lbL+lf4, lbR+lf5);
    return value;
};





const PAT_BAG                        = "PAT bag";
const SEL_BAG                        = "SEL bag";
const HEADSUP_W                      = "Words options";
const HEADSUP                        = "Tools options";

const HEADSUP_DS                     = "Document tools";
const DOM_TRAVERSAL                  = "DOM traversal";
const HEADSUP_BW                     = "Body width";
const HEADSUP_BZ                     = "Body zoom";
const HEADSUP_FS                     = "Body font-size";

const TEST_PANEL                     = "Test PANEL";
const DEV_LOG_MAP                    = "DEV [LOG_MAP";
const TRANSCRIPT1                    = "Transcript 1";
const TRANSCRIPT2                    = "Transcript 2";

const DOM_LOAD_TAGS                  = "DOM [LOAD_TAGS";


const ALT_BAG                        = "ALT bag";
const BAK_BAG                        = "BAK bag";
const OFF_BAG                        = "OFF bag";

const BAGOPEN                        = "Open-Close BAGS";
const BAG_LOG                        = "Status details";
const BAG_ROT                        = "Rotate bags";

const CLEAR_PANEL                    = "Clear panel";
const CLOSE_PANEL                    = "Close panel";
const MAGNIFY_PANEL                  = "Magnify panel";
const PIN_PANEL                      = "Pin panel";

const FLY_LOG                        = "Flying tooltips";
const SORT_SELECTION                 = "Sort selection";


const SCROLL_SMOOTH                  = "Smooth or Instant scrolling";
const DOM_FREEZE                     = "DOM freeze (Remove All Event Listeners)";
const USER_LANG                      = "Interface language";
const ANCHOR_FREEZE                  = "Disable links navigation";
const CONTAINERS_HI                  = "Highlight paragraph containers";
const DENY_OR_ALLOW                  = "Deny or Allow (no-op at this time)";
const DOM_HIDE1_RESET                = "Reset all hidden containers";
const DOM_HIDE1_UNDO                 = "Revert to previous NODE TO HIDE STACK";
const EDIT_OR_STAGE                  = "Edit or Apply hidden containers";
const LOG_SEEKSPOT                   = "Log seekspot tool parameters";

const REMOVE_ADS                     = "Remove Ads Tags";
const SPLIT_WALL_OF_TEXT             = "Split Text Panels"+LF+"(i.e. Wall-of-Text)";
const LINES_WALL_OF_TEXT             = "Show Wall-of-Text line numbers";

const MASK_OR_HIDE                   = "Mask or Hide hidden containers";
const OVERFLOW_VISI                  = "Force text-overflow visibility";

const DETAILS_CLOSE                  = "DETAILS ➔ All closed";
const DETAILS_OPEN                   = "DETAILS ➔ All opened";
const DETAILS_RADIO                  = "DETAILS ➔ Only one opened at a time";

const PIN_SEEKSPOT                   = "Keep last seekspot visible";
const WORDS_RECYCLE                  = "Recycle";
const WORDS_RECYCLE_CLICK_TO_HIDE    = "Click to hide";
const WORDS_RECYCLE_CLICK_TO_DISCARD = "Click to discard all";
const STORED_PATTERNS                = "Stored patterns";
const SHOW_SEEKZONE                  = "Show lst seek zone area";
const SITE_OR_PAGE                   = "Hiding containers at SITE or PAGE level";
const THEME_DARK                     = "Dark Theme";
const TOOLS_TIER2                    =  "TIER-TWO TOOLS SELECTED"
 +LF+"✔ headsup"
 +LF+"✔ headsup_w"
 +LF+"✔ pat_bag"
 +LF+"☀ t_sync_tools_tier2"
 +LF
 +LF+"SEEKER MOVES FASTER"
 +LF+"☀ onMove_5_GRAB_SELECTION"
 +LF+"☀ onMove_6_GRAB_STICKY"
 +LF+"☀ t_seeker_onMove2_ON_NEXT_STICKY"
 +LF
 +LF+"SENTENCE POPUP ACTIVE"
 +LF
;
const TOOLS_SCROLL                   = "Tools fixed or scrolling with the page";
const TOOLS_TRAP                     = "Trap tools in their current quadrant while moving hotspot";

const WORDING                        = "Wording State: FREEZED LINKS and PAGE-COLOR-THEME";
const WORDS2_EXACT                   = "Select whole words only";
const WORDS3_SEGMENT                 = "Select word segment";
const WORDS4_HEAD_TAIL               = "Grab words prefix and suffix";
const WORDS5_OPCYCLE                 = "Auto-cycle:"+LF+"1 - whole words"+LF+"2 - word segments"+LF+"3 - head and tail"+LF+"4 .. unselected";
const WORDS6_DROP_CASE               = "Ignore case";
const WORDS7_DROP_ING                = "Drop [ing] word terminaisons";
const WORDS8_DROP_S                  = "Drop [s] word treminations";



const AS_SET_BY_USER                   = "As set by user";
const BAGS_CONTENT                     = "Current content";
const IS_EMPTY                         = " is empty";
const COPY_ALL_PARAGRAPHS_TO_CLIPBOARD = "Copy all paragraphs to clipboard";
const MONOSPACE                        = "SHOW (and COPY) HTML or TEXT Format";
const ADS_REMOVED                      = "ADS removed";
const COPY_PARAGRAPH_TO_CLIPBOARD      = "Copy paragraph to clipboard";
const CURRENTLY                        = "Currently";
const REVERSED_Z_TO_A                  = "Reversed Z..A";
const SCROLL_TO_THIS_PARAGRAPH         = "Scroll to this paragraph";
const SORTED_A_TO_Z                    = "Sorted A..Z";
const UNORDERED                        = "Unordered";
const MOVE_IN_GUTTER_TO_CLEAR_STORAGE
    = "No data worth storing about this page:"+LF
    + "---"+LF
    + "Drag hotspot into gutter"+LF
    + "to clear tools selection and layout."
;
const ALL_PAGE_LOCAL_STORAGE_REMOVED
    = "No stored information for this page."+LF
    +  t_data.SYMBOL_BLACK_SUN+" Local Storage is empty"
;

const NOT_FOUND                        = "not found";
const TOO_MANY                         = "too many";


const STICKY_FIX_TOOLTIP               = "DELETE";
const STICKY_HAND_MOV_TOOLTIP          = "MOVE";
const STICKY_PAD_TOOLTIP               = "LONG PRESS EDIT";
const STICKY_PASTE_TOOLTIP             = "PASTE SELECTED TEXT";
const STICKY_PEN_TOOLTIP               = "EDIT";
const STICKY_REFLOW_TOOLTIP            = "RESIZE";
const STICKY_REFONT_TOOLTIP            = "RESIZE FONT";
const STICKY_ROTATE                    = "ROTATE";





const LANGUAGES = [ "FR" , "EN" , "DE" , "GR" ];

const ARRAY_FR  = [

        [   SEL_BAG                          , "Index des mots sélectionnés" ]
        , [ PAT_BAG                          , "Liste des mots sélectionnés" ]
        , [ ALT_BAG                          , "Liste ALT"                   ]
        , [ BAK_BAG                          , "Liste BAK"                   ]
        , [ OFF_BAG                          , "Liste OFF"                   ]

        , [ BAGOPEN                          , "Déployer-Replier les listes" ]
        , [ BAG_LOG                          , "Informations détaillées"     ]
        , [ BAG_ROT                          , "Rotation des listes"         ]

        , [ CLEAR_PANEL                      , "Vider le panneau"            ]
        , [ CLOSE_PANEL                      , "Déselectionner le panneau"   ]
        , [ MAGNIFY_PANEL                    , "Agrandir le panneau"         ]
        , [ PIN_PANEL                        , "Épingler le panneau"         ]

        , [ FLY_LOG                          , "Infos-bulles"                ]
        , [ SORT_SELECTION                   , "Classer la sélection"        ]

        , [ DOM_TRAVERSAL                    , "Exploration du DOM"          ]

        , [ HEADSUP                          , "Options des outils"          ]
        , [ HEADSUP_BW                       , "Body - largeur"              ]
        , [ HEADSUP_BZ                       , "Body - zoom"                 ]
        , [ HEADSUP_FS                       , "Body - font-size"            ]
        , [ HEADSUP_DS                       , "Opérations sur le document"  ]
        , [ HEADSUP_W                        , "Sélection des mots"          ]

        , [ DEV_LOG_MAP                      , "DEV [LOG_MAP]"               ]
        , [ DOM_LOAD_TAGS                    , "DOM [LOAD_TAGS]"             ]
        , [ TEST_PANEL                       , "Tests"                       ]
        , [ TRANSCRIPT1                      , "Panneau de test 1"           ]
        , [ TRANSCRIPT2                      , "Panneau de test 2"           ]



        , [ AS_SET_BY_USER                   , "Positionné par l'utilisateur"                      ]
        , [ BAGS_CONTENT                     , "contenu actuel"                                    ]
        , [ IS_EMPTY                         , " est vide"                                         ]
        , [ COPY_ALL_PARAGRAPHS_TO_CLIPBOARD , "Copier tous les paragraphes dans le presse-papier" ]
        , [ MONOSPACE                        , "Affichage (et Copie) au format HTML ou TEXTE"      ]
        , [ ADS_REMOVED                      , "Annonces supprimées"                               ]
        , [ COPY_PARAGRAPH_TO_CLIPBOARD      , "Copier ce  paragraphe  dans le presse-papier"      ]
        , [ CURRENTLY                        , "Actuellement"                                      ]
        , [ REVERSED_Z_TO_A                  , "inversé Z..A"                                      ]
        , [ SCROLL_TO_THIS_PARAGRAPH         , "Recentrer sur ce paragraphe"                       ]
        , [ SORTED_A_TO_Z                    , "ordonné A..Z"                                      ]
        , [ UNORDERED                        , "non classé"                                        ]
        , [ NOT_FOUND                        , "pas trouvé"                                        ]
        , [ TOO_MANY                         , "dépacement"                                        ]
        , [ MOVE_IN_GUTTER_TO_CLEAR_STORAGE  , "Pas d'information à enregistrer pour cette page:"+LF
 + "---"+LF
 + "Glissez le panneau vers une bordure"+LF
 + "pour supprimer les paramètres associés."
        ]
        , [ ALL_PAGE_LOCAL_STORAGE_REMOVED   , "Aucune information enregistrée pour cette page."+LF
 +  t_data.SYMBOL_BLACK_SUN+" Local Storage est vide"]

        , [ STICKY_FIX_TOOLTIP               , "SUPPRIMER"                   ]
        , [ STICKY_HAND_MOV_TOOLTIP          , "DÉPLACER"                    ]
        , [ STICKY_PAD_TOOLTIP               , "ÉDITER AVEC UN APPUI LONG"   ]
        , [ STICKY_PASTE_TOOLTIP             , "COPIER LE TEXTE SÉLECTIONNÉ" ]
        , [ STICKY_PEN_TOOLTIP               , "ÉDITER"                      ]
        , [ STICKY_REFLOW_TOOLTIP            , "REDIMENSIONNER"              ]
        , [ STICKY_REFONT_TOOLTIP            , "TAILLE DES CARACTÈRES"       ]
        , [ STICKY_ROTATE                    , "ORIENTER"                    ]

        , [ SCROLL_SMOOTH                    , "Défilement progressif ou instantané"                                    ]
        , [ USER_LANG                        , "Language de l'interface"                                                ]
        , [ DOM_FREEZE                       , "DOM freeze (Suppression des Event Listeners)"                           ]
        , [ ANCHOR_FREEZE                    , "Blocage des liens de navigation"                                        ]
        , [ CONTAINERS_HI                    , "Coloration des paragraphes sélectionnés"                                ]
        , [ DENY_OR_ALLOW                    , "Deny or Allow (no-op pour le moment)"                                   ]
        , [ DOM_HIDE1_RESET                  , "Remise à zéro des sections cachées"                                     ]
        , [ DOM_HIDE1_UNDO                   , "Recul dans l'historique des sections cachées"                           ]
        , [ EDIT_OR_STAGE                    , "Édition ou Application des section cachées"                             ]
        , [ LOG_SEEKSPOT                     , "Log des paramètres du seekspot"                                         ]

        , [ REMOVE_ADS                       , "Suppression des Annonces"                                               ]
        , [ SPLIT_WALL_OF_TEXT               , "Partition des pages de texte"+LF+"(i.e. Wall-of-Text)"                  ]
        , [ LINES_WALL_OF_TEXT               , "Numérotation des lignes Wall-of-Text"                                   ]

        , [ MASK_OR_HIDE                     , "Masquer ou Cacher les sections à cacher"                                ]
        , [ OVERFLOW_VISI                    , "Rendre visible les textes en overflow"                                  ]

        , [ DETAILS_CLOSE                    , "DETAILS ➔ tous repliés"                                                 ]
        , [ DETAILS_OPEN                     , "DETAILS ➔ tous dépliés"                                                 ]
        , [ DETAILS_RADIO                    , "DETAILS ➔ un seul ouvert à la fois"                                     ]

        , [ PIN_SEEKSPOT                     , "Garder le dernier seekspot visible"                                     ]
        , [ WORDS_RECYCLE                    , "Recycler"                                                               ]
        , [ WORDS_RECYCLE_CLICK_TO_HIDE      , "Click pour les cacher"                                                  ]
        , [ WORDS_RECYCLE_CLICK_TO_DISCARD   , "Click pour les supprimer"                                               ]
        , [ STORED_PATTERNS                  , "Mots sélectionnés"                                                      ]
        , [ SHOW_SEEKZONE                    , "Afficher la dernière zone de sélection"                                 ]
        , [ SITE_OR_PAGE                     , "Cacher les containers au niveau SITE ou PAGE"                           ]
        , [ THEME_DARK                       , "Theme foncé"                                                            ]
        , [ TOOLS_TIER2                      , TOOLS_TIER2                                                              ]
        , [ TOOLS_SCROLL                     , "Outils fixes à l'écran ou sur la page"                                  ]
        , [ TOOLS_TRAP                       , "Outils confinés dans leur quadrant pendant les déplacements du hotspot" ]

        , [ WORDING                          , "Mode de sélection des mots-clés:"+LF+"- Navigation bloquée"+LF+"- Couleurs de la page" ]
        , [ WORDS2_EXACT                     , "Sélectionner des mots entiers"                                          ]
        , [ WORDS3_SEGMENT                   , "Sélectionner des segments de mot"                                       ]
        , [ WORDS4_HEAD_TAIL                 , "Sélectionner aussi les prefixes et suffixes"                            ]
        , [ WORDS5_OPCYCLE                   , "Cycle-auto:"+LF+"1 - mots entier"+LF+"2 - segments de mot"+LF+"3 - préfixes et suffixes"+LF+"4 .. désélectionner" ]
        , [ WORDS6_DROP_CASE                 , "Confondre majuscules et minuscules"                                          ]
        , [ WORDS7_DROP_ING                  , "Ignorer les terminaisons en [ing]"                                      ]
        , [ WORDS8_DROP_S                    , "Ignorer les terminaisons en [s]"                                        ]


    ];
let i18n_map_FR;



let i18n_map_LANGUAGES = function()
{

let   caller = "i18n_map_LANGUAGES";
let log_this = DOM_I18N_TAG || DOM_I18N_LOG || LOG_MAP.T1_DOM_LOAD;

if(log_this) log_caller();


    let i18n_object_FR             = new Object    ( ARRAY_FR                   );
    let i18n_object_FR_stringified = JSON.stringify( i18n_object_FR             );
    let i18n_object_FR_parsed      = JSON.parse    ( i18n_object_FR_stringified );
i18n_map_FR                = new Map       ( i18n_object_FR_parsed      );

    if(user_lang == undefined)
        i18n_set_args({ lang: window.navigator.language , caller });


if(log_this) {
    log(caller);

    t_log.console_dir("ARRAY_FR", ARRAY_FR);

    t_log.console_dir("i18n_object_FR", i18n_object_FR   );
    log_key_val_group("i18n_object_FR"  , i18n_object_FR       ,     lf1, false);

    log("%c i18n_object_FR_stringified"+LF + "%c"+ i18n_object_FR_stringified, lbH+lf2, lbA);

    log_key_val_group("i18n_object_FR_parsed     " , i18n_object_FR_parsed           ,     lf3, false);
    t_log.console_dir("i18n_object_FR_parsed",   i18n_object_FR_parsed        );

    t_log.console_dir("i18n_map_FR",   i18n_map_FR      );
    log_key_val_group("i18n_map_FR"    , i18n_map_FR         ,     lf4, false);

    t_log.console_dir("i18n_map_FR",i18n_map_FR);
    i18n_map_FR.forEach(function(value, key) {
        log("%c"+key +"%c"+ value, lbL+lf4,lbR+lf5);
    });

}

};





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_i18n"
    , logging : (state) => DOM_I18N_LOG = t_store_set_state("DOM_I18N_LOG",state)
    , tagging : (state) => DOM_I18N_TAG = t_store_set_state("DOM_I18N_TAG",state)
    , t_i18n_IMPORT



    , i18n_set_args



    , i18n_get
    , i18n_get_LANGUAGES         : () => LANGUAGES
    , i18n_get_user_lang
    , i18n_get_user_lang_applied : () => user_lang_applied




    , PAT_BAG
    , SEL_BAG
    , HEADSUP_W
    , HEADSUP

    , HEADSUP_DS
    , DOM_TRAVERSAL
    , HEADSUP_BW
    , HEADSUP_BZ
    , HEADSUP_FS

    , TEST_PANEL
    , DEV_LOG_MAP
    , TRANSCRIPT1
    , TRANSCRIPT2

    , DOM_LOAD_TAGS


    , ALT_BAG
    , BAK_BAG
    , OFF_BAG

    , BAGOPEN
    , BAG_LOG
    , BAG_ROT

    , CLEAR_PANEL
    , CLOSE_PANEL
    , MAGNIFY_PANEL
    , PIN_PANEL

    , FLY_LOG
    , SORT_SELECTION


    , SCROLL_SMOOTH
    , DOM_FREEZE
    , USER_LANG
    , ANCHOR_FREEZE
    , CONTAINERS_HI
    , DENY_OR_ALLOW
    , DOM_HIDE1_RESET
    , DOM_HIDE1_UNDO
    , EDIT_OR_STAGE
    , LOG_SEEKSPOT

    , REMOVE_ADS
    , SPLIT_WALL_OF_TEXT
    , LINES_WALL_OF_TEXT

    , MASK_OR_HIDE
    , OVERFLOW_VISI

    , DETAILS_CLOSE
    , DETAILS_OPEN
    , DETAILS_RADIO

    , PIN_SEEKSPOT
    , WORDS_RECYCLE
    , WORDS_RECYCLE_CLICK_TO_HIDE
    , WORDS_RECYCLE_CLICK_TO_DISCARD
    , STORED_PATTERNS
    , SHOW_SEEKZONE
    , SITE_OR_PAGE
    , THEME_DARK
    , TOOLS_TIER2
    , TOOLS_SCROLL
    , TOOLS_TRAP

    , WORDING
    , WORDS2_EXACT
    , WORDS3_SEGMENT
    , WORDS4_HEAD_TAIL
    , WORDS5_OPCYCLE
    , WORDS6_DROP_CASE
    , WORDS7_DROP_ING
    , WORDS8_DROP_S



    , ADS_REMOVED
    , ALL_PAGE_LOCAL_STORAGE_REMOVED
    , AS_SET_BY_USER
    , BAGS_CONTENT
    , COPY_ALL_PARAGRAPHS_TO_CLIPBOARD
    , COPY_PARAGRAPH_TO_CLIPBOARD
    , CURRENTLY
    , IS_EMPTY
    , MONOSPACE
    , MOVE_IN_GUTTER_TO_CLEAR_STORAGE
    , REVERSED_Z_TO_A
    , SCROLL_TO_THIS_PARAGRAPH
    , SORTED_A_TO_Z
    , UNORDERED

    , NOT_FOUND
    , TOO_MANY


    , STICKY_FIX_TOOLTIP
    , STICKY_HAND_MOV_TOOLTIP
    , STICKY_PAD_TOOLTIP
    , STICKY_PASTE_TOOLTIP
    , STICKY_PEN_TOOLTIP
    , STICKY_REFLOW_TOOLTIP
    , STICKY_REFONT_TOOLTIP
    , STICKY_ROTATE



, ARRAY_FR
, i18n_map_LANGUAGES

};


}());

/*INLINE}}}*/
//@ sourceURL=dom_i18n.js
`

;
/*}}}*/
/**   10 PROP     JS dom_prop_js_data {{{*/
/*
../script/dom_prop.js
*/
let dom_prop_js_data ="data:text/javascript;charset='utf-8',"+ `
/*INLINE{{{*/











const DOM_PROP_JS_ID        = "dom_prop_js";
const DOM_PROP_JS_TAG       = DOM_PROP_JS_ID    +" (220308:16h:22)";


let dom_prop    = (function() {
"use strict";
let   DOM_PROP_LOG          = false;
let   DOM_PROP_TAG          = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;






















let t_prop_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;























    prop_INTERN();

    DOM_PROP_LOG = DOM_PROP_LOG || localStorage_getItem("DOM_PROP_LOG");
    DOM_PROP_TAG = DOM_PROP_TAG || localStorage_getItem("DOM_PROP_TAG");


if(log_this) log("%c 08 prop", lbH+lf8);
};



let LOG_MAP;

let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;

let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let get_id_or_tag;
let mPadEnd;
let mPadStart;


let   prop_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


    get_id_or_tag       = t_util.get_id_or_tag;
    mPadEnd             = t_util.mPadEnd;
    mPadStart           = t_util.mPadStart;


};


let localStorage_setItem = function(key,val) { if(val) localStorage.setItem   (key,val); else localStorage.removeItem(key); };
let localStorage_getItem = function(key    ) { return  localStorage.getItem   (key    ); };
let localStorage_delItem = function(key    ) { localStorage.removeItem(key    ); };




const C_LEN_PREFIX     = 10;
const C_LEN_ID         = 24;
const C_LEN_REC_VALUE  = 10;
const C_LEN_EL         = 24;
const C_LEN_ONCHANGE   = 24;




let prop_init          = function(id, value, onchange) { return _prop_set  (id, value, onchange)        ; };
let prop_set           = function(id, value, onchange) { return _prop_parse(id, value, onchange)        ; };
let prop_get           = function(id                 ) { return _prop_get  (id                 ).value  ; };
let prop_toggle        = function(id                 ) { return _prop_parse(id,"toggle"        ).value  ; };
let prop_set_EL        = function(id, el             ) { return _prop_get  (id                 ).el = el; };
let prop_get_EL        = function(id                 ) { return _prop_get  (id                 ).el     ; };
let prop_get_MAP       = function(                   ) { return                                 Prop_Map; };
let prop_set_CB        = function(cb                 ) {                                    Prop_CB = cb; };
let prop_log_true      = function(_caller            ) { prop_log_MAP(_caller,       true); };
let prop_log_false     = function(_caller            ) { prop_log_MAP(_caller,      false); };
let prop_log_undefined = function(_caller            ) { prop_log_MAP(_caller,  undefined); };
let prop_log_onchange  = function(_caller            ) { prop_log_MAP(_caller, "onchange"); };
let prop_log_MAP       = function(...args) {


let log_this = DOM_PROP_LOG || LOG_MAP.T3_LAYOUT;



    let last_arg
        = (args.length > 1) ? args[1]
        : (args.length > 0) ? args[0]
        :                     "";

    let filter_value
        = (last_arg  ===       true ) ? true
        : (last_arg  ===      false ) ? false
        : (last_arg  === "undefined") ? undefined
        : (last_arg  ===  undefined ) ? undefined
        :                               "any";

    let filter_onchange
        = (String(last_arg).toLowerCase() === "onchange");



    let identifier
        =  (args.length >  0)
        && (args[0]                       !==  true      )
        && (args[0]                       !==  false     )
        && (args[0]                       !==  undefined )
        && (args[0]                       !== "undefined")
        && (String(args[0]).toLowerCase() !==  "onchange")
        ?   args[0]
        :   "";

    let                               filter_id_to_match = false;
    if( identifier.startsWith("*")) { filter_id_to_match = true; identifier = identifier.substring(1); }
    if( identifier.endsWith  ("*")) { filter_id_to_match = true; identifier = identifier.substring(0, identifier.length-1); }

    let unfiltered
        =  !filter_onchange
        && !filter_id_to_match
        && (filter_value == "any")
    ;


    let prop = identifier && !filter_id_to_match && _prop_got( identifier );

if( log_this) {
    let showing
        = (  prop
             ?  "PROP ITEM "+identifier
             :  "PROP ITEM LIST"
          )
        + ((filter_value!="any") ? " .. "+filter_value : "")
        + ( filter_onchange      ? " .. onchange"      : "")
    ;

    log_key_val_group(   showing
                         , { args_length : args.length
                           , last_arg
                           , identifier
                           , filter_value
                           , filter_id_to_match
                           , filter_onchange
                           , unfiltered
                         }
                         , lf9
                         , false);
}
    if(identifier && !filter_id_to_match && !prop)
    {
        log("%c PROP %c"+identifier+"%c NOT FOUND", lbL, lbC, lbR);

        return;
    }


    let prefix_header = identifier
        ?         mPadStart("ITEM", identifier.length)
        :                   "ITEM";

    log(    "%c"+ mPadEnd  (prefix_header         , C_LEN_PREFIX   )
         + " %c"+ mPadStart("ITEM id"             , C_LEN_ID       )
         + " %c"+ mPadEnd  ("VALUE "+filter_value , C_LEN_REC_VALUE)
         + " %c"+ mPadStart("NODE el"             , C_LEN_EL       )
         + " %c"+ mPadEnd  ("HANDLER onchange"    , C_LEN_ONCHANGE )
         + " %c"+           "CSS"
         , lbH+lf3
         , lbL+lf3
         , lbC+lf3
         , lbR+lf3
         , lbH+lf3
         , lbH+lf3);



    if( prop )
    {
        prop.log(identifier);

    }


    else {

        let map_length = Prop_Map.length;
        let map_sorted = Prop_Map.sort( function(a,b) { return (a.id > b.id) ? 1 : -1; } );
        map_sorted.forEach(
                           function(each_prop,index)
                           {
                               if(filter_id_to_match && !each_prop.id.includes( identifier ))      return;

                               let has_onchange = !unfiltered && ( filter_onchange && each_prop.onchange);
                               let    has_value = !unfiltered && ( filter_value    == each_prop.value   );

                               if(   filter_id_to_match
                                  || unfiltered
                                  || has_onchange
                                  || has_value
                                 ) {
                                   let prefix = mPadStart(index+1+" / "+map_length, C_LEN_PREFIX);
                                   each_prop.log( prefix );
                               }
                           });

    }


};





let Prop_Map = [];
let Prop_CB;



let Prop = function(id, value, onchange)
{
    this.id        = id;
    this.value     = (value == "toggle") ? true      : value        ;
    this.onchange  = onchange;
    this.el        = null;

    this.toString = function()
    {
        let onchange_name
            = this.onchange ? this.onchange.name
            :  Prop_CB      ? Prop_CB      .name
            :                 ""
        ;
        let el_name
            = this.el
            ?  " "+get_id_or_tag(this.el)+" → "
            :  " "
        ;

        return       mPadStart(this.id  +" "+this.value   , 24)
            + " … "+ mPadStart(el_name  +    onchange_name, 24)+" "
        ;

    };


    this.log = function(prefix="") {

        let lfv = (this.value ==  null) ? lf7
            :     (this.value == false) ? lf6
            :     (this.value ==  true) ? lb5
            :                             lb7;

        let lfe = (this.el            ) ? (this.value ? lf4 : lf9)
            :                             lf2;

        let this_onchange
            = this.onchange
            ?  t_data.SYMBOL_FUNCTION+" "+(this.onchange.name||"anonymous")
            :  "";

        console.groupCollapsed( "%c"+ prefix
                       +       " %c"+ mPadStart(               this.id           , C_LEN_ID       )
                       +       " %c"+ mPadEnd  (               this.value        , C_LEN_REC_VALUE)
                       +       " %c"+ mPadStart( get_id_or_tag(this.el  )        , C_LEN_EL       )
                       +       " %c"+ mPadEnd  (               this_onchange     , C_LEN_ONCHANGE )
                       +       " %c"+ (this.el ? " "+          this.el.className : ""             )
                       ,       lbH
                       ,       lbL+lfe
                       ,       lbC+lfv
                       ,       lbR+lfe
                       ,       lbH+lf3
                       ,       lbH+lf9
                              );

        log_key_val(this.id, this, lf3);
        console.trace();
        console.groupEnd();
    };


};


let _prop_set = function(...args)
{

let log_this = DOM_PROP_LOG || LOG_MAP.T3_LAYOUT;

    let id       = args[0] ||        "";
    let value    = args[1];
    let onchange = args[2] || undefined;

let   caller = "_prop_set("+id+", "+value+", "+(onchange ? onchange.name:"")+")"; if(typeof dom_prop_notify != "undefined") dom_prop_notify(caller);

if( log_this) log("%c _prop_set %c"+id+" %c "+value         +" %c "+(onchange ? onchange.name:"")
                 ,lbH+lf3      ,lbL+lf4 ,lbR+(value?lf5:lf8)  ,lbH+lf9                           );


    let    prop  =  _prop_get(id, value, onchange);
    if(onchange &&  (prop.onchange  != onchange )) { prop.onchange       = onchange;  }
    if(             (prop.value     != value    )) { prop.value = (value == "toggle") ? !prop.value : value ; }
    else if( log_this) log("...unchanged");

    if(Prop_CB) Prop_CB(id, prop.value);

    return prop;
};


let _prop_got = function(id)
{
    for(let i=0; i < Prop_Map.length; ++i ) {
        if(  id   == Prop_Map[i].id  ) {
            return   Prop_Map[i];
        }
    }
    return null;
};


let _prop_get = function(id, value, onchange)
{
    let prop = _prop_got(id);

    if(!prop ) {
        prop = new Prop(id, value, onchange);
        Prop_Map.push(prop);
    }

if(DOM_PROP_TAG && !!prop.value && ((DOM_PROP_TAG===true) || String(DOM_PROP_TAG).includes(id)))
    log_key_val(prop.toString(), {DOM_PROP_TAG , DOM_PROP_LOG , caller:dom_log.get_callers()}, lfX[prop.value ? 9:0]);

    return prop;
};


let _prop_parse = function(id, value, onchange)
{

let   caller = "_prop_parse("+id+", "+value+")";
let log_this = DOM_PROP_LOG || LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

    let prop = _prop_get(id, value, onchange);
    if(       onchange && (onchange != prop.onchange ))
        prop .onchange  =  onchange;

    if(  prop.value != value)
    {
        _prop_set(id , value);

        if( prop.onchange)
            prop.onchange(id, prop.value);
    }
else if( log_this) log("...unchanged");

if( log_this) prop.log(caller);
    return prop;
};






let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_prop"
    , logging : (state) => DOM_PROP_LOG = t_store_set_state("DOM_PROP_LOG",state)
    , tagging : (state) => DOM_PROP_TAG = t_store_set_state("DOM_PROP_TAG",state)
    , t_prop_IMPORT

    , init          : prop_init
    , set           : prop_set
    , get           : prop_get
    , toggle        : prop_toggle
    , set_EL        : prop_set_EL
    , get_EL        : prop_get_EL
    , get_MAP       : prop_get_MAP
    , set_CB        : prop_set_CB
    , log_MAP       : prop_log_MAP


    , log_true      : prop_log_true
    , log_false     : prop_log_false
    , log_undefined : prop_log_undefined
    , log_onchange  : prop_log_onchange
};



}());
/*INLINE}}}*/
//@ sourceURL=dom_prop.js
`
 .replace(/\\/g,"\\\\")

 .replace(/%u/g,"\\u")
;
/*}}}*/

/**   11 STORE    JS dom_store_js_data {{{*/
/*
../script/dom_store.js
*/
let dom_store_js_data ="data:text/javascript;charset='utf-8',"+ `
/*INLINE{{{*/








const DOM_STORE_JS_ID       = "dom_store_js";
const DOM_STORE_JS_TAG      = DOM_STORE_JS_ID   +" (211122:23h:50)";

let dom_store   = (function() {
"use strict";
let   DOM_STORE_LOG         = false;
let   DOM_STORE_TAG         = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;

let t_prop     = {}        ;




















let t_store_IMPORT  = function(log_this,import_num)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;

    t_prop    = dom_prop   ;





















    store_INTERN();

    DOM_STORE_LOG = DOM_STORE_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_STORE_LOG"));
    DOM_STORE_TAG = DOM_STORE_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_STORE_TAG"));


if(log_this) log("%c "+import_num+" store", lbH+lf9);
};





let LOG_MAP;

let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;

let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let LF;


let   store_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


    LF = t_data.LF;



    if( dom_prop ) t_prop = dom_prop;


};







let store_info_observers = [];


let t_store_add_info_observer = function(observer)
{


    if(!store_info_observers.includes( observer ))
        store_info_observers.push    ( observer );
};
let _notify_info = function(info)
{

    for(let i=0; i < store_info_observers.length; ++i)
        store_info_observers[i](info);
};




let t_store_set_state = function(key, state)
{

let log_this = DOM_STORE_LOG || LOG_MAP.T0_STORE;




    let     v  = t_store_getBool(key);
    if( state == undefined) {
        state  = v;
    }


    else if( state ) {
        if(log_this) t_store_key_log("STORING  STATE",      key, state);

        store_setItem   (                           key, state);
    }


    else if( v ) {
if(log_this) t_store_key_log("REMOVING STATE",      key);

        store_removeItem(                           key);
    }

    return !!state;
};


let t_store_set_value = function(key, value)
{

let log_this = DOM_STORE_LOG || LOG_MAP.T0_STORE;




    let v = t_store_getItem(key);
    if( v && (v == value)) {


    }


    else if(value) {
if(log_this) t_store_key_log("STORING   VALUE", key, value);

        store_setItem(key , value);
    }


    else if(v) {
if(log_this) t_store_key_log("REMOVING  VALUE", key);

        store_removeItem(key);
    }

    return value;
};


let store_setItem = function(key,value)
{

    localStorage        .setItem(    store_get_site_or_page_pfx_for_key(key)+"."+key, value);
};


let store_removeItem = function(key)
{
    return  localStorage.removeItem( store_get_site_or_page_pfx_for_key(key)+"."+key       );
};




let t_store_getBool = function(key)
{
    return (localStorage.getItem(    store_get_site_or_page_pfx_for_key(key)+"."+key) == "true");
};


let t_store_getItem = function(key, site_or_page)
{
    let item
        = (site_or_page == "page") ? localStorage.getItem( t_store_get_page_pfx()+"."+key)
        : (site_or_page == "site") ? localStorage.getItem( t_store_get_site_pfx()+"."+key)
        :                            localStorage.getItem( store_get_site_or_page_pfx_for_key( key )+"."+key)
    ;

    return item;
};


let t_store_parseXY = function(key)
{
    let caller = "t_store_parseXY("+key+")";
let log_this = DOM_STORE_LOG || LOG_MAP.T0_STORE;
if( log_this) log(caller);

    let dom_string = t_store_getItem(key);
    if(!dom_string) return null;
if( log_this) log("...dom_string=["+dom_string+"]");

    let xy = null;
    try {
        xy    = JSON.parse(dom_string);
        let s = ""; Object.keys(xy).forEach( function(k) { s += "["+k+" = "+xy[k]+"]"+LF; });
if( log_this) log("%c"+ caller+":", lb0);
if( log_this) log("%c"+ s         , lb7);
     }
     catch(ex) {
if( log_this) log("%c"+caller+":"                                                     , lb2    );
if( log_this) log("%c"+t_util.trip_CR_LF(dom_string)                                  , lbF+lb0);
if( log_this) log("%c"+"0123456789_123456789_123456789_123456789_123456789_123456789_", lbF+lb8);
if( log_this) log("%c"+"0_________1_________2_________3_________4_________5_________6", lbF+lb8);
if( log_this) log("%c*** "+ex, lb2);
    }
    return xy;
};


let t_store_has_some_page_keys = function()
{
    let some_page_keys = [];
    let site_pfx = t_store_get_site_pfx();

    for(let i=localStorage.length-1; i>=0; --i)
    {
        let key      = localStorage.key(i);
        if(   !key.startsWith( site_pfx        )
           && !key.endsWith  ( "window_scrollY")
          )
            some_page_keys.push(key);
    }
    return some_page_keys.length
        ?  some_page_keys
        :  ""
    ;
};


let t_store_log_site_and_page = function()
{
    let results  = [];
    let site_pfx = t_store_get_site_pfx();
    let page_pfx = t_store_get_page_pfx();

    for(let i=localStorage.length-1; i>=0; --i)
    {
        let    key = localStorage.key(i);
        if(   !key.includes( site_pfx )
           && !key.includes( page_pfx )
          )
            continue;

        let       val = localStorage[key];

        let { filter_in  ,  filter_out } = store_FILTER(key,val);
        if(   filter_in || !filter_out)
        {
            let value = localStorage.getItem( key );
            results.push({key , value});
        }
    }

    t_log.console_table(results, "["+site_pfx+"] .. ["+page_pfx+"]");
    return results;
};


const EMPTY_ARRAY = '[""]';

let store_FILTER = function(key,val)
{

    if     ( val.includes("selected")) val = JSON.parse(val);




    let filter_in  = "";


    if( val.selected || val.pinned) filter_in    = "SELECTED OR PINNED";



    let filter_out = "";


    if(val == EMPTY_ARRAY)
        filter_out = "(val == "+EMPTY_ARRAY+")";

    else if(val.xy && !val.selected && !val.pinned)
        filter_out = "NOT selected and NOT pinned";


    if(   key.includes("hotspot"      )
       || key.includes("pivot"        )
       || key.includes("fly_div"      )
       || key.includes("ratio_"       )
       || key.includes("sel_arr"      )
       || key.includes("window_scroll")
      )
        filter_out = key;



    return { filter_in , filter_out };
};




let store_isa_page_key_array = [];
let t_store_add_page_key       = function(key) {        store_isa_page_key_array.push    ( key ); };
let store_isa_page_key       = function(key) { return store_isa_page_key_array.includes( key ); };


let   store_isa_site_key_array = [];
let t_store_add_site_key       = function(key) {        store_isa_site_key_array.push    ( key ); };
let   store_isa_site_key       = function(key) { return store_isa_site_key_array.includes( key ); };


let t_store_remove_shared_items = function(msg="")
{

let   caller = "t_store_remove_shared_items";
let log_this = DOM_STORE_TAG || DOM_STORE_LOG || LOG_MAP.T0_STORE;



    let site_pfx = t_store_get_site_pfx();
    let page_pfx = t_store_get_page_pfx();

    let page_items_keys_to_remove_array = [];
    for(let i=localStorage.length-1; i>=0; --i)
    {
        let k = localStorage.key(i);
        if( t_store_is_a_shared_item(site_pfx,page_pfx,i+1,k,log_this) )
        {
            page_items_keys_to_remove_array.push(k);
        }
    }


    if(page_items_keys_to_remove_array.length)
    {
if( log_this) log("%c"+caller, lbb+lbH+lf4);
if( log_this) log("%c localStorage: %c SITE %c"+site_pfx+"%c PAGE %c"+page_pfx +" %c REMOVING PAGE ITEMS:"
                  ,lbH+lf2         ,lbL+lf8,lbR+lf2      ,lbL+lf8,lbR+lf3        ,lbH+lf3                 );

        let removed_keys = "";
        for(let i=0; i < page_items_keys_to_remove_array.length; ++i)
        {
            let k = page_items_keys_to_remove_array[i];
if(log_this) log((i+1)+"%c removing %c"+k
                 ,      lbL+lf2    ,lbR+lf3);

            localStorage.removeItem(k);
            removed_keys += (i+1)+" - "+store_key_tail(k)+LF;
        }
        _notify_info(  (  msg
                        ? msg+LF
                        : ""
                       )
                       + (  removed_keys
                          ? "PAGE STORAGE CLEARED:"+LF+removed_keys
                          : "NO PAGE STORAGE CLEARED"
                         )
                    );
    }

};


let t_store_is_a_shared_item = function(site_pfx,page_pfx,num,key,log_this)
{
 let why_not    = ""; let why_shared = "";                  let lfx = lf8;

    if     ( key.startsWith(site_pfx     ) ) { why_not    =                 "SKIPPING SITE KEY"    ; lfx = lf0; }
    else if( key.includes  (".DOM"       ) ) { why_not    =                 "SKIPPING DOM  KEY"    ; lfx = lf7; }
    else if( key.includes  (".SNAPSHOT"  ) ) { why_not    =                 "SKIPPING SNAPSHOT KEY"; lfx = lf7; }
    else if( key.startsWith(page_pfx     ) ) {                 why_shared = "SHARING  PAGE KEY"    ; lfx = lf2; }


if(log_this) {
    let result = why_shared || why_not;
    log(num+"%c "+t_util.mPadStart(result,16)+"%c"+t_util.mPadStart(key,48)+"%c"+ t_util.ellipsis(localStorage.getItem(key),32)
        ,    lbL+lfx                          ,lbC+lfx                      ,lbR+lfx                                           );
}

    return why_shared;
};


let t_store_remove_all_site_items = function(msg="")
{

let   caller = "t_store_remove_all_site_items";
let log_this = DOM_STORE_LOG || LOG_MAP.T0_STORE;



    let site_pfx = t_store_get_site_pfx();

    let site_items_keys_to_remove_array = [];
    for(let i=localStorage.length-1; i>=0; --i)
    {
        let k      = localStorage.key(      i);
        if( k.startsWith( site_pfx ) )
        {

            site_items_keys_to_remove_array.push(k);
        }
        else {

        }
    }


    if(site_items_keys_to_remove_array.length)
    {
if( log_this) log("%c"+caller, lbb+lbH+lf4);
if( log_this) log("%c localStorage: %c SITE %c"+site_pfx+"%c PAGE %c"+site_pfx +" %c REMOVING PAGE ITEMS:"
                  ,lbH+lf2         ,lbL+lf8,lbR+lf2      ,lbL+lf8,lbR+lf3        ,lbH+lf3                 );

        let removed_keys = "";
        for(let i=0; i < site_items_keys_to_remove_array.length; ++i)
        {
            let k = site_items_keys_to_remove_array[i];
if(log_this) log((i+1)+"%c removing %c"+k
                 ,      lbL+lf2    ,lbR+lf3);

            localStorage.removeItem(k);

            removed_keys += (i+1)+" - "+store_key_tail(k)+LF;
        }
        _notify_info(  (  msg
                        ? msg+LF
                        : ""
                       )
                       + (  removed_keys
                          ? "SITE STORAGE CLEARED:"+LF+removed_keys
                          : "NO SITE STORAGE CLEARED"
                         )
                    );
    }

};


let t_store_get_site_pfx = function()
{
    return t_util.tokenize
        ?  t_util.tokenize( window.location.hostname || SITE_URL_TEMPLATE)
        :                   window.location.hostname
    ;
};



const BACKSLASH = String.fromCharCode(92);
const FORESLASH = String.fromCharCode(47);


let t_store_get_page_pfx = function()
{
    let a
        = (window.location.pathname.indexOf(FORESLASH) >= 0)
        ?  window.location.pathname.split  (FORESLASH)
        :  window.location.pathname.split  (BACKSLASH);

    let dirName
        = (  a.length > 1)
        ?  a[a.length - 2]
        :  ""
    ;

    let fileName_or_index
        =  a[a.length-1]
        || "index"
    ;

    let idx = fileName_or_index.indexOf(".");
    let ext
        = (idx > 1)
        ?  fileName_or_index.substring(idx+1)
        :  ""
    ;
    if(ext) fileName_or_index = fileName_or_index.substring(0, fileName_or_index.length - ext.length -1);



    let result
        = (dirName   !=               "")
        ? (dirName+"_"+fileName_or_index)
        :              fileName_or_index
    ;

    return result || "index";

};




let t_store_add_listener =function()
{

let   caller = "t_store_add_listener";
let log_this = DOM_STORE_LOG || LOG_MAP.T0_STORE;

if( log_this) log(caller);


    window.addEventListener("storage", store_storage_listener);
};


let store_storage_listener = function(e)
{
let log_this = DOM_STORE_LOG || LOG_MAP.T0_STORE;

if( log_this ) {
    log("%c STORAGE EVENT %c key %c"+e.key
        ,lbH+lf3    ,lbL+lf5,lbR+lf4);

    log_key_val_group( "url keys values"
                       , {        url : e.url
                           ,      key : e.key
                           , oldValue : t_util.ellipsis(e.oldValue)
                           , newValue : t_util.ellipsis(e.newValue)
                           ,  callers : t_log.get_callers()
                       }
                       , lf8
                       , true
                     );
    console.dir(e.storageArea);
}
};




let t_site_or_page_logged_keys_clear = function(_caller)
{

    site_or_page_logged_keys=[];
};


let site_or_page_logged_keys = [];
let store_isa_site_or_page_key = function(key)
{

let   caller = "store_isa_site_or_page_key";
let log_this = LOG_MAP && (LOG_MAP.T0_STORE);

if( log_this) {
    log(caller+"("+key+")");

    if(!site_or_page_logged_keys.includes(key) )
    {
        site_or_page_logged_keys.push(key);

        let isa_site_key = store_isa_site_key( key          ); let l_s = isa_site_key ? lf2 : lf0;
        let isa_page_key = store_isa_page_key( key          ); let l_p = isa_page_key ? lf6 : lf0;
        let site_or_page =       t_prop.get( t_data.SITE_OR_PAGE ); let l_m = site_or_page ? lf2 : lf6;

        if(isa_site_key || isa_page_key || site_or_page)
        {
            log("...%c"+t_util.mPadStart(key,32)+"%c"+(isa_site_key ? "site key":"")+"%c"+(isa_page_key ? "page key":"")+"%c"+(site_or_page ? "mode site":"mode page")
                ,   lbL+lf4                      ,lbR+l_s                            ,lbR+l_p                            ,lbH+l_m                                     );
        }
    }
}

    if( store_isa_site_key( key ) ) return  true;
    if( store_isa_page_key( key ) ) return false;
      return t_prop.get( t_data.SITE_OR_PAGE );
};




const SITE_URL_TEMPLATE = "www.localhost.com";


let store_get_site_or_page_pfx_for_key = function(key)
{
    return store_isa_site_or_page_key( key )
        ?  t_store_get_site_pfx()
        :  t_store_get_page_pfx();
};





let _store_log_transient_key_array  = [];

let  t_store_do_not_log_transient_key = function(key) {        _store_log_transient_key_array.push    ( key ); };
let _store_isa_transient_key        = function(key) { return _store_log_transient_key_array.includes( key ); };


let t_store_key_log = function(msg, key, value="")
{
    if( _store_isa_transient_key( key ) ) {

        return;
    }

    let site_or_page = store_isa_site_or_page_key( key ) ? "PAGE" : "SITE";
    let          lbx = (site_or_page == "PAGE") ? lbA : lbb;
    let          lfx = (site_or_page == "PAGE") ? lf5 : lf7;

    log(   "%c STORE SCOPE %c"+ site_or_page +"%c"+ store_get_site_or_page_pfx_for_key( key )
          +  "%c"             + msg
          +   "%c"            + key +"%c = %c"+ (value || "&nbsp;")
          ,  lbL+lf8       ,lbC+lfx            ,lbR+lfx
          ,    lbH+lfx
          ,     lbx+lfx+lbL,        lbx+lbC,lbx+lbR+lfx
       );

};


let store_key_tail = function(k)
{
    return k.substring(k.lastIndexOf(".") + 1);
};


// t_store_IMPORT(true);// ReferenceError: Cannot access 'dom_store' before initialization


return { name : "dom_store"
    , logging : (state) => DOM_STORE_LOG = t_store_set_state("DOM_STORE_LOG",state)
    , tagging : (state) => DOM_STORE_TAG = t_store_set_state("DOM_STORE_TAG",state)
    , t_store_IMPORT

    , SITE_URL_TEMPLATE


    , t_store_set_state
    , t_store_set_value


    , t_store_getBool
    , t_store_getItem
    , t_store_parseXY
    , t_store_has_some_page_keys
    , t_store_log_site_and_page


    , t_store_add_page_key
    , t_store_add_site_key
    , t_store_remove_shared_items
    , t_store_is_a_shared_item
    , t_store_remove_all_site_items
    , t_store_get_page_pfx
    , t_store_get_site_pfx


    , t_store_add_info_observer
    , t_store_add_listener


    , t_site_or_page_logged_keys_clear


    , t_store_do_not_log_transient_key
    , t_store_key_log

};



}());

//dom_store.t_store_IMPORT(true,0);
/*INLINE}}}*/
//@ sourceURL=dom_store.js
`
 .replace(/\\/g,"\\\\")

 .replace(/%u/g,"\\u")
;

/*}}}*/
/**  12 FLY      JS dom_fly_js_data .. ESCAPE [sample += "--- !! @@ ## $$ %% ~~ ^^ ** (( ))"] {{{*/
/*
../script/dom_fly.js
*/
let dom_fly_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/


const DOM_FLY_JS_ID         = "dom_fly_js";
const DOM_FLY_JS_TAG        = DOM_FLY_JS_ID     +" (211122:16h:42)";
let dom_fly     = (function() {
"use strict";


















let   DOM_FLY_LOG           = false;
let   DOM_FLY_TAG           = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;
let t_i18n     = {}        ;
let t_prop     = {}        ;
let t_store    = {}        ;



let t_select   = {}        ;












let t_tools    = {}        ;


let t_fly_IMPORT    = function(log_this)
{

    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;
    t_i18n    = dom_i18n   ;
    t_prop    = dom_prop   ;
    t_store   = dom_store  ;



    t_select  = dom_select ;













    t_tools   = dom_tools  ;

    fly_INTERN();

    DOM_FLY_LOG = DOM_FLY_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_FLY_LOG"));
    DOM_FLY_TAG = DOM_FLY_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_FLY_TAG"));


if(log_this) log("%c 10 FLY", lbH+lf0);
};



let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let   fly_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;



    fly_DEPEND();
};



let DOC_EVT_DIV_EMPTY;
let DOC_LOG_DIV_EMPTY;
let DOC_EVT_DIV_HEADER;
let DOC_LOG_DIV_HEADER;

let FLOATLOG_MARGIN;


let   fly_DEPEND = function()
{

    DOC_EVT_DIV_EMPTY  = "<span style='font-size:500%;'>"+t_data.SYMBOL_GEAR+"</span>";
    DOC_LOG_DIV_EMPTY  = "<span style='font-size:500%;'>"+t_data.SYMBOL_BULB+"</span>";
    DOC_EVT_DIV_HEADER = "<span style='font-size:200%;'>"+t_data.SYMBOL_GEAR+"</span>";
    DOC_LOG_DIV_HEADER = "<span style='font-size:200%;'>"+t_data.SYMBOL_BULB+"</span>";

    FLOATLOG_MARGIN
        = {   top    :16
            , left   :16
            , right  :16 + t_data.SCROLLBAR_WIDTH
            , bottom :16 + t_data.SCROLLBAR_WIDTH
        };

};








let fly_div;


let t_fly_div_get = function()
{
    if(fly_div) return fly_div;

    fly_div    = document.createElement("DIV"  );

    fly_div.id = "fly_div";
    t_tools.t_set_CSS_PINNED(fly_div, true);

    let xy = t_store.t_store_parseXY("fly_div_XY");
    if(xy) {
        fly_div.style.left = xy.x+"px";
        fly_div.style.top  = xy.y+"px";
    }

    let fly_div_parent = get_fly_div_parent();

    if( fly_div_parent ) fly_div_parent.appendChild( fly_div );

    return fly_div;
};


let get_fly_div_parent = function()
{
    return (typeof dom_tools != "undefined")
        ?          t_tools.t_get_tool("dom_tools_html")
        :          document.documentElement
    ;
};



let div_ccX = 0;


let t_fly_log_set_state = function(state)
{

let   caller = "t_fly_log_set_state("+state+")";


    let fly_log = t_tools.t_get_fly_log();
    if(!fly_log) return;


    if(LOG_MAP.EV8_FLOATLOG) t_util.add_el_class(fly_log, t_tools.CSS_DISABLED);
    else                     t_util.del_el_class(fly_log, t_tools.CSS_DISABLED);


    state
        = LOG_MAP.EV8_FLOATLOG ? "EV8_FLOATLOG"
        :                        state
    ;


    fly_log.innerHTML
        =  state ? (LOG_MAP.EV8_FLOATLOG
                    ? t_data.SYMBOL_GEAR
                    : t_data.SYMBOL_CHECK_MARK)
        :             t_data.SYMBOL_MENU
    ;
    fly_log.title
        = t_i18n.i18n_get(t_i18n.FLY_LOG)
        + (  LOG_MAP.EV8_FLOATLOG
           ?  t_data.LF+"LOG_MAP.EV8_FLOATLOG"
           :  "")
    ;

    t_tools.t_set_id_class_on_off(fly_log.id, t_data.CSS_CHECKED , state);


    t_util.set_el_class_on_off(fly_div   , t_tools.CSS_FLOATLOG, state);


    t_prop.set(t_data.FLOATLOG, state);

    div_ccX        = 0;


    if( t_fly_tooltip_has_category() ) fly_clr_top(caller+"("+state+")");
    else                               t_fly_init (caller+"("+state+")");
};


let t_fly_onlayout = function(_caller)
{
    if(!fly_div) return;

    let         w_H = Math.min(window.innerHeight, document.body.parentElement.clientHeight);
    let         w_W = Math.min(window.innerWidth , document.body.parentElement.clientWidth );

    let       scale = t_util.has_el_class(fly_div, t_tools.CSS_MAGNIFIED) ? 2 : 1;

    let         bcr = fly_div.getBoundingClientRect();

    let                 t_x = ((bcr.left + bcr.width /2) < (w_W/2)) ? 0 : 100;
    let                 t_y = ((bcr.top  + bcr.height/2) < (w_H/2)) ? 0 : 100;
    fly_div.transformOrigin = t_x+"% "+t_y+"% 0";

    let off_left            = (bcr.left   < (      FLOATLOG_MARGIN.left  ));
    let off_right           = (bcr.right  > (w_W - FLOATLOG_MARGIN.right ));
    let off_top             = (bcr.top    < (      FLOATLOG_MARGIN.top   ));
    let off_bottom          = (bcr.bottom > (w_H - FLOATLOG_MARGIN.bottom));


    if( off_left   ) fly_div.style.left = (      FLOATLOG_MARGIN.left                       )+"px";
    if( off_top    ) fly_div.style.top  = (      FLOATLOG_MARGIN.top                        )+"px";
    if( off_right  ) fly_div.style.left = (w_W - FLOATLOG_MARGIN.right  - bcr.width  / scale)+"px";
    if( off_bottom ) fly_div.style.top  = (w_H - FLOATLOG_MARGIN.bottom - bcr.height / scale)+"px";

    t_util.t_adjust_panel_transform_origin(fly_div);

};


let t_fly_div_magnified_toggle = function(new_state="toggle")
{

let   caller = "t_fly_div_magnified_toggle("+new_state+")";
let log_this = (LOG_MAP.EV4_LONG_PRESS || LOG_MAP.T3_LAYOUT);

if( log_this) t_log_event_status(caller, lf9);

    t_prop.set( t_data.FLY_DIV_MAGNIFIED , new_state);


    if(new_state == "toggle")
    {
        fly_div.style.right = "unset";

    }

    new_state = (new_state == "toggle") ? !t_util.has_el_class(fly_div, t_tools.CSS_MAGNIFIED) : new_state ;
if(log_this) t_log.log("...new_state=["+new_state+"]");

    if( new_state ) t_util.add_el_class(fly_div, t_tools.CSS_MAGNIFIED);
    else            t_util.del_el_class(fly_div, t_tools.CSS_MAGNIFIED);

    t_tools.t_save_update_post("fly_div_magnified "+new_state);

if(log_this) t_log.log(caller+": fly_div_magnified: %c "+new_state+" ", (new_state ? lb9 : lb8));
};






let t_log_stage = function(stage, something_clicked, pattern_clicked, e_target, parent_div)
{
    let innerHTML = ""
        +       " <em class='cc"+stage.color+"'>"+  t_util.strip_UL( stage.level    ) +"</em>"
        +       " <em class='cc"+stage.color+"'>"+  t_util.strip_UL( stage.context  ) +"</em>"
        +       " <em class='cc"+stage.color+"'>"+  t_util.strip_UL( stage.action   ) +"</em>"
        +   ( pattern_clicked
            ? ( " <em class='cc"+stage.color+"'>"+            e_target.title   +"</em>")
            : ( " <em class='cc"+stage.color+"'>"+ t_util.get_n_lbl( parent_div     ) +"</em>"))
    ;

    t_log_stage_msg((something_clicked ? STAGE_1_INPUT : STAGE_2_ACTION), innerHTML);
};



const STAGE_0_NONE      = "stage_0_none";

const STAGE_1_INPUT     = "stage_1_input" ;
const STAGE_2_ACTION    = "stage_2_action";
const STAGE_3_RESULT    = "stage_3_result";

const STAGE_1_MISSED    = "stage_1_missed";
const STAGE_2_MISSED    = "stage_2_missed";
const STAGE_3_MISSED    = "stage_3_missed";
const STAGE_1_MORE      = "stage_1_more"  ;
const STAGE_3_MORE      = "stage_3_more"  ;




let t_log_stage_msg = function(stage, msg)
{

let log_this = LOG_MAP.EV8_FLOATLOG;

if( log_this) t_log.log("%c t_log_stage_msg("+stage+" , "+msg+") ", lbF+lb7);


    let prev_div
        = (fly_div.children.length > 0)
        ?  fly_div.children[fly_div.children.length-1]
        : null;
if( log_this) t_log.log("...children.length=["+fly_div.children.length+"]");

if( log_this && prev_div) t_log.log("%c prev_div=["+t_util.strip_HTML(prev_div.innerHTML)+"]", lbH);


    let prev_stage
        = t_util.has_el_class(prev_div, STAGE_1_INPUT ) ? STAGE_1_INPUT
        : t_util.has_el_class(prev_div, STAGE_2_ACTION) ? STAGE_2_ACTION
        : t_util.has_el_class(prev_div, STAGE_3_RESULT) ? STAGE_3_RESULT
        :                                          STAGE_0_NONE;
if( log_this) t_log.log("......prev_stage=["+ prev_stage +"]");



    let tools_status = t_log_tools_status_get();
    let event_status = t_log_event_status_get();
    let is_prev_stage_continuation
        =  (stage == prev_stage);

if( log_this) t_log.log("...is_prev_stage_continuation=["+is_prev_stage_continuation+"]");


    if( !is_prev_stage_continuation ) {
        let prev_stage_missed = "";
        switch( stage ) {
            case STAGE_1_INPUT : if(prev_stage != STAGE_3_RESULT) prev_stage_missed = STAGE_3_MISSED; break;
            case STAGE_2_ACTION: if(prev_stage != STAGE_3_RESULT) prev_stage_missed = STAGE_3_MISSED; break;
            case STAGE_3_RESULT: if(prev_stage != STAGE_3_RESULT) prev_stage_missed = STAGE_3_MISSED; break;
        }
        if(prev_stage == STAGE_0_NONE)                            prev_stage_missed = STAGE_1_MISSED;

        if(prev_stage_missed)
            t_util.add_el_class(prev_div, prev_stage_missed);
    }
    else {
        t_util.flip_el_class(   prev_div    , STAGE_3_MISSED);
        if(              prev_stage == STAGE_3_RESULT)
            t_util.add_el_class(prev_div    , STAGE_3_MORE  );
    }


    let stage_missed = "";
    switch(stage) {
        case     STAGE_0_NONE  :                                          stage_missed = STAGE_3_MISSED+" "+STAGE_3_MISSED;   break;
        case     STAGE_1_INPUT : if( is_prev_stage_continuation )         stage_missed = STAGE_1_MORE  ;                      break;
        case     STAGE_2_ACTION: if(!is_prev_stage_continuation )         stage_missed = STAGE_1_MISSED;                      break;
        case     STAGE_3_RESULT: if(!is_prev_stage_continuation )         stage_missed = STAGE_1_MISSED+" "+STAGE_2_MISSED;   break;
    }
if( log_this) t_log.log("...stage_missed=["+stage_missed+"]");


    let symbol = "";
    switch(stage) {
        case STAGE_1_INPUT : symbol = t_data.SYMBOL_STAGE1_INPUT ; break;
        case STAGE_2_ACTION: symbol = t_data.SYMBOL_STAGE2_ACTION; break;
        case STAGE_3_RESULT: symbol = t_data.SYMBOL_STAGE3_RESULT; break;

    }


    if(!is_prev_stage_continuation)
        div_ccX = (div_ccX + 1) % 10;



    let title = t_util.strip_HTML(tools_status + t_data.LF + event_status);



    t_fly_add_innerHTML("<div class='cc"+div_ccX+" "+stage+" "+stage_missed+"' title='"+title+"'>"+symbol+" "+msg+"</div>");



    if(stage != STAGE_3_RESULT) {
        if(t_log_stage_close_timer) clearTimeout(t_log_stage_close_timer);
        t_log_stage_close_timer   =   setTimeout(t_log_stage_close_handler, T_LOG_STAGE_CLOSE_DELAY);
    }

};



const T_LOG_STAGE_CLOSE_DELAY = t_data.T_STANDBY1_DELAY + 500;
let t_log_stage_close_timer;


let t_log_stage_close_handler = function()
{
let log_this = LOG_MAP.EV8_FLOATLOG;

    let last_div
        = (fly_div.children.length > 0)
        ?  fly_div.children[fly_div.children.length-1]
        : null;
if( log_this) t_log.log("t_log_stage_close_handler: ...children.length=["+fly_div.children.length+"]");
    if(!last_div) return;


    let last_stage
        = t_util.has_el_class(last_div, STAGE_1_INPUT ) ? STAGE_1_INPUT
        : t_util.has_el_class(last_div, STAGE_2_ACTION) ? STAGE_2_ACTION
        : t_util.has_el_class(last_div, STAGE_3_RESULT) ? STAGE_3_RESULT
        :                                          STAGE_0_NONE;
if( log_this) t_log.log("......last_stage=["+ last_stage +"] ["+last_div.textContent+"]");

    if(last_stage != STAGE_3_RESULT) t_util.add_el_class(last_div, STAGE_3_MISSED);





};






let t_log_behavior = function()
{
    let transcript2 = t_tools.t_get_transcript2();


    if(!t_doc_div_clear("doc_log_div") )
        t_tools.t_tools_panel_select(transcript2);

    t_tools.t_clear("t_log_behavior");
    t_tools.t_load_BEHAVIOR();
};


let t_log_regex = function()
{
    let transcript2 = t_tools.t_get_transcript2();


    if(!t_doc_div_clear("doc_log_div") )
        t_tools.t_tools_panel_select(transcript2);

    let sample;
    let html = "";
    html += "<hr><em class='cc1'>t_util.get_first_word:</em>";
    sample = "word_1 word_2 word_3";
    html += "<br>SAMPLE=<div class='eso_div'>"+             sample                 +"</div>";
    html += "RESULT=<div class='eso_div'>"+ t_util.get_first_word( sample, "t_log_regex") +"</div>";


    html += "<hr><em class='cc1'>t_util.get_first_word:</em>";
    sample += "--- !! @@ ## $$ %% ~~ ^^ ** (( ))"+          sample;
    html += "<br>SAMPLE=<div class='eso_div'>"+             sample                 +"</div>";
    html += "RESULT=<div class='eso_div'>"+ t_util.get_first_word( sample, "t_log_regex") +"</div>";


    html += "<hr><em class='cc1'>t_select.get_word_at_offset:</em>";

    let ruler_tens = "_________1_________2_________3_________4_________5_________6_________7_________8_________9_______100_______110___";
    let ruler_unit = "123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123";
    let ruler_off  = "|_|_____|___|_____|___|_____|___|__|_|_____|___|_____||___|||______|___|___________________________________|___||";
    sample         = "Le papillon qui est la forme 'adulte' de la chenille, éclos durant l'été entre juin et septembre selon le climat.";

    if( !t_tools.t_tools_IN_WEBVIEW ) ruler_off = t_util.vbar_to_up_arrow(           ruler_off );


    html
        += "<div style='font-size:150%' class='cc0'>"
        +  sample     +"<br>"
        +  ruler_off  +"<br>"
        +  ruler_unit +"<br>"
        +  ruler_tens
        +  "</div>"
    ;

    let offset;
    html
        += "<div style='float:left'>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset =  1, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset =  3, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset =  9, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 13, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 19, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 33, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  "</div>"
    ;
    html
        += "<div style='float:left'>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 36, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 38, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 44, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 48, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 54, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 55, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  "</div>"
    ;

    html
        += "<div style='float:left'>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 59, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 60, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 61, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 68, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = 72, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset =108, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset =112, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset =113, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em><br>"
        +  "</div>"
    ;

    html
        += "<div style='float:left'>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset = -5, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em>"
        +  " <em class='cc8'>offset "+t_util.mPadStart(offset =150, 3)+"</em> <em class='cc4'>"+ t_select.get_word_at_offset(sample, offset) +"</em>"
        +  "</div>"
    ;

    html += "<br style='clear:both;'>";

    html += "<hr><em class='cc1'>t_util.strip_CR_LF:</em>";
    sample = "...LINE1 ENDING WITH t_data.CR"+t_data.CR+"...LINE2 ENDING WITH CRLF"+t_data.CR+t_data.LF+"...LINE3 ENDING WITH t_data.LF"+t_data.LF;
    html += "<br>SAMPLE=<div class='eso_div'>"+                 sample    +"</div>";
    html += "RESULT=<div class='eso_div'>"+       t_util.strip_CR_LF(  sample  ) +"</div>";


    html += "<hr><em class='cc1'>t_util.trim_empty_lines(alnum_filter=false):</em>";
    sample
        += "NEXT LINE: only space chars='"+t_data.LF
        +  "             "+t_data.LF
        +  "'"+t_data.LF
        +  "NEXT LINE: only non-word chars='"+t_data.LF
        +  "--- !! @@ ## $$ %% ~~ ^^ ** (( ))"+t_data.LF
        +  "'"+t_data.LF
    ;

    html += "<br>SAMPLE=<div class='eso_div'>"+                 sample         +"</div>";
    html += "RESULT=<div class='eso_div'>"+  t_util.trim_empty_lines(  sample, false) +"</div>";


    html += "<hr><em class='cc1'>t_util.trim_empty_lines(alnum_filter=true):</em>";
    html += "<br>SAMPLE=<div class='eso_div'>"+                 sample        +"</div>";
    html += "RESULT=<div class='eso_div'>"+  t_util.trim_empty_lines(  sample, true) +"</div>";


    if     (t_tools.t_tools_panel_is_selected( transcript2 )) t_log.log_TR_RESULT_set(html);
    else if(                               doc_log_div  ) t_log_transcript_info  (html);
};






let t_last_event_status;
let t_last_tools_status;

let t_fly_clr_status = function()
{
    t_last_event_status = "";
    t_last_tools_status = "";
};



let t_log_event_status = function(_caller="console", l_x=lf9)
{



    let l_l = _caller.includes(t_data.LF) ? lbH : lbL;

console.groupCollapsed("%c"+_caller+" %c STATUS... %c"+t_data.SYMBOL_ANCHOR, l_l+l_x, lbR+l_x, lbb+l_x);

    t_log.log_key_val_group("UI", log_get_tools_status_object(), lf5, false);
    t_log.log_key_val_group("EV", log_get_event_status_object(), lf6, false);

console.trace();
console.groupEnd();

};


let t_log_event_status_if_changed = function(_caller="console", l_x=undefined)
{
    if(    t_log_tools_status_get_if_changed()
        || t_log_event_status_get_if_changed()
      )
        t_log_event_status(_caller, l_x);

};


let t_log_event_status_if_changed_filter = function(_caller="console", filter="", l_x=undefined)
{
    if(    t_log_tools_status_get_if_changed(filter)
        || t_log_event_status_get_if_changed(filter)
      )
        t_log_event_status(_caller+(filter ? (" [filter "+filter+"]") : ""), l_x);

};



let t_log_tools_status_get_if_changed = function(filter)
{
    let tools_status  = log_get_tools_status_string(filter);

    if( tools_status != t_last_tools_status) {
        t_last_tools_status  = tools_status;
        return                 tools_status;
    }
    else {
        return              null;
    }
};


let t_log_tools_status_get = function()
{
    let                           tools_status = log_get_tools_status_string();
    if(    t_last_tools_status != tools_status)   t_last_tools_status = tools_status;
    return                        tools_status;
};



let t_log_event_status_get_if_changed = function(filter)
{
    let event_status  = log_get_event_status_string(filter);
    if( event_status != t_last_event_status) {
        t_last_event_status  = event_status;
        return                 event_status;
    }
    else {
        return              null;
    }
};


let t_log_event_status_get = function()
{
    let                       event_status = log_get_event_status_string();
    if(t_last_event_status != event_status)   t_last_event_status = event_status;
    return                    event_status;
};



let log_get_tools_status_string = function(filter)
{
    let o = log_get_tools_status_object();

    let tools_status
        =       " onWork_EL...........: "+ o.onWork_EL+" "+o.tool_details + t_data.LF
        +       " onWork_SEEK_TARGET..: "+ o.onWork_SEEK_TARGET           + t_data.LF
        +       " onWork_PANEL........: "+ o.onWork_PANEL                 + t_data.LF
        +       " .pivot_PANEL........: "+ o. pivot_PANEL                 + t_data.LF
        +       " onWork_MOVABLE_PANEL: "+ o.onWork_MOVABLE_PANEL
    ;


    return tools_status;
};


let log_get_event_status_string = function(filter)
{
    let o = log_get_event_status_object();

    let event_status
        =       "EVENT CAPTURED BY "              + o.captured_by                 + t_data.LF
        +       "EVENT CONSUMED BY "              + o.consumed_by                 + t_data.LF
        +       "...................was_a_click: "+ o.was_a_click                 + t_data.LF
        +       "............selection_progress: "+ o.selection_progress          + t_data.LF
        +       ".....................onSeekXYL: "+ o.onSeekXYL                   + t_data.LF
    ;
    if(!filter || !filter.includes("scroll"))
        event_status
            +=  ".....................has_moved: "+ o.has_moved                   + t_data.LF
            +   "................window.scrollY: "+ o.window_scrollY              + t_data.LF
            +   "...has_been_scrolled_by_script: "+ o.has_been_scrolled_by_script + t_data.LF;

    return event_status;
};



let         tools_status_object_prev;
let log_get_tools_status_object = function()
{

    let tools_status_object = t_tools.t_get_tools_status_object();



    let            onDown_EL_changed = (!tools_status_object_prev || (tools_status_object.onDown_EL            != tools_status_object_prev.onDown_EL           ));
    let            onWork_EL_changed = (!tools_status_object_prev || (tools_status_object.onWork_EL            != tools_status_object_prev.onWork_EL           ));
    let  onWork_EL_last_used_changed = (!tools_status_object_prev || (tools_status_object.onWork_EL_last_used  != tools_status_object_prev.onWork_EL_last_used ));
    let         onWork_PANEL_changed = (!tools_status_object_prev || (tools_status_object.onWork_PANEL         != tools_status_object_prev.onWork_PANEL        ));
    let onWork_MOVABLE_PANEL_changed = (!tools_status_object_prev || (tools_status_object.onWork_MOVABLE_PANEL != tools_status_object_prev.onWork_MOVABLE_PANEL));
    let     onWork_SEEK_TOOL_changed = (!tools_status_object_prev || (tools_status_object.onWork_SEEK_TARGET     != tools_status_object_prev.onWork_SEEK_TARGET    ));
    let  seeker_isOn_SLOT_EL_changed = (!tools_status_object_prev || (tools_status_object.seeker_isOn_SLOT_EL  != tools_status_object_prev.seeker_isOn_SLOT_EL ));
    let           ui_details_changed = (!tools_status_object_prev || (tools_status_object.tool_details         != tools_status_object_prev.tool_details        ));




    if(!tools_status_object_prev)                                            tools_status_object_prev = {};

    let o = { onDown_EL            : (           onDown_EL_changed ? (t_log.L_NEW+ tools_status_object.onDown_EL            +t_log.L_ARL +tools_status_object_prev.onDown_EL           ) : t_log.L_CHK+ tools_status_object.onDown_EL           )
        ,     onWork_EL            : (           onWork_EL_changed ? (t_log.L_NEW+ tools_status_object.onWork_EL            +t_log.L_ARL +tools_status_object_prev.onWork_EL           ) : t_log.L_CHK+ tools_status_object.onWork_EL           )
        ,     onWork_EL_last_used  : ( onWork_EL_last_used_changed ? (t_log.L_NEW+ tools_status_object.onWork_EL_last_used  +t_log.L_ARL +tools_status_object_prev.onWork_EL_last_used ) : t_log.L_CHK+ tools_status_object.onWork_EL_last_used )
        ,     onWork_PANEL         : (        onWork_PANEL_changed ? (t_log.L_NEW+ tools_status_object.onWork_PANEL         +t_log.L_ARL +tools_status_object_prev.onWork_PANEL        ) : t_log.L_CHK+ tools_status_object.onWork_PANEL        )
        ,     onWork_MOVABLE_PANEL : (onWork_MOVABLE_PANEL_changed ? (t_log.L_NEW+ tools_status_object.onWork_MOVABLE_PANEL +t_log.L_ARL +tools_status_object_prev.onWork_MOVABLE_PANEL) : t_log.L_CHK+ tools_status_object.onWork_MOVABLE_PANEL)
        ,     onWork_SEEK_TARGET     : (    onWork_SEEK_TOOL_changed ? (t_log.L_NEW+ tools_status_object.onWork_SEEK_TARGET     +t_log.L_ARL +tools_status_object_prev.onWork_SEEK_TARGET    ) : t_log.L_CHK+ tools_status_object.onWork_SEEK_TARGET    )
        ,     seeker_isOn_SLOT_EL  : ( seeker_isOn_SLOT_EL_changed ? (t_log.L_NEW+ tools_status_object.seeker_isOn_SLOT_EL  +t_log.L_ARL +tools_status_object_prev.seeker_isOn_SLOT_EL ) : t_log.L_CHK+ tools_status_object.seeker_isOn_SLOT_EL )
        ,     tool_details         : (          ui_details_changed ? (t_log.L_NEW+ tools_status_object.tool_details         +t_log.L_ARL +tools_status_object_prev.tool_details        ) : t_log.L_CHK+ tools_status_object.tool_details        )
    };


    tools_status_object_prev = tools_status_object;


    return o;
};


let     event_status_object_prev;
let log_get_event_status_object = function()
{


    let event_status_object = t_tools.t_get_event_status_object();



    let                 captured_by_changed = (!event_status_object_prev || (event_status_object.captured_by                 != event_status_object_prev.captured_by                ));
    let                 consumed_by_changed = (!event_status_object_prev || (event_status_object.consumed_by                 != event_status_object_prev.consumed_by                ));
    let                   has_moved_changed = (!event_status_object_prev || (event_status_object.has_moved                   != event_status_object_prev.has_moved                  ));
    let                 was_a_click_changed = (!event_status_object_prev || (event_status_object.was_a_click                 != event_status_object_prev.was_a_click                ));
    let          selection_progress_changed = (!event_status_object_prev || (event_status_object.selection_progress          != event_status_object_prev.selection_progress         ));
    let has_been_scrolled_by_script_changed = (!event_status_object_prev || (event_status_object.has_been_scrolled_by_script != event_status_object_prev.has_been_scrolled_by_script));
    let              window_scrollY_changed = (!event_status_object_prev || (event_status_object.window_scrollY              != event_status_object_prev.window_scrollY             ));
    let                   onSeekXYL_changed = (!event_status_object_prev || (event_status_object.onSeekXYL                   != event_status_object_prev.onSeekXYL                  ));



    if(!event_status_object_prev)                                                           event_status_object_prev = {};

    let o = { captured_by                 : (                 captured_by_changed ? (t_log.L_NEW+ event_status_object.captured_by                 +t_log.L_ARL + event_status_object_prev.captured_by                 ) : t_log.L_CHK+ event_status_object_prev.captured_by                 )
        ,     consumed_by                 : (                 consumed_by_changed ? (t_log.L_NEW+ event_status_object.consumed_by                 +t_log.L_ARL + event_status_object_prev.consumed_by                 ) : t_log.L_CHK+ event_status_object_prev.consumed_by                 )
        ,     has_moved                   : (                   has_moved_changed ? (t_log.L_NEW+ event_status_object.has_moved                   +t_log.L_ARL + event_status_object_prev.has_moved                   ) : t_log.L_CHK+ event_status_object_prev.has_moved                   )
        ,     was_a_click                 : (                 was_a_click_changed ? (t_log.L_NEW+ event_status_object.was_a_click                 +t_log.L_ARL + event_status_object_prev.was_a_click                 ) : t_log.L_CHK+ event_status_object_prev.was_a_click                 )
        ,     selection_progress          : (          selection_progress_changed ? (t_log.L_NEW+ event_status_object.selection_progress          +t_log.L_ARL + event_status_object_prev.selection_progress          ) : t_log.L_CHK+ event_status_object_prev.selection_progress          )
        ,     has_been_scrolled_by_script : ( has_been_scrolled_by_script_changed ? (t_log.L_NEW+ event_status_object.has_been_scrolled_by_script +t_log.L_ARL + event_status_object_prev.has_been_scrolled_by_script ) : t_log.L_CHK+ event_status_object_prev.has_been_scrolled_by_script )
        ,     window_scrollY              : (              window_scrollY_changed ? (t_log.L_NEW+ event_status_object.window_scrollY              +t_log.L_ARL + event_status_object_prev.window_scrollY              ) : t_log.L_CHK+ event_status_object_prev.window_scrollY              )
        ,     onSeekXYL                   : (                   onSeekXYL_changed ? (t_log.L_NEW+ event_status_object.onSeekXYL                   +t_log.L_ARL + event_status_object_prev.onSeekXYL                   ) : t_log.L_CHK+ event_status_object_prev.onSeekXYL                   )
    };


    event_status_object_prev = event_status_object;


    return o;
};






let t_log_transcript_event_top = function(html) { t_log_transcript(html, "doc_evt_div", "t_log.log_TOP"); };
let t_log_transcript_event_bot = function(html) { t_log_transcript(html, "doc_evt_div", "t_log.log_BOT"); };
let t_log_transcript_info      = function(html) { t_log_transcript(html, "doc_log_div", ""           ); };
let t_log_transcript           = function(                         html,  div_id,       log_class   )
{


    if(    LOG_MAP.EV7_DISPATCH
       && (LOG_MAP.EV8_FLOATLOG || t_prop.get(t_data.FLOATLOG))
      ) {
        let stage
            = (log_class == "t_log.log_TOP") ? STAGE_1_INPUT
            : (log_class != "t_log.log_BOT") ? STAGE_2_ACTION
            : STAGE_3_RESULT
        ;
        t_fly_add_innerHTML("<div class='"+stage+"'>"+html+"</div>");
    }


    let onWork_EL   = t_tools.t_get_onWork_EL();
    let onWork_PANEL= t_tools.t_get_onWork_PANEL();
    let transcript1 = t_tools.t_get_transcript1();
    let transcript2 = t_tools.t_get_transcript2();
    if(div_id == "doc_evt_div")
    {
        if(    (onWork_EL                     != transcript1)
            && (onWork_PANEL                  != transcript1)
            && t_tools.t_tools_panel_is_selected(transcript1)
        ) {

            t_log.log_TR_EVENT_add(html);
        }
    }
    else {
        if(    (onWork_EL                     != transcript2)
            && (onWork_PANEL                  != transcript2)
            && t_tools.t_tools_panel_is_selected(transcript2)
        ) {

            t_log.log_TR_LAYOUT_add(html);
        }
    }


    if(div_id == "doc_evt_div") t_doc_div_add("doc_evt_div", "<div class='"+log_class+"'>"+html+"</div>");
    else                        t_doc_div_add("doc_log_div", "<div class='"+log_class+"'>"+html+"</div>");

    if     (log_class == "t_log.log_TOP") t_log.log_TOP(html);
    else if(log_class == "t_log.log_BOT") t_log.log_BOT(html);
};







let   doc_evt_div;
let   doc_log_div;



let t_doc_div_clear = function(div_id)
{
    let doc_div = null;
    switch(div_id)
    {
        case "doc_evt_div":
        if(  !doc_evt_div ) doc_evt_div = document.getElementById(div_id);
        if(  !doc_evt_div ) return false;
        doc_div           = doc_evt_div;
        break;

        case "doc_log_div":
        if(  !doc_log_div ) doc_log_div = document.getElementById(div_id);
        if(  !doc_log_div ) return false;
        doc_div           = doc_log_div;
        break;
    }
    doc_div.innerHTML
        = (doc_div == doc_log_div) ? DOC_LOG_DIV_EMPTY
        : (doc_div == doc_evt_div) ? DOC_EVT_DIV_EMPTY
        :                            ""
    ;
    doc_div.cleared   = "cleared";
    return true;
};


let t_doc_div_add = function(div_id, html)
{
    if( !html.trim()      ) return false;

    let doc_div = null;
    switch(div_id)
    {
        case "doc_evt_div":
        if(  !doc_evt_div ) doc_evt_div = document.getElementById("doc_evt_div");
        if(  !doc_evt_div ) return false;
        doc_div           = doc_evt_div;

        break;

        case "doc_log_div":
        if(  !doc_log_div ) doc_log_div = document.getElementById("doc_log_div");
        if(  !doc_log_div ) return false;
        doc_div           = doc_log_div;

        break;
    }

    if( doc_div.cleared ) {
        doc_div.cleared        = ""      ;
        doc_div.innerHTML      = (div_id == "doc_evt_div") ? DOC_EVT_DIV_HEADER : DOC_LOG_DIV_HEADER;
        t_tools.t_add_closepin_on_panel( doc_div );
    }

    doc_div.innerHTML += html;

    return true;
};






let T_FLY_CLR_DELAY           = 3000;
let T_FLY_CLR_POSTPONED_DELAY =  500;

let t_fly_tooltip_report_timer;



let t_fly_init = function(reason)
{

let   caller = "t_fly_init";
let log_this = LOG_MAP.EV8_FLOATLOG;

if(log_this) t_log.logBIG(caller+"("+reason+")");
if(log_this) t_log.log_caller();


    fly_div.innerHTML = "";

    fly_div.title     = reason;

    fly_clr_FADE_OR_REMOVE();
};


let t_fly = function(html)
{
    if(!fly_div) return;

    let tooltip = fly_get_tooltip_pre_with_html( html );
    if( tooltip )
        fly_flash( tooltip );
    else
        t_fly_add_innerHTML("<div class='stage_0_log'>"+ html +"</div>");


    fly_clr_FADE_OR_REMOVE();

    t_fly_onlayout("t_fly");
};


let   fly_get_tooltip_pre_with_html = function(html)
{
    let html_text = t_util.strip_HTML( html );

    for(const tooltip of fly_div.getElementsByTagName("PRE"))
    {
        if( html_text == t_util.strip_HTML(tooltip.innerHTML))
            return tooltip;
    }

    return null;
};



let t_log_all_csv_prev;


let t_fly_all_csv = function(phase_update_pushed_staged, have_want_done)
{

    let [ pat_csv, off_csv, alt_csv, bak_csv, bin_csv] = t_tools.t_get_all_csv();
    let pat_c  = t_util.csv_count(pat_csv);
    let off_c  = t_util.csv_count(off_csv);
    let alt_c  = t_util.csv_count(alt_csv);
    let bak_c  = t_util.csv_count(bak_csv);
    let bin_c  = t_util.csv_count(bin_csv);



    let same_result_msg = "";
    switch(phase_update_pushed_staged)
    {
        case t_data.SYMBOL_UPDATE: {
            t_log_all_csv_prev = { pat_c , off_c , alt_c , bak_c , bin_c };
        }
        break;

        case t_data.SYMBOL_STAGE : {
            if(    (pat_c == t_log_all_csv_prev.pat_c)
                && (off_c == t_log_all_csv_prev.off_c)
                && (alt_c == t_log_all_csv_prev.alt_c)
                && (bak_c == t_log_all_csv_prev.bak_c)
                && (bin_c == t_log_all_csv_prev.bin_c)
            )
                same_result_msg = "AS ASSIGNED";
            else
                t_log_all_csv_prev = { pat_c , off_c , alt_c , bak_c , bin_c };
        }
        break;

        case t_data.SYMBOL_RESULT: {
            if(    (pat_c == t_log_all_csv_prev.pat_c)
                && (off_c == t_log_all_csv_prev.off_c)
                && (alt_c == t_log_all_csv_prev.alt_c)
                && (bak_c == t_log_all_csv_prev.bak_c)
                && (bin_c == t_log_all_csv_prev.bin_c)
            )
                same_result_msg = "AS STAGED";

            t_log_all_csv_prev = null;
        }
        break;

        default:
        t_log.log("t_fly_all_csv: BACKSTAGE PHASE ["+phase_update_pushed_staged+"]");
        break;
    }


    let html = "";

    if(same_result_msg)
    {
        let phase_color     = (phase_update_pushed_staged == t_data.SYMBOL_STAGE) ? "cc6" :  "cc4";
        if(!html) html      = " <em  class='have "+ phase_color +"'>"+ same_result_msg +"</em>";
    }
    else {
        if(pat_c && off_c) {
            html+=            " <em  class='"+ have_want_done +" cc1'>pat "+ pat_c
                +             " <sup class='"+ have_want_done +" cc5'>off "+ off_c +"</sup>"
                +             "</em>";
        }
        else {
            if(pat_c) html += " <em  class='"+ have_want_done +" cc1'>pat "+ pat_c +"</em>";
            if(off_c) html += " <em  class='"+ have_want_done +" cc5'>off "+ off_c +"</em>";
        }
        if(alt_c) html     += " <em  class='"+ have_want_done +" cc2'>alt "+ alt_c +"</em>";
        if(bak_c) html     += " <em  class='"+ have_want_done +" cc2'>bak "+ bak_c +"</em>";
        if(bin_c) html     += " <em  class='"+ have_want_done +" cc0'>bin "+ bin_c +"</em>";

        if(!html) html      = " <em  class='have cc8'>ALL BAGS EMPTY</em>";
    }

    t_fly( phase_update_pushed_staged + html);


};


let t_fly_observerCB = function(text)
{
    if(DOM_FLY_TAG) t_fly( t_util.escape_LF_BR( text ) );
};



let t_fly_tooltip = function(pre_innerHTML,category_className)
{

    if(category_className) fly_tooltip_add_category_className( category_className );

    category_className = "transcript "+t_tools.CSS_TOOLTIP+(category_className ? " "+category_className : "")
        +       (t_prop.get( t_data.THEME_DARK ) ? " "+t_data.CSS_DARK : "");

    let fly_STATE_was  = t_prop.get(t_data.FLOATLOG);

    t_prop.set(t_data.FLOATLOG, "TOOLTIP");

    t_fly("<pre class='"+category_className+"'>"+pre_innerHTML+"</pre>");

    t_prop.set(t_data.FLOATLOG, fly_STATE_was);

};


let t_fly_tooltip_clear = function(category_className)
{
    t_fly_tooltip_update("", category_className);

};


let t_fly_tooltip_update = function(tooltip, category_className)
{

let   caller = "t_fly_tooltip_update";
let log_this = LOG_MAP.EV8_FLOATLOG;

if(log_this) t_log.log("%c"+caller+"("+category_className+")", lbH+lf5);
if(log_this) t_log.log_caller();


    if(!fly_div ) return;

    if( t_fly_clr_is_pending() )
        t_fly_clr_cancel();

    t_tools.t_add_closepin_on_panel( fly_div );



    let  tooltip_text = t_util.strip_HTML(tooltip);
if( log_this) t_log.log(caller+": tooltip_text=["+tooltip_text+"]");


    let tooltip_pre = t_util.get_el_child_with_tag_class(fly_div,"PRE", category_className);


    if(tooltip && !tooltip_pre)
    {
if(log_this || DOM_FLY_LOG) t_log.logBIG("ADDING NEW TOOLTIP", lf7);

        t_fly_tooltip( tooltip     , category_className);
        tooltip_pre = t_util.get_el_child_with_tag_class(fly_div,"PRE", category_className);
        if( tooltip_pre )
        {
            let                 pre_parent = tooltip_pre.parentElement;
            t_util.add_el_class(pre_parent , t_tools.CSS_TOOLTIP);
        }
    }


    else if(tooltip) {
        let tooltip_pre_text = t_util.strip_HTML(tooltip_pre.innerHTML);

        if( log_this) {
            t_log.log("%c tooltip_pre_text=["                         + tooltip_pre_text                        +"]", lbH+lf6);
            t_log.log("%c tooltip_pre_text.includes('tooltip_text'): "+ tooltip_pre_text.includes(tooltip_text)     , lbH+lf7);
            t_log.log("%c tooltip_pre.innerHTML.includes('tooltip'): "+ tooltip_pre.innerHTML.includes(tooltip)     , lbH+lf6);
        }

        if(!tooltip_pre_text.includes(tooltip_text))
        {
if(log_this || DOM_FLY_LOG) t_log.logBIG("CHANGING TOOLTIP CONTENT", lf6);


            let             pre_parent = tooltip_pre.parentElement;
            if(t_util.has_el_class(pre_parent, t_tools.CSS_REMOVING) )
            {
                let   closepin = t_util.get_el_child_with_class(fly_div, t_tools.CSS_CLOSEPIN);
                let pre_parent_is_on_top
                    =  (!closepin && (pre_parent == fly_div.children[0]))
                    || (!closepin && (pre_parent == fly_div.children[1]))
                    || ( closepin && (pre_parent == fly_div.children[2]))
                ;

                if( !pre_parent_is_on_top ) {
                    if(closepin)
                        fly_div.insertBefore(pre_parent, closepin.nextSibling);
                    else
                        fly_div.insertBefore(pre_parent, fly_div.firstElementChild);
                }

                t_util.del_el_class(pre_parent, t_tools.CSS_REMOVING);
            }


            tooltip_pre.update_count
                = tooltip_pre.update_count
                ? tooltip_pre.update_count+1
                : 2;

            tooltip_pre.innerHTML
                = tooltip
                +t_data.LF+"<em class='update_count cc"+(tooltip_pre.update_count % 10)+"'>"+tooltip_pre.update_count+"</em>"
            ;
        }
        else {
if(log_this || DOM_FLY_LOG) t_log.logBIG("TOOLTIP CONTENT UNCHANGED", lf5);

            fly_flash( tooltip_pre );
        }
    }


    else if(tooltip_pre)
    {
        t_event_LOG_TOOLTIP_clearTimeout(category_className);

if(log_this) t_log.log("DELETING TOOLTIP");
        fly_div.removeChild( tooltip_pre.parentElement );

        let has_closepin = !!t_util.get_el_child_with_class(fly_div, t_tools.CSS_CLOSEPIN);
        if( fly_div.children.length < (has_closepin ? 2:1) )
            t_fly_init(caller+": fly_div.children.length < "+(has_closepin ? 2:1));
    }


    else {
if(log_this) t_log.log("TOOLTIP ["+category_className+"] NOT FOUND");
    }

};



let t_fly_tooltip_buffer           = "";
let t_fly_tooltip_report_functions = [];


let t_fly_tooltip_add = function(msg)
{

    let same_msg_already_in_buffer = t_fly_tooltip_buffer && t_fly_tooltip_buffer.includes(msg);
    if(!same_msg_already_in_buffer)
    {
        t_fly_tooltip_buffer
            += (t_fly_tooltip_buffer ? t_data.LF : "")
            +  msg;

    }


    if(t_fly_tooltip_buffer && !t_fly_tooltip_report_timer)
    {
        t_fly_tooltip_report_timer
            = setTimeout(
                         function() {
                             t_fly_tooltip_report_timer  = null;


                             if(t_fly_tooltip_buffer) {
                                 t_fly_tooltip( t_fly_tooltip_buffer );

                                 t_fly_tooltip_buffer =   "";
                             }


                             if(t_fly_tooltip_report_functions.length)
                             {
                                 for(let i=0; i< t_fly_tooltip_report_functions.length; ++i)
                                     t_fly_tooltip_report_functions[i]();

                                 t_fly_tooltip_report_functions = [];
                             }
                         }
                         , 1000);
    }

};


let t_fly_tooltip_add_report_function = function( report_function )
{
    if(!t_fly_tooltip_report_functions || !t_fly_tooltip_report_functions.includes( report_function ))
        t_fly_tooltip_report_functions.push( report_function );
};



let t_fly_add_innerHTML = function(innerHTML)
{
    if(!innerHTML) return;
    if(!fly_div  ) return;

    fly_div.insertAdjacentHTML("beforeend", innerHTML);

    fly_clr_FADE_OR_REMOVE();
};


let t_fly_tooltip_append_child = function(el)
{

let   caller = "t_fly_tooltip_append_child";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) t_log.log("%c "+caller+"( "+t_util.get_n_lbl(el)+" )", lf5);


    t_fly_clr_cancel();

    t_fly_init(caller);

    fly_div.appendChild(el);

    t_tools.t_add_closepin_on_panel( fly_div );

    t_fly_onlayout();
};




let   fly_flash = function(tooltip)
{
    t_util.add_el_class(                        tooltip, "standby");
    setTimeout(function() { t_util.del_el_class(tooltip, "standby"); }, 250);
};


let t_fly_cancel_fading = function()
{


    if(!fly_div) return;
    let node_list = fly_div.querySelectorAll("."+t_tools.CSS_FADING);

    for(let i=0; i < node_list.length; ++i)
        t_util.del_el_class(node_list[i], t_tools.CSS_FADING);
};





const EVENT_LOG_TOOLTIP_DELAY =  500;

let   event_LOG_TOOLTIP_timer;
let   event_LOG_TOOLTIP_last_caller;
let t_event_LOG_TOOLTIP_last_MS;

let t_event_LOG_TOOLTIP = function(_caller)
{

    if(_caller == event_LOG_TOOLTIP_last_caller)
    {
        let this_MS = new Date().getTime();
        let elapsed = this_MS - t_event_LOG_TOOLTIP_last_MS;
        if( elapsed < EVENT_LOG_TOOLTIP_DELAY) return;
        else      t_event_LOG_TOOLTIP_last_MS = this_MS;
    }

    event_LOG_TOOLTIP_last_caller = _caller;


    if(event_LOG_TOOLTIP_timer) clearTimeout(event_LOG_TOOLTIP_timer);
    event_LOG_TOOLTIP_timer   = setTimeout(function() { event_LOG_TOOLTIP_handler(_caller); }, EVENT_LOG_TOOLTIP_DELAY);


};


let t_event_LOG_TOOLTIP_clearTimeout = function(category_className)
{

let   caller = "t_event_LOG_TOOLTIP_clearTimeout("+category_className+")";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) t_log.log(caller);


    if(!event_LOG_TOOLTIP_timer) return;

    clearTimeout(event_LOG_TOOLTIP_timer);

    event_LOG_TOOLTIP_timer = null;

};


let   event_LOG_TOOLTIP_handler = function(_caller)
{
    let consumed_by_html
        = "<pre class='fg0'>"
        +   "<em class='big cc9'>"+_caller+"</em>"
        +   t_tools.t_get_consumed_by_table()
        + "</pre>"
    ;

    t_fly_tooltip_update(consumed_by_html, t_data.CSS_EVENT_LOG);
};




const FLOATLOG_STACK_MAX = 16;
let   fly_clr_postpone_reason;



let t_fly_clr = function(e_target)
{

let caller = "t_fly_clr";
let log_this = LOG_MAP.EV8_FLOATLOG;

if( log_this) t_log.log("%c"+caller+"%c e_target=["+t_util.get_n_lbl(e_target)+"]", lbL, lbR+lf9);
if( log_this) t_log.log_caller();


    if(!fly_div.children.length) return;
    let fly_div_child = t_util.get_el_parent_with_class(e_target.parentElement, t_tools.CSS_TOOLTIP);
if( log_this) t_log.log("%c fly_div_child=["+fly_div_child+"]", lbH+lf8);

    let index;
    for(index=0; index < fly_div.children.length; ++index) {
        if( t_util.is_el_or_child_of_parent_el(e_target, fly_div.children[index]) )
            break;
    }

    let from_bottom =                            (index   >   (fly_div.children.length/2)  );
if(log_this) t_log.log("...from_bottom=["+from_bottom+"] (index="+index+" > "+(fly_div.children.length/2)+")");



    if( from_bottom ) fly_clr_bot();
    else              fly_clr_top();
};


let t_fly_clr_is_pending = function()
{
    return (fly_clr_REMOVE_timer != null);
};



let fly_clr_REMOVE_timer;


let t_fly_clr_cancel = function()
{
    if(fly_clr_REMOVE_timer        ) { clearTimeout( fly_clr_REMOVE_timer         ); fly_clr_REMOVE_timer         = null; }
    if(fly_clr_FADE_OR_REMOVE_timer) { clearTimeout( fly_clr_FADE_OR_REMOVE_timer ); fly_clr_FADE_OR_REMOVE_timer = null; }


    t_fly_cancel_fading();
};


let   fly_clr_top = function()
{

let caller = "fly_clr_top";
let log_this = LOG_MAP.EV8_FLOATLOG;

if( log_this) t_log.log(caller);

    let children_remaining  = fly_div.children.length;
    if( children_remaining == 0) return;

    let       closepin = t_util.get_el_child_with_class(fly_div, t_tools.CSS_CLOSEPIN);
    let     next_child = closepin ? 1 : 0;

    let removing_count = 0;
    let  more_on_stage = false;
    do {
        children_remaining -= 1;

        let child  = fly_div.children[next_child];
        if(!child            ) continue;
        if( child == closepin) continue;

        if(!t_util.has_el_class(child, t_tools.CSS_TOOLTIP) )
        {
            t_util.add_el_class(child, t_tools.CSS_REMOVING);
            removing_count += 1;

if( log_this) t_log.log("%c #"+next_child+": ... REMOVING: "+t_util.get_id_or_tag(child), lbH+lf8);
        }
        else {
            t_util.del_el_class(child, t_tools.CSS_REMOVING);
            t_util.del_el_class(child, t_tools.CSS_FADING  );

if( log_this) t_log.log("%c #"+next_child+": NOT REMOVING: "+t_util.get_id_or_tag(child), lbH+lf7);
        }


        next_child += 1;
        child       = fly_div.children[next_child];
        more_on_stage
            =       (removing_count < 1)
            ||       t_util.has_el_class(child, STAGE_1_MORE  )
            ||       t_util.has_el_class(child, STAGE_3_MORE  )
            || (    !t_util.has_el_class(child, STAGE_1_INPUT )
                &&  !t_util.has_el_class(child, STAGE_1_MISSED))
        ;

if(log_this) t_log.log("...more_on_stage=["+more_on_stage+"] .. child ["+t_util.get_n_lbl(child)+"]");

    }
    while(more_on_stage && (children_remaining > 0));



    if(removing_count > 0)
        fly_clr_REMOVE(caller+": removing_count="+removing_count, 0);
};


let   fly_clr_bot = function()
{

let caller = "fly_clr_bot";
let log_this = LOG_MAP.EV8_FLOATLOG;

if( log_this) t_log.log(caller);

    let children_remaining  = fly_div.children.length;
    if( children_remaining == 0) return;

    let  more_on_stage = false;
    let       closepin = t_util.get_el_child_with_class(fly_div, t_tools.CSS_CLOSEPIN);
    let     prev_child = children_remaining - 1;
    let removing_count = 0;
    do {
        children_remaining -= 1;

        let child  = fly_div.children[prev_child];
        if(!child            ) continue;
        if( child == closepin) continue;

        if(!t_util.has_el_class(child, t_tools.CSS_TOOLTIP) )
        {
            t_util.add_el_class(child, t_tools.CSS_REMOVING);
            removing_count += 1;

if( log_this) t_log.log("%c #"+prev_child+": ... REMOVING: "+t_util.get_id_or_tag(child), lbH+lf8);
        }
        else {
            t_util.del_el_class(child, t_tools.CSS_REMOVING);
            t_util.del_el_class(child, t_tools.CSS_FADING  );

if( log_this) t_log.log("%c #"+prev_child+": NOT REMOVING: "+t_util.get_id_or_tag(child), lbH+lf7);
        }


        prev_child -= 1;
        child       = fly_div.children[prev_child];
        more_on_stage
            =       (removing_count < 1)
            ||       t_util.has_el_class(child, STAGE_3_RESULT)
            ||      !t_util.has_el_class(child, STAGE_3_MISSED)


        ;

if(log_this) t_log.log("...more_on_stage=["+more_on_stage+"] .. child ["+t_util.get_n_lbl(child)+"]");

    }
    while(more_on_stage && (children_remaining > 0));

if( log_this) t_log.log("...removing_count=["+removing_count+"]");
    if(removing_count > 0)
        fly_clr_REMOVE(caller+": removing_count="+removing_count, 0);
};




let   fly_clr_FADE_OR_REMOVE_timer;

let   fly_clr_FADE_OR_REMOVE = function()
{
    t_fly_clr_cancel();

    if( fly_div.children.length )
    {
        t_util.add_el_class(fly_div,            t_tools.CSS_PAUSE_ANIMATION    );
        t_util.add_el_class(fly_div,            t_tools.CSS_STACKING           );

        if(fly_clr_FADE_OR_REMOVE_timer) clearTimeout(fly_clr_FADE_OR_REMOVE_handler);
        fly_clr_FADE_OR_REMOVE_timer   =   setTimeout(function() { fly_clr_FADE_OR_REMOVE_handler("SCHEDULED CLEANUP: SOMETHING DISPLAYED"); }, T_FLY_CLR_DELAY);
    }
    else {
        t_util.del_el_class(fly_div,            t_tools.CSS_PAUSE_ANIMATION    );
        t_util.del_el_class(fly_div,            t_tools.CSS_STACKING           );

        t_tools.t_del_pin_css_on_panel(fly_div, t_tools.CSS_CLOSEPIN           );
    }
};


let   fly_clr_FADE_OR_REMOVE_handler = function(reason)
{

let   caller = "fly_clr_FADE_OR_REMOVE_handler";
let log_this = LOG_MAP.EV8_FLOATLOG;

if(log_this) t_log.log("%c"+caller+"("+reason+")", lbH+lf5);


    fly_clr_FADE_OR_REMOVE_timer = null;

    t_fly_clr_cancel();

    if(!fly_div.innerHTML) return;


    let      closepin = t_util.get_el_child_with_class(fly_div, t_tools.CSS_CLOSEPIN);

    let children_stack_length = fly_div.children.length - (closepin ? 1 : 0);

    let floatlog_requested
        =  LOG_MAP.EV8_FLOATLOG
        || t_prop.get(   t_data.FLOATLOG );

    let floatlog_stack_max = closepin ? FLOATLOG_STACK_MAX : FLOATLOG_STACK_MAX/2;
    let children_stack_overflow = (children_stack_length >= floatlog_stack_max);


    let   fading_count = 0;
    let removing_count = 0;
    let children_remaining = children_stack_length;

    if( children_stack_overflow )
    {
        let     next_child = (closepin ? 1 : 0);
        let  more_on_stage = false;
        while(   (children_remaining > floatlog_stack_max)
              || (more_on_stage && (children_remaining > 0))
             ) {

            children_remaining -= 1;

            let child  = fly_div.children[next_child];
            if( child == closepin) continue;

            if(!t_util.has_el_class(child, t_tools.CSS_TOOLTIP))
            {
                t_util.add_el_class(child, t_tools.CSS_REMOVING);

                removing_count += 1;
            }
            else {

if(log_this || DOM_FLY_LOG) t_log.logBIG("NOT REMOVING "+t_util.get_n_lbl(child), lf2);
            }


            next_child += 1;
            child       = fly_div.children[next_child];
            more_on_stage
                =        t_util.has_el_class(child, STAGE_1_MORE  )
                ||       t_util.has_el_class(child, STAGE_3_MORE  )
                || (    !t_util.has_el_class(child, STAGE_1_INPUT )
                    &&  !t_util.has_el_class(child, STAGE_1_MISSED))
            ;

if(log_this) t_log.log("...more_on_stage=["+more_on_stage+"] .. child ["+t_util.get_n_lbl(child)+"]");

        }
    }


    else if(!closepin)
    {
        for(let i=0; i < fly_div.children.length; ++i)
        {

            let              child  = fly_div.children[i];
            if(              child == closepin) continue;
            if(!t_util.has_el_class(child, t_tools.CSS_TOOLTIP))
            {
                t_util.add_el_class(child, t_tools.CSS_FADING);

                fading_count += 1;
            }
            else {
                t_util.del_el_class(child, t_tools.CSS_REMOVING);
                t_util.del_el_class(child, t_tools.CSS_FADING  );

if(log_this || DOM_FLY_LOG) t_log.logBIG("NOT FADING   "+t_util.get_n_lbl(child), lf2);
            }

        }

    }


    let remove_delay = fly_clr_postpone_reason
        ?        T_FLY_CLR_POSTPONED_DELAY
        :        T_FLY_CLR_DELAY;

if( log_this) t_log.log_key_val_group( caller
                                 , {   closepin : (closepin ? "HAS CLOSEPIN" : "NO CLOSEPIN")+": ...to be cleared by "+(closepin ? "USER":"TIMER")
                                     , FLOATLOG : "----------------------------------------"
                                     , floatlog_requested
                                     , FLOATLOG_STACK_MAX
                                     , floatlog_stack_max
                                     , CHILDREN : "----------------------------------------"
                                     , children_stack_length
                                     , children_stack_overflow
                                     , children_remaining
                                     , REMOVING : "----------------------------------------"
                                     , fading_count
                                     , removing_count
                                     , fly_clr_postpone_reason
                                     , remove_delay
                                 }
                                 , lf5, true);

    if((removing_count > 0) || (fading_count > 0))
        fly_clr_REMOVE(reason, remove_delay);


};


let   fly_clr_REMOVE = function(reason, delay=T_FLY_CLR_DELAY)
{

let   caller = "fly_clr_REMOVE";
let log_this = LOG_MAP.EV8_FLOATLOG;

if(log_this) t_log.log("%c"+caller+"("+reason+")", lbH+lf5);
if(log_this) t_log.log_caller();

    if(fly_clr_REMOVE_timer) clearTimeout(fly_clr_REMOVE_timer);
    fly_clr_REMOVE_timer   =   setTimeout(function() { fly_clr_REMOVE_handler(reason); }, delay);
};


let   fly_clr_REMOVE_handler = function(reason="TIMER")
{

let caller = "fly_clr_REMOVE_handler";
let log_this = LOG_MAP.EV8_FLOATLOG;

if(log_this) t_log.log("%c"+caller+"("+reason+")", lbH+lf6);


    fly_clr_REMOVE_timer = null;
    t_fly_clr_cancel();



    let onWork_EL = t_tools.t_get_onWork_EL();
    if(onWork_EL != null)
    {
        fly_clr_postpone_reason = "t_data.FLOATLOG kept visible while user is holding ["+t_util.get_n_lbl(onWork_EL)+"]";
if( log_this || DOM_FLY_LOG) t_log.log(fly_clr_postpone_reason);

        fly_clr_REMOVE(fly_clr_postpone_reason, T_FLY_CLR_POSTPONED_DELAY);
        return;
    }

    fly_clr_postpone_reason = false;


    let children_stack_length = fly_div.children.length;
    let removed_count         = 0;
    let has_removing        = t_util.get_el_child_with_class(fly_div, t_tools.CSS_REMOVING);
    let has_fading          = t_util.get_el_child_with_class(fly_div, t_tools.CSS_FADING  );
    if( has_removing || has_fading )
    {

if( log_this || DOM_FLY_LOG) t_log.logBIG("REMOVING t_tools.CSS_REMOVING MARKED ENTRIES", lf0);
        let child_removed;
        for(let i=0; i < fly_div.children.length; i += (child_removed ? 0 : 1))
        {
            child_removed = false;
            let                  child = fly_div.children[i];
            if(     t_util.has_el_class(child, t_tools.CSS_FADING  )
                ||  t_util.has_el_class(child, t_tools.CSS_REMOVING)
              ) {

                if( t_util.has_el_class(child, t_tools.CSS_TOOLTIP))
                {
                    t_util.del_el_class(child, t_tools.CSS_REMOVING);
                    t_util.del_el_class(child, t_tools.CSS_FADING  );

if( log_this) t_log.log("%c #"+(i+1)+" / "+children_stack_length+" .. CATEGORY: "+t_util.get_id_or_tag(child), lf5);
                }


                else
                {
                    fly_div.removeChild( child );
                    child_removed      = true;
                    removed_count     += 1;

if( log_this) t_log.log("%c #"+(i+1)+" / "+children_stack_length+" ... REMOVED: "+t_util.get_id_or_tag(child), lf2);
                }

            }
            else {

if( log_this) t_log.log("%c #"+(i+1)+" / "+children_stack_length+" NOT REMOVED: "+t_util.get_id_or_tag(child), lf3);
            }
        }

    }


    else {
if( log_this || DOM_FLY_LOG) t_log.log("%c NO ENTRIES TO REMOVE", lbH+lf0);

        t_fly_init(caller);
    }


    let closepin = t_util.get_el_child_with_class(fly_div, t_tools.CSS_CLOSEPIN);
    if(fly_div.children.length < 2)
    {
        if( closepin ) {
 if( log_this || DOM_FLY_LOG) t_log.log("%c REMOVING LONE CLOSEPIN", lf0);

            fly_div.removeChild( closepin );
        }
    }

    t_fly_onlayout();

if( log_this) t_log.log_key_val_group( caller
                                 , {   closepin : (closepin ? "HAS CLOSEPIN" : "NO CLOSEPIN")+": ...to be cleared by "+(closepin ? "USER":"TIMER")
                                     , children_stack_length
                                     , has_fading
                                     , has_removing
                                     , removed_count
                                 }
                                 , lf6, true);

};




let fly_tooltip_category_className_array = [];



let t_fly_tooltip_has_category = function(category_className)
{
    let pin_pre;
    for(let i=0; i < fly_tooltip_category_className_array.length; ++i)
    {
        let      className = fly_tooltip_category_className_array[i];
        if( !category_className || (category_className == className) )
        {
            pin_pre = t_util.get_el_child_with_class(fly_div, className);


            return !!pin_pre;
        }
    }


    return false;
};


let   fly_tooltip_add_category_className = function(category_className)
{


    if(!fly_tooltip_category_className_array.includes( category_className ))
    {
        fly_tooltip_category_className_array.push    ( category_className );

if(DOM_FLY_LOG) t_log.log("fly_tooltip_category_className_array: adding %c["+category_className+"]", lbH+lf7);
    }
};







let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_fly"
    , logging : (state) => DOM_FLY_LOG = t_store_set_state("DOM_FLY_LOG",state)
    , tagging : (state) => DOM_FLY_TAG = t_store_set_state("DOM_FLY_TAG",state)
    , t_fly_IMPORT


    , STAGE_0_NONE
    , STAGE_1_INPUT
    , STAGE_2_ACTION
    , STAGE_3_RESULT
    , STAGE_1_MISSED
    , STAGE_2_MISSED
    , STAGE_3_MISSED
    , STAGE_1_MORE
    , STAGE_3_MORE




    , t_doc_evt_div_get : () => doc_evt_div
    , t_doc_log_div_get : () => doc_log_div
    , t_doc_div_clear




    , t_fly_cancel_fading
    , t_fly_clr
    , t_fly_clr_cancel
    , t_fly_clr_is_pending
    , t_fly_tooltip_has_category

    , t_fly
    , t_fly_add_innerHTML
    , t_fly_div_get
    , t_fly_div_magnified_toggle
    , t_fly_init
    , t_fly_log_set_state
    , t_fly_observerCB
    , t_fly_onlayout
    , t_fly_all_csv
    , t_fly_tooltip
    , t_fly_tooltip_add
    , t_fly_tooltip_add_report_function
    , t_fly_tooltip_append_child
    , t_fly_tooltip_clear
    , t_fly_tooltip_update



    , t_event_LOG_TOOLTIP

    , t_fly_clr_status
    , t_log_behavior
    , t_log_event_status
    , t_log_event_status_get
    , t_log_event_status_if_changed
    , t_log_event_status_if_changed_filter
    , t_log_regex
    , t_log_stage
    , t_log_stage_msg
    , t_log_tools_status_get
    , t_log_transcript_event_bot
    , t_log_transcript_event_top
    , t_log_transcript_info

    , fclear : fly_clr_REMOVE_handler
};



}());
/*INLINE}}}*/
//@ sourceURL=dom_fly.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;
/*}}}*/
  /**   13 WORDING  JS dom_wording_js_data .. ESCAPE=[color : #FFF] {{{*/
/*
../script/dom_wording.js
*/
let dom_wording_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/










const DOM_WORDING_JS_ID     = 'dom_wording_js';
const DOM_WORDING_JS_TAG    = DOM_WORDING_JS_ID +' (220307:17h:39)';

let dom_wording = (function() {
"use strict";
let   DOM_WORDING_LOG       = false;
let   DOM_WORDING_TAG       = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;
let t_i18n     = {}        ;


















let t_tools    = {}        ;


let t_wording_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;
    t_i18n    = dom_i18n   ;



















    t_tools   = dom_tools  ;


    wording_INTERN();

    DOM_WORDING_LOG = DOM_WORDING_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_WORDING_LOG"));
    DOM_WORDING_TAG = DOM_WORDING_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_WORDING_TAG"));


if(log_this) log("%c 11 wording", lbH+lf1);
};





let LOG_MAP;

let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;

let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;

let   wording_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;

};






const DOM_WORDING_CSS_ID    = 'dom_wording_css';




let t_wording_cycle = function(stage='OFF', anchor_freeze=true)
{

let   caller = "t_wording_cycle(stage=["+stage+"], anchor_freeze=["+anchor_freeze+"])";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller);

    if(!dom_wording_css && !t_wording_inject()) return;

    dom_wording_css.className
        = (    stage          && (stage  != 'CYCLE')) ?  stage
        : (    dom_wording_css.className == 'DARK' )  ? 'LIGHT'
        : (    dom_wording_css.className == 'LIGHT')  ? 'OFF'
        :                                               'DARK'
        ;


    t_wording_activate(anchor_freeze);

};


let t_wording_activate = function(anchor_freeze)
{

let   caller = "t_wording_activate(anchor_freeze "+anchor_freeze+")";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller);


    let anchor = anchor_freeze ? "a" : "A";

    let wording, theme;
    switch( dom_wording_css.className ) {
        case 'DARK' : wording = "W" ; theme = "D"; break;
        case 'LIGHT': wording = "W" ; theme = "L"; break;
        default:
        case 'OFF'  : wording = "w" ; theme = "" ; break;
    }


    let key
        = theme
        + wording
        + anchor
    ;
    let found;
    for(let i = 0; i< css_map.length; ++i) {
        let      id = css_map[i].id;
        let      el = css_map[i].el;
        found       = found || (id == key);

        el.disabled = (id != key);

if(log_this && !el.disabled) logBIG("WORDING CSS: i=["+i+"] .. found=["+found+"].. key=["+key+"] .. id=["+css_map[i].id+"] .. el ["+t_util.get_id_or_tag(css_map[i].el)+"]");
    }

if(!found) console.warn("*** "+caller+": ["+key+"] NOT FOUND IN PRELOADED [css_map]");

    if(anchor_freeze) document.body.addEventListener   ('click', t_wording_capture_click, true);
    else              document.body.removeEventListener('click', t_wording_capture_click, true);

};


let dom_wording_css;
let t_wording_inject = function()
{
    if(!dom_wording_css) t_wording_init();
    return dom_wording_css;
};



let css_map = [];

let anchor_on;
let anchor_off;
let wording_on;
let wording_off;
let light_theme;
let dark_theme;


let t_wording_init = function()
{

let   caller = "t_wording_init";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller+": INSERTING ["+DOM_WORDING_CSS_ID+"]");


    anchor_on
        = ''

        + ' a        {                 color : initial;                            }'
        + ' a        {      background-color : initial;                            }'

        + ' a, input { text-decoration-style : initial;                            }'

    ;

    anchor_off
        = ''

        + ' a, a *          {           cursor : text;                             }'
        + ' a               {            color : #FFF                  !important; }'
        + ' a               {      text-shadow : 1px 1px 2px black     !important; }'
        + ' a               { background-color : #888                  !important; }'
        + ' a               {    border-radius : 1em                   !important; }'
        + ' a               {          opacity : 0.8                   !important; }'
        + ' .toolbag_button {           cursor : not-allowed;                      }'
        + ' .toolbag_button {            color : #222                  !important; }'
        + ' .toolbag_button { background-color : rgba(128,128,128,0.5) !important; }'


    ;


    wording_on
        = ''


        + ' a, input { text-decoration-style : solid;                              }'


    ;

    wording_off
        = ''

    ;




    light_theme = ''
        + ' :not(em) {                 color : #333                   !important; }'
        + ' :not(em) {            background :  rgb(238,238,238)      !important; }'

    ;

    dark_theme
        = ''
        + ' :not(em) {                 color : #CCC                   !important; }'
        + ' :not(em) {            background :  rgb( 32, 32, 32)      !important; }'

        + '::selection {               color : white                  !important; }'
        + '::selection {          background : red                    !important; }'

        + ' .sentence_container * {    color : #FFF                             ; }'

        +' ::-webkit-scrollbar                       { width: 24px; }'

        +' ::-webkit-scrollbar-track                 { -webkit-border-radius: 96px; border-radius: 96px; }'
        +' ::-webkit-scrollbar-track                 { -webkit-box-shadow   : inset 0 0 6px rgba(0,0,0,0.3); }'

        +' ::-webkit-scrollbar-thumb                 { -webkit-border-radius: 96px; border-radius: 96px; }'
        +' ::-webkit-scrollbar-thumb                 { -webkit-box-shadow   : inset 0 0 6px rgba(0,0,0,0.5); }'

        +' ::-webkit-scrollbar-track                 { background: rgba( 96, 96, 96,0.4); }'
        +' ::-webkit-scrollbar-track:window-inactive { background: rgba(128,128,128,0.2); }'

        +' ::-webkit-scrollbar-thumb                 { background: rgba( 24, 24, 24,0.8); }'
        +' ::-webkit-scrollbar-thumb:window-inactive { background: rgba( 24, 24, 24,0.2); }'

        +' ::-webkit-scrollbar-thumb                 { box-shadow: rgba(0, 0, 0, 0.8) 0 8px 24px; }'

    ;



    let         sig = "#"+DOM_WORDING_CSS_ID+" { content: "+DOM_WORDING_JS_TAG+"; } ";
    let          id = DOM_WORDING_CSS_ID;
    let          su = "";
    let        data = 'data:text/css,'+escape(su +"\\n"+ sig);

    dom_wording_css = t_wording_inject_css(id, data);



    let el;
    id="DWA"; data= 'data:text/css,'+escape("" +dark_theme  +wording_on  +anchor_on  );  el = t_wording_inject_css(id, data);  css_map.push({id , el});
    id="LWA"; data= 'data:text/css,'+escape("" +light_theme +wording_on  +anchor_on  );  el = t_wording_inject_css(id, data);  css_map.push({id , el});
    id="DWa"; data= 'data:text/css,'+escape("" +dark_theme  +wording_on  +anchor_off );  el = t_wording_inject_css(id, data);  css_map.push({id , el});
    id="LWa"; data= 'data:text/css,'+escape("" +light_theme +wording_on  +anchor_off );  el = t_wording_inject_css(id, data);  css_map.push({id , el});

    id= "wA"; data= 'data:text/css,'+escape(""              +wording_off +anchor_on  );  el = t_wording_inject_css(id, data);  css_map.push({id , el});
    id="DwA"; data= 'data:text/css,'+escape("" +dark_theme  +wording_off +anchor_on  );  el = t_wording_inject_css(id, data);  css_map.push({id , el});
    id="LwA"; data= 'data:text/css,'+escape("" +light_theme +wording_off +anchor_on  );  el = t_wording_inject_css(id, data);  css_map.push({id , el});
    id= "wa"; data= 'data:text/css,'+escape(""              +wording_off +anchor_off );  el = t_wording_inject_css(id, data);  css_map.push({id , el});



};


let t_wording_inject_css = function(id, link_or_data)
{
    let el  = document.createElement("link");
    el.id   = id;
    el.type = "text/css";
    el.rel  = "stylesheet";
    el.href = link_or_data;
    document.getElementsByTagName("head")[0].appendChild(el);
    return el;
};


let t_wording_by_href = function(anchor_freeze)
{

    let          sig = "#"+DOM_WORDING_CSS_ID+" { content: "+DOM_WORDING_JS_TAG+"; } ";
    let anchor_style = anchor_freeze ? anchor_off : anchor_on;

    let data;
    switch( dom_wording_css.className )
    {
        default:
        case "DARK" : data = sig + anchor_style + wording_on  + dark_theme ; break;
        case "LIGHT": data = sig + anchor_style + wording_on  + light_theme; break;
        case "OFF"  : data = sig + anchor_style + wording_off              ; break;

    }
    dom_wording_css. href = "data:text/css,"+ escape( data );

    if(anchor_freeze) document.body.addEventListener   ('click', t_wording_capture_click, true);
    else              document.body.removeEventListener('click', t_wording_capture_click, true);
};


let t_wording_capture_click = function(e)
{

let   caller = "t_wording_capture_click";
let log_this = DOM_WORDING_TAG || DOM_WORDING_LOG || LOG_MAP.EV5_TOOL_CB;


    let is_a_details_summary    =                            (e.target.tagName == "SUMMARY");
    let is_a_child_of_doc_tools = t_util .is_el_child_of_id  (e.target, t_data.DOC_TOOLS_ID);
    let is_a_handled_tool       = t_tools.t_is_a_handled_tool(e.target);

    let   dissmissed_by
        = is_a_details_summary    ?  "IS A DTAILS-SUMMARY"
        : is_a_child_of_doc_tools ?  "IS A CHILD OF DOC_TOOLS_ID"
        : is_a_handled_tool       ?  "IS A HANDLED TOOL"
        :                            ""
    ;
if( log_this)
    log("%c"+caller+"%c"+t_util.get_n_lbl(e.target)+"%c["+dissmissed_by+"]"
        ,lbb+lbL+lf7,lbb+lbC+lf9                    ,lbb+lbR+lfX[dissmissed_by ? 4:6]);

    if( dissmissed_by )
        return;

    t_tools.t_event_add_e_consumed_by(e, caller);

    if( e.ctrlKey ) return;

    if( e.stopPropagation          ) e.stopPropagation();
    if( e.stopImmediatePropagation ) e.stopImmediatePropagation();
    if( e.preventDefault           ) e.preventDefault();

};





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_wording"
    , logging : (state) => DOM_WORDING_LOG = t_store_set_state("DOM_WORDING_LOG",state)
    , tagging : (state) => DOM_WORDING_TAG = t_store_set_state("DOM_WORDING_TAG",state)
    , t_wording_IMPORT

    , t_wording_cycle



};



})();

/*INLINE}}}*/
//@ sourceURL=dom_wording.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
  /**  14 SELECT   JS dom_select_js_data .. ESCAPE=[t_data.LF +"Slot #"] {{{*/
/*
../script/dom_select.js
*/
let dom_select_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/






















const DOM_SELECT_JS_ID      = "dom_select_js";
const DOM_SELECT_JS_TAG     = DOM_SELECT_JS_ID  +" (220917:03h:11)";

let dom_select  = (function() {
"use strict";
let   DOM_SELECT_LOG        = false;
let   DOM_SELECT_TAG        = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;
let t_i18n     = {}        ;
let t_prop     = {}        ;
let t_store    = {}        ;
let t_fly      = {}        ;



let t_slot     = {}        ;











let t_tools    = {}        ;


let t_select_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;
    t_i18n    = dom_i18n   ;
    t_prop    = dom_prop   ;
    t_store   = dom_store  ;
    t_fly     = dom_fly    ;




    t_slot    = dom_slot   ;











    t_tools   = dom_tools  ;


    select_INTERN();

    DOM_SELECT_LOG = DOM_SELECT_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_SELECT_LOG"));
    DOM_SELECT_TAG = DOM_SELECT_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_SELECT_TAG"));


if(log_this) log("%c 12 SELECT", lbH+lf2);
};





let LOG_MAP;

let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let prop;


let   select_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


    prop = t_prop;


};






const SELECT_SLOT_MAX                = 10;
const S_TOUCHED_WORD_LENGTH_MAX      = 256;

let mStartRange =  null;
let mEndRange   =  null;







const CONTAINER_HUGE_CHILDREN_LENGTH = 128;

let ccs = [];


let CCS = function()
{

    this.clear = function() {
        this.slot         =  0;
        this.num_selected =  1;
        this.pattern      = "";
        this.words_option = "";
        this.nodes        = [];
        this.thumbs       = [];
        this.containers   = [];

    };


    this.toString = function() {

        let uniq_containers=0, c;
        for(let i=0; i<this.containers.length; ++i) {
            uniq_containers += (c !== this.containers[i]) ? 1 : 0;
 c   = this.containers[i];
        }

        return   t_data.SYMBOL_RIGHT            +this.pattern      + t_data.SYMBOL_LEFT
            +t_data.LF +"Slot #"                +this.slot
            +t_data.LF +t_data.SYMBOL_ELLIPSIS +" "    +this.nodes.length + " item"     +((this.nodes.length > 1) ? "s":"")
            +t_data.LF +t_data.SYMBOL_ELLIPSIS +" in " +uniq_containers   + " container"+((  uniq_containers > 1) ? "s":"")
            +t_data.LF +t_data.SYMBOL_ELLIPSIS +" "    +this.words_option
        ;
    };


    this.num_toHTML = function(num) {
        let slot_em    =              "slot=<em class='cc"+((this.slot) % SELECT_SLOT_MAX)+"'>"+ this.slot + "</em>";
        let num_em     =               "num=<em class='cc"+((     num ) % SELECT_SLOT_MAX)+"'>"+      num  + "</em>";

        let pattern_em = pattern_toHTML(this.pattern, this.words_option);

        let empty      = (this.nodes.length < 1);

        let thumb_p_str= empty ? "_" : t_get_thumb_p_str(this.get_num_thumb_p(num)) +"% ";

        let text_em    = empty ? "" : "<em class='cc7'>"                + this.nodes [num-1].textContent + "</em>";

        return ""
            + slot_em + num_em
            + thumb_p_str.replace(" ","&nbsp;")
            + pattern_em + text_em
        ;

    };


    this.get_num_thumb_p = function(num)
    {

        let caller   = "get_num_thumb_p";
        let log_this = LOG_MAP.S3_SLOT;




        if( this.thumbs[num-1] ) return this.thumbs[num-1];


        let ccs_node  = this.nodes     [num-1];
        let container = this.containers[num-1];

        let node
            = (container && container.children.length < CONTAINER_HUGE_CHILDREN_LENGTH)
            ?  container
            :  ccs_node;

        let thumb_p = get_node_thumb_p( node );
        if( thumb_p < 0.01)
        {




        }
        let thumb_p_str = "";
        if( thumb_p ) {
            thumb_p_str = t_get_thumb_p_str( thumb_p );

        }
        this.thumbs[num-1] = thumb_p_str;

if(log_this) log(caller+"("+num+"): slot=["+this.slot+"] num=["+(num)+"] thumb_p=["+thumb_p_str+"] ["+ccs_node.textContent+"]");
        return this.thumbs[num-1];
    };

    this.clear();
};



let next_to_reuse_slot          =   1;


let   get_free_slot = function()
{
    let caller = "get_free_slot";
let log_this = DOM_SELECT_LOG || LOG_MAP.S3_SLOT;
let tag_this = DOM_SELECT_TAG || log_this;




    let slot;
    for(slot = 1; slot <= SELECT_SLOT_MAX; ++slot)
    {
        let ccX       = slot % SELECT_SLOT_MAX;
        let sel_class = SEL_CLASS_PREFIX + ccX;
        let selector  = "."+sel_class;

        let el = document.querySelector( selector );
        if(!el) break;
    }

    if(slot <= SELECT_SLOT_MAX) {
        next_to_reuse_slot = slot + 1; if(next_to_reuse_slot > SELECT_SLOT_MAX) next_to_reuse_slot = 1;
if(tag_this) log("%c"+caller+"%c 1/2 - FREE  SLOT ["+slot+"] .. next_to_reuse_slot=["+next_to_reuse_slot+"]", lbL+lf8, lbR+lf5);
    }
    else {
        slot = next_to_reuse_slot;
        next_to_reuse_slot = slot + 1; if(next_to_reuse_slot > SELECT_SLOT_MAX) next_to_reuse_slot = 1;
if(tag_this) log("%c"+caller+"%c 2/2 - REUSE SLOT ["+slot+"] .. next_to_reuse_slot=["+next_to_reuse_slot+"]", lbL+lf8, lbR+lf7);
    }

    if(   !ccs[slot] ) ccs[slot] = new CCS();
    else t_slot.t_clear_slot(     slot);

    return slot;
};


let   ccs_sort_pattern = function()
{
    ccs.sort(
        function(a, b) {
            return b.pattern - a.pattern;
        }
    );
};


let   ccs_log = function()
{
    for(let slot = 0; slot < ccs.length; ++slot)
    {
        if(ccs[slot])
            log(slot+" "+ ccs[slot].toString());
    }
};


let   get_ccs_slot_num_thumb_p = function(slot, num)
{
    return ccs[slot].thumbs[num-1];
};



const THUMB_OFFSET = 0;
let ph;
let reset_page_geometry = function() { ph = 0; };

let last_node_thumb_p   = {};


let   get_node_thumb_p    = function(node)
{
    if(last_node_thumb_p && (last_node_thumb_p.node == node))
        return last_node_thumb_p.thumb_p;

    if(!ph)   ph = t_util.getPageHeight();

    let node_top = t_util.getInPageTop(node) - THUMB_OFFSET;

    last_node_thumb_p.thumb_p = 100 * node_top / ph;
    last_node_thumb_p.node    = node;

    return last_node_thumb_p.thumb_p;
};



let t_select_get_slot_nodes_length = function(slot)
{
    return ccs[slot]
        ?  ccs[slot].nodes.length
        :  0
    ;
};


let t_select_get_ccs_length = function()
{
    return ccs.length;
};


let t_select_get_slot_num_selected = function(slot)
{
    return ccs[slot]
        ?  ccs[slot].num_selected
        :  0
    ;
};


let t_select_set_slot_num_selected = function(slot, num_selected)
{
    ccs[slot].num_selected = num_selected;
};


let t_select_get_slot_num_node = function(slot,num)
{
    return ccs[slot]
        ?  ccs[slot].nodes[num-1]
        :  null
    ;
};


let t_select_get_slot_pattern = function(slot)
{
    return ccs[slot]
        ?  ccs[slot].pattern
        :  null
    ;
};


let t_select_switch_from_to_slot = function(was_slot,new_slot)
{

let   caller = "t_select_switch_from_to_slot";
let log_this = LOG_MAP.S3_SLOT;


    let ccs_was_in_slot = ccs[new_slot];
    let ccs_new_in_slot = ccs[was_slot];

    ccs[was_slot]       = ccs_was_in_slot;
    ccs[new_slot]       = ccs_new_in_slot;

    if(ccs[was_slot])     ccs[was_slot].slot = was_slot;
    if(ccs[new_slot])     ccs[new_slot].slot = new_slot;

if(log_this                 ) log(caller+"("+was_slot+" , "+new_slot+"):");
if(log_this && ccs[new_slot]) log("...PUSHED IN: ["+ccs[new_slot].slot+"]=["+ccs[new_slot].pattern+"]");
if(log_this && ccs[was_slot]) log("...MOVED OUT: ["+ccs[was_slot].slot+"]=["+ccs[was_slot].pattern+"]");
};


let t_select_clear_slot = function(slot)
{
    if(ccs[slot]) ccs[slot].clear();
};


let t_get_thumb_p_str = function(thumb_p)
{
    if(thumb_p < 0) return "";

    let thumb_i = Math.trunc(       thumb_p           );
    let thumb_f = Math.round(100 * (thumb_p - thumb_i));

    thumb_i = t_util.mPadStart(thumb_i,2," ");
    thumb_f = t_util.mPadStart(thumb_f,2,"0");

    return (thumb_i +"."+ thumb_f);
};







let touchedWord_range_parent;
let touchedWord_slot;


let touchedWord = function(x,y)
{

let   caller = "touchedWord(x="+x+" , y="+y+")";
let log_this = LOG_MAP.S1_RANGE;

if(log_this) log(caller);


    touchedWord_range_parent = null;

    let  rangeFromXY = get_range_from_XY(x, y);

    if( !rangeFromXY ) {
if(log_this) t_log.log_TR_SELECT_set("<em class='big'>SELECTION: NO RANGE AT ["+x+"@"+y+"]</em>");
        return;
    }


    let slot = get_slot_for_range(rangeFromXY);
    if( slot >= 0) {
if(log_this) t_log.log_TR_SELECT_set("<em class='big'>SELECTION: CLEAR CLICKED SLOT #"+slot+"</em>");

        t_slot.t_clear_slot( slot );

        return;
    }


    let range = touchedWord_adjust( rangeFromXY );
    if(!range ) {
if(log_this) t_log.log_TR_SELECT_set("<em class='big'>SELECTION: NO WORD RANGE</em>");

        return;
    }


    if(   range
       && range.startContainer && range.startContainer.parentElement
       && t_util.has_el_class(    range.startContainer.parentElement, t_data.CSS_LINE_NUM)
      ) {


        return;
    }


if(log_this) t_log.log_TR_RESULT_set( rangeToString(range, caller) );

    slot = get_slot_for_range(range);
    if( slot >= 0) {
if(log_this) t_log.log_TR_SELECT_set("<em class='big'>SELECTION: CLEAR ADJUSTED SLOT #"+slot+"</em>");
        t_slot.t_clear_slot( slot );
        return;
    }




    let touched_text =                  range.toString();
if(log_this) log("touched_text=["+touched_text+"]");

    if( touched_text )
    {
if(log_this) t_log.log_TR_SELECT_set("<em class='big'>SELECTION: FILTER=["+touched_text+"]</em>");


        if(!prop.get(t_data.WORDS_SEGMENT) ) {
            let escaped_filter = t_escapeREGEX( touched_text );

if( log_this) log(   ".....touched_text: %c"+ touched_text
                   +                    "%c"+t_data.LF
                   + "...escaped_filter: %c"+ escaped_filter
                   ,                     lb9
                   ,                     lbA
                   ,                     lb3
                 );
        }

        if(range.drop) {
            touched_text += "("+range.drop+")?";

        }

        touchedWord_range_parent = range.startContainer.parentNode;

        t_tools.t_words_regex_reset( touched_text);
        check_TreeWalker(      "", touched_text);

        return;
    }

};



const SEL_CLASS_PREFIX = "select";


let get_slot_for_range = function(range)
{

let caller = "get_slot_for_range";
let log_this = LOG_MAP.S3_SLOT;

if( log_this) log(caller+"("+range.toString()+"):");


    let slot = -1;

    if(range.startContainer && (range.startContainer.parentNode.id))
    {
        slot = range.startContainer.parentNode.id.startsWith( SEL_CLASS_PREFIX )
            ?  range.startContainer.parentNode.id.substring ( SEL_CLASS_PREFIX.length, SEL_CLASS_PREFIX.length+1)
            :                                                 -1
        ;
    }

if( log_this) log(caller+"("+range.toString()+"): return ["+slot+"] .. (startContainer: id=["+range.startContainer.id+"] parentNode.id=["+range.startContainer.parentNode.id+"])");

    if((slot >=0) && !ccs[slot]) ccs[slot] = new CCS();

    return slot;
};



const s_escapeREGEX_chars
    = {  "\\" : "\\\\"

        ,"^"  :  "\\^"
        ,"$"  :  "\\$"
        ,"."  :  "\\."
        ,"+" :  "\\+"
        ,"*" :  "\\*"

        ,"("  :  "\\("
        ,")"  :  "\\)"
        ,"["  :  "\\["
        ,"]"  :  "\\]"
    };

const regexp_REGEX_CHARS = new RegExp("[\\\\"+"^$"+"\.\+\*"+"\\(\\)\\[\\]]", "g");

let t_escapeREGEX = function (text)
{
  return text.replace(regexp_REGEX_CHARS, function(character) { return s_escapeREGEX_chars[character]; });
};



let touchedWord_adjust = function(range)
{

let   caller = "touchedWord_adjust";
let log_this = LOG_MAP.S1_RANGE;

if( log_this) log(caller+"("+range.toString()+"):");


    let node = range.startContainer ? range.startContainer : range.offsetNode;
    let text = t_util.strip_CR_LF(node.textContent);
    if(    (text.length > 0)
       &&  !prop.get( t_data.WORDS_EXACT   )
       &&  !prop.get( t_data.WORDS_SEGMENT )
       &&  touchedWord_adjust_1_in_embedding_container(range)
      ) {
if(log_this) log("...EXPANDED TO EMBEDDING-CONTAINERS %c["+ t_util.strip_CR_LF(range.toString()) +"]", lb6);
        return range;
    }


    if(touchedWord_adjust_2_in_selection(range)) {
        if( prop.get(t_data.WORDS_EXACT) ) {

            t_tools.t_override_USER_OPTION(t_data.WORDS_EXACT    , false);
            t_tools.t_override_USER_OPTION(t_data.WORDS_HEAD_TAIL, false);
            t_tools.t_override_USER_OPTION(t_data.WORDS_SEGMENT  ,  true);
        }
if(log_this) log("...EXPANDED TO SELECTION-RANGE %c["+t_util.strip_CR_LF(range.toString())+"]", lb5);
        return range;
    }


    let word_range = touchedWord_adjust_3_word_syntaxic_lookup(range);
    if( word_range )
    {
if(log_this) log("...GOT WORD FROM SYNTAXIC LOOKUP %c["+t_util.strip_CR_LF(word_range.toString())+"]", lb5);
        return word_range;
    }

if(log_this) log("... GOT NO WORD FROM SYNTAXIC LOOKUP %c["+t_util.strip_CR_LF(range.toString())+"]", lb5);
    return null;
};


let touchedWord_adjust_1_in_embedding_container = function(range)
{

let   caller = "touchedWord_adjust_1_in_embedding_container";
let log_this = LOG_MAP.S1_RANGE;

if( log_this) log(caller+"("+range.toString()+"):");
if( log_this) t_log.console_dir(caller+"(range)", range);


    let node          = range.startContainer ? range.startContainer : range.offsetNode;
    let node_parent   = node.parentNode;
    let node_before   = node.previousSibling;
    let node_after    = node.nextSibling;
    let node_longword = (node_parent.textContent && (node_parent.textContent.length > S_TOUCHED_WORD_LENGTH_MAX));
    let node_inline
        =  (node_parent.tagName == "A"     )
        || (node_parent.tagName == "CITE"  )
        || (node_parent.tagName == "CODE"  )
        || (node_parent.tagName == "EM"    )
        || (node_parent.tagName == "I"     )
        || (node_parent.tagName == "LABEL" )
        || (node_parent.tagName == "SMALL" )
        || (node_parent.tagName == "SPAN"  )
        || (node_parent.tagName == "SUP"   )
        || (node_parent.tagName == "U"     )
        || (node_parent.tagName == "VAR"   )
    ;

if( log_this) {
    log_key_val( caller
                 , {   node
                     , node_parent
                     , node_before
                     , node_after
                     , node_longword : node_longword ? "node_longword ("+node_parent.textContent.length+" > "+S_TOUCHED_WORD_LENGTH_MAX+")" : false
                     , node_inline   : node_inline +" ("+node_parent.tagName+")"
                 }
                 , lf1
               );
}



    let rejected_by = "";
    if     ( !node_parent   ) rejected_by = "!node_parent";
    else if( !node_inline   ) rejected_by = "!node_inline ("+node_parent.tagName+")";
    else if(  node_longword ) rejected_by = "node_longword xtContent.length > "+S_TOUCHED_WORD_LENGTH_MAX+")";


    if(rejected_by) {
if(log_this) log(caller+": %c "+ rejected_by, lb6);
        return false;
    }


    if( node_inline)
    {
        let text = t_util.strip_CR_LF(node.textContent);
        let    s = range.startOffset;
        let    e = range.  endOffset;


if(log_this) {
    log(caller+": s=["+s+"] e=["+e+"] "+ t_util.node_toString(node));
    log("...%c node_parent=["+t_util.get_n_lbl(node_parent)+"]", lb7); if(node_parent) console.dir(node_parent);
    log("...%c node_before=["+t_util.get_n_lbl(node_before)+"]", lb3); if(node_before) console.dir(node_before);
    log("...%c text.......=["+text+"]"                         , lb4);
    log("...%c node_after.=["+t_util.get_n_lbl(node_after  )+"]", lb5); if(node_after ) console.dir(node_after);
    log("___length=["+node.data.length+"]");
    log("___[123456789_1234567890]");
    log("___["+node.data+"]");
}


            range.setStart(node, 0);
            range.setEnd  (node, text.length);


            while(range.toString().startsWith(" ") || range.toString().startsWith("\t")) { range.setStart(node, range.startOffset+1); range.setEnd  (node, range.  endOffset+1); }
            while(range.toString().  endsWith(" ") || range.toString().  endsWith("\t")) {                                            range.setEnd  (node, range.  endOffset-1); }



            if((text[0] == "[") && (text[text.length-1] == "]"))
            {
if(log_this) log("...TRIM SURROUNDING BRACKETS %c["+ t_util.strip_CR_LF(range.toString()) +"]", lb6);
                range.setStart(node, 1);
                range.setEnd  (node, text.length-1);
            }



if(log_this) {
    log("...........................range=%c["+t_util.strip_CR_LF( range.toString() ) +"]", lb6);
    t_util.log_range(range,caller);
}

    }
    return true;

};



let touchedWord_adjust_2_in_selection = function(range)
{

let   caller = "touchedWord_adjust_2_in_selection";
let log_this = LOG_MAP.S1_RANGE;

if( log_this) log(caller+"("+range.toString()+"):");


    let        onDown_SELECTION = t_tools.get_onDown_SELECTION();             let rejected_by = "";
    if((typeof onDown_SELECTION) == "undefined"                         ) rejected_by = "onDown_SELECTION...............: NOT DEFINED";
    else if(  !onDown_SELECTION                                         ) rejected_by = "onDown_SELECTION...............: NONE";
    else if(  !onDown_SELECTION.anchorNode                              ) rejected_by = "onDown_SELECTION.anchorNode....: NONE";
    else if(  !onDown_SELECTION.focusNode                               ) rejected_by = "onDown_SELECTION.focusNode.....: NONE";
    else if(   onDown_SELECTION.anchorNode != onDown_SELECTION.focusNode) rejected_by = "onDown_SELECTION...............: MULTI-NODE-SELECTION";
    else if(   onDown_SELECTION.isCollapsed                             ) rejected_by = "onDown_SELECTION...............: isCollapsed";
    else if(  !range                                                    ) rejected_by = "range........................... NO range";
    else if(  !range.startContainer                                     ) rejected_by = "range.startContainer...........: NO startContainer";
    else if( !(onDown_SELECTION.containsNode(range.startContainer,true))) rejected_by = "onDown_SELECTION.containsNode(): OUT OF SELECTION";

    if(rejected_by)
    {
if(log_this) log(caller+": onDown_SELECTION=["+onDown_SELECTION+"] .. %c "+ rejected_by, lb5);
        return false;
    }









    let node = range.startContainer;

    if(onDown_SELECTION.anchorOffset < onDown_SELECTION.focusOffset)
    {
        range.setStart(node, onDown_SELECTION.anchorOffset);
        range.setEnd  (node, onDown_SELECTION.focusOffset );
    } else {
        range.setStart(node, onDown_SELECTION.focusOffset );
        range.setEnd  (node, onDown_SELECTION.anchorOffset);
    }





if(log_this) {
    log(caller+": %c onDown_SELECTION=["+onDown_SELECTION+"]"                      , lb6);
    log("...........................range=%c["+t_util.strip_CR_LF( range.toString() ) +"]", lb6);
    t_util.log_range(range,caller);
}


    return true;


};


let touchedWord_adjust_2_in_selection_word_bounds = function(range)
{

let   caller = "touchedWord_adjust_2_in_selection";
let log_this = LOG_MAP.S1_RANGE;

if( log_this) log(caller+"("+range.toString()+"):");

    if(!prop.get(t_data.WORDS_SEGMENT) )
    {
if(log_this) log("ADJUSTING TO WORDS BOUNDARIES");

        let node = range.startContainer;
        let t = node.textContent ;
if(log_this) log(".......t=%c["+ t_util.strip_CR_LF(t_util.escape_CR_LF(t)) +"]", lb3);
if(log_this) log("...range=%c["+ range.toString()             +"]", lb3);

        let s = range.startOffset+1;
        let e = range.endOffset;
        let l = t.length;

        while((s <= l) && !t_util.isAlNum( t.charAt(s-1) )         ) s += 1;
        while((s >= 1) &&  t_util.isAlNum( t.charAt(s-1) )         ) s -= 1;
        if(               !t_util.isAlNum( t.charAt(s-1) )         ) s += 1;

        while((e >= s) && !t_util.isAlNum( t.charAt(e-1) )         ) e -= 1;
        while(             t_util.isAlNum( t.charAt(e) ) && (e < l)) e += 1;

        s = Math.min(s,l);
if(log_this) log("...l=["+l+"] .. s=["+s+"]=[%c"+ t.charAt(s-1) +"%c] .. e=["+e+"]=[%c"+ t.charAt(e-1) +"%c]", lb1+lbF,lbA , lb2+lbF,lbA);

        range.setStart(node, s-1);
        range.setEnd  (node, e  );

if(log_this) log("...range=%c["+ range.toString() +"]", lb3);
    }
};


let touchedWord_adjust_3_word_syntaxic_lookup = function(range)
{

let   caller = "touchedWord_adjust_3_word_syntaxic_lookup";
let log_this = LOG_MAP.S1_RANGE;

if( log_this) log(caller+"("+range.toString()+"):");


    let node = range.startContainer ? range.startContainer : range.offsetNode;
    let    s = range.startOffset   ;
    let    e = range. endOffset    ;
    let  tse = {s:0, e:0, t:""};

    for(let loop_num = 0; node != null; ++loop_num)
    {

        if(t_log.get_log_is_full()) {
            log();
            break;
        }



        if(    (node.nodeType != Node.TEXT_NODE)
            || (loop_num > 0)
        ) {
            node = range_setStart_at_end_of_previous_text_node( range );
            if(node == null)
            {
if(log_this) log("...got nothing from range_setStart_at_end_of_previous_text_node");
                break;
            }

if(log_this) {
    if(range.startContainer) log("___.........range.startContainer.=["+  range.startContainer.textContent +"]");
    if(range.offsetNode    ) log("___.........range.....offsetNode.=["+  range.offsetNode                 +"]");
    log("___.node.........................=["+  node.textContent                 +"]");
    if(range.startContainer) log("___(node == range.startContainer)=["+ (node == range.startContainer)    +"]");
    if(range.offsetNode    ) log("___(node == range.....offsetNode)=["+ (node == range.offsetNode    )    +"]");
}


            s = range.startOffset   ;
            e = range. endOffset    ;
        }


        let text =  node.textContent;
        let l    =  node.textContent.length;



        tse.t = text;
        tse.s = s;
        tse.e = e;
        get_word_start_end( tse );
        s = tse.s;
        e = tse.e;
if(log_this) {
    log("...get_word_start_end: s=["+s+"]=["+t_util.strip_CR_LF(t_util.escape_CR_LF(text.charAt(s-1)))+"] e=["+e+"]=["+text.charAt(e-1)+"]");
    log("<em>"+ t_util.mPadStart(""+ loop_num,3," ")
    + " s=["+s+"]=["+ text.charAt(s-1)            +"]"
    + " e=["+e+"]=["+ text.charAt(e-1)            +"]"
    + " l=["+l+"]=["+ t_util.trim_node_textContent(node) +"]</em>");
}


        if(e <= s) {
if(log_this) log("%c WORD NOT FOUND", lb3);

        }


        else {
if(log_this) log("%c WORD FOUND: <em>"+text.substring(s-1, e)+"</em>", lb4);

            break;
        }

    }


    if( !node ) {

if(log_this) log("%c FOUND NO TEXT NODE", lb2);
        return null;
    }


    range.setStart(node, s);
    range.setEnd  (node, e);
    if(tse.drop) range.drop = tse.drop;

    let word = range.toString();
if(log_this) log("SELECTED WORD s=["+s+"] e=["+e+"] l=["+word.length+"] word: <em>"+word+"</em> FROM: <em>"+ t_util.truncate(t_util.trim_node_textContent(node)) +"</em>");
    return range;

};





const CHECK_LOG_MAX       =  64;
const TOO_MANY_SELECTIONS = 256;

let mNodeRegexP;


let get_word_at_offset = function(text, offset)
{
    let tse = { s:offset, e:offset, t:text };

    get_word_start_end(tse);

    return text.substring(tse.s, tse.e);
};


let get_word_start_end = function(tse)
{


    let t = tse.t;
    let s = tse.s;
    let e = tse.e;
    let l = tse.t.length;

    if(s>l) s = l;
    if(s<1) s = 1;

    while((s >= 1) && !t_util.isAlNum( t.charAt(s-1) )) s -= 1;
    while((s <= l) && !t_util.isAlNum( t.charAt(s-1) )) s += 1;
    while((s >= 1) &&  t_util.isAlNum( t.charAt(s-1) )) s -= 1;

    e = s;
    while( t_util.isAlNum( t.charAt(e) ) && (e < l)) e += 1;

    tse.s = s;
    tse.e = e;

    get_word_end_up_to_dropped_suffix(tse);
};





let get_word_end_up_to_dropped_suffix = function(tse)
{

let    word = tse.t.substring(tse.s, tse.e);
let  caller = "get_word_end_up_to_dropped_suffix("+word+")";
let log_this = LOG_MAP.S1_RANGE;

if(log_this) log(caller);

    let len = tse.e - tse.s;
    let suffix, must_not_end_with, min_len;


    let ignore_case
        = prop.get(t_data.WORDS_DROP_CASE);

    if( ignore_case )
        word = word.toLowerCase();



    for(let i = 0; i  < t_data.WORDS_SUFFIXES.length; ++i) {

        suffix        = t_data.WORDS_SUFFIXES[i];
        let prop_name ="words_drop_"+suffix;

        if(!prop.get(prop_name) ) {
if(log_this) log(   "!prop.get("+prop_name+")");
            continue;
        }


        min_len           = t_data.WORDS_SUFFIXE_MIN_LEN  [suffix] || suffix.length;
        must_not_end_with = t_data.WORDS_MUST_NOT_END_WITH[suffix];
        if(   (len >= min_len)
           &&  word.endsWith( suffix )
           && (!must_not_end_with || !word.endsWith(must_not_end_with))
          ) {
            tse.drop = suffix;
            tse.e   -= suffix.length;
            break;
        }

    }

if(log_this && tse.drop) {
    log("..............suffix=["+ suffix            +"]");
    log(".............min_len=["+ min_len           +"]");
    log("...must_not_end_with=["+ must_not_end_with +"]");

    log("%c"+caller+"%c return ["+tse.t.substring(tse.s, tse.e)+"] %c"+(tse.drop ? " .. drop=["+tse.drop+"]" : "")
       , lbH        ,lbH+lf4                                      ,lbH+lf3                                        );
}

};


let range_setStart_at_end_of_previous_text_node = function(range)
{

let   caller = "range_setStart_at_end_of_previous_text_node";
let log_this = LOG_MAP.S1_RANGE;

if( log_this) log(caller+"("+range.toString()+"):");



    let node = getPreviousTextNode(range.startContainer ? range.startContainer : range.offsetNode);


    if(node && node.nodeValue)
    {
        let s = node.nodeValue.length;
        let e = s;
        range.setStart(node, s);
        range.setEnd  (node, e);
    }

if(log_this) log(caller+": %c PREVIOUS-TEXT-NODE=["+ t_util.node_toString(node) +"]", lbF+lb6);
    return node;
};


let getPreviousTextNode = function(node)
{

let   caller = "getPreviousTextNode";
let log_this = LOG_MAP.S1_RANGE;

if(log_this) log(caller+"(node=["+ t_util.node_toString(node)+"]");

    let previousNode = null;

    try {

        let   root = null;
        for(  root  = node.parentNode
            ;(root != null) && (root.children.length < 2)
            ; root  = root.parentNode
        ) {
if(log_this) log("...root="+ t_util.node_toString( root ));
        }
        if(root == null)
        {
if(log_this) log("getPreviousTextNode: ...return null");
            return null;
        }

if(log_this) log("SEARCHING ROOT: "+ t_util.node_toString(root));


        let mTreeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, mNodeFilter_function);
        mNodeRegexP     = null;

        if(log_this) {
            root  = mTreeWalker.root;
            log("...mTreeWalker.root: "+                          t_util.node_toString( mTreeWalker.root ) );
            log("....root.parentNode: "+ (!root.parentNode ? "" : t_util.node_toString( root.parentNode  )));
            log("....root.firstChild: "+ (!root.firstChild ? "" : t_util.node_toString( root.firstChild  )));
            log("....root. lastChild: "+ (!root. lastChild ? "" : t_util.node_toString( root. lastChild  )));
        }


        while(mTreeWalker.nextNode())
        {
            if(node == mTreeWalker.currentNode)
            {
                if(log_this) {
                    log("REACHED REFERENCE NODE");
                    log("|..mTreeWalker.currentNode.............:"+ ( mTreeWalker.currentNode                                                ));
                    log("|..mTreeWalker.currentNode.nodeValue...:"+ (!mTreeWalker.currentNode ? "" : mTreeWalker.currentNode.nodeValue       ));
                    log("|==mTreeWalker.currentNode.textContent=["+ (!mTreeWalker.currentNode ? "" : mTreeWalker.currentNode.textContent +"]"));
                }
                break;
            }
        }


        do {
            previousNode = mTreeWalker.previousNode();
            if(log_this) {
                log("mTreeWalker.previousNode():");
                log("|..previousNode.............:"+ ( previousNode                                     ));
                log("|..previousNode.nodeValue...:"+ (!previousNode ? "" : previousNode.nodeValue       ));
                log("|==previousNode.textContent=["+ (!previousNode ? "" : previousNode.textContent +"]"));
            }
        }
        while( ( previousNode != null)
            && (!previousNode.nodeValue || (t_util.trim_empty_lines(previousNode.textContent).length < 1))
        );


    }
    catch(ex) { log(caller+": "+ex, "warn"); }

    if(log_this) {
        if(previousNode) log("getPreviousTextNode: ...return "+t_util.node_toString(previousNode));
        else             log("getPreviousTextNode: ...return null");
    }
    return previousNode;

};


let pattern_toHTML = function(pattern, words_option) {

    switch(words_option)
    {


        case t_data.WORDS_EXACT    : return "<em title='EXACT WORD'   class='cc1 "+words_option+"'>"+ pattern +"</em>";
        case t_data.WORDS_SEGMENT  : return "<em title='WORD SEGMENT' class='cc1 "+words_option+"'>"+ pattern +"</em>";
        default:
        case t_data.WORDS_HEAD_TAIL: return "<em title='HEAD & TAIL'  class='cc1 "+words_option+"'>"+ pattern +"</em>";

    }
};






let t_slot_visibility_changed = function()
{

let caller = "t_slot_visibility_changed";
let log_this = DOM_SELECT_LOG || DOM_SELECT_TAG || LOG_MAP.S3_SLOT;

if( log_this) log("%c "+caller, lbH+lf3);



    for(let slot = 1; slot < ccs.length; ++slot)
    {
        if( ccs[slot] &&  ccs[slot].visible_num_array)
            delete        ccs[slot].visible_num_array;
    }
};


let t_get_slot_num_next_wrap_to = function(slot,num_next,wrap_to)
{

let   caller = "t_get_slot_num_next_wrap_to";
let log_this = DOM_SELECT_LOG || LOG_MAP.S3_SLOT;


    let num_max  = t_select_get_slot_nodes_length(slot);

    let lfx = lfX[num_next % 10]; let l_x; let msg; let result;
    if     ( num_max  <  wrap_to) {   l_x = lbB + lf2; msg = log_this && "ENDLESS "+num_next; result = 0       ; }
    else if( num_next == wrap_to) {   l_x = lbb + lf9; msg = log_this && "    EOL "+num_next; result = wrap_to ; }
    else if( num_next  > num_max) {   l_x = lbb + lfx; msg = log_this && "   WRAP "+num_next; result = 1       ; }
    else                          {   l_x =       lfx; msg = log_this && "   NEXT "+num_next; result = num_next; }

if( log_this) {
    log("%c"+caller+"(slot "+slot+" , num_next "+num_next+" , wrap_to "+wrap_to+")%c num_max "+num_max+"%c"+msg+"%c"+result
        ,lbH                                                                     ,lbL                  ,lbC     ,lbR+l_x   );
}
    return result;
};


let t_is_slot_num_visible = function(slot,num)
{

let caller = "t_is_slot_num_visible";
let log_this = DOM_SELECT_LOG || LOG_MAP.S3_SLOT;


    if(         !ccs[slot]                   ) return false;
    if(          ccs[slot].nodes.length < num) return false;

    if(         !ccs[slot].visible_num_array ) slot_visible_num_array_update(slot );

    let result = ccs[slot].visible_num_array.includes(num);

if( log_this)
    log("%c"+caller+"%c slot "+slot+"%c num "+num+"%c return "+result
        ,lbL+lf5    ,lbC+lfX[slot]  ,lbR+lfX[num] ,lbH+lfX[result ? 4:8]);
    return result;
};


let t_get_slot_num_visible_count = function(slot)
{

let caller = "t_get_slot_num_visible_count";
let log_this = DOM_SELECT_LOG || LOG_MAP.S3_SLOT;

if( log_this)
    log("%c"+caller+"%c slot "+slot
        ,lbL+lf5    ,lbC+lfX[slot] );

    if(         !ccs[slot]                   ) return 0;

    if(         !ccs[slot].visible_num_array ) slot_visible_num_array_update(slot );

    let result = ccs[slot].visible_num_array.length;

if( log_this) log("...return "+result);
    return result;
};


let t_get_slot_num_visible_num = function(slot,num)
{

let caller = "t_get_slot_num_visible_num";
let log_this = DOM_SELECT_LOG || LOG_MAP.S3_SLOT;

if( log_this)
    log("%c"+caller+"%c slot "+slot+"%c num "+num
        ,lbL+lf5    ,lbC+lfX[slot]  ,lbR+lfX[num]);

    if(         !ccs[slot]                   ) return false;
    if(          ccs[slot].nodes.length < num) return false;

    if(         !ccs[slot].visible_num_array ) slot_visible_num_array_update(slot );

    let index  = ccs[slot].visible_num_array.indexOf( num );

    let result = (index >= 0) ? index+1 : 0;

if( log_this) log("...return "+result);
    return result;
};


let   slot_visible_num_array_update = function(slot)
{

let   caller = "slot_visible_num_array_update";
let log_this = DOM_SELECT_TAG || DOM_SELECT_LOG || LOG_MAP.S3_SLOT;

if( log_this) log("%c "+caller+"("+slot+")", lbH+lf4);


    if(!ccs[slot]) return;

    ccs[slot].visible_num_array = [];

    for(let num = 1; num <= ccs[slot].nodes.length; ++num)
    {
        if( is_slot_num_visible(slot, num) )
            ccs[slot].visible_num_array.push(     num );
    }
if( log_this) log(ccs[slot].visible_num_array);
};


let   is_slot_num_visible = function(slot, num)
{

let   caller = "is_slot_num_visible";
let log_this = DOM_SELECT_LOG || LOG_MAP.S3_SLOT;

let tag_this = DOM_SELECT_TAG || log_this;
if( tag_this) caller += "(slot "+slot+"  num "+num+")";
if( log_this ) log("%c"+caller, lbH+lf4);


    if(slot <= 0              ) return false;
    if(slot >  SELECT_SLOT_MAX) return false;

    if(!ccs[slot])              return false;

    let count = ccs[slot].nodes.length;
    if( count < 1)              return false;

    if(  num <=    0)           return false;
    if(  num > count)           return false;

if(log_this) log(".count=["+ count +"]");

    let thumb_p = parseFloat( ccs[slot].get_num_thumb_p(num) );


    if(LOG_MAP.T3_LAYOUT)
    {
        let page_height = t_util.getPageHeight();
        let body        = document.body;
        let html        = document.documentElement;
        let page_geometry = ""
            +"<table id='table_params'>"
            +" <tr class='slot'><TH class='cc8'>select</TH> <th>        slot</th><td class='cc"+slot+"'>"+ slot              +"</td> <th>         num</th><td class='cc"+(num % 10)+"'>"+ num               +"</td> <th>       count</th><td class='cc"+(count % 10)+"'>"+ count             +"</td></tr>"
            +" <tr             ><TH class='cc8'>HTML  </TH> <th>scrollHeight</th><td class='cc8'>"       + html.scrollHeight +"</td> <th>offsetHeight</th><td class='cc1'>"             + html.offsetHeight +"</td> <th>clientHeight</th><td class='cc2'>"               + html.clientHeight +"</td></tr>"
            +" <tr             ><TH class='cc8'>BODY  </TH> <th>scrollHeight</th><td class='cc8'>"       + body.scrollHeight +"</td> <th>offsetHeight</th><td class='cc3'>"             + body.offsetHeight +"</td> <th>clientHeight</th><td class='cc4'>"               + body.clientHeight +"</td></tr>"
            +" <tr             ><TH class='cc8'>window</TH> <th> page_height</th><td class='cc8'>"       + page_height       +"</td> <th>     thumb_p</th><td class='cc5'>"             + thumb_p           +"</td> <th>     scrollY</th><td class='cc6'>"               + window.scrollY    +"</td></tr>"
            +"</table"
        ;

        let info = ""
            +"<div class='info'>"
            +"<em class='cc8'>Scroll state</em><br>"
            +" <u>clientHeight</u> VIEWABLE +PADDING                    -border -scrollbar -margin<br>"
            +" <u>offsetHeight</u> VIEWABLE +PADDING +BORDER +SCROLLBAR                    -margin<br>"
            +" <u>scrollHeight</u> OVERFLOW +PADDING                    -border -scrollbar -margin<br>"
            +"</div>"
        ;

        t_log.log_TR_LAYOUT_set(page_geometry +"<br>"+ info);
    }
    else {
        if(log_this) {
            count       = ccs[slot].nodes.length;
            let    body = document.body;
            let    html = document.documentElement;

            log("select         slot=["+ slot              +"]          num=["+ num               +"]        count=["+ count             +"]");
            log("HTML   scrollHeight=["+ html.scrollHeight +"] offsetHeight=["+ html.offsetHeight +"] clientHeight=["+ html.clientHeight +"]");
            log("BODY   scrollHeight=["+ body.scrollHeight +"] offsetHeight=["+ body.offsetHeight +"] clientHeight=["+ body.clientHeight +"]");
        }
    }


    let el = ccs[slot].nodes[num-1];

    let can_be_made_visible
        = (typeof dom_details != "undefined")
        &&        dom_details.details_has_closed_el_parent(el);

    let visible
        = ((thumb_p > 0) || can_be_made_visible)
        && t_util.is_el_visible(el)
    ;


if( tag_this ) log("%c"+caller+": ...return "+visible, lbH+lfX[visible ? 5:2]);
    return visible;
};




let last_selected_thumb_p = 0;
let last_selected_slot    =-1;
let last_selected_num     = 0;


let t_set_last_selected_slot_num = function(slot, num, thumb_p)
{

let caller = "set_last_selected_slot_num";
let log_this = DOM_SELECT_LOG || LOG_MAP.S3_SLOT;

if( log_this) log("%c"+caller+"(slot=["+slot+"], num=["+num+"], thumb_p=["+thumb_p+"])", lbH+lf4);


    if(!thumb_p)
        thumb_p = parseFloat( ccs[slot].get_num_thumb_p(num) );

    highlight_data_thumb_p(thumb_p, slot);

    if(ccs[slot])
    {
        t_tools.t_words_regex_reset  ( ccs[slot].pattern      );
        log_tools_filter_slot(           slot               );
    }

    last_selected_slot    = slot;
    last_selected_num     = num;
    last_selected_thumb_p = thumb_p;
};



let get_parent_with_overflow = function(node)
{
    for(let parent  = node
        ;   parent && parent.style
        ;   parent  = parent.parentNode
    ) {
        let computedStyle = window.getComputedStyle(parent);
        if( computedStyle.overflow && (computedStyle.overflow != "visible"))
        {
logXXX(t_util.get_n_lbl(parent)+" %c overflow ["+parent.style.overflow+"] %c COMPUTED ["+computedStyle.overflow+"]"
    ,                      lbL+lf6                                ,lbR+lf7);

            return parent;
        }
    }
    return null;
};


let scroll_thumb_p_to_onSeek_XY = function(thumb_p, slot, onSeekXYL)
{
let   caller = "scroll_thumb_p_to_onSeek_XY(thumb_p=["+thumb_p+"], slot=["+slot+"], onSeekXYL["+onSeekXYL.x+" "+onSeekXYL.y+"])";
let log_this = LOG_MAP.S3_SLOT;
if( log_this ) log(caller);

    let page_height
        = t_util.getPageHeight() * (t_tools.t_get_body_zoom_percent() / 100.0);

    let scrollX
        = window.scrollX
        - onSeekXYL.x;

    let scrollY
        = page_height * (thumb_p / 100.0)
        - onSeekXYL.y;

    try {
        t_tools.t_window_scrollTo(scrollX, scrollY);
if(log_this) log("%c PAGE "+page_height+" %c thumb_p "+thumb_p+" %c scrollY "+Math.floor(scrollY)+" "
    ,             lbL+lf9                ,lbC+lf6                ,lbR+lf7);
    }
    catch(ex) {
        console.log(caller+": "+ex);
    }
};




let get_last_selected_slot = function()
{
    return last_selected_slot;
};


let clear_last_selected_slot = function()
{
    last_selected_slot    = -1;
    last_selected_num     = -1;
};


let highlight_data_thumb_p = function(thumb_p, slot)
{

let   caller = "highlight_data_thumb_p(thumb_p=["+thumb_p+"] slot=["+ slot+"])";
let log_this = LOG_MAP.S3_SLOT;

if(log_this) log(caller);



    let el;
    let text                     = String(       thumb_p );
    if(               thumb_p < 10) text  = " "+ text     ;
    if     (text.indexOf(".") <  0) text +=          ".00";
    else if(text.length       <  5) text +=            "0";
if(log_this) log(" text=["+text+"]");



    let                  shadow_root = t_tools.t_get_shadow_root();
    let doc           = (shadow_root) ? shadow_root : document;
    let data_selector = "[data-thumb_p]";
    let elements      = doc.querySelectorAll( data_selector );

if(log_this) log(" "+ elements.length+" "+data_selector);

    for(let i=0; i < elements.length; ++i)
        t_util.del_el_class(elements[i], "current_slot_num");



    for(let s=0; s < SELECT_SLOT_MAX; ++s)
    {
        let id;
        id = ".select"  +s    ; if(el = t_tools.t_get_tool(id)) { if(s == slot) t_util.add_el_class(el,"current_slot"); else t_util.del_el_class(el,"current_slot"); }
        id = "thumb_p_"+s+"_0"; if(el = t_tools.t_get_tool(id)) { if(!(el.innerHTML.includes(t_data.SYMBOL_E))) el.innerText = t_data.SYMBOL_E; }
        id = "thumb_s_"+s+"_0"; if(el = t_tools.t_get_tool(id)) { if(!(el.innerHTML.includes(t_data.SYMBOL_E))) el.innerText = t_data.SYMBOL_E; }
    }



    data_selector = "[data-thumb_p='"+text+"']";
    elements = doc.querySelectorAll( data_selector );
if(log_this) log(" "+ elements.length+" "+data_selector);
    for(let i=0;  i < elements.length; ++i) {
        t_util.add_el_class(elements[i], "current_slot_num");
    }




    let container;
    for(slot = 1; slot < ccs.length; ++slot)
    {
        if(!ccs[slot]) continue;

        for(let num = 1; num <= ccs[slot].nodes.length; ++num)
        {
            let p  = parseFloat( ccs[slot].get_num_thumb_p(num) );
            if( p == thumb_p) {
                container = ccs[slot].containers[num-1];
                break;
            }
        }
        if(container) break;
    }
if(log_this) t_log.console_dir("container", container);

    for(slot = 1; slot < ccs.length; ++slot)
    {
        if(!ccs[slot]) continue;

        for(let num = 1; num <= ccs[slot].nodes.length; ++num)
        {
            let in_same_container
                = (container && (container ==  ccs[slot].containers     [num-1])) ? "IN CONTAINER ["+t_util.get_id_or_tag(container)+"]"
                : (     thumb_p == parseFloat( ccs[slot].get_num_thumb_p(num)  )) ? "AT THUMB ["+thumb_p+"]"
                :                                                             ""
            ;
            if(in_same_container)
            {
if(log_this) logBIG("slot=["+slot+"] num=["+num+"] .. "+in_same_container);


                let slot_num_id = "thumb_p_"+ slot +"_"+ num;
                if( !t_tools.t_get_tool(slot_num_id) )
                {

                    let id = "thumb_p_"+slot+"_0";
                    if( el = t_tools.t_get_tool( id ))
                    {
if(log_this) log(".HIGHLIGHT: id=["+id+"]");
                        el.innerText = String(num);
                        t_util.add_el_class(el, "current_slot_num");
                    }


                    id = "thumb_s_"+slot+"_0";
                    if( el = t_tools.t_get_tool( id ))
                    {
if(log_this) log(".HIGHLIGHT: id=["+id+"]");
                        el.innerText = String(num);
                        t_util.add_el_class(el, "current_slot_num");
                    }
                }
                else {
if(log_this) log(".DEDICATED SLOT TOOL HIGHLIGHTED: slot_num_id=["+slot_num_id+"]");
                }
                break;
            }

        }
    }

};


let t_clear_slot_all = function()
{
    let caller = "t_clear_slot_all";
let log_this = LOG_MAP.S2_SELECT || LOG_MAP.S3_SLOT;

    let cleared_count   = 0;
    let cleared_pat_csv = "";

    for(let slot = ccs.length-1; slot >= 1        ; --slot)
    {
        let       pattern    = ccs[slot] ? ccs[slot].pattern : "";

        let clear_slot_count = t_slot.t_clear_slot( slot );

        if( clear_slot_count && pattern)
            cleared_pat_csv  = t_util.csv_add(cleared_pat_csv, pattern);

        cleared_count       += clear_slot_count;
    }

if(log_this) log(caller+": "+cleared_count+" words highlighting cleared");
    return cleared_pat_csv;
};



let s_selection_execCommand = function(cmd_csv)
{
    let caller = "s_selection_execCommand("+cmd_csv+")";
if(LOG_MAP.S3_SLOT) log(caller);

    document.designMode = "on";
    try {
        if(cmd_csv.indexOf("undo"         ) >= 0) document.execCommand("undo"                , false, null           );

        if(cmd_csv.indexOf("foreColor"    ) >= 0) document.execCommand("foreColor"           , false, "#FF0000"      );
        if(cmd_csv.indexOf("backColor"    ) >= 0) document.execCommand("backColor"           , false, "#00AADD"      );
        if(cmd_csv.indexOf("hiliteColor"  ) >= 0) document.execCommand("hiliteColor"         , false, "pink"         );

        if(cmd_csv.indexOf("bold"         ) >= 0) document.execCommand("bold"                , false, null           );
        if(cmd_csv.indexOf("fontName"     ) >= 0) document.execCommand("fontName"            , false, "Comic sans ms");
        if(cmd_csv.indexOf("fontSize"     ) >= 0) document.execCommand("fontSize"            , false, "400%"         );

        if(cmd_csv.indexOf("strikeThrough") >= 0) document.execCommand("strikeThrough"       , false, null           );
    }
    catch(ex) { log(caller+": "+ex, "error"); }
    document.designMode = "off";


};


const CANNOT_EXPAND_TO_SELECTION = "cannot_expand_to_selection";
let t_selection_add_cannot_expand = function()
{
log("t_selection_add_cannot_expand");
    s_selection_execCommand("hiliteColor");
    t_util.add_el_class(document.body, CANNOT_EXPAND_TO_SELECTION);
};


let t_selection_del_cannot_expand = function()
{
log("t_selection_del_cannot_expand");
    t_util.del_el_class(document.body, CANNOT_EXPAND_TO_SELECTION);
};



let t_get_slot_num_for_last_highlight_thumb_p = function(slot, backward)
{
    return get_slot_num_for_thumb_p(slot, last_selected_thumb_p, backward);
};


let get_slot_num_for_thumb_p = function(slot, thumb_p, backward)
{
    let caller = "get_slot_num_for_thumb_p(slot=["+slot+"], thumb_p=["+thumb_p+"], backward=["+backward+"])";
let log_this = LOG_MAP.S3_SLOT;
if( log_this) log(caller);

    if( !ccs[slot] ) {
if( log_this) log(caller+": SLOT "+ slot +" is empty");
        return 0;
    }
    let num_at_or_past_thumb_p = 0;

    let first = 1;
    let  last = ccs[slot].nodes.length;
    let   num = 0;

    if(!backward) {
        for(num    = first; num <= last; num += 1) {
            let p  = parseFloat( ccs[slot].get_num_thumb_p(num) );
            if( p <= thumb_p) num_at_or_past_thumb_p = num;
            if( p >  thumb_p) break;
        }
    }
    else {
        for(num    = last; num >= first; num -= 1) {
            let p  = parseFloat( ccs[slot].get_num_thumb_p(num) );
            if( p >= thumb_p) num_at_or_past_thumb_p = num;
            if( p <  thumb_p) break;
        }
    }

    if((num < first) || (num > last))
        num_at_or_past_thumb_p = 0;

if( log_this) log(caller+": return "+ num_at_or_past_thumb_p);

    return num_at_or_past_thumb_p;
};







let get_range_from_XY = function(x, y)
{

let   caller = "get_range_from_XY";
let log_this = LOG_MAP.S1_RANGE;

let       msg_log  = "";
if( log_this) msg_log += caller+"(x="+x+" , y="+y+")";

    let       range = get_range_from_caret(x,y);
    let not_a_range = (range && !range.setStart);
    if(not_a_range && range && range.offsetNode)
    {

if(log_this) {
    console.dir(range);
    msg_log += "[not_a_range ..!range.setStart) .. CREATING RANGE:<br>";
    msg_log += "...range.offsetNode....=["+ t_util.get_n_txt(range.offsetNode) +"]<br>";
    msg_log += "...range.offset........=["+ range.offset                +"]<br>";
}

        let new_range = document.createRange();
        new_range.setStart(range.offsetNode, range.offset);
        range = new_range;
    }

if(log_this) {
    if(range) {
        msg_log += rangeToString(range, caller);
        t_log.console_dir(msg_log, range);
    }
    else {
        msg_log += caller+": ...return null";
    }

    t_log.log_TR_RESULT_set( msg_log );
}

    return range;
};


let get_range_from_caret = function(x, y)
{

let   caller = "get_range_from_caret";
let log_this = LOG_MAP.S1_RANGE;



    let  range = null;

    if(!range     && document.caretRangeFromPoint)
    {
        try {
            range =  document.caretRangeFromPoint(x,y);
        }
        catch(ex) {
            log(caller+": "+ex, "caretRangeFromPoint failed");
        }
    }


    if(!range     && document.caretPositionFromPoint)
    {
        try {
            range =  document.caretPositionFromPoint(x,y);
        }
        catch(ex) {
            log(caller+": "+ex, "caretPositionFromPoint failed");
        }
    }

if(log_this) t_util.log_range(range, caller+"(x="+x+" , y="+y+")");
    return range;
};


let rangeToString = function(range, rangeName="RANGE")
{
    if(!range) return "<div>rangeToString(null range)</div>";

    let caller = "rangeToString";
    try {

        let range_str =  range.toString();
        if(!range_str && range.startContainer.parentElement)
            range_str =  range.startContainer.parentElement.textContent;

        let range_attr
            = range.collapsed
            ?  "<span class='cc8'>collapsed at "+ range.startOffset                              +"</span>"
            :  "<span class='cc4'>offset "      + t_util.ellipsis(range.startOffset,32) +" .. "+ t_util.ellipsis(range.endOffset,32) +"</span> "
        ;

        let ancestor = "";
        if(range.commonAncestorContainer)
            ancestor =                         range.commonAncestorContainer.toString()          + " "
            +                                  get_n_attributes(range.commonAncestorContainer)   + " "
            +  range.commonAncestorContainer.length ? ""
            :                        "length=["+ range.commonAncestorContainer.length            +"] "
        ;

        let container_node = range.startContainer ? range.startContainer : range.offsetNode;

        let container;
        container = "";
        if(container_node)
            container =                   container_node.toString()                              + " "
            +                   " nodeName=["+ container_node.nodeName                           +"] "
            +                     " length=["+ container_node.length                             +"] "
            +                                  get_n_attributes(container_node                 ) +"] "
            + !container_node.previousSibling ? ""
            :             "previousSibling: "+ get_n_attributes(container_node.previousSibling ) + " "
        ;

        let endContainer = "";
        if(range.endContainer)
            endContainer =                     range.  endContainer.toString()                   + " "
            +                   " nodeName=["+ range.  endContainer.nodeName                     +"] "
            +                     " length=["+ range.  endContainer.length                       +"] "
            +                                  get_n_attributes(range. endContainer            ) +"] "
            + !container_node.nextSibling ? ""
            :                 "nextSibling: "+ get_n_attributes(range. endContainer.nextSibling) + " "
        ;

        rangeName = "<span class='cc7'>"+rangeName+"</span>";
        range_str = "<span class='str'>"+t_util.ellipsis(range_str)+"</span>";

        container = "";
        if(range.commonAncestorContainer)
            container = t_util.node_toString( range.commonAncestorContainer.parentElement );

        return "<div class='div_match'>"
            +  rangeName
            +  " <div>container: "     + container    +"</div>"
            +  " <ul>"
            +  "  <li>"                + range_str    +"</li>"
            +  "  <li>"                + range_attr   +"</li>"
            +  "  <li>Ancestor: "      + ancestor     +"</li>"
            +  "  <li>Start: "         + container    +"</li>"
            +  "  <li>End: "           + endContainer +"</li>"
            +  " </ul>"
            +  "</div>"
        ;
    }
    catch(ex) {
        log(    caller+"("+rangeName+"): "+ex, "error");
        return "<div>"
            +   caller+"("+rangeName+"):<br>"
            +   ex
            +   "<hr>"+ dom_log.t_log.get_callers()
            +  "</div>"
        ;
    }
};







let root_last_used_id;


let check_NodeIterator = function(           tag_or_id, pattern) { return check_Traversal("NodeIterator", tag_or_id, pattern); };
let check_TreeWalker   = function(           tag_or_id, pattern) { return check_Traversal("TreeWalker"  , tag_or_id, pattern); };
let check_Traversal    = function(traversal, tag_or_id, pattern)
{

let   caller = "check_traversal";
let log_this = LOG_MAP.S3_SLOT;

if( log_this) log("%c"+caller+" %c traversal=["+traversal+"] %c tag_or_id=["+tag_or_id+"] %c pattern=["+pattern+"]"
    ,             lbH         ,lbL                         ,lbC                         ,lbR                      );
if( log_this) t_log.log_TR_SELECT_add("<em class='cc3'>caller</em> traversal=<em class='cc3'>"+traversal+"</em> tag_or_id=<em class='cc4'>"+tag_or_id+"</em> pattern=<em class='cc6'>"+pattern+"</em>");


    if( !pattern ) {
        log("%c"+caller+" %c no pattern to look for", lbL, lbR+lf3);
        return;
    }



    if(tag_or_id) {              root_last_used_id = tag_or_id; if(log_this) log("%c SET %c root_last_used_id = tag_or_id %c "+tag_or_id, lbL+lf5, lbC, lbR+lf5); }
    else          { tag_or_id  = root_last_used_id            ; if(log_this) log("%c GET %c tag_or_id = root_last_used_id %c "+tag_or_id, lbL+lf8, lbC, lbR+lf8); }



    let root = pick_tag_or_id_node(tag_or_id, caller);

    let mDomTraversal
        = (traversal == "NodeIterator")
        ?  document.createNodeIterator(root, NodeFilter.SHOW_TEXT, mNodeFilter_function)
        :  document.createTreeWalker  (root, NodeFilter.SHOW_ALL , mNodeFilter_function);

if( log_this) log("<em class='cc3'>"+ t_util.object_label(mDomTraversal) +"</em> ID: <em class='cc4'>"+tag_or_id+"</em>");



    let clicked_selection
        = t_tools.t_get_onDown_EL(caller);

    mNodeRegexP         = get_mNodeRegexP(pattern);
if( log_this) log("mNodeRegexP=["+mNodeRegexP+"]");

    if(!mNodeRegexP) return;

    let words_option = mNodeRegexP.words_option;

    let node_array
        = get_traversal_node_array(pattern, clicked_selection, mDomTraversal);



    if(!node_array) {
if( log_this) t_log.log_TR_RESULT_set();

        return;
    }


    reset_page_geometry();
    if(    (node_array.length >= TOO_MANY_SELECTIONS)
        || (node_array.length == 0                  )
    ) {
        let sel_bag;
        if( sel_bag = t_tools.t_get_tool("sel_bag"))
        {

            let msg = (node_array.length > 0)
                ? "*** TOO MANY: <em class='cc8'>"+pattern+"</em> .. (max "+TOO_MANY_SELECTIONS+") ***"
                : "--- NO MATCH: <em class='cc8'>"+pattern+"</em> ---";

            let el;
            if( el = t_tools.t_get_tool("sel_bag_warn_div") )
                el.innerHTML
                    = msg;
            else
                sel_bag.innerHTML
                    = "<div id='sel_bag_warn_div' class='cc2'>"+  msg +"</div><br>"
                    +    sel_bag.innerHTML;


            setTimeout(
                       function() {
                           let div;
                           if( div = t_tools.t_get_tool("sel_bag_warn_div")) div.parentElement.removeChild(div);
                       }
                       , 2000);

        }

        let [ sel_text ] = t_tools.t_pattern_to_sel_text_words_option( pattern );

        let tooltip
            = t_data.SYMBOL_ELLIPSIS +" "+words_option;

        let warning
            = (node_array.length)
            ? (t_i18n.i18n_get(t_i18n.TOO_MANY ) +" (max "+TOO_MANY_SELECTIONS+")")
            :  t_i18n.i18n_get(t_i18n.NOT_FOUND);

        t_tools.t_words_regex_no_match("<em>"+t_util.ellipsis_short(sel_text)+"</em> &#x2794; "+warning, tooltip);


if( log_this) t_log.log_TR_RESULT_set();
        return;
    }



if( log_this) {
    let msg = ""
        +"<p><em class='cc8'>" + words_option                          +"</em>"
        +"<br><em class='cc7'>"+ pattern_toHTML(pattern, words_option) +"</em>"
        +"<br>"                + "has selected"
        +"<br><em>"            + node_array.length                +"</em> nodes"
        +"</p>"
    ;

    log("<div class='badge'>"+msg+"</div>");
}


    touchedWord_slot                   = get_free_slot();
    ccs[touchedWord_slot].pattern      = pattern;
    ccs[touchedWord_slot].slot         = touchedWord_slot;
    ccs[touchedWord_slot].words_option = words_option;

    delete ccs[touchedWord_slot].visible_num_array;

    let can_collect_more = (ccs[touchedWord_slot].nodes.length < TOO_MANY_SELECTIONS);

    for(let i = 0; can_collect_more && (i < node_array.length); ++i)
    {
if( log_this) log("<em class='cc0' style='font-size:300%;'>"+(i+1)+"/"+node_array.length+"</em>");

        collect_node_matches_to_slot(touchedWord_slot, node_array[i], pattern, words_option);

        can_collect_more = (ccs[touchedWord_slot].nodes.length < TOO_MANY_SELECTIONS);
    }

    ccs[touchedWord_slot].mNodeRegexP = mNodeRegexP;

    log_tools_filter_slot( touchedWord_slot );


if( log_this) t_log.log_TR_RESULT_set();
};


let check_childNodes = function(tag_or_id, pattern)
{

    let caller = "<em class='cc3'>check_childNodes</em> tag_or_id=<em class='cc4'>"+tag_or_id+"</em> pattern=<em class='cc6'>"+pattern+"</em>";
let log_this = LOG_MAP.S1_RANGE;
if( log_this) log(caller);
if( log_this) t_log.log_TR_SELECT_set(caller);

    let root = pick_tag_or_id_node(tag_or_id, caller);
    if(!root) return;

if( log_this) log("<em class='cc3'>check_childNodes</em> <em class='cc4'>ID: "+tag_or_id+"</em> <em class='cc4'>pattern: "+pattern+"</em>");
if( log_this) log_tags();
if( log_this) log("mNodeRegexP=["+mNodeRegexP+"]");


    reset_page_geometry();
    let node, last_node, count, empty_count=0;
    for(count = 0; count < root.childNodes.length; ++count)
    {
        node         = root.childNodes[count];
        last_node    = node;
        if(count < CHECK_LOG_MAX) check_log_num_thumb(count, node);
    }

    if( log_this && (count >= CHECK_LOG_MAX)) {
        log(t_util.mPadStart(" .../..."));
        log(t_util.mPadStart(" "+count,3," ") +  t_util.node_toString( last_node ));
    }
    if( log_this && (empty_count > 0)) log("...empty_count=["+empty_count+"]");

};


let check_tagNodes = function(tag, pattern)
{

    if(!tag) tag = "*";
    let caller = "<em class='cc3'>check_tagNodes</em> tag=<em class='cc4'>"+tag+"</em> pattern=<em class='cc5'>"+pattern+"</em>";
let log_this = LOG_MAP.S1_RANGE;
if(log_this) log(caller);
if(log_this) t_log.log_TR_SELECT_set(caller);


    let elements = document.getElementsByTagName(tag);
if(log_this) log(caller+" <em class='cc4'>"+elements.length+" "+tag+" elements</em>");

    if(!elements.length) {
        elements = document.querySelectorAll( tag );
if(log_this) log(".document.querySelectorAll("+tag+")=["+elements.length+"]");
    }


    let    flags = prop.get(t_data.WORDS_DROP_CASE) ? "giu" : "gu";
    mNodeRegexP  = (pattern) ? new RegExp(pattern, flags) : null;
if(log_this) log_tags();
if(log_this) log("mNodeRegexP=["+mNodeRegexP+"]");


    reset_page_geometry();
    let node, last_node, count, empty_count=0;
    for(count = 0; count < elements.length; ++count)
    {
        node         = elements[count];
        last_node    = node;
        if(!mNodeRegexP || node.textContent.match(mNodeRegexP))
        {
            if(count < CHECK_LOG_MAX) check_log_num_thumb(count, node);
        }
    }

if(log_this && (count >= CHECK_LOG_MAX)) {
    log(t_util.mPadStart(" .../..."));
    log(t_util.mPadStart(" "+count,3," ") +  t_util.node_toString( last_node ));
}

if(log_this && (empty_count > 0)) log("...empty_count=["+empty_count+"]");

};


let get_traversal_node_array = function(pattern, clicked_selection, mDomTraversal)
{

let   caller = "get_traversal_node_array";
let log_this = DOM_SELECT_LOG || LOG_MAP.S1_RANGE;
let tag_this = DOM_SELECT_TAG || log_this;

if( tag_this) log("%c"+caller+"(pattern=["+pattern+"], clicked_selection=["+t_util.get_n_txt(clicked_selection)+"])", lbH);
if( log_this) log_tags();



    let slot;
    if( slot = t_slot.get_slot_matching_pattern( pattern )) {
        if(!clicked_selection) {
if( tag_this) log("%c PATTERN ALREADY MACTHED: slot=["+slot+"]", lbH+lf3);
            return [];
        }
if( tag_this) log("%c CLEARING PREVIOUS MACTH: slot=["+slot+"]", lbH+lf5);
        t_slot.t_clear_slot( slot );
    }

    let node_array = [];
    let node;
    while(node = mDomTraversal.nextNode())
    {
        if( node_has_some_text(  node) ) {

            if(node_array.length >= TOO_MANY_SELECTIONS)
                break;
            node_array.push(node);
        }
        else {
if( tag_this) {
    log_key_val_group(  caller
                     ,{ NODE             : "--------------------------------------------"
                      , toString         : t_util.node_toString   (node            ) +"]"
                      , nodeValue        :                        (node.nodeValue  ) +"]"
                      , textContent      :                        (node.textContent) +"]"
                      , trim_alNum_lines : t_util.trim_alNum_lines(node.textContent) +"]"
                     }, lf8, false);
}

        }
    }
if( tag_this) log(caller+": return node_array.length=["+node_array.length+"]");
    return node_array;
};


let get_mNodeRegexP = function(pattern)
{

let   caller = "get_mNodeRegexP";
let log_this = LOG_MAP.S1_RANGE;


    let flags = prop.get(t_data.WORDS_DROP_CASE) ? "giu" : "gu";
    let    rx = null;

    let [ sel_text , words_option ] = t_tools.t_pattern_to_sel_text_words_option( pattern );

    try {
        switch( words_option   ) {
        case    t_data.WORDS_EXACT    : rx = new RegExp( "\\b("+sel_text+")\\b" , flags); break;
        case    t_data.WORDS_SEGMENT  : rx = new RegExp(    "("+sel_text+")"    , flags); break;

        case    t_data.WORDS_HEAD_TAIL: rx = new RegExp("\\w*("+sel_text+")\\w*", flags); break;
        default:
        logBIG("*** wrong words_option ["+words_option+"] ***", lf2);
        }
    } catch(ex) {
if( log_this) log(caller+"(sel_text=["+sel_text+"] words_option=["+words_option+"]):"+t_data.LF+"*** "+ex);
        t_tools.t_words_regex_no_match(sel_text, t_util.get_ex_tooltip(ex));
        return null;
    }

    rx.pattern      = pattern;
    rx.words_option = words_option;

if(log_this) log(caller+"("+sel_text+" "+words_option+"): ...return ["+rx+"]");
    return rx;
};


let t_check_hasFeature = function(feature, version)
{
    let caller = "<em class='cc3'>t_check_hasFeature</em> feature=<em class='cc4'>"+feature+"</em> version=<em class='cc5'>"+version+"</em>";
let log_this = LOG_MAP.S1_RANGE;
if( log_this) log(caller);

    let result = "";
    try {
        let input_feature = t_tools.t_get_tool("input_feature"); feature = input_feature.value;
        let input_version = t_tools.t_get_tool("input_version"); version = input_version.value;
        result = document.implementation.hasFeature(   feature , version);
    }
    catch(ex) {
        result = ex.toString();
    }

if( log_this) log(caller+": ...return "+result);
    return result;
};


let check_log_num_thumb = function(count, node)
{
    let         num = t_util.mPadStart(count, 5, " ");

    let thumb_p     = get_node_thumb_p( node    );
    let thumb_p_str = t_get_thumb_p_str ( thumb_p );
    let      offset = " ["+ thumb_p_str.replace(" ","&nbsp;") +"%]";

    let         val = t_util.node_toString(node);

    log("<span class='check_log_num_thumb'>"+num + offset +"</span> "+ val);
};


let mNodeFilter_function = function(node)
{
let caller = "mNodeFilter_function";
let log_this = LOG_MAP.S1_RANGE;
    let check_result = mNodeFilter_check_node( node );

if(log_this && (check_result != NodeFilter.FILTER_SKIP)) log(caller+": "+ mNodeFilter_toString(check_result) + t_util.node_toString(node));

    return check_result;
};


let mNodeFilter_check_node = function(node)
{




    let parent = node.parentNode;
    if( parent && (parent.nodeType == Node.ELEMENT_NODE))
    {
        if( parent.tagName  == "SCRIPT"             ) return NodeFilter.FILTER_REJECT;
        if( parent.tagName  == "STYLE"              ) return NodeFilter.FILTER_REJECT;
        if( t_is_node_selected( parent )            ) return NodeFilter.FILTER_REJECT;
    }




    if( t_util.is_marked_to_hide(node) ) {

        return NodeFilter.FILTER_REJECT;
    }


    if( t_util.has_el_class(node, t_data.CSS_LINE_NUM) ) {

        return NodeFilter.FILTER_REJECT;
    }








    if(node.nodeType != Node.TEXT_NODE              ) return NodeFilter.FILTER_SKIP  ;



    if(    mNodeRegexP         && node.textContent  )
        if(mNodeRegexP.pattern == node.textContent  ) return NodeFilter.FILTER_ACCEPT;



    if(                       !mNodeRegexP          ) return NodeFilter.FILTER_ACCEPT;



    if(!node.textContent                            ) return NodeFilter.FILTER_SKIP  ;
    if(!node.textContent.match(mNodeRegexP)         ) return NodeFilter.FILTER_SKIP  ;



    else                                              return NodeFilter.FILTER_ACCEPT;


};


let mNodeFilter_toString = function( check_result )
{
    switch( check_result )
    {
        case NodeFilter.FILTER_ACCEPT: return "<em class='cc4'>FILTER_ACCEPT </em>";
        case NodeFilter.FILTER_REJECT: return "<em class='cc1'>FILTER_REJECT </em>";
        case NodeFilter.FILTER_SKIP  : return "<em class='cc8'>FILTER_SKIP   </em>";
        default                      : return "<em class='cc2'>FILTER_ERROR  </em>";
    }
};






let collect_node_matches_to_slot = function(slot, node, pattern, words_option)
{

let   caller = "collect_node_matches_to_slot";
let log_this = LOG_MAP.S1_RANGE;

if( log_this) log(caller+"(slot=["+slot+"], node=["+t_util.get_n_txt(node)+"]");


if( log_this) log("<div class='div_match'>");
    let matches;
    for(let i = 0; node && (matches = mNodeRegexP.exec(node.textContent)); ++i)
    {
if( log_this) log("<div class='div_match' style='border:3px dotted yellow !important;'>");

        let num = ccs[slot].nodes.length+1;
if( log_this) log_match(node, slot, num, i, mNodeRegexP, matches);

        let       match = matches[0];
        let startOffset = matches.index;
        let   endOffset = startOffset + match.length;


        let       range = document.createRange();
        range.setStart(node, startOffset);
        range.setEnd  (node,   endOffset);


        if(ccs[slot].nodes.length < TOO_MANY_SELECTIONS)
        {
            t_util.clearSelection();
            try {
                window.getSelection().addRange( range );
            } catch(ex) { log(caller+": pattern=["+pattern+"]"+ex, "error"); }


            if(i == 0) document.execCommand("copy");


            let ccs_node_nextSibling = collect_selection_to_slot(slot, pattern, words_option);
            if( ccs_node_nextSibling )
            {

                node = ccs_node_nextSibling;
                mNodeRegexP.lastIndex = 0;
            }
if( log_this) log("...<blockquote class='cc6'>"+ t_util.get_n_txt(node).substring(mNodeRegexP.lastIndex) +"</blockquote>");
        }
        else {

if( log_this) log("%c TOO_MANY_SELECTIONS=["+TOO_MANY_SELECTIONS+"]", lbH+lf8);
            node = null;
        }
if( log_this) log("</div>");
    }


    t_util.clearSelection();

if( log_this) log("</div>");
};


let log_match = function(node, slot, num, i, regex, matches)
{
    let s = ""
        + "<blockquote class='cc6'> "+            t_util.escape_CR_LF( t_util.ellipsis(node.textContent, 128) ) +"</blockquote>"
        + "<em class='cc6 em_match'> "+           matches[0]                                      +"</em>"
        + "<br>"
        + "<em class='cc"+((slot  )%9 + 1)+"'>slot "+   slot                                      +"</em>"
        + "<em class='cc"+(( num-1)%9 + 1)+"'>num "+    num                                       +"</em>"
        + "<em class='cc"+((   i  )%9 + 1)+"'>match #"+ (i+1)                                     +"</em>"
        + " REGEX: "
        + "<em class='cc4'> "+                    regex                                           +"</em>"
        + "<em class='cc5'> index "+              matches.index                                   +"</em>"
        + "<em class='cc8'> lastIndex "+          mNodeRegexP.lastIndex                           +"</em>"
    ;
    log(s);
};



let collect_selection_to_slot = function(slot, pattern, words_option)
{

    let caller = "collect_selection_to_slot";
let log_this = LOG_MAP.S3_SLOT;

if( log_this) log(caller+"(slot=["+slot+"], pattern=["+pattern+"], words_option=["+words_option+"])");


    let selection = window.getSelection();
    if(!selection               ) return null;
    if( selection.rangeCount < 1) return null;

    let range     = selection.getRangeAt(0);

    let sel_text  = range.toString();
if(log_this) log(".sel_text=["+sel_text +"]");

    if(!sel_text                ) return null;

    if(!pattern) pattern = sel_text;


    let ccs_node        = document.createElement("em");
    ccs_node.innerText  = sel_text;

    collect_ccs_range_node_slot(range, ccs_node, slot, pattern, words_option);

if(log_this) log("return ccs_node.nextSibling=["+ccs_node.nextSibling+"]");
    return ccs_node.nextSibling;
};




let collect_ccs_range_node_slot = function(range, ccs_node, slot, pattern, words_option)
{

let caller = "collect_ccs_range_node_slot";
let log_this = LOG_MAP.S3_SLOT;

if( log_this) log(caller+"(range, ccs_node, slot=["+slot+"])");


    let parent_with_overflow = get_parent_with_overflow( ccs_node );
    if( parent_with_overflow )
    {
if(log_this) log(caller+"%c NOT COLLECTING "+t_util.get_n_txt( ccs_node )+" .. parent_with_overflow "+t_util.get_n_txt( parent_with_overflow ), lbH+lf2);
        return;
    }


    let container                      = get_text_container( range.startContainer );
    let container_H                    = container ? container.offsetHeight : 0;
    let container_is_too_high          = (container_H             >  window.innerHeight);
    let container_is_body              = (container               == document.body);
    let container_is_body_direct_child = (container.parentElement == document.body);
    let container_is_body_single_child = (container               == document.body) && (document.body.childNodes.length == 1);
    let container_is_body_first_child  = (container               == document.body) && (document.body.childNodes[0]     == container);

if(log_this && container_is_too_high         ) log("%c container_is_too_high         ", lbH+lf2);
if(log_this && container_is_body             ) log("%c container_is_body             ", lbH+lf3);
if(log_this && container_is_body_direct_child) log("%c container_is_body_direct_child", lbH+lf4);
if(log_this && container_is_body_single_child) log("%c container_is_body_single_child", lbH+lf5);
if(log_this && container_is_body_first_child ) log("%c container_is_body_first_child ", lbH+lf6);



if(log_this) log("%c container %c "+t_util.get_n_lbl(container)+"%c H="+container_H, lbL, lbC+lf7, lbR+lf8);


    if(    container
       &&  prop.get("containers_hi")
       &&  container.classList
       && !container.classList.contains( "container_dark"  )
       && !container.classList.contains( "container_light" )
      ) {
        let theme_class = prop.get(t_data.THEME_DARK) ? "container_dark" : "container_light";
        t_util.add_el_class(container, theme_class);
    }

    if(container && container.children.length >= CONTAINER_HUGE_CHILDREN_LENGTH)
    {
        t_util.add_el_class(container              , "container_huge");
        t_util.add_el_class(container.parentElement, "container_huge_parent");
    }



    range.deleteContents();
    range.insertNode(ccs_node);



    let                   next_idx = ccs[slot].nodes.length;
    let                        ccX =     slot % SELECT_SLOT_MAX;
    let                 slot_class = SEL_CLASS_PREFIX +     ccX;
    let                 word_class = SEL_CLASS_PREFIX +"_"+ words_option;

    ccs_node.id                    = slot_class +"_"+(next_idx+1);
    ccs_node.className             = slot_class +" "+ word_class;
    ccs[slot].nodes     [next_idx] = ccs_node;
    ccs[slot].containers[next_idx] = container;

if(log_this) log("%c ccs_node: "+ t_util.node_toString(ccs_node), "background-color:#880");


};



const BAIL_OUT_COUNT = 10;
let get_text_container = function(node)
{
    let caller = "get_text_container("+t_util.get_n_txt(node)+")";
let log_this = LOG_MAP.S3_SLOT;

    let container = node.parentElement;

    let node_text_length = node.textContent.trim().length;
    if(!node_text_length) return container;

    let count;
    for(count = 0; count < BAIL_OUT_COUNT; ++count)
    {
        if(container == null)
        {
if(log_this) log("%c"+caller+"%c NO PARENT", lbL, lbR+lf2);

            break;
        }

        if( is_text_container_node( container ) )
        {
if(log_this) log("%c"+caller+"%c FOUND CONTAINER ["+t_util.get_n_str( container )+"] ("+container.tagName+")", lbL, lbR+lf4);
            break;


        }

        container = container.parentElement;
    }

    if(count >= BAIL_OUT_COUNT)
    {
if(log_this) log("%c"+caller+"%c BAILING OUT ON ["+t_util.get_n_str(node)+"] after "+count+" attempts at looking for a container", lbL, lbR+lf1);

    }

    return container;
};


let is_text_container_node = function(node)
{
let   caller = "is_text_container_node";
let log_this = LOG_MAP.S1_RANGE;

    let tag = node.nodeName.toLowerCase();
if( log_this) log("%c"+caller+" %c tag "+tag+" %c len "+node.textContent.length+" %c text "+t_util.get_n_txt(node)
                 ,lbL          ,lbR           ,lbH+lf5                           ,lbH+lf4                  );

    let result
        =      (tag == "p"        )
        ||     (tag == "div"      )
        ||    ((tag == "span"     ) && (node.textContent.length >= 360))
        ||    ((tag == "code"     ) && (node.textContent.length >=  80))
        ||    ((tag == "li"       ) && (node.textContent.length >=  80))
        ||    ((tag == "ol"       ) && (node.textContent.length >=  80))
        ||    ((tag == "ul"       ) && (node.textContent.length >=  80))
        ||     (tag == "section"  )
        ||     (tag == "article"  )
        ||     (tag == "aside"    )
        ||     (tag == "header"   )
        ||     (tag == "nav"      )

        || (   (tag != "span"     )
            && (tag != "a"        )
            && (tag != "b"        )
            && (tag != "em"       )
            && (tag != "font"     )
            && (tag != "strong"   )
            && (tag != "u"        )

            && (tag != "code"     )
            && (tag != "li"       )
            && (tag != "ol"       )
            && (tag != "ul"       )
        )
    ;

if( log_this) log("is_text_container_node(["+t_util.get_n_str(node)+"]...["+t_util.get_n_lbl(node)+"]): ...return "+result+" node.textContent.length=["+node.textContent.length+"]");
    return result;
};



let t_sync_containers_hi = function()
{

    let caller = "t_sync_containers_hi";
    let log_this = LOG_MAP.S1_RANGE;

if( log_this) log(caller+": containers_hi=["+prop.get("containers_hi")+"]");


    let className = "container_light";
    let node_list = document.querySelectorAll("."+className);
    for(let i     = 0; i < node_list.length; ++i)
    {
        t_util.del_el_class(node_list[i], className);
    }

    className     = "container_dark";
    node_list     = document.querySelectorAll("."+className);
    for(let i     = 0; i < node_list.length; ++i)
    {
        t_util.del_el_class(node_list[i], className);
    }



    if(prop.get("containers_hi"))
    {
        let theme_class = prop.get(t_data.THEME_DARK) ? "container_dark" : "container_light";
        let container;
        for(let slot = 1; slot < ccs.length; ++slot)
        {
            if( ccs[slot] )
            {
                for(let i = 0; i < ccs[slot].nodes.length; ++i)
                {
                    if(container = ccs[slot].containers[i])
                        t_util.add_el_class(container, theme_class);
                }
            }
        }
    }






    let   container;
    while(container = t_util.get_el_child_with_class(document.body, dom_sentence.CSS_SENTENCE_CONTAINER))
        dom_sentence.t_SENTENCE_RESTORE_EL( container );


};



let get_slot_num_container = function(slot, num)
{
    let s =  slot;
    let n = num-1;

    let node
        = (ccs[s] && ccs[s].containers && ccs[s].containers[n]) ? ccs[s].containers[n]
        : (ccs[s] && ccs[s].nodes      && ccs[s].nodes     [n]) ? ccs[s].nodes     [n]
        :                                                         null
    ;

    return  node;
};







const  PATTERN_UPDATE_DELAY =  550;
const  PATTERN_UPDATE_QUICK =  250;

let   onPatternUpdate_timer = null;

let t_onPatternUpdate_no_delay = function(msg, caller       ) { t_onPatternUpdate(msg, caller, 0                   ); };
let t_onPatternUpdate_quick    = function(msg, caller       ) { t_onPatternUpdate(msg, caller, PATTERN_UPDATE_QUICK); };
let t_onPatternUpdate          = function(msg, caller, delay=PATTERN_UPDATE_DELAY)
{

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_2_ACTION, msg);

    if(  onPatternUpdate_timer) {
        clearTimeout(  onPatternUpdate_timer);

    }
    if(delay) onPatternUpdate_timer =   setTimeout(onPatternUpdate_handler, delay);
    else                                           onPatternUpdate_handler();
};


let   onPatternUpdate_handler = function()
{

let   caller = "onPatternUpdate_handler";
let log_this = LOG_MAP.S0_PATTERN;

if( log_this ) logBIG(caller, lf4);

      onPatternUpdate_timer = null;

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly_all_csv(t_data.SYMBOL_UPDATE, "want");

    t_tools.t_pattern1_sync_csv_from_ccs();

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly_all_csv(t_data.SYMBOL_STAGE , "have");

    t_tools.t_pattern2_set_sel_bag_innerHTML();

    t_tools.t_pattern3_pat_off_alt_bak_innerHTML(caller);
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly_all_csv(t_data.SYMBOL_RESULT, "have");

    t_tools.t_onPatternUpdate_done();

};



let t_get_docker_bag_msg = function(bag_name, mov_count, ass_count, ins_count)
{
    let ccX
        = (bag_name == "pat") ? "cc1"
        : (bag_name == "off") ? "cc5"
        : (bag_name == "bak") ? "cc2"
        : (bag_name == "bin") ? "cc0"
        : ""
    ;

    let            docker_bag_msg  = "";
    if(ins_count ) docker_bag_msg += " <em class='done "+ccX+"'> INSERTED</em> <em class='bags "+ccX+"'>"+ bag_name +" + "+ ins_count +"</em>";
    if(mov_count ) docker_bag_msg += " <em class='done "+ccX+"'>    MOVED</em> <em class='bags "+ccX+"'>"+ bag_name +" + "+ mov_count +"</em>";
    if(ass_count ) docker_bag_msg += " <em class='done "+ccX+"'>CONFIRMED</em> <em class='bags "+ccX+"'>"+ bag_name +" = "+ ass_count +"</em>";

    if(!docker_bag_msg) return "";
    else                return "<br>"+ t_data.SYMBOL_DOCKER+" "+docker_bag_msg;
};



let t_collect_el_class_from_into = function(el_class, from, into)
{
    let spans = from.getElementsByTagName("SPAN");
    let count = 0;
    for(let i=0; i < spans.length; ++i)
    {
        if(              from != spans[i].parentNode  ) continue;
        if( t_is_accessory_node( spans[i]           ) ) continue;
        if(!t_util.has_el_class(        spans[i], el_class ) ) continue;
        into.push(spans[i]);
        count += 1;
    }

    return count;
};


let t_get_pat_span_with_pattern = function(from_bag, pattern)
{
    let pat_span  = null;
    let spans = from_bag.getElementsByTagName("SPAN");
    for(let i=0; i < spans.length; ++i)
    {
        if(          from_bag != spans[i].parentNode ) continue;
        if( t_is_accessory_node( spans[i]           )) continue;
        if(!t_util.has_el_class(        spans[i],"pat_span")) continue;
        if(!spans[i].textContent                     ) continue;
        if(!spans[i].textContent.includes(pattern   )) continue;
        pat_span = spans[i];
        break;
    }

    return pat_span;
};


let t_is_accessory_node = function(node)
{
    return (node == t_tools.t_get_tool( "bak_bag" )    )
        || (node == t_tools.t_get_tool( "off_bag" )    )
        || (node == t_tools.t_get_tool( "bot_div" )    )
        || (node == t_tools.t_get_tool( "mov_div" )    )

        || (node == t_tools.t_get_tool( "hov1"    )   )
        || (node == t_tools.t_get_tool( "hov2"    )   )
        || (node == t_tools.t_get_tool( "hov3"    )   )
        || (node == t_tools.t_get_tool( "hov4"    )   )

        || t_util.has_el_class(node, "seeker_handle")
        || t_util.has_el_class(node, "screener"     )

        || t_util.has_el_class(node, "push_pin"     )
        || t_util.has_el_class(node, "closepin"     )
        || t_util.has_el_class(node, "scalepin"     )
        || t_util.has_el_class(node, "clearpin"     )

    ;
};


let remove_pat_span_from_div = function(div)
{

    let caller = "remove_pat_span_from_div";
let log_this = LOG_MAP.S2_SELECT;

if( log_this) log(caller+"("+t_util.get_id_or_tag(div)+")");


    let  count = 0;
    let length = div.childNodes.length;
    let node_removed;
    for(let i=0; i < length; i += (node_removed ? 0 : 1))
    {
        let node = div.childNodes[i];
        node_removed = false;

        if(t_util.has_el_class(node, "pat_span") || t_util.has_el_class(node, "pat_div"))
        {
if(log_this) log("...REMOVING %c "+t_util.get_id_or_tag(node)+" %c"+node.textContent, lbL, lbR+lf2);
            div.removeChild(node);
            count += 1;
            node_removed = true;
        }
        else {

        }
    }
if(log_this) log("..."+count+" ["+t_util.get_n_lbl(div)+"] transient nodes removed");
};



let t_get_pat_span_line = function(num, pat, css_class)
{
    let data_pattern = t_util.csv_escape(pat);

    let [ sel_text , words_option ] = t_tools.t_pattern_to_sel_text_words_option(pat);
    let pat_less_sfx = sel_text;

    let text         = t_util.t_get_htmlEntities( t_util.ellipsis(pat_less_sfx, 16) );

    let title        = t_util.t_get_htmlEntities(sel_text) + t_data.LF + words_option;



    let className    = words_option+" "+t_data.CSS_DATA_PATTERN+" "+css_class;


    return "<span class='pat_span'>"
        +   "<em  class='num_em'>"+num+"</em>&nbsp;"
        +   "<em  class='"+className+"' data-pattern='"+data_pattern+"' title='"+title+"'>"+text+"</em>"
        +  "</span>"
    ;
};


let t_adjust_pat_span_words_option = function(pat_span, pat)
{
    t_tools.t_set_el_pat_words_option(pat_span.childNodes[2], pat);
};


let t_get_pat_span_index = function(pat_spans, pat)
{
    pat = t_tools.t_pattern_del_words_option_sfx(pat);

    for(let pat_span_index=0; pat_span_index < pat_spans.length; ++pat_span_index)
    {
        if(pat_spans[pat_span_index] == null) continue;

        let el      = pat_spans[pat_span_index].childNodes[2];
        let el_pat  = t_util.csv_unescape(el.getAttribute("data-pattern"));
        el_pat      = t_tools.t_pattern_del_words_option_sfx(el_pat);
        if( el_pat == pat) {

            return pat_span_index;
        }
    }
    return -1;
};






let getElementsByContent = function(text)
{
 let caller = "getElementsByContent";

    let result = null;
    try {
        let elements = document.getElementsByTagName("*");



        let deep_containers=[];
        let container = null;
        let text_toLowerCase = text.toLowerCase();
        for(let i = 0; i < elements.length; ++i)
        {
            let        el = elements[i];
            if(        el.textContent ) {
                if(    el.textContent.includes(text)
                    || el.textContent.toLowerCase().includes(text_toLowerCase)
                ) {

                    if     (!container              ) { container = el; }
                    else if( container.contains(el) ) { container = el; }
                    else                              { deep_containers.push( container ); container =el; }
                }
            }
        }

        if( container )
            deep_containers.push( container );


        result
            = (deep_containers.length > 0)
            ?  deep_containers[0]
            :  null
        ;


    }
    catch(ex) { log(caller+": "+ex, "error"); }
    return result;
};





let get_n_attributes = function(node)
{
    if(!node           ) return "*** get_n_attributes( !node ) ***";
    if(!node.attributes) return "";
    let     result = "";
    try {
        for(let  i = 0; i < node.attributes.length; ++i)
            result += "<span class='cc"+(i % SELECT_SLOT_MAX)+"'>"+node.attributes[i].name+": "+ node.attributes[i].value+"</span>";
    }
    catch(ex) { return "*** get_n_attributes("+node+") "+ex +" ***"; }
    return  result;
};


let node_has_some_text = function(node)
{
    return node.nodeValue
        && node.textContent
        && (t_util.trim_alNum_lines(node.textContent).length > 0)
    ;
};


let t_is_node_selected = function(node)
{
let   caller = "t_is_node_selected";
let log_this = LOG_MAP.S1_RANGE;

    if(!node) return false;

    let result = false;
    try {
        result = (node.className && node.className.startsWith( SEL_CLASS_PREFIX ));
    } catch(ex) {

    }

if(log_this && result) log(caller+"("+t_util.get_n_lbl(node)+"): ...return "+result);
    return result;
};


let is_a_select_tool = function(el)
{
    if(     !el    ) return false;
    if(     !el.id ) return false;
    return   el.id.startsWith("thumb_p_");
};








let pick_tag_or_id_node = function(tag_or_id, _caller)
{

    let caller = "pick_tag_or_id_node("+tag_or_id+")";
let log_this = LOG_MAP.S1_RANGE;

if(log_this) log(caller+".. CALLED BY ["+_caller+"]");


    let node = (!tag_or_id) ? document.body : null;

    let id = tag_or_id;



    if(!node) {
        node =    document.getElementsByTagName(  id  )[0] ;

if(log_this) log("document.getElementsByTagName("+id+")[0].....["+t_util.get_id_or_tag(node)+"]");
    }


    if(!node) {
        node =    document.getElementById      (  id      );

if(log_this) log("document.getElementById      ("+id+")........["+t_util.get_id_or_tag(node)+"]");
    }


    if(!node) {
        node =    getElementsByContent         (  tag_or_id );

if(log_this) log("getElementsByContent         ("+tag_or_id+")...["+t_util.get_id_or_tag(node)+"]");
    }

if(log_this) console.dir(node);



    let selector;
    if(!node ) {
        selector = "#"+id;
if(log_this) log(caller+": NOT FOUND .. trying selector ["+selector+"]");

        node = document.querySelector( selector );
    }


    if(!node ) {
        selector = "."+id;
if(log_this) log(caller+": NOT FOUND .. trying selector ["+selector+"]");

        node = document.querySelector( selector );
    }


    if(!node )
    {
if(log_this) log(caller+": NOT FOUND .. using body");

        node = document.body;
    }


    if(!node )
    {
if(log_this) log(caller+": NOT FOUND .. using document");

        node = document;
    }


if(log_this) {
    log("<div class='cc8'>");
    log(caller);
    log_node(t_data.SYMBOL_CHECK_MARK +" NODE"       , node           );
    log_node(t_data.SYMBOL_CHECK_MARK +" PARENT"     , node.parentNode);
    log_node(t_data.SYMBOL_CHECK_MARK +" FIRST CHILD", node.firstChild);
    log_node(t_data.SYMBOL_CHECK_MARK +" LAST CHILD" , node.lastChild );
    log("</div>");
    log(caller+": ...return "+t_util.get_id_or_tag(node));
console.dir(node);
}

    return node;
};




let log_tags = function()
{
    let tag;        let s  = "";
    tag = "#document" ; s +=        tag +" <em class='cc3'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "HTML"      ; s += "    "+tag +" <em class='cc3'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "HEAD"      ; s += "    "+tag +" <em class='cc3'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "BODY"      ; s += "    "+tag +" <em class='cc3'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "SCRIPT"    ; s += "    "+tag +" <em class='cc3'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "DIV"       ; s += "    "+tag +" <em class='cc3'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "BLOCKQUOTE"; s += "    "+tag +" <em class='cc3'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    s  +="<br>";
    tag = "SPAN"      ; s +=        tag +" <em class='cc4'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "EM"        ; s += "    "+tag +" <em class='cc4'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "A"         ; s += "    "+tag +" <em class='cc4'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "BUTTON"    ; s += "    "+tag +" <em class='cc4'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "INPUT"     ; s += "    "+tag +" <em class='cc4'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "TEXTAREA"  ; s += "    "+tag +" <em class='cc4'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;
    tag = "LI"        ; s += "    "+tag +" <em class='cc4'>"+ t_util.get_h_tag(tag) +"</em>"+t_data.LF;


    t_log.log_TR_SELECT_add("<div id='log_tags_div'>"+ s +"</div>");
};


let log_node = function(label, node)
{
    if(!node) {
        log(t_util.mPadStart(label,16)+" <em></em>");
        return;
    }
    let em_class
        = (node.nodeType == Node.TEXT_NODE   ) ? "cc4"
        : (node.nodeType == Node.COMMENT_NODE) ? "cc8"
        :                                        "cc3"
    ;
    let n_str = t_util.get_n_str( node          );
    let p_str = t_util.get_p_str( node          );
    let n_tag =            node.nodeName;

    log(t_util.mPadStart(label,16)+" <em>"+n_tag+"</em> <em class='"+em_class+"'>"+ p_str +" "+ n_str +"</em>" +" has "+ node.childNodes.length +" childNodes");
};







let log_tools_filter_slot = function(slot)
{
    t_tools.t_words_option_select ( ccs[slot].words_option          );

    let innerHTML = ccs[slot].mNodeRegexP ? ccs[slot].mNodeRegexP.toString() : t_data.SYMBOL_ELLIPSIS;
    let tooltip   = ccs[slot]             ? ccs[slot]            .toString() : t_data.SYMBOL_ELLIPSIS;
    t_tools.t_words_option_tooltip(innerHTML, tooltip);
};






let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_select"
    , logging : (state) => DOM_SELECT_LOG = t_store_set_state("DOM_SELECT_LOG",state)
    , tagging : (state) => DOM_SELECT_TAG = t_store_set_state("DOM_SELECT_TAG",state)
    , t_select_IMPORT


    , SELECT_SLOT_MAX
    , SEL_CLASS_PREFIX



    , ccs



    , get_touchedWord_range_parent      : () => touchedWord_range_parent
    , get_mStartRange                   : () =>              mStartRange
    , get_mEndRange                     : () =>                mEndRange
    , get_touchedWord_slot              : () =>         touchedWord_slot
    , get_last_highlighted_num          : () =>        last_selected_num

    , check_NodeIterator
    , check_TreeWalker
    , check_childNodes
    , check_tagNodes
    , clear_last_selected_slot
    , get_last_selected_slot
    , get_range_from_XY
    , get_range_from_caret
    , get_slot_num_container
    , get_text_container
    , get_word_at_offset
    , is_a_select_tool
    , remove_pat_span_from_div

    , t_adjust_pat_span_words_option
    , t_check_hasFeature
    , t_clear_slot_all
    , t_collect_el_class_from_into
    , t_escapeREGEX
    , t_get_docker_bag_msg
    , t_get_pat_span_index
    , t_get_pat_span_line
    , t_get_pat_span_with_pattern
    , t_get_slot_num_for_last_highlight_thumb_p
    , t_get_slot_num_next_wrap_to
    , t_get_slot_num_visible_count
    , t_get_slot_num_visible_num
    , t_get_thumb_p_str
    , t_is_accessory_node
    , t_is_node_selected
    , t_is_slot_num_visible
    , t_onPatternUpdate
    , t_onPatternUpdate_no_delay
    , t_onPatternUpdate_quick
    , t_select_clear_slot
    , t_select_get_ccs_length
    , t_select_get_slot_nodes_length
    , t_select_get_slot_num_node
    , t_select_get_slot_num_selected
    , t_select_get_slot_pattern
    , t_select_set_slot_num_selected
    , t_select_switch_from_to_slot
    , t_set_last_selected_slot_num
    , t_slot_visibility_changed
    , t_sync_containers_hi

    , touchedWord
    , touchedWord_adjust

    , slot_visible_num_array_update



    , scroll_thumb_p_to_onSeek_XY
    , t_selection_add_cannot_expand
    , t_selection_del_cannot_expand
    , touchedWord_adjust_2_in_selection_word_bounds
    , get_ccs_slot_num_thumb_p
    , ccs_log
    , ccs_sort_pattern



};


}());


/*INLINE}}}*/
//@ sourceURL=dom_select.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
  /**   15 SLOT     JS dom_slot_js_data .. ESCAPE=[log("%c...found slot #"+slot)] {{{*/
/*
../script/dom_slot.js
*/
let dom_slot_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/









const DOM_SLOT_JS_ID        = "dom_slot_js";
const DOM_SLOT_JS_TAG       = DOM_SLOT_JS_ID  +" (211122:16h:49)";

let dom_slot    = (function() {
"use strict";
let   DOM_SLOT_LOG          = false;
let   DOM_SLOT_TAG          = false;







let t_data     = {}        ;
let t_log      = {}        ;


let t_prop     = {}        ;




let t_select   = {}        ;












let t_tools    = {}        ;


let t_slot_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;


    t_prop    = dom_prop   ;




    t_select  = dom_select ;













    t_tools   = dom_tools  ;


    slot_INTERN();

    DOM_SLOT_LOG = DOM_SLOT_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_SLOT_LOG"));
    DOM_SLOT_TAG = DOM_SLOT_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_SLOT_TAG"));


if(log_this) log("%c 13 slot", lbH+lf8);
};





let LOG_MAP;

let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;

let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let prop;


let   slot_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


    prop                = t_prop;


};








let get_slotted_pattern_count = function()
{

let   caller = "get_slotted_pattern_count";
let log_this = LOG_MAP.S3_SLOT;


    let count = 0;
    let                      ccs_length = t_select.t_select_get_ccs_length();
    for(let slot = 1; slot < ccs_length; ++slot)
    {
        count += (t_select.t_select_get_slot_nodes_length(slot) > 0) ? 1 : 0;
    }
if( log_this) log(caller+": ...return "+count);
    return count;
};


let get_slot_matching_pattern = function(pattern)
{

    let caller = "get_slot_matching_pattern";
let log_this = LOG_MAP.S3_SLOT;

if( log_this) log("%c"+caller+"%c"+pattern, lbL,lbR);


    let ignore_case = prop.get(t_data.WORDS_DROP_CASE);

    pattern = t_tools.t_pattern_del_words_option_sfx( pattern );
    if(ignore_case) pattern = pattern.toLowerCase();

    let slot;
    let slot_pattern;
    try {
        let                  ccs_length = t_select.t_select_get_ccs_length();
        for(slot = 1; slot < ccs_length; ++slot)
        {
            slot_pattern = t_select.t_select_get_slot_pattern(slot);
            if(!slot_pattern) continue;
            slot_pattern = t_tools.t_pattern_del_words_option_sfx( slot_pattern );

            if(ignore_case) slot_pattern = slot_pattern.toLowerCase();

            let matching_pattern; let lfx;
            if     (slot_pattern        ==      pattern  ) { matching_pattern = "SLOT_PATTERN ==       pattern"; lfx = lf5; }
            else if(slot_pattern.includes(      pattern )) { matching_pattern = "SLOT_PATTERN includes pattern"; lfx = lf6; }
            else if(     pattern.includes( slot_pattern )) { matching_pattern = "pattern includes SLOT_PATTERN"; lfx = lf7; }
            if( matching_pattern ) {
if( log_this) log("%c...found slot #"+slot+" .. ("+matching_pattern+")", lfx);
                return slot;
            }

        }
    }
    catch(ex) { log("%c"+caller+"("+pattern+"): slot=["+slot+"]%c"+t_data.LF+"slot_pattern=["+slot_pattern+"]"+t_data.LF+ex, lbH+lf2, lf2); }

if( log_this) log("%c...found no pattern matching current filter", lf8);
    return 0;
};


let get_slot_of_pattern = function(pattern)
{
let   caller = "get_slot_of_pattern("+pattern+")";
let log_this = LOG_MAP.S3_SLOT;

    pattern  = unescape(pattern);
    pattern  = t_tools.t_pattern_del_words_option_sfx(pattern);

    let slot;
    let slot_pattern;
    let                  ccs_length = t_select.t_select_get_ccs_length();
    for(slot = 1; slot < ccs_length; ++slot)
    {
        slot_pattern  = t_select.t_select_get_slot_pattern(slot);
        if(!slot_pattern) continue;

        slot_pattern  = t_tools.t_pattern_del_words_option_sfx(slot_pattern);
        if(  pattern == slot_pattern)
            break;
    }

    if(slot >= ccs_length) slot = 0;

if(log_this) log(caller+": ...return slot=["+slot+"]");
    return slot;
};


let t_set_slot_of_pattern = function(new_slot, pattern)
{
let   caller = "t_set_slot_of_pattern("+new_slot+" ,"+pattern+")";
let log_this = LOG_MAP.S3_SLOT;

    pattern  = unescape(pattern);
    pattern  = t_tools.t_pattern_del_words_option_sfx(pattern);

    let was_slot;
    let slot_pattern;
    let                          ccs_length = t_select.t_select_get_ccs_length();
    for(was_slot = 1; was_slot < ccs_length; ++was_slot)
    {
        slot_pattern  = t_select.t_select_get_slot_pattern(was_slot);
        if(!slot_pattern) continue;
        slot_pattern  = t_tools.t_pattern_del_words_option_sfx(slot_pattern);
        if(  pattern == slot_pattern)
            break;
    }


    if((was_slot < ccs_length) && (was_slot != new_slot))
    {
        t_select.t_select_switch_from_to_slot(was_slot,new_slot);

    }
    else {

if(log_this) log(caller+": nothing to move out from slot #"+new_slot+"");
    }


    return new_slot;
};


let last_cleared_pattern;

let t_clear_slot = function(slot)
{

let   caller = "t_clear_slot";
let log_this = DOM_SLOT_LOG || LOG_MAP.S3_SLOT;




    let ccX       = slot % t_select.SELECT_SLOT_MAX;
    let sel_class = t_select.SEL_CLASS_PREFIX + ccX;
    let selector  = "."+sel_class;
    let sel_list  = document.querySelectorAll( selector );

    let slot_pattern = t_select.t_select_get_slot_pattern(slot);
    if( slot_pattern ) t_tools.t_clear_slot_sync(slot, slot_pattern);

    let cleared_count = 0;
    for(let i = 0; i < sel_list.length; ++i)
    {
        sel_list[i].outerHTML = sel_list[i].innerHTML;
        cleared_count += 1;
    }

if(log_this) log("%c"+caller+"(slot "+slot+")%cpattern=["+slot_pattern+"]%c selector ["+selector+"] %c x"+sel_list.length+"%c"+cleared_count+" cleared"
                 ,lbL+lf7                   ,lbR+lf7                    ,lbL+lf4                   ,lbC+lf4               ,lbR+lf5                     );

    if( slot_pattern ) {
        t_select.t_select_clear_slot(slot);
        last_cleared_pattern = slot_pattern;
    }

    if(cleared_count) {
        t_select.t_sync_containers_hi();
    }

    return cleared_count;
};


let get_prev_populated_slot = function(slot)
{
    let slot_with_nodes = 0;
    for(let i = (slot-1); i > (slot-t_select.SELECT_SLOT_MAX); --i)
    {
        let s = 1+ ((i-1+t_select.SELECT_SLOT_MAX) % t_select.SELECT_SLOT_MAX);
        let l = t_select.t_select_get_slot_nodes_length(s);
        if(l && !slot_with_nodes) slot_with_nodes = s;
    }
    return slot_with_nodes;
};


let get_next_populated_slot = function(slot)
{
    let slot_with_nodes = 0;
    for(let i = (slot+1); i < (slot+t_select.SELECT_SLOT_MAX); ++i)
    {
        let s = 1+ ((i-1+t_select.SELECT_SLOT_MAX) % t_select.SELECT_SLOT_MAX);
        let l = t_select.t_select_get_slot_nodes_length(s);
        if(l && !slot_with_nodes) slot_with_nodes = s;
    }
    return slot_with_nodes;
};





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_slot"
    , logging : (state) => DOM_SLOT_LOG = t_store_set_state("DOM_SLOT_LOG",state)
    , tagging : (state) => DOM_SLOT_TAG = t_store_set_state("DOM_SLOT_TAG",state)
    , t_slot_IMPORT


    , get_last_cleared_pattern : () => last_cleared_pattern


    , get_next_populated_slot
    , get_prev_populated_slot
    , get_slot_matching_pattern
    , get_slot_of_pattern
    , get_slotted_pattern_count
    , t_clear_slot
    , t_set_slot_of_pattern

};

}());

/*INLINE}}}*/
//@ sourceURL=dom_slot.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/

  /**  16 HIDE     JS dom_hide_js_data .. ESCAPE=[log(caller+": %c #"+num)] {{{*/
/*
../script/dom_hide.js
*/
let dom_hide_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/



















const DOM_HIDE_JS_ID        = "dom_hide_js";
const DOM_HIDE_JS_TAG       = DOM_HIDE_JS_ID  +" (211122:16h:43)";

let dom_hide    = (function() {
"use strict";
let   DOM_HIDE_LOG          = false;
let   DOM_HIDE_TAG          = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;
let t_i18n     = {}        ;
let t_prop     = {}        ;
let t_store    = {}        ;
















let t_tools    = {}        ;


let t_hide_IMPORT   = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;
    t_i18n    = dom_i18n   ;
    t_prop    = dom_prop   ;
    t_store   = dom_store  ;

















    t_tools   = dom_tools  ;


    hide_INTERN();

    DOM_HIDE_LOG = DOM_HIDE_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_HIDE_LOG"));
    DOM_HIDE_TAG = DOM_HIDE_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_HIDE_TAG"));


if(log_this) log("%c 14 hide", lbH+lf8);
};




let prop;


let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let   hide_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


    prop = t_prop;


};






const LAST_HIDDEN               = "last_hidden";
const NODE_TO_HIDE_MASK         = "node_to_hide_mask";
const NODE_TO_HIDE_NOT_VISIBLE  = "node_to_hide_not_visible";

let node_to_hide_csv            = "";




const DOM_HIDE_SYNC_UI_DELAY = 500;

let _dom_hide_sync_UI_timer;

let _dom_hide_sync_UI = function()
{
    if(_dom_hide_sync_UI_timer) clearTimeout(_dom_hide_sync_UI_timer);
    _dom_hide_sync_UI_timer   =   setTimeout(_dom_hide_sync_UI_handler, DOM_HIDE_SYNC_UI_DELAY);
};


let _dom_hide_sync_UI_handler = function()
{


    let count = t_util.csv_count(node_to_hide_csv);
    prop.init(t_data.DOM_HIDE1_RESET, (count > 0));

    let el = prop.get_EL(t_data.DOM_HIDE1_RESET);
    if( el )
        el.title
            = t_i18n.i18n_get(t_i18n.DOM_HIDE1_RESET, t_data.DOM_HIDE1_RESET)
            + t_data.LF
            + t_data.LF+ _site_page_or_both_label
            + t_data.LF+"HIDDEN CONTAINERS"
            + t_data.LF+"TO UNHIDE"
    ;

    el = prop.get_EL(t_data.DOM_HIDE1_UNDO);
    if( el )
        el.innerHTML = _dom_hide_node_to_hide_csv_STACK_length();


};




let _dom_hide_clear_display = function()
{

let caller = "_dom_hide_clear_display";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);


    _dom_hide_clear_subtree();

};


let _dom_hide_clear_subtree = function( parent_node=null )
{

let   caller = "_dom_hide_clear_subtree";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c("+t_util.get_node_id_or_tag(parent_node)+")", lbH+lf2);

    let hide_count = _dom_hide_clear_mark_subtree_MARKED_TO_HIDE( parent_node );
    let mask_count = _dom_hide_clear_mark_subtree_mask          ( parent_node );

    let count
        = hide_count
        + mask_count
    ;

    let            msg  = "";
    if(hide_count) msg  = "<em class='cc8'>"+hide_count+" HIDDEN NODES CLEARED</em>";
    if(mask_count) msg += "<em class='cc8'>"+mask_count+" MASKED NODES CLEARED</em>";
    if(!msg)       msg  = "<em class='cc8'>            NO HIDDEN NODES</em>";

    _notify_hide_info( msg );

    return count;
};


let _dom_hide_clear_mark_subtree_MARKED_TO_HIDE = function(parent_node)
{
    let count     = 0;
    let node_hidden_list = document.querySelectorAll("."+t_data.MARKED_TO_HIDE);
    for(let     i = 0; i < node_hidden_list.length; ++i)
    {
        if( parent_node == node_hidden_list[i]) continue;
        let node_hidden  = node_hidden_list[i];
        if(!parent_node || t_util.is_el_or_child_of_parent_el(node_hidden, parent_node))
        {
            _dom_hide_del_node_mask( node_hidden );
            count   += 1;
        }
    }
    return count;
};


let _dom_hide_clear_mark_subtree_mask  = function( parent_node )
{
    let count     = 0;
    let node_mask_list = document.querySelectorAll("."+NODE_TO_HIDE_MASK);
    for(let     i = 0; i < node_mask_list.length; ++i) {
        if( parent_node == node_mask_list[i].node_hidden) continue;
        let    node_mask = node_mask_list[i];
        let  node_hidden = node_mask.node_hidden;

        if(!parent_node || t_util.is_el_or_child_of_parent_el(node_hidden, parent_node))
        {
            _dom_hide_del_node_mask( node_hidden );
            count   += 1;
        }
    }
    return count;
};





let _dom_hide_MARKED_TO_HIDE = function(node, state)
{

let caller = "_dom_hide_MARKED_TO_HIDE";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c(["+t_util.get_node_id_or_tag(node)+"], "+state+")", lbH+lf2);


    if( state ) t_util.add_el_class(node, t_data.MARKED_TO_HIDE);
    else        t_util.del_el_class(node, t_data.MARKED_TO_HIDE);
};



let _dom_hide_is_node_parent_hidden = function( node )
{
    let                     node_hidden_list = document.querySelectorAll("."+t_data.MARKED_TO_HIDE);
    for(let i = 0;      i < node_hidden_list.length; ++i) {
        if( node         == node_hidden_list[i]) continue;
        let parent_hidden = node_hidden_list[i];
        if( t_util.is_el_or_child_of_parent_el(node, parent_hidden) )
            return                            parent_hidden;
    }
    return null;
};


let _dom_hide_set_visibility = function(node, visible)
{

let   caller = "_dom_hide_set_visibility";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c(["+t_util.get_node_id_or_tag(node)+"], "+visible+")", lbH+lf2);




    if(!node) return;
    let mask = node.node_mask;
    if(visible) {
        if(    node.parentElement
           &&  node.parentElement.classList
           &&  node.parentElement.classList.contains( NODE_TO_HIDE_NOT_VISIBLE )
          ) {

            t_util.del_el_class(node.parentElement, NODE_TO_HIDE_NOT_VISIBLE);
        }

t_util.del_el_class(node, NODE_TO_HIDE_NOT_VISIBLE);
        if(mask) t_util.del_el_class(mask, NODE_TO_HIDE_NOT_VISIBLE);


        if(mask) setTimeout(function() { _dom_hide_fit_node_mask(node); }, 100);
    }


    else {
        t_util.add_el_class(node, NODE_TO_HIDE_NOT_VISIBLE);
        if( _dom_hide_all_siblings_hidden( node ) )
        {

            if(node && (node.parentElement != document.body)) t_util.add_el_class(node.parentElement, NODE_TO_HIDE_NOT_VISIBLE);
            if(mask && (mask.parentElement != document.body)) t_util.add_el_class(mask.parentElement, NODE_TO_HIDE_NOT_VISIBLE);
        }
    }



};


let _dom_hide_is_at_xy = function(node, x, y)
{
let caller = "_dom_hide_is_at_xy";

    if(!node.offsetTop              ) return false;
    if( node.style.display == "none") return false;

    let    xy = t_util.get_el_xy(node, caller);
    let result
        =  (x > xy.x)
        && (x < (xy.x + node.offsetWidth ))
        && (y > xy.y)
        && (y < (xy.y + node.offsetHeight))
    ;

    return result;
};





let _node_mask_div;


let _dom_hide_add_node_mask = function( node )
{

let   caller = "_dom_hide_add_node_mask";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c("+t_util.get_node_id_or_tag(node)+")", lbH+lf2);


    if(!_node_mask_div )
    {
        _node_mask_div           = document.createElement("div");
        _node_mask_div.className = NODE_TO_HIDE_MASK;
    }


    let node_mask         = _node_mask_div.cloneNode(true);
    node_mask.innerText   = _dom_hide_get_body_hop_count(node);
    node_mask.title       = t_util.get_parentage(node);
    node_mask.node_hidden = node;

    document.body.insertBefore(node_mask, document.lastChild.nextSibling);

    node     .node_mask   = node_mask;
    t_util.add_el_class(node, "has_node_mask");

    _dom_hide_fit_node_mask( node );

};


let _dom_hide_get_body_hop_count = function(node)
{
    let hop = 0;
    while(        node
              && (node != document.body)
              && (node != document.documentElement)
         ) {
        node            = node.parentNode;
        hop             = hop + 1;
    }

    return hop;
};


let _dom_hide_fit_node_mask = function( node )
{

let   caller = "_dom_hide_fit_node_mask";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c("+t_util.get_node_id_or_tag(node)+")", lbH+lf2);

    if( t_util.has_el_class(node.parentElement, NODE_TO_HIDE_NOT_VISIBLE) ) t_util.del_el_class(node.parentElement, NODE_TO_HIDE_NOT_VISIBLE);
    if( t_util.has_el_class(node              , NODE_TO_HIDE_NOT_VISIBLE) ) t_util.del_el_class(node              , NODE_TO_HIDE_NOT_VISIBLE);

    let  xy = t_util.get_el_xy(   node);
    let e_W = Math.max(16, node.scrollWidth  || node.offsetWidth );
    let e_H = Math.max(16, node.scrollHeight || node.offsetHeight);

    if( node.node_mask)
    {
        node.node_mask.style.left         =     xy.x +"px";
        node.node_mask.style.top          =     xy.y +"px";
        node.node_mask.style.width        =     e_W  +"px";
        node.node_mask.style.height       =     e_H  +"px";

        node.node_mask.style.zIndex       = 1 + node.style.zIndex;
        node.node_mask.style.borderRadius = parseInt(window.getComputedStyle(node).borderRadius) +"px";
    }

};


let _dom_hide_del_node_mask = function( node )
{

let   caller = "_dom_hide_del_node_mask";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c("+t_util.get_node_id_or_tag(node)+")", lbH+lf2);


    if( node.node_mask )
    {
        document.body.removeChild( node.node_mask );
        node.node_mask = null;
        t_util.del_el_class(node, "has_node_mask");
    }


    t_util.del_el_class            (node, t_data.MARKED_TO_HIDE);
    _dom_hide_set_visibility(node, true);


};


let _dom_hide_is_node_parent_masked = function( node )
{
    let                     node_mask_list = document.querySelectorAll("."+NODE_TO_HIDE_MASK);
    for(let i = 0;      i < node_mask_list.length; ++i) {
        if( node         == node_mask_list[i].node_hidden) continue;
        let parent_hidden = node_mask_list[i].node_hidden;
        if( t_util.is_el_or_child_of_parent_el(node, parent_hidden) )
            return                            parent_hidden;
    }
    return null;
};




let _dom_hide_add_csv = function( node )
{

let   caller = "_dom_hide_add_csv";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c("+t_util.get_node_id_or_tag(node)+")", lbH+lf2);


    let node_parent
        =  _dom_hide_is_node_parent_hidden( node )
        || _dom_hide_is_node_parent_masked( node )
    ;
    if( node_parent )
    {
        _notify_hide_info("<em class='cc9'>"+ t_util.get_node_id_or_tag(node)          +"</em>"
                   +      "<em class='cc8'>   already hidden by                        </em>"
                   +      "<em class='cc9'>"+ t_util.get_node_id_or_tag( node_parent ) +"</em>"
                 );

        return false;
    }


    let node_path = t_util.get_node_path( node );
if(log_this) log("...node_path=["+node_path+"]");



    if( t_util.csv_contains(node_to_hide_csv, node_path))
    {
        return false;
    }


    _dom_hide_csv_stack_push("BEFORE ADD");



    node_to_hide_csv = t_util.csv_add(node_to_hide_csv, node_path);
if(log_this) _dom_hide_csv_dump();



    dom_hide2_store_save();

    return true;

};


let _dom_hide_del_csv = function( node )
{

let caller = "_dom_hide_del_csv";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c("+t_util.get_node_id_or_tag(node)+")", lbH+lf2);


    let node_path = t_util.get_node_path( node );
if(log_this) log("...node_path=["+node_path+"]");



    if(!t_util.csv_contains(node_to_hide_csv, node_path))
    {
        return false;
    }


    _dom_hide_csv_stack_push("BEFORE DEL");



    node_to_hide_csv     = t_util.csv_del(node_to_hide_csv, node_path);
if(log_this) _dom_hide_csv_dump();



    dom_hide2_store_save();

    return true;

};


let _dom_hide_clear_csv_and_store = function()
{

let caller = "_dom_hide_clear_csv_and_store";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);


    node_to_hide_csv      = "";

    loaded_site_csv_count = 0;
    loaded_page_csv_count = 0;


    dom_hide2_store_save();


};


let _dom_hide_rebuild_csv_from_hidden_and_masked_nodes = function() {

let caller = "_dom_hide_rebuild_csv_from_hidden_and_masked_nodes";
let log_this = LOG_MAP.T3_LAYOUT;
if( log_this) log(caller);


    _dom_hide_clear_csv_and_store();



    let hidden_count = 0;
    let                      node_hidden_list = document.querySelectorAll("."+t_data.MARKED_TO_HIDE);
    for(let i = 0;      i <  node_hidden_list.length; ++i) {
        let node_hidden   =  node_hidden_list[i];
        let     node_path = t_util.get_node_path( node_hidden );
if(log_this) log("...node_path=["+node_path+"]");
        node_to_hide_csv = t_util.csv_add(node_to_hide_csv, node_path);
        hidden_count += 1;
    }
if(log_this) log("...hidden_count=["+hidden_count+"]");



    let masked_count = 0;
    let                      node_mask_list = document.querySelectorAll("."+NODE_TO_HIDE_MASK);
    for(let i = 0;      i <  node_mask_list.length; ++i) {
        let node_hidden   =  node_mask_list[i].node_hidden;
        let     node_path = t_util.get_node_path( node_hidden );
if(log_this) log("...node_path=["+node_path+"]");
        node_to_hide_csv  = t_util.csv_add(node_to_hide_csv, node_path);
        masked_count += 1;
    }
if(log_this) log("...masked_count=["+masked_count+"]");



    dom_hide2_store_save();


if(log_this) _dom_hide_csv_dump();
};




let _dom_hide_csv_dump = function()
{
    if(!node_to_hide_csv) return;

    let node_to_hide_csv_array = node_to_hide_csv.split(",");
    for(let n_num = 1; n_num  <= node_to_hide_csv_array.length; ++n_num)
    {
        let     node_path = node_to_hide_csv_array[n_num-1];

        t_util.get_node_path_target(node_path, n_num);
    }
};






let dom_hide1_container_clicked = function(container,hide_parent)
{

let   caller = "dom_hide1_container_clicked"; if(typeof playground_notify != "undefined") playground_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c"+t_util.get_node_id_or_tag(container)+"%c hide_parent "+hide_parent, lbL+lf2, lbR+lfX[hide_parent ? 3:8]);
    if(!container) return;


    let          hiding = !prop.get( t_data.MASK_OR_HIDE );
    let     node_hidden = _dom_hide_mark_container( container );
    while(  node_hidden && (node_hidden != document.body))
    {
        if( hide_parent ) {
            _dom_hide_history_freeze(true, caller);

            for(let num = 0; num   < node_hidden.parentElement.children.length; ++num) {
                let el  = node_hidden.parentElement.children[num];
                if( el != node_hidden)
                    _dom_hide_mark_container( el );
            }

            _dom_hide_history_freeze(false);
        }

        if( _dom_hide_all_siblings_hidden( node_hidden ) )
        {
            node_hidden = _dom_hide_mark_container( node_hidden.parentElement );
            if( hide_parent ) break;
        }
        else {
            if( hiding )  _dom_hide_set_visibility( node_hidden,  true);
            break;
        }
    }
};



let  children_collection = [];


let dom_hide1_collect_nodes = function(child_level, _parent, parent_level)
{

let   caller = "dom_hide1_collect_nodes(child_level=["+child_level+"], _parent=["+t_util.get_n_lbl(_parent)+"], parent_level=["+parent_level+"])";
let log_this = LOG_MAP.T3_LAYOUT;



    let parent = _parent;
    if(!parent || (parent == document.body)) {
        children_collection = [];
        parent              = document.body;
        parent_level        = 0;
    }


    let child_collected_count = 0;
    for(let num=0; num < parent.children.length; ++num)
    {
        let child = parent.children[num];

        if(parent_level == (child_level-1))
        {
            if( _dom_hide_is_node_maskable(child, num) )
            {
                children_collection.push( child );
                child_collected_count += 1;
            }
        }

        else
            dom_hide1_collect_nodes(child_level,  child, parent_level+1);

    }


if(log_this && (parent_level == (child_level-1)) && parent.children.length)
    log(caller+": %c level"+child_level+" %c"+t_util.get_parentage(parent)+" %c "+ child_collected_count +" children"
        ,        lbH                     ,lbL+lf9                    ,lbR+lf7);

if(log_this && (parent == document.body))
    log("%c "+children_collection.length+" %c level "+child_level+" nodes"
        ,lbH+lbb+lf7                      ,lbH+lf7);


    _dom_hide_add_children_collection();

};


let _dom_hide_is_node_maskable = function(node, num)
{

let   caller = "_dom_hide_is_node_maskable";
let log_this = LOG_MAP.T3_LAYOUT;


    let                                                    not_maskable = "";                    let lfx =  "";
    if(                             !node.clientWidth  ) { not_maskable = "HAS NO WIDTH";            lfx = lf5; }
    if(                             !node.clientHeight ) { not_maskable = "HAS NO HEIGHT";           lfx = lf6; }
    if( t_util.is_a_doc_tool_panel ( node )            ) { not_maskable = "IS A DOC TOOL PANEL";     lfx = lf3; }
    if( t_util.is_a_doc_tool_button( node )            ) { not_maskable = "IS A DOC TOOL BUTTON";    lfx = lf4; }

    let result = (not_maskable == "");
if(log_this && !result) log(caller+": %c #"+num+" %c"+t_util.get_parentage(node)+"%c"+not_maskable
    ,                                 lbL+lf2    ,lbC+lf9                 ,lbR+lfx         );
    return (not_maskable == "");
};


let _dom_hide_add_children_collection = function()
{

let   caller = "_dom_hide_add_children_collection";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+": "+children_collection.length+" nodes");

    _dom_hide_history_freeze(true, caller);

    for(let i=children_collection.length-1; i >= 0                         ; --i) dom_hide1_container_clicked(children_collection[i]);

    _dom_hide_history_freeze(false);
    _dom_hide_csv_stack_push("AFTER _dom_hide_add_children_collection");
};


let dom_hide1_reset = function()
{

let   caller = "dom_hide1_reset"; if(typeof playground_notify != "undefined") playground_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) console.trace();


    _dom_hide_csv_stack_clear_history();
    _dom_hide_clear_csv_and_store();
    _dom_hide_clear_display();

    _site_page_or_both_label
        = "ALL RESET"
    ;
    _dom_hide_sync_UI();
};


let _dom_hide_all_siblings_hidden = function( node )
{
    if( !node                                ) return false;
    if( !node.parentElement                  ) return false;
    if(  node               == document.body ) return false;
    if(  node.parentElement == document.body ) return false;

    let all_siblings_hidden = true;
    for(let i=0;    i < node.parentElement.childNodes.length; ++i)
    {
        let     child = node.parentElement.childNodes[i];
        if(    !child.classList ) continue;

        if(    !child.classList.contains( NODE_TO_HIDE_NOT_VISIBLE )
            && !child.node_mask
          ) {
            all_siblings_hidden = false;
            break;
        }
    }


    return all_siblings_hidden;
};


let _dom_hide_mark_container = function(container,toggle_marked=true)
{

let   caller = "_dom_hide_mark_container";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"%c("+t_util.get_node_id_or_tag(container)+")", lbH+lf2);



    let node_hidden
        = container.node_hidden ? container.node_hidden
        : container.node_mask   ? container
        :                         container
    ;
if(log_this) t_log.console_dir("node_hidden", node_hidden);

    let node_mask
        = container.node_hidden ? container
        : container.node_mask   ? container.node_mask
        :                         null
    ;

if(log_this) t_log.console_dir("node_mask", node_mask);



    if( !node_mask ) {
if( log_this) log("...NO  MASK .. ADD ONE");

        if( !_dom_hide_add_csv ( node_hidden )) return null;



        _dom_hide_add_node_mask( node_hidden );

        let hiding = !prop.get( t_data.MASK_OR_HIDE );
        if( hiding ) {
            _dom_hide_set_visibility(node_hidden, false);
        }


        if( _dom_hide_clear_subtree( node_hidden ) )
        {

            _dom_hide_rebuild_csv_from_hidden_and_masked_nodes();

            let count = t_util.csv_count( node_to_hide_csv );
            let em_class = count ? "cc"+(count % 10) : "done cc9";
            _notify_hide_info("<em class='"+em_class+"'>"+(count || "NO")+" HIDDEN SUBTREE NODES</em> <em class='cc2'>SUBTREE REBUILT</em>");
        }
        else {
            let count = t_util.csv_count( node_to_hide_csv );
            let em_class = count ? "cc"+(count % 10) : "done cc9";
            _notify_hide_info("<em class='"+em_class+"'>"+(count || "NO")+" NODES MARKED TO HIDE</em>");
        }

    }


    else if( toggle_marked ) {
if( log_this) log("...HAS MASK .. REMOVE IT");
        if( t_util.has_el_class(node_hidden, LAST_HIDDEN) )
        {
if( log_this) log("...t_util.has_el_class(node_hidden, LAST_HIDDEN)");
            t_util.del_el_class(node_hidden, LAST_HIDDEN);

            _dom_hide_del_node_mask( node_hidden );



            dom_hide_csv_stack_pop("REMOVING LAST_HIDDEN");
        }
        else {

            _dom_hide_del_node_mask( node_hidden );



            _dom_hide_del_csv      ( node_hidden );


        }
        let count = t_util.csv_count( node_to_hide_csv );
        let em_class = count ? "cc"+(count % 10) : "done cc9";
        _notify_hide_info("<em class='"+em_class+"'>"+(count || "NO")+" NODES MARKED TO HIDE</em>");
    }


    _dom_hide_highlight_last_hidden();



    _dom_hide_sync_UI();
    return node_hidden;
};


let get_node_hidden_parentElement = function(container)
{
    return container
        && container.node_hidden
        && container.node_hidden.parentElement
        ?  container.node_hidden.parentElement
        :  null
    ;
};







let dom_hide2_store_reload = function(site_or_page_or_both="both")
{

let   caller = "dom_hide2_store_reload"; if(typeof playground_notify != "undefined") playground_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"("+site_or_page_or_both+")", lbH+lf2);


    _dom_hide_clear_display();

    _dom_hide_localStorage_load( site_or_page_or_both );

};


let dom_hide2_store_save = function()
{

let   caller = "dom_hide2_store_save"; if(typeof playground_notify != "undefined") playground_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);


    let key
        = prop.get( t_data.SITE_OR_PAGE )
        ? "site_node_to_hide_arr"
        : "page_node_to_hide_arr";

    let arr_JSON =         node_to_hide_csv
        ?   JSON.stringify(node_to_hide_csv.split(","))
        :   ""
    ;
    _notify_hide_store(key, arr_JSON);


};



let loaded_site_csv_count    = 0;
let loaded_page_csv_count    = 0;

let _site_page_or_both_label = "";

let _dom_hide_localStorage_load = function(site_or_page_or_both)
{

let   caller = "_dom_hide_localStorage_load("+site_or_page_or_both+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);


    let site_csv   = "";
    let site_label = "";
    if((site_or_page_or_both == "site") || (site_or_page_or_both == "both"))
    {
        let    key = "site_node_to_hide_arr";
        let    arr = t_store.t_store_getItem(key, "site"); site_csv = (arr == null) ? "" : JSON.parse(arr).join(",");

        loaded_site_csv_count =  t_util.csv_count(site_csv);
        site_label = (site_csv ? loaded_site_csv_count : "NO")+" SITE";
    }


    let page_csv   = "";
    let page_label = "";
    if((site_or_page_or_both == "page") || (site_or_page_or_both == "both"))
    {
        let    key = "page_node_to_hide_arr";
        let    arr = t_store.t_store_getItem(key, "page"); page_csv = (arr == null) ? "" : JSON.parse(arr).join(",");

        loaded_page_csv_count =  t_util.csv_count(page_csv);
        page_label = (page_csv ? loaded_page_csv_count : "NO")+" PAGE";
    }



    if((site_or_page_or_both == "site"))
    {
        node_to_hide_csv =  site_csv;

if(log_this) t_util.csv_log(node_to_hide_csv, "SITE");
    }
    else if((site_or_page_or_both == "page"))
    {
        node_to_hide_csv = page_csv;

if(log_this) t_util.csv_log(node_to_hide_csv, "PAGE");
    }
    else {
        node_to_hide_csv = page_csv;

        let csv_array =  site_csv.split(",");
        site_label    = (site_csv ? t_util.csv_count(site_csv) : "NO")+" SITE";

        for(let i = csv_array.length-1; i >= 0; --i)
            node_to_hide_csv = t_util.csv_ins(node_to_hide_csv, csv_array[i]);
    }
if(log_this) t_util.csv_log(node_to_hide_csv, "CURRENT");


    _site_page_or_both_label
        = (site_label && page_label) ? (site_label+" and "+page_label)
        :                site_label  ?  site_label
        :                page_label  ?  page_label
        : ""
    ;
    _dom_hide_sync_UI();
};







let dom_hide3_set_MASK_OR_HIDE = function(_hiding)
{

let   caller = "dom_hide3_set_MASK_OR_HIDE"; if(typeof playground_notify != "undefined") playground_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;



    let hiding = _hiding || !prop.get( t_data.MASK_OR_HIDE );
if( log_this) log("%c HIDE OR MASK %c "+(hiding ? "HIDE" : "MASK"), lbL, lbR);

if( log_this) t_util.csv_log(node_to_hide_csv, "node_to_hide_csv");

    let invisible_count = 0;
    if(                         !node_to_hide_csv       ) return;
    let                          node_to_hide_csv_array = node_to_hide_csv.split(",");
    for(let n_num = 1; n_num <=  node_to_hide_csv_array.length; ++n_num)
    {
        let node_path         =  node_to_hide_csv_array[n_num-1];
        let node              = t_util.get_node_path_target(node_path, n_num);
        if( node ) {
            if( hiding ) {
                _dom_hide_MARKED_TO_HIDE                   ( node,  true);
                _dom_hide_set_visibility                   ( node, false); ++invisible_count;
            }
            else {
                if(!node.node_mask) _dom_hide_add_node_mask( node );
                else                _dom_hide_fit_node_mask( node );
                _dom_hide_set_visibility(                    node, true);
            }
        }
    }


    let       hidden_count = document.querySelectorAll("."+t_data.MARKED_TO_HIDE   ).length;
    let       masked_count = document.querySelectorAll("."+NODE_TO_HIDE_MASK).length;
    let              count = t_util.csv_count(node_to_hide_csv);
    let                ccx = hiding ? 7 : 2;
    let  hiding_or_masking = hiding ? "HIDING" : "MASKING";

    _notify_hide_info(            " <em class='cc"+ccx         +"'>"+ hiding_or_masking            +      "</em>"
                      +           " <em class='cc"+(count % 10)+"'>"+ (count || "No")              +" Nodes</em>"
                      + (!hidden_count    ? "" : " <em class='cc9'>hidden_count="+ hidden_count    +      "</em>")
                      + (!masked_count    ? "" : " <em class='cc9'>masked_count="+ masked_count    +      "</em>")
                      + (!invisible_count ? "" : " <em class='cc0'> not visible="+ invisible_count +      "</em>")
                     );



    if(!hiding )
        _dom_hide_highlight_last_hidden();


};







const SCROLL_TO_LAST_HIDDEN_DELAY =  250;

let _dom_hide_scroll_to_last_hidden_timer;
let _dom_hide_scroll_to_last_hidden_DONE_MS;
let _dom_hide_scroll_to_last_hidden_el;



let dom_hide4_scroll_to_last_hidden = function( node )
{

let   caller = "dom_hide4_scroll_to_last_hidden"; if(typeof playground_notify != "undefined") playground_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

    _dom_hide_scroll_to_last_hidden_el = node;

    if(      _dom_hide_scroll_to_last_hidden_timer ) clearTimeout(_dom_hide_scroll_to_last_hidden_timer);

    if(node) _dom_hide_scroll_to_last_hidden_timer  =  setTimeout(_dom_hide_scroll_to_last_hidden_handler, SCROLL_TO_LAST_HIDDEN_DELAY);
    else     _dom_hide_scroll_to_last_hidden_timer  = null;
};


let dom_hide4_scroll_to_last_hidden_is_pending = function()
{
    return (_dom_hide_scroll_to_last_hidden_timer != null);
};


let dom_hide4_scroll_to_last_hidden_handled_recently = function(delay)
{
    if(_dom_hide_scroll_to_last_hidden_DONE_MS == 0)
        return false;

    let           this_MS = new Date().getTime();
    let elapsed = this_MS - _dom_hide_scroll_to_last_hidden_DONE_MS;

    _dom_hide_scroll_to_last_hidden_DONE_MS = 0;



    return (elapsed < delay);
};


let _dom_hide_scroll_to_last_hidden_handler = function()
{
    _dom_hide_scroll_to_last_hidden_timer   = null;

    _dom_hide_scroll_to_last_hidden_DONE_MS = new Date().getTime();

    let xy = t_tools.t_scrollIntoViewIfNeeded_get_scrollXY_with_margin( _dom_hide_scroll_to_last_hidden_el );
    if( xy ) {
        let dx = (xy.x - window.scrollX);
        let dy = (xy.y - window.scrollY);
        if(dx || dy) t_tools.t_window_scrollTo(xy.x, xy.y);
    }
};







let dom_hide5_history_start = function()
{

let   caller = "dom_hide5_history_start"; if(typeof playground_notify != "undefined") playground_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

if( log_this) t_util.csv_log(node_to_hide_csv, "REBUILDING STACK HISTORY FROM node_to_hide_csv:");

    _dom_hide_csv_stack_clear_history();

    let        count      = t_util.csv_count( node_to_hide_csv );
    let      tmp_csv      =                   node_to_hide_csv;
    node_to_hide_csv      =                   "";
    for(let step=1; step <= count; ++step)
    {
        let    node_path  = t_util.csv_get(         tmp_csv, step);
        node_to_hide_csv  = t_util.csv_add(node_to_hide_csv, node_path);

        if(step < count)
            _dom_hide_csv_stack_push("INIT");
    }
if( log_this) t_util.csv_log(node_to_hide_csv, "REBUILT STACK HISTORY");


    _dom_hide_sync_UI();
};


let _dom_hide_history_freeze_caller;
let _dom_hide_history_freeze = function(state, caller)
{
    if(state) _dom_hide_history_freeze_caller = caller;
    else      _dom_hide_history_freeze_caller =     "";
};


let node_to_hide_csv_STACK = [];



let _dom_hide_csv_stack_clear_history = function()
{
    node_to_hide_csv_STACK = [];
};


let _dom_hide_csv_stack_push = function(reason)
{

let caller = "_dom_hide_csv_stack_push";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"(%c "+reason+"):"
                  ,lbH         ,lbL+lf3);


    if( _dom_hide_history_freeze_caller )
    {

if( log_this) log("...%c HISTORY FREEZED BY "+ _dom_hide_history_freeze_caller, lbH+lf8);
    }
    else if(    (                       node_to_hide_csv_STACK.length > 0)
             && (node_to_hide_csv_STACK[node_to_hide_csv_STACK.length - 1] == node_to_hide_csv))
    {

if( log_this) log("...%c ALREADY ON TOP OF STACK", lbH+lf3);
    }
    else {
        node_to_hide_csv_STACK.push( node_to_hide_csv );

if( log_this) t_util.csv_log(node_to_hide_csv,t_util.csv_count(node_to_hide_csv)+" NODES PUSHED ON TOP OF STACK");
    }

};


let dom_hide_csv_stack_pop = function(_caller)
{

let caller = "dom_hide_csv_stack_pop";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+" %c "+_caller, lbL+lf3,lbR+lf3);



    let popped_csv = node_to_hide_csv_STACK.pop() || "";

    if(popped_csv) {

if(log_this) {
    let from_count = t_util.csv_count(node_to_hide_csv       );
    let   to_count = t_util.csv_count(popped_csv             );
    log("%c HISTORY BACK (from "+from_count+" to "+to_count+")", lbH+lfX[from_count % 10]);
}

        node_to_hide_csv = popped_csv;
    }
    else {
        if( t_util.csv_count(node_to_hide_csv) ) {

if(log_this) {
    let from_count = t_util.csv_count(node_to_hide_csv       );
    log("%c DROPPING LAST (from "+from_count+")", lbH+lfX[from_count % 10]);
}

            node_to_hide_csv = t_util.csv_del_last(node_to_hide_csv);
        }
        else {

if(log_this) {
    log("%c HISTORY IS EMPTY", lbH+lf8);
}

        }
    }



    dom_hide2_store_save();



    _dom_hide_highlight_last_hidden();


    _dom_hide_sync_UI();
};


let _dom_hide_node_to_hide_csv_STACK_length = function()
{
    return node_to_hide_csv_STACK.length;
};







let hide_container_observers = [];


let dom_hide6_add_container_observer = function(observer)
{

    if(!hide_container_observers.includes( observer ))
        hide_container_observers.push    ( observer );
};
let _notify_hide_container = function(container, _caller, msg)
{

    for(let i=0; i < hide_container_observers.length; ++i)
        hide_container_observers[i](container, _caller, msg);
};



let hide_t_store_set_value_observers = [];


let dom_hide6_add_t_store_set_value_observer = function(observer)
{

    if(!hide_t_store_set_value_observers.includes( observer ))
        hide_t_store_set_value_observers.push    ( observer );
};
let _notify_hide_store = function(key,value)
{

    for(let i=0; i < hide_t_store_set_value_observers.length; ++i)
        hide_t_store_set_value_observers[i](key, value);
};



let hide_info_observers = [];


let dom_hide6_add_info_observer = function(observer)
{

    if(!hide_info_observers.includes( observer ))
        hide_info_observers.push    ( observer );
};
let _notify_hide_info = function(info)
{

    let caller = "node_to_hide_csv("+info+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

    for(let i=0; i < hide_info_observers.length; ++i)
        hide_info_observers[i](info);
};








let _transcript = null;
let last_logged_node_to_hide_csv;
let last_log_was_site_or_page;

let missing_transcript_notified_once;

let dom_hide_log_settings = function()
{


    if( _transcript == null) _transcript = document.getElementById("dom_hide_log");
    if(!_transcript) {
        if( !missing_transcript_notified_once) {
logBIG("HTML HAS NO [dom_hide_log] TRANSCRIPT TO LOG TO", lbH+lf3);
            missing_transcript_notified_once = true;
        }
        return;
    }


    let    this_log_is_site_or_page      = prop.get(   t_data.SITE_OR_PAGE);
    if(   (last_log_was_site_or_page    == this_log_is_site_or_page)
       && (last_logged_node_to_hide_csv == node_to_hide_csv)
      ) return;



    let children_collection_length    = children_collection.length;
    let csv_count_node_to_hide_csv    = t_util.csv_count( node_to_hide_csv );
    let node_to_hide_csv_stack_length = _dom_hide_node_to_hide_csv_STACK_length();


    let firstElementChild = _transcript.firstElementChild;
    let             scope = this_log_is_site_or_page ? "SITE" : "PAGE";
    let               ccX = this_log_is_site_or_page ? "cc2"  :  "cc6";

    _transcript.innerHTML
        = "<em class='big "+ccX+"'>"+ scope + "</em><br>"
        + "COLLECTION    <em class='big cc8'>"+ children_collection_length    +"</em><br>"
        + "NODES TO HIDE <em class='big cc9'>"+ csv_count_node_to_hide_csv    +"</em><br>"
        + "HISTORY       <em class='big cc7'>"+ node_to_hide_csv_stack_length +"</em><br>"
        + _dom_hide_csv_to_html( node_to_hide_csv )
    ;


    if(       firstElementChild
       && (   firstElementChild.classList.contains( t_tools.CSS_CLEARPIN )
           || firstElementChild.classList.contains( t_tools.CSS_CLOSEPIN )
           || firstElementChild.classList.contains( t_tools.CSS_PUSH_PIN )
           || firstElementChild.classList.contains( t_tools.CSS_SCALEPIN )
           || firstElementChild.classList.contains("toolbag_button")
         )
      )
        _transcript.insertBefore(firstElementChild, _transcript.firstElementChild);

    last_logged_node_to_hide_csv = node_to_hide_csv;
    last_log_was_site_or_page    = this_log_is_site_or_page;
};


let _dom_hide_csv_to_html = function(csv)
{
    if(!csv) return "";

    let html = "<em class='cc9'>PARENT</em> <em class='cc0 sup'>child-num</em> <em class='cc9'>CHILD</em><br>";

    let            nodes = csv.split(",");
    for(let i=0; i < nodes.length; ++i)
    {
        let path    = "";
        let indent  = "";
        let p_count =  1;
        let            steps = nodes[i].split("|");
        for(let j=0; j < steps.length; ++j)
        {
            let num_child_parent = steps[j].split(" ");
            let              num = num_child_parent[0];
            let            child = num_child_parent[1];
            let           parent = num_child_parent[3];
            path += indent
                +   "<em class='cc"+(  p_count)+"'>"+ parent +"</em><em class='sup cc"+(num % 10)+"'>"+num+"</em>"
                +  " <em class='cc"+(++p_count)+"'>"+ child  +"</em>"
                +  "<br>"+t_data.LF
            ;
            indent += t_data.SYMBOL_RIGHT_ARROW;
        }
        html += path+"<br>";
    }

    return html;
};








const NODE_TO_HIDE_HIGHLIGHT_LAST_HIDDEN_DELAY = 500;

let _dom_hide_highlight_last_hidden_timer;

let _dom_hide_highlight_last_hidden = function()
{

let caller = "_dom_hide_highlight_last_hidden";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

    if(_dom_hide_highlight_last_hidden_timer) clearTimeout(_dom_hide_highlight_last_hidden_timer);
    _dom_hide_highlight_last_hidden_timer   =   setTimeout(_dom_hide_highlight_last_hidden_handler, NODE_TO_HIDE_HIGHLIGHT_LAST_HIDDEN_DELAY);
};


let _dom_hide_highlight_last_hidden_handler = function()
{

let caller = "_dom_hide_highlight_last_hidden_handler";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

    _dom_hide_highlight_last_hidden_timer = null;
    let         count = t_util.csv_count( node_to_hide_csv );

    if(count < 1) return;


    let node_list = document.querySelectorAll("."+LAST_HIDDEN);
    for(let i=0; i < node_list.length; ++i)
        t_util.del_el_class(node_list[i], LAST_HIDDEN);

    let     node_path = t_util.csv_get(node_to_hide_csv, count);

    let          node = t_util.get_node_path_target(node_path);
    if(!node) return;


    t_util.add_el_class(node          , LAST_HIDDEN);
    t_util.add_el_class(node.node_mask, LAST_HIDDEN);


    _notify_hide_container(node, caller, "LAST HIDDEN "+t_util.get_id_or_tag(node));
};






let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name    : "dom_hide"
    ,    logging : (state) => DOM_HIDE_LOG = t_store_set_state("DOM_HIDE_LOG",state)
    ,    tagging : (state) => DOM_HIDE_TAG = t_store_set_state("DOM_HIDE_TAG",state)
    ,    t_hide_IMPORT


    ,    dom_hide1_collect_nodes
    ,    dom_hide1_container_clicked
    ,    dom_hide1_reset


    ,    dom_hide2_store_reload
    ,    dom_hide2_store_save


    ,    dom_hide3_set_MASK_OR_HIDE


    ,    dom_hide4_scroll_to_last_hidden
    ,    dom_hide4_scroll_to_last_hidden_handled_recently
    ,    dom_hide4_scroll_to_last_hidden_is_pending


    ,    dom_hide5_history_start
    ,    dom_hide_csv_stack_pop


    ,    dom_hide6_add_container_observer
    ,    dom_hide6_add_info_observer
    ,    dom_hide6_add_t_store_set_value_observer


    ,    dom_hide_log_settings


    ,    get_node_hidden_parentElement
    ,    get_node_to_hide_csv_count : ()   => loaded_site_csv_count + loaded_page_csv_count


    , _dom_hide_sync_UI
    , _dom_hide_csv_stack_clear_history

};



}());

/*INLINE}}}*/
//@ sourceURL=dom_hide.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
/**   17 VIEW     JS dom_view_js_data {{{*/
/*
../script/dom_view.js
*/
let dom_view_js_data ="data:text/javascript;charset='utf-8',"+ `
/*INLINE{{{*/





















const DOM_VIEW_JS_ID        = "dom_view_js";
const DOM_VIEW_JS_TAG       = DOM_VIEW_JS_ID  +" (211122:16h:57)";

let dom_view    = (function() {
"use strict";
let   DOM_VIEW_LOG          = false;
let   DOM_VIEW_TAG          = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;
let t_i18n     = {}        ;
let t_prop     = {}        ;










let t_seek     = {}        ;






let t_tools    = {}        ;


let t_view_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;
    t_i18n    = dom_i18n   ;
    t_prop    = dom_prop   ;











    t_seek    = dom_seek   ;






    t_tools   = dom_tools  ;


    view_INTERN();

    DOM_VIEW_LOG = DOM_VIEW_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_VIEW_LOG"));
    DOM_VIEW_TAG = DOM_VIEW_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_VIEW_TAG"));


if(log_this) log("%c 15 view", lbH+lf8);
};





let LOG_MAP;

let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;

let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;
let log_label_URDL;
let console_dir;


let prop;


let   view_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;

    log_label_URDL      = t_log.log_label_URDL;
    console_dir         = t_log.console_dir;


    prop                = t_prop;

};





let t_view1_is_el_in_viewport = function(el)
{
    let xy = t_util.get_el_xy(el);
    return t_view1_is_xy_in_viewport(xy.x, xy.y);
};


let t_view1_is_el_topLeft_or_bottomRight_in_viewport = function(el)
{
    let xy = t_util.get_el_xy(el);

    let tl_in_viewport = t_view1_is_xy_in_viewport(xy.x, xy.y);

    xy.x += el.clientWidth;
    xy.y += el.clientHeight;
    let br_in_viewport = t_view1_is_xy_in_viewport(xy.x, xy.y);

    return tl_in_viewport || br_in_viewport;
};




let t_view1_is_xy_in_viewport = function(x,y)
{

    x = Math.floor(x);
    y = Math.floor(y);

    let x_min         =       window.scrollX;
    let y_min         =       window.scrollY;
    let x_max         =       window.scrollX + window.innerWidth ;
    let y_max         =       window.scrollY + window.innerHeight;

    let x_IN_viewport = (x >= x_min) && (x <= x_max);
    let y_IN_viewport = (y >= y_min) && (y <= y_max);




    return x_IN_viewport && y_IN_viewport;
};



let t_view2_is_xy_near_viewport = function(x,y)
{

    x = Math.floor(x);
    y = Math.floor(y);

    let x_min         =       window.scrollX - window.innerWidth     ;
    let y_min         =       window.scrollY - window.innerHeight    ;
    let x_max         =       window.scrollX + window.innerWidth  * 2;
    let y_max         =       window.scrollY + window.innerHeight * 2;
    let x_nearviewport = (x >= x_min) && (x <= x_max);
    let y_nearviewport = (y >= y_min) && (y <= y_max);




    return x_nearviewport && y_nearviewport;
};



let t_view3_move_panel_BORDERING = function(panel, x=panel.offsetLeft, y=panel.offsetTop)
{

let caller = "t_view3_move_panel_BORDERING";
let log_this = DOM_VIEW_LOG || LOG_MAP.T3_LAYOUT;



    let panel_not_bordering = (panel.id == "fly_div");
    if( panel_not_bordering )
    {
        panel.style.left = x+"px";
        panel.style.top  = y+"px";

        panel.bordering = {};
    }


    else {
        panel.bordering = t_view4_move_panel_CONFINED(panel, x, y);

    }


    if( view3_move_panel_is_bordering(panel) )
    {
        t_util.add_el_class(panel, t_data.CSS_BORDERING);

    }


    else if( t_util.has_el_class(panel, t_data.CSS_BORDERING) )
    {
        t_util.del_el_class(panel, t_data.CSS_BORDERING);

    }


if(log_this && panel.bordering && panel.bordering.new_URDL) log_label_URDL(caller, panel.bordering);

    view3_move_panel_CSS( panel );

};


let   view3_move_panel_is_bordering = function(panel)
{
    if(   !panel            ) return false;
    if(   !panel.bordering  ) return false;
    return panel.bordering.u
        || panel.bordering.r
        || panel.bordering.d
        || panel.bordering.l
    ;
};



let onUp_pinned_panels_show_seekzone_done;


let   view3_move_panel_CSS = function(panel)
{

    let wcX = (window.innerWidth  - t_data.SCROLLBAR_WIDTH) / 2;
    let wcY = (window.innerHeight - t_data.SCROLLBAR_WIDTH) / 2;

    let poW = panel.offsetWidth ; let pcX = panel.offsetLeft + poW / 2;
    let poH = panel.offsetHeight; let pcY = panel.offsetTop  + poH / 2;


    if(panel.bordering)
    {
        t_util.set_el_class_on_off(panel, "u", panel.bordering.u);
        t_util.set_el_class_on_off(panel, "r", panel.bordering.r);
        t_util.set_el_class_on_off(panel, "d", panel.bordering.d);
        t_util.set_el_class_on_off(panel, "l", panel.bordering.l);
    }


    let   u = (pcY <  wcY);
    let   r = (pcX >= wcX);
    let   d = (pcY >= wcY);
    let   l = (pcX <  wcX);


    t_util.set_el_class_on_off(panel, t_data.CSS_CORNER_U_R, u && r);
    t_util.set_el_class_on_off(panel, t_data.CSS_CORNER_R_D, r && d);
    t_util.set_el_class_on_off(panel, t_data.CSS_CORNER_D_L, d && l);
    t_util.set_el_class_on_off(panel, t_data.CSS_CORNER_L_U, l && u);



    if(   !onUp_pinned_panels_show_seekzone_done
       &&  prop.get( t_data.SHOW_SEEKZONE )
       &&  t_tools.t_get_onWork_PANEL()
      ) {
        let dx, dy;
        if(         l) {
            if     (u) { dx =   0  ; dy =   0  ; }
            else if(d) { dx =   0  ; dy = poH  ; }
            else       { dx =   0  ; dy = poH/2; }
        }
        else if(    r) {
            if     (u) { dx = poW  ; dy =   0  ; }
            else if(d) { dx = poW  ; dy = poH  ; }
            else       { dx = poW  ; dy = poH/2; }
        }
        else {
            if     (u) { dx = poW/2; dy =   0  ; }
            else if(d) { dx = poW/2; dy = poH  ; }
            else       { dx = poW/2; dy = poH/2; }
        }

        let corner_x = panel.offsetLeft + dx;
        let corner_y = panel.offsetTop  + dy;

        let css_corner
            = (u && r) ? t_data.CSS_CORNER_U_R
            : (r && d) ? t_data.CSS_CORNER_R_D
            : (d && l) ? t_data.CSS_CORNER_D_L
            : (l && u) ? t_data.CSS_CORNER_L_U
            :            "";

        t_seek.t_seekzone9_show_bordering(css_corner);
        t_seek.t_seekzone1_show_onDown_XY(corner_x, corner_y);
        t_seek.t_seekzone5_hide();

        onUp_pinned_panels_show_seekzone_done = true;
    }

};




const NEAR_BORDER_MARGIN = 8;
let   move_bordering_panel_URDL_pageXY_result = {};
let   last_panel_cache;


let t_view4_move_panel_CONFINED = function(panel, x, y, margin_urdl)
{

let caller = "t_view4_move_panel_CONFINED";
let log_this = LOG_MAP.T3_LAYOUT;



    let  w_W = window.innerWidth  - t_data.SCROLLBAR_WIDTH;
    let  w_H = window.innerHeight - t_data.SCROLLBAR_WIDTH;



    if(!last_panel_cache || (last_panel_cache.panel != panel))
    {
        last_panel_cache
            = {                panel
                , transformOrigin_XY : t_util.get_el_transformOrigin(panel)
            };
    }

    let has_transformOrigin
        = !!(last_panel_cache.transformOrigin_XY.x || last_panel_cache.transformOrigin_XY.y)
    ;

    let new_XY;
    if(x && y)
    {
        new_XY = true;
    }
    else {
        new_XY = false;

        let panel_x = panel.offsetLeft + (has_transformOrigin ? last_panel_cache.transformOrigin_XY.x : 0);
        let panel_y = panel.offsetTop  + (has_transformOrigin ? last_panel_cache.transformOrigin_XY.y : 0);

        let not_in_viewport
            =  (panel_x < (window.scrollX                     ))
            || (panel_x > (window.scrollX + window.innerWidth ))
            || (panel_y < (window.scrollY                     ))
            || (panel_y > (window.scrollY + window.innerHeight));

        if(not_in_viewport)
        {
if( log_this) log("%c not_in_viewport=["+panel_x+" "+panel_y+"]", lbH+lf8);

            return null;
        }
        else {
            x = panel_x;
            y = panel_y;
        }

if( log_this)
    log_key_val_group(caller+" DEFAULT XY"
                      , {   x
                          , y
                          , last_panel_cache
                      }
                      , lf7, true);

    }


    let panel_fixed = (panel.style.position == "fixed");
    let in_page_panel
        = !panel_fixed
        || t_util.has_el_class(panel, t_data.CSS_STICKY_TOOL)
    ;
    if( in_page_panel )
    {
        let wsX = panel_fixed ? 0 : window.scrollX;
        let wsY = panel_fixed ? 0 : window.scrollY;


        if(margin_urdl && !margin_urdl.can_move_in) {
            x = Math.max(x, wsX       + (margin_urdl ? margin_urdl.l : 0));
            x = Math.min(x, wsX + w_W - (margin_urdl ? margin_urdl.r : 0));
            y = Math.max(y, wsY       + (margin_urdl ? margin_urdl.u : 0));
            y = Math.min(y, wsY + w_H - (margin_urdl ? margin_urdl.d : 0));
        }
        else {
            x = Math.max(x, wsX      );
            x = Math.min(x, wsX + w_W);
            y = Math.max(y, wsY      );
            y = Math.min(y, wsY + w_H);
        }

        if( has_transformOrigin )
        {
            panel.style.left = (x - last_panel_cache.transformOrigin_XY.x)+"px";
            panel.style.top  = (y - last_panel_cache.transformOrigin_XY.y)+"px";
        }
        else {
            panel.style.left = x+"px";
            panel.style.top  = y+"px";
        }


        x -= wsX;
        y -= wsY;


    }


    else {
        [x,y] = view4_move_panel_try_XY(panel, x, y);


    }


    let  poW =                           panel.offsetWidth ;
    let  poH =                           panel.offsetHeight;

    let near_x_min =             (margin_urdl ? margin_urdl.l : 0);
    let near_x_max = w_W - poW - (margin_urdl ? margin_urdl.r : 0);
    let near_y_min =             (margin_urdl ? margin_urdl.u : 0);
    let near_y_max = w_H - poH - (margin_urdl ? margin_urdl.d : 0);


    near_x_max     =    Math.max((margin_urdl ? margin_urdl.l : 0), near_x_max);
    near_y_max     =    Math.max((margin_urdl ? margin_urdl.u : 0), near_y_max);

    let u = (y <= near_y_min);
    let r = (x >= near_x_max);
    let d = (y >= near_y_max);
    let l = (x <= near_x_min);

    let new_URDL
        = (   (u != move_bordering_panel_URDL_pageXY_result.u)
           || (r != move_bordering_panel_URDL_pageXY_result.r)
           || (d != move_bordering_panel_URDL_pageXY_result.d)
           || (l != move_bordering_panel_URDL_pageXY_result.l))
    ;
if(log_this && new_URDL) log_key_val_group("was", move_bordering_panel_URDL_pageXY_result, lf4, true);

    move_bordering_panel_URDL_pageXY_result
        = { panel
        ,   u, r, d, l
        ,   x, y
        ,   w:poW, h:poH
        ,   near_x_min , near_x_max
        ,   near_y_min , near_y_max
        ,   new_URDL
        ,   new_XY
        };

if(log_this && new_URDL) log_key_val_group("now", move_bordering_panel_URDL_pageXY_result, lf3, true);


    if(!in_page_panel)
    {
        view4_move_panel_urdl_xy_min_max( move_bordering_panel_URDL_pageXY_result );

    }


if(log_this && new_URDL) log_label_URDL(caller, move_bordering_panel_URDL_pageXY_result);


    return move_bordering_panel_URDL_pageXY_result;

};



const MOVE_STEP =  16;
const PANEL_GAP =   8;

let bumps_logged_since_last_panels_notification = [];
let onUp_pinned_panels;

let   view4_move_panel_try_XY = function(panel, x, y)
{

let   caller = "view4_move_panel_try_XY";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"["+x+" "+y+"]");


    if(    !onUp_pinned_panels
       ||  (onUp_pinned_panels.length < 1)
       || ((onUp_pinned_panels.length < 2) && (onUp_pinned_panels[0] === panel))
      )
        return [x,y];



    let p = {};
    p.h = panel.offsetHeight;
    p.w = panel.offsetWidth;
    p.t = panel.offsetTop;
    p.l = panel.offsetLeft;

    p.b = p.t + p.h;
    p.r = p.l + p.w;

    p.c = p.l + p.w/2;
    p.m = p.t + p.h/2;



    p.x_arg = x;
    x         =  Math.max(p.l  - MOVE_STEP , x              );
    x         =  Math.min(               x , p.l + MOVE_STEP);

    p.y_arg = y;
    y         =  Math.max(p.t  - MOVE_STEP , y              );
    y         =  Math.min(               y , p.t + MOVE_STEP);

if(log_this) log("%c......CAPPED ["+x+" "+y+"] ..  p.t=["+ p.t+"]", lf3);
    p.t = y;
    p.l = x;
    p.b = p.t + p.h;
    p.r = p.l + p.w;

    return view4_move_panel_bump_XY(panel, x, y, p);
};


let   view4_move_panel_bump_XY = function(panel, x, y, p)
{

let caller = "view4_move_panel_bump_XY";
let log_this = DOM_VIEW_LOG || LOG_MAP.T3_LAYOUT;



    let w_W = window.innerWidth  - t_data.SCROLLBAR_WIDTH;
    let w_H = window.innerHeight - t_data.SCROLLBAR_WIDTH;

    let v_L =                      NEAR_BORDER_MARGIN;
    let v_R = w_W                - NEAR_BORDER_MARGIN;
    let v_T =                      NEAR_BORDER_MARGIN;
    let v_B = w_H                - NEAR_BORDER_MARGIN;



    let o = {};
    for(let i=0; i<onUp_pinned_panels.length; ++i)
    {

        if(   onUp_pinned_panels[i] === panel) continue;
        o.h = onUp_pinned_panels[i].offsetHeight;
        o.w = onUp_pinned_panels[i].offsetWidth;
        o.t = onUp_pinned_panels[i].offsetTop   ;
        o.l = onUp_pinned_panels[i].offsetLeft  ;
        o.b = o.t + o.h;
        o.r = o.l + o.w;


        if( !t_util.intersect_tlbr({p , o, gap:PANEL_GAP}) ) continue;



        let o_center_x = (o.l + o.r) / 2;
        let o_center_y = (o.t + o.b) / 2;
        let p_center_x = (p.l + p.r) / 2;
        let p_center_y = (p.t + p.b) / 2;
        let         dx = o_center_x - p_center_x;
        let         dy = o_center_y - p_center_y;



        let                t_x = (dx > 0) ? (o.l - p.w - PANEL_GAP) : (o.r + PANEL_GAP);
        let                t_y = (dy > 0) ? (o.t - p.h - PANEL_GAP) : (o.b + PANEL_GAP);
        let t_x_within_margins = (v_L < t_x) && (t_x < (v_R - p.w));
        let t_y_within_margins = (v_T < t_y) && (t_y < (v_B - p.h));

        let             x_wall = ((p_center_y < o.t) || (p_center_y > o.b));
        let             y_wall = ((p_center_x < o.l) || (p_center_x > o.r));

        let             x_jump = (Math.abs(t_x - p.x_arg) > (w_W / 4));
        let             y_jump = (Math.abs(t_y - p.y_arg) > (w_H / 4));

if(log_this) view4_move_panel_bump_XY_log(caller, {p, t_x, t_y, x_wall, y_wall, x_jump, y_jump });


        if     (y_wall && !x_jump && t_x_within_margins) x = t_x;
        else if(          !y_jump && t_y_within_margins) y = t_y;


    }

    return [x,y];
};


let   view4_move_panel_bump_XY_log = function (caller, {p, t_x, t_y, x_wall, y_wall, x_jump, y_jump })
{


    if( !(   (x_wall && !bumps_logged_since_last_panels_notification.includes("x_wall"))
          || (y_wall && !bumps_logged_since_last_panels_notification.includes("y_wall"))
          || (x_jump && !bumps_logged_since_last_panels_notification.includes("x_jump"))
          || (y_jump && !bumps_logged_since_last_panels_notification.includes("y_jump")))
      )
        return;

    if(x_wall && !bumps_logged_since_last_panels_notification.includes("x_wall")) bumps_logged_since_last_panels_notification.push("x_wall");
    if(y_wall && !bumps_logged_since_last_panels_notification.includes("y_wall")) bumps_logged_since_last_panels_notification.push("y_wall");
    if(x_jump && !bumps_logged_since_last_panels_notification.includes("x_jump")) bumps_logged_since_last_panels_notification.push("x_jump");
    if(y_jump && !bumps_logged_since_last_panels_notification.includes("y_jump")) bumps_logged_since_last_panels_notification.push("y_jump");

    let lxw = lbL + (x_wall ? lf3 : lf8);
    let lyw = lbR + (y_wall ? lf3 : lf8);
    let lxj = lbL + (x_jump ? lf7 : lf8);
    let lyj = lbR + (y_jump ? lf7 : lf8);

log(caller+"%c x_arg=["+p.x_arg+"] %c t_x=["+t_x+"] %c "+Math.abs(t_x - p.x_arg)+" %c "+Math.abs(t_y - p.y_arg)+" %c x_wall %c y_wall %c x_jump %c y_jump"
    ,       lbL+lf1               ,lbR+lf2         ,lbL+lf4                       ,lbR+lf4                       ,lxw      ,lyw      ,lxj      ,lyj       );

};


let   view4_move_panel_urdl_xy_min_max = function(bordering)
{
    let { panel, u,r,d,l, x,y, near_x_min,near_y_min , near_x_max,near_y_max } = bordering;

    if     (l)         x = near_x_min;
    else if(r)         x = near_x_max;

    if     (u)         y = near_y_min;
    else if(d)         y = near_y_max;

    x =       Math.max(x, near_x_min);
    x =       Math.min(x, near_x_max);

    y =       Math.max(y, near_y_min);
    y =       Math.min(y, near_y_max);

    panel.style.left = x+"px";
    panel.style.top  = y+"px";



};



let t_view5_move_panel_XY = function(panel, x=panel.offsetLeft, y=panel.offsetTop)
{

let   caller = "t_view5_move_panel_XY";
let log_this = DOM_VIEW_LOG || LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"("+panel.id+", "+x+", "+y+")");


    view5_move_panel_origin_and_view( panel );

    let xy    = { x , y };
    xy.x      = Math.max(       panel.view_left  , x);
    xy.x      = Math.min( xy.x, panel.view_right    );

    xy.y      = Math.max(       panel.view_top   , y);
    xy.y      = Math.min( xy.y, panel.view_bottom   );


    xy.capped = (x != xy.x) || (y != xy.y);
    if(    xy.capped
       && !panel.capped_from_x && !panel.capped_from_y
      )
        view5_set_panel_capped_from_xy(panel, panel.offsetLeft, panel.offsetTop);



    t_view3_move_panel_BORDERING(panel, x, y);


if(log_this) {
    let  w_W = window.innerWidth  - t_data.SCROLLBAR_WIDTH;
    let  w_H = window.innerHeight - t_data.SCROLLBAR_WIDTH;

    let  poW = panel.offsetWidth;
    let  poH = panel.offsetHeight;

    let lfx = xy.capped ? lf3 : lf4;

    let v_T = parseInt(panel.view_top    );
    let v_L = parseInt(panel.view_left   );
    let v_B = parseInt(panel.view_bottom );
    let v_R = parseInt(panel.view_right  );

    log_key_val_group(     caller+" .. "+   panel.id
                     , {   panel_id       : panel.id
                         , panel_scale    : panel.scale
                         , panel_tox      : panel.tox
                         , panel_toy      : panel.toy
                         , panel_WH       : "["+ poW         + " "+ poH         +"]"
                         , win_WH         : "["+ w_W         + " "+ w_H         +"]"
                         , view_TL_BR     : "["+ v_T+" "+v_L +"]["+ v_B+" "+v_R +"]"
                         , move_XY        : "["+    x        + " "+    y        +"]"
                         , capped         : xy.capped ? ("XY=["+xy.x +" "+ xy.y+"]") : false
                         , capped_from    : "["+ panel.capped_from_x  +" "+ panel.capped_from_y+"] "
                     }
                     , lfx, false);

if(panel.bordering && panel.bordering.new_URDL) log_label_URDL(caller, panel.bordering);
}
if( log_this) log_caller();


    return xy;
};


let   view5_set_panel_capped_from_xy = function(panel,x,y)
{
    panel.capped_from_x = x;
    panel.capped_from_y = y;

    t_util.add_el_class(panel, t_data.CSS_CAPPED);
};


let   view5_move_panel_origin_and_view = function(panel)
{




    if(   !panel.bordering ) panel.bordering = {};

    panel.tox
        =  panel.bordering.l ?   0
        :  panel.bordering.r ? 100
        :  panel.bordering.u ?  50
        :  panel.bordering.d ?  50
        :                       50
    ;
    panel.toy
        =  panel.bordering.u ?   0
        :  panel.bordering.d ? 100
        :  panel.bordering.l ?  50
        :  panel.bordering.r ?  50
        :                       50
    ;





    let  w_W = window.innerWidth  - t_data.SCROLLBAR_WIDTH;
    let  w_H = window.innerHeight - t_data.SCROLLBAR_WIDTH;

    let  poW = panel.offsetWidth ;
    let  poH = panel.offsetHeight;



    panel.view_top    =         0;
    panel.view_left   =         0;
    panel.view_bottom = w_H - poH;
    panel.view_right  = w_W - poW;


};



let t_view6_cache_PINNED_panels = function(panels)
{

let caller = "t_view6_cache_PINNED_panels";
let log_this = DOM_VIEW_LOG || LOG_MAP.T3_LAYOUT;



    onUp_pinned_panels                          = panels;
    onUp_pinned_panels_show_seekzone_done       = false;
    bumps_logged_since_last_panels_notification = [];

if(log_this) console_dir(caller+".onUp_pinned_panels", onUp_pinned_panels);

};



let t_view7_clr_panel_capped_from_xy = function(panel)
{
    panel.capped_from_x = 0;
    panel.capped_from_y = 0;

    t_util.del_el_class(panel, t_data.CSS_CAPPED);
};






let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_view"
    , logging : (state) => DOM_VIEW_LOG = t_store_set_state("DOM_VIEW_LOG",state)
    , tagging : (state) => DOM_VIEW_TAG = t_store_set_state("DOM_VIEW_TAG",state)
    , t_view_IMPORT

    , t_view1_is_el_in_viewport
    , t_view1_is_el_topLeft_or_bottomRight_in_viewport
    , t_view1_is_xy_in_viewport
    , t_view2_is_xy_near_viewport

    , t_view3_move_panel_BORDERING
    , t_view4_move_panel_CONFINED
    , t_view5_move_panel_XY

    , t_view6_cache_PINNED_panels
    , t_view7_clr_panel_capped_from_xy
};


}());

/*INLINE}}}*/
//@ sourceURL=dom_view.js
`

 .replace(/%u/g,"\\u")
;
/*}}}*/
/**  18 STICKY   JS dom_sticky_js_data .. ESCAPE=[anchor_nodes_in_viewport : "#"+anchor_nodes_in_viewport] {{{*/
/*
../script/dom_sticky.js
*/
let dom_sticky_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/






















const DOM_STICKY_JS_ID      = "dom_sticky_js";
const DOM_STICKY_JS_TAG     = DOM_STICKY_JS_ID  +" (211122:16h:49)";

let dom_sticky  = (function() {
"use strict";





let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;
let t_i18n     = {}        ;
let t_prop     = {}        ;
let t_store    = {}        ;
let t_fly      = {}        ;






let t_view     = {}        ;

let t_seek     = {}        ;






let t_tools    = {}        ;


let t_sticky_IMPORT = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;
    t_i18n    = dom_i18n   ;
    t_prop    = dom_prop   ;
    t_store   = dom_store  ;
    t_fly     = dom_fly    ;







    t_view    = dom_view   ;

    t_seek    = dom_seek   ;






    t_tools   = dom_tools  ;


    sticky_INTERN();

    DOM_STICKY_LOG = DOM_STICKY_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_STICKY_LOG"));
    DOM_STICKY_TAG = DOM_STICKY_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_STICKY_TAG"));


if(log_this) log("%c 16 STICKY", lbH+lf6);
};




let CSS_CC1, CSS_CC2, CSS_CC3, CSS_CC4, CSS_CC5, CSS_CC6, CSS_CC7, CSS_CC8, CSS_CC9, CSS_CC0;

let CSS_ANCHOR_BACK;
let CSS_ANCHOR_CHILD;
let CSS_ANCHOR_CLOSEST;
let CSS_ANCHOR_DETACHED;
let CSS_ANCHOR_NODE;
let CSS_ANCHOR_NOT_FOUND;
let CSS_ANCHOR_UNSET;
let CSS_BORDERING;
let CSS_COLLAPSING;
let CSS_DIMMED;
let CSS_DIMMED_OFF;
let CSS_FIXED ;
let CSS_HAS_FOCUS;
let CSS_PASTE_TARGET;
let CSS_PINNED;
let CSS_PRESSED;
let CSS_RESIZE_CAP;
let CSS_RESIZING;
let CSS_SEEK_TARGET;
let CSS_SLOW_LAYOUT;
let CSS_STICKY_LOG;
let CSS_STICKY_MSG_EDIT;
let CSS_STICKY_RAISED;
let CSS_STICKY_RING;
let CSS_STICKY_TOOL;
let CSS_TOUCHED;

let SCROLLBAR_WIDTH;



let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;

let log_anchor_step;



let JSON_parse;
let add_el_class;
let atob_msg;
let btoa_msg;
let check_xy_in_node_rect;
let clearSelection;
let comma_to_LF;
let csv_log;
let del_el_class;
let ellipsis;
let ellipsis_16;
let ellipsis_short;
let encode_LF;
let escapeHTML;
let get_document_el_at_XY;
let get_el_anchor_in_view_array;
let get_el_child_with_class;
let get_el_child_with_tag;
let get_el_parent_with_class;
let get_el_transformOrigin;
let get_el_xy;
let get_id_or_node_path_tail;
let get_id_or_tag;
let get_n_lbl;
let get_n_txt;
let get_node_path;
let get_node_path_tail;
let get_node_path_target;
let get_node_txt_id_or_tag_path;
let get_xy_tlbr_dist;
let has_el_class;
let has_scrollbar;
let i18n_get;
let is_contained_by_parent;
let is_el_or_child_of_parent_el;
let is_event_on_scrollbar;
let not_an_anchor_target;
let selectNodeContents;
let set_el_class;
let set_el_class_on_off;
let set_el_class_removing;
let strip_CR_LF;
let strip_HTML;
let strip_contentEditable;
let t_TEXT_LINES_to_COLORED_HTML;
let vbar_to_LF;



let   sticky_INTERN = function()
{

    [ CSS_CC1, CSS_CC2, CSS_CC3, CSS_CC4, CSS_CC5, CSS_CC6, CSS_CC7, CSS_CC8, CSS_CC9, CSS_CC0 ] = t_data.CCX_CLASSLIST;

    CSS_ANCHOR_BACK     = t_data.CSS_ANCHOR_BACK;
    CSS_ANCHOR_CHILD    = t_data.CSS_ANCHOR_CHILD;
    CSS_ANCHOR_CLOSEST  = t_data.CSS_ANCHOR_CLOSEST;
    CSS_ANCHOR_DETACHED = t_data.CSS_ANCHOR_DETACHED;
    CSS_ANCHOR_NODE     = t_data.CSS_ANCHOR_NODE;
    CSS_ANCHOR_NOT_FOUND= t_data.CSS_ANCHOR_NOT_FOUND;
    CSS_ANCHOR_UNSET    = t_data.CSS_ANCHOR_UNSET;
    CSS_BORDERING       = t_data.CSS_BORDERING;
    CSS_COLLAPSING      = t_data.CSS_COLLAPSING;
    CSS_DIMMED          = t_data.CSS_DIMMED;
    CSS_DIMMED_OFF      = t_data.CSS_DIMMED_OFF;
    CSS_FIXED           = t_data.CSS_FIXED ;
    CSS_HAS_FOCUS       = t_data.CSS_HAS_FOCUS;
    CSS_PASTE_TARGET    = t_data.CSS_PASTE_TARGET;
    CSS_PINNED          = t_data.CSS_PINNED;
    CSS_PRESSED         = t_data.CSS_PRESSED;
    CSS_RESIZE_CAP      = t_data.CSS_RESIZE_CAP;
    CSS_RESIZING        = t_data.CSS_RESIZING;
    CSS_SEEK_TARGET     = t_data.CSS_SEEK_TARGET;
    CSS_SLOW_LAYOUT     = t_data.CSS_SLOW_LAYOUT;
    CSS_STICKY_LOG      = t_data.CSS_STICKY_LOG;
    CSS_STICKY_MSG_EDIT = t_data.CSS_STICKY_MSG_EDIT;
    CSS_STICKY_RAISED   = t_data.CSS_STICKY_RAISED;
    CSS_STICKY_RING     = t_data.CSS_STICKY_RING;
    CSS_STICKY_TOOL     = t_data.CSS_STICKY_TOOL;
    CSS_TOUCHED         = t_data.CSS_TOUCHED;

    SCROLLBAR_WIDTH     = t_data.SCROLLBAR_WIDTH;



    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;
    log_anchor_step     = t_log.log_anchor_step;



    JSON_parse                      = t_util.JSON_parse;
    add_el_class                    = t_util.add_el_class;
    atob_msg                        = t_util.atob_msg;
    btoa_msg                        = t_util.btoa_msg;
    check_xy_in_node_rect           = t_util.check_xy_in_node_rect;
    clearSelection                  = t_util.clearSelection;
    comma_to_LF                     = t_util.comma_to_LF;
    csv_log                         = t_util.csv_log;
    del_el_class                    = t_util.del_el_class;
    ellipsis                        = t_util.ellipsis;
    ellipsis_16                     = t_util.ellipsis_16;
    ellipsis_short                  = t_util.ellipsis_short;
    encode_LF                       = t_util.encode_LF;
    escapeHTML                      = t_util.escapeHTML;
    get_document_el_at_XY           = t_util.get_document_el_at_XY;
    get_el_anchor_in_view_array     = t_util.get_el_anchor_in_view_array;
    get_el_child_with_class         = t_util.get_el_child_with_class;
    get_el_child_with_tag           = t_util.get_el_child_with_tag;
    get_el_parent_with_class        = t_util.get_el_parent_with_class;
    get_el_transformOrigin          = t_util.get_el_transformOrigin;
    get_el_xy                       = t_util.get_el_xy;
    get_id_or_node_path_tail        = t_util.get_id_or_node_path_tail;
    get_id_or_tag                   = t_util.get_id_or_tag;
    get_n_lbl                       = t_util.get_n_lbl;
    get_n_txt                       = t_util.get_n_txt;
    get_node_path                   = t_util.get_node_path;
    get_node_path_tail              = t_util.get_node_path_tail;
    get_node_path_target            = t_util.get_node_path_target;
    get_node_txt_id_or_tag_path     = t_util.get_node_txt_id_or_tag_path;
    get_xy_tlbr_dist                = t_util.get_xy_tlbr_dist;
    has_el_class                    = t_util.has_el_class;
    has_scrollbar                   = t_util.has_scrollbar;
    is_contained_by_parent          = t_util.is_contained_by_parent;
    is_el_or_child_of_parent_el     = t_util.is_el_or_child_of_parent_el;
    is_event_on_scrollbar           = t_util.is_event_on_scrollbar;
    not_an_anchor_target            = t_util.not_an_anchor_target;
    selectNodeContents              = t_util.selectNodeContents;
    set_el_class                    = t_util.set_el_class;
    set_el_class_on_off             = t_util.set_el_class_on_off;
    set_el_class_removing           = t_util.set_el_class_removing;
    strip_CR_LF                     = t_util.strip_CR_LF;
    strip_HTML                      = t_util.strip_HTML;
    strip_contentEditable           = t_util.strip_contentEditable;
    t_TEXT_LINES_to_COLORED_HTML    = t_util.t_TEXT_LINES_to_COLORED_HTML;
    vbar_to_LF                      = t_util.vbar_to_LF;




    i18n_get                        = t_i18n.i18n_get;


    sticky_DEPEND();
};





let STICKY0_HTML;

let STICKY1_HTML_HAND;

let STICKY2_HTML_PAD0;

let STICKY3_HTML_PAD_NUM ;
let STICKY4_HTML_PAD_MSG ;
let STICKY5_HTML_PAD_DAT ;

let STICKY6_HTML_TAIL;
let STICKY7_HTML_FIX;
let STICKY8_HTML_PEN;
let STICKY9_HTML_REFONT;
let STICKY9_HTML_REFLOW;

let STICKY9_HTML_RESIZE_NW;
let STICKY9_HTML_RESIZE_NE;
let STICKY9_HTML_RESIZE_SE;
let STICKY9_HTML_RESIZE_SW;

let STICKY0_HTML_PASTE;


let   sticky_DEPEND = function()
{



    STICKY1_HTML_HAND
        = "<span  class='"+ STICKY_HAND     +"' >&nbsp;"
        +  "<span class='"+ STICKY_HAND_MOV +"' >"+ t_data.SYMBOL_CLOCKWISE_OPEN_CIRCLE  +"</span>"
        + "</span>";



    STICKY2_HTML_PAD0
        = "<div   class='"+ STICKY_PAD      + " " + STICKY_PLACE_HOLDER_PAD_BGNUM +"'>" + "</div>";

    STICKY3_HTML_PAD_NUM
        =  "<span class='"+ STICKY_PAD_NUM  +"' >"+ STICKY_PLACE_HOLDER_PAD_NUM   +"</span>";

    STICKY4_HTML_PAD_MSG
        =  "<pre  class='"+ STICKY_PAD_MSG  +" '>"+ STICKY_PLACE_HOLDER_PAD_MSG   +"</pre>";

    STICKY5_HTML_PAD_DAT
        =  "<span class='"+ STICKY_PAD_DAT  +"'>"                                 +"</span>";



    STICKY6_HTML_TAIL
        = "<span  class='"+ STICKY_ROTATE       +"' >"
        +  "<span class='"+ STICKY_ROTATE_DIR   +"' >"+ t_data.SYMBOL_BLACK_L_HAND + t_data.SYMBOL_BLACK_R_HAND +"</span>"
        + "</span>";

    STICKY7_HTML_FIX
        =  "<span class='"+ STICKY_FIX          +"' >"+ t_data.SYMBOL_STICKY_FIX             +"</span>";

    STICKY8_HTML_PEN
        =  "<span class='"+ STICKY_PEN          +"' >"+ t_data.SYMBOL_STICKY_PEN             +"</span>";

    STICKY9_HTML_REFONT
        =  "<span class='"+ STICKY_REFONT       +"' >"+ t_data.SYMBOL_STICKY_REFONT          +"</span>";

    STICKY9_HTML_REFLOW
        =  "<span class='"+ STICKY_REFLOW       +"' >"+ t_data.SYMBOL_STICKY_REFLOW          +"</span>";

    STICKY9_HTML_RESIZE_NW
        = "<span  class='"+ STICKY_RESIZE+" "+CSS_POINT_NW+"' >"
        +  "<span class='"+ STICKY_RESIZE_DIR   +"' >"+ t_data.SYMBOL_BLACK_L_HAND +"<br>"+ t_data.SYMBOL_BLACK_R_HAND +"</span>"
        + "</span>";

    STICKY9_HTML_RESIZE_NE
        = "<span  class='"+ STICKY_RESIZE+" "+CSS_POINT_NE+"' >"
        +  "<span class='"+ STICKY_RESIZE_DIR   +"' >"+ t_data.SYMBOL_BLACK_L_HAND +"<br>"+ t_data.SYMBOL_BLACK_R_HAND +"</span>"
        + "</span>";

    STICKY9_HTML_RESIZE_SE
        = "<span  class='"+ STICKY_RESIZE+" "+CSS_POINT_SE+"' >"
        +  "<span class='"+ STICKY_RESIZE_DIR   +"' >"+ t_data.SYMBOL_BLACK_L_HAND +"<br>"+ t_data.SYMBOL_BLACK_R_HAND +"</span>"
        + "</span>";

    STICKY9_HTML_RESIZE_SW
        = "<span  class='"+ STICKY_RESIZE+" "+CSS_POINT_SW+"' >"
        +  "<span class='"+ STICKY_RESIZE_DIR   +"' >"+ t_data.SYMBOL_BLACK_L_HAND +"<br>"+ t_data.SYMBOL_BLACK_R_HAND +"</span>"
        + "</span>";


    STICKY0_HTML_PASTE
        =  "<span class='"+ STICKY_PASTE        +"'>" + t_data.SYMBOL_STICKY_PASTE           +"</span>";



    STICKY0_HTML
        = STICKY3_HTML_PAD_NUM
        + STICKY4_HTML_PAD_MSG
        + STICKY5_HTML_PAD_DAT
        + STICKY6_HTML_TAIL
        + STICKY7_HTML_FIX
        + STICKY8_HTML_PEN
        + STICKY9_HTML_REFONT
        + STICKY9_HTML_REFLOW
        + STICKY9_HTML_RESIZE_NW
        + STICKY9_HTML_RESIZE_NE
        + STICKY9_HTML_RESIZE_SE
        + STICKY9_HTML_RESIZE_SW
        + STICKY0_HTML_PASTE
    ;


};



let   DOM_STICKY_LOG        = false;
let   DOM_STICKY_TAG        = false;

const CSS_LAYOUT_NE             = "layout_NE";
const CSS_LAYOUT_NW             = "layout_NW";
const CSS_LAYOUT_SE             = "layout_SE";
const CSS_LAYOUT_SW             = "layout_SW";

const CSS_POINT_EE              = "point_EE";
const CSS_POINT_SE              = "point_SE";
const CSS_POINT_SW              = "point_SW";
const CSS_POINT_WW              = "point_WW";
const CSS_POINT_NW              = "point_NW";
const CSS_POINT_NE              = "point_NE";
const CSS_POINT_00              = "point_00";
const CSS_POINT_DEFAULT         = CSS_POINT_SE;
const CSS_POINT_XX
    = [   CSS_POINT_EE
        , CSS_POINT_SE
        , CSS_POINT_SW
        , CSS_POINT_WW
        , CSS_POINT_NW
        , CSS_POINT_NE
        , CSS_POINT_00
    ];

const CSS_ROTATE_NE             = "rotate_NE";
const CSS_ROTATE_NW             = "rotate_NW";
const CSS_ROTATE_SE             = "rotate_SE";
const CSS_ROTATE_SW             = "rotate_SW";
const CSS_ROTATE_XX
    = [   CSS_ROTATE_NE
        , CSS_ROTATE_NW
        , CSS_ROTATE_SE
        , CSS_ROTATE_SW
    ];



const WH_CONFINED_PERCENT = "90%";



const CSS_WS_PRE          = "ws_pre";
const CSS_WS_PRE_WRAP     = "ws_pre_wrap";
const CSS_WS_BREAK_SPACES = "ws_break_spaces";
const CSS_WS_PRE_LINE     = "ws_pre_line";
const CSS_WS_NORMAL       = "ws_normal";
const CSS_WS_NOWRAP       = "ws_nowrap";
const CSS_WS_DEFAULT      = CSS_WS_PRE_WRAP;
const CSS_WS_XX
    = [   CSS_WS_PRE_WRAP
        , CSS_WS_PRE
        , CSS_WS_BREAK_SPACES
        , CSS_WS_PRE_LINE
        , CSS_WS_NORMAL
        , CSS_WS_NOWRAP
    ];



const STICKY_HAND         = "sticky_hand";
const STICKY_HAND_MOV     = "sticky_hand_mov";

const STICKY_ROTATE       = "sticky_rotate";
const STICKY_ROTATE_DIR   = "sticky_rotate_dir";

const STICKY_FIX          = "sticky_fix";
const STICKY_PEN          = "sticky_pen";

const STICKY_REFONT       = "sticky_refont";

const STICKY_REFLOW       = "sticky_reflow";

const STICKY_RESIZE       = "sticky_resize";
const STICKY_RESIZE_DIR   = "sticky_resize_dir";

const STICKY_PAD          = "sticky_pad";
const STICKY_PAD_NUM      = "sticky_pad_num";
const STICKY_PAD_MSG      = "sticky_pad_msg";
const STICKY_PAD_DAT      = "sticky_pad_dat";

const STICKY_PASTE        = "sticky_paste";




const STICKY_PLACE_HOLDER_PAD_BGNUM = "STICKY_BGNUM";
const STICKY_PLACE_HOLDER_PAD_NUM   = "STICKY_PAD_NUM";
const STICKY_PLACE_HOLDER_PAD_MSG   = "STICKY_PAD_MSG";



const STICKY_MAX              =   10;
const STICKY_SEL_TEXT_LEN_MAX = 4096;
const ANCHOR_CHILDREN_MAX     =  256;

let onWork_STICKY;






let t_sticky_NEW_XY_SEL_TEXT = function(x, y, sel_text)
{

let   caller = "t_sticky_NEW_XY_SEL_TEXT";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log("%c"+caller+"("+ellipsis_short(strip_CR_LF(sel_text))+")", lb3);
if( log_this) log_caller();


    let sticky = sticky_NEW(x, y);
    if(!sticky ) return null;


    sticky_NEW_XY_SEL_TEXT_MSG(sticky, escapeHTML(sel_text));

    sticky.touched = STICKY_HAND;

    sticky_FIXED_START(sticky);

    t_tools.t_save_update_post(caller);

    return sticky;
};


let   sticky_NEW_XY_SEL_TEXT_MSG = function(sticky,msg)
{

let   caller = "sticky_NEW_XY_SEL_TEXT_MSG";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log(caller+"("+msg+")");



    sticky.date_MS = new Date().getTime();


    sticky_change_msg(sticky, msg);

};


let sticky_NEW = function(fixed_x, fixed_y)
{

let   caller = "sticky_NEW("+fixed_x+", "+fixed_y+")";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log(caller);


    let sticky_num;
    for(sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky = sticky_array[sticky_num];
        if(!sticky || !has_el_class(sticky, CSS_PINNED))
            break;
    }


    if(sticky_num > STICKY_MAX)
    {
        t_fly.t_fly_add_innerHTML( "<div class='stage_0_log'>"
                            + "<em class='cc4'>sticky_num &gt; STICKY_MAX</em>"
                            + " .. "
                            + "<em class='big cc2'>"+STICKY_MAX+"</em>"
                            +"</div>"
                           );

        t_sticky_CHOOSE();
        return null;
    }


    let sticky  = sticky_GET( sticky_num );

    sticky.xy.x = fixed_x + window.scrollX;
    sticky.xy.y = fixed_y + window.scrollY - STICKY_TOOL_HALF_HEIGHT;
    t_tools.t_pin_panel_at_XY(sticky, sticky.xy.x, sticky.xy.y);



    sticky_scrollTo(sticky_num, fixed_x, fixed_y);


if( log_this) log("...return "+get_n_lbl(sticky)+"");
    return sticky;
};



let sticky_array = [];


let sticky_GET = function(sticky_num)
{



    let sticky = sticky_array[sticky_num];
    if(!sticky) {
        sticky = sticky_CREATE(sticky_num);
        sticky_array[          String(sticky_num)] = sticky;


    }

    return sticky;
};


let sticky_PIN_x_y_pos_date_msg = function(sticky, x, y, position, date_MS, msg)
{
    sticky.xy.x = x;
    sticky.xy.y = y;
    t_tools.t_pin_panel_at_XY(sticky, sticky.xy.x,sticky.xy.y, position);

    sticky_change_msg(sticky, msg);

    sticky.date_MS = date_MS;

    t_tools.t_set_CSS_PINNED(sticky, true);
    sticky.style.display = "block";


    let                     pad_msg                = get_sticky_pad_msg( sticky );
    if(sticky.msg_fontSize) pad_msg.style.fontSize = sticky.msg_fontSize+"px";

    let                     sticky_pad              = get_sticky_pad( sticky );
    if(sticky.pad_W       ) sticky_pad.style.width  = sticky.pad_W+"px";
    if(sticky.pad_H       ) sticky_pad.style.height = sticky.pad_H+"px";


};


let sticky_CREATE = function(sticky_num, zIndex=t_data.ZINDEX_STICKY_TOOL_ZERO, id_prefix="")
{

let   caller = "sticky_CREATE";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log_caller();


    let sticky            = document.createElement("DIV");
    sticky_num            = Math.max(sticky_num , 1);
    sticky.num            = 1+      (sticky_num - 1) % STICKY_MAX;
    sticky.id             = id_prefix+"sticky_"+sticky_num;
    sticky.className      = CSS_STICKY_TOOL +" fg"+(sticky.num % 10)+ " "+CSS_POINT_WW;
    sticky.style.display  = "none";
    sticky.style.position = "absolute";
    sticky.style.zIndex   = zIndex + sticky_num;
    sticky.xy             = { x:0 , y:0 };
    sticky.pad_flow       = last_set_pad_flow  || CSS_WS_DEFAULT;
    sticky.dir_class      = last_set_dir_class || CSS_POINT_DEFAULT;

    sticky.title          = sticky.id;
    sticky.innerHTML
        = STICKY1_HTML_HAND
        + STICKY2_HTML_PAD0.replace(STICKY_PLACE_HOLDER_PAD_BGNUM, "bg"+(sticky.num % 10))
    ;

    t_tools.t_dom_tools_html_appendChild(sticky);


if( log_this)
    log_key_val(   caller+"( "+sticky_num+" )"
               , { id        : sticky.id
                 , num       : sticky.num
                 , title     : sticky.title
                 , className : sticky.className
                 , innerHTML : sticky.innerHTML
               });

    return sticky;
};


let t_sticky_GET_COUNT = function()
{
    let count = 0;
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let  sticky    = sticky_array[ sticky_num ];
        if( !sticky    ) continue;
        count     += has_el_class(sticky, CSS_PINNED) ? 1 : 0;
    }
    return count;
};


let t_sticky_GET_NUM = function(el)
{
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky     = sticky_array[ sticky_num ];
        if(!sticky     )        continue;
        if( sticky.id == el.id) return sticky.num;
    }
    return 0;
};

let get_sticky_hand     = function(sticky) { return sticky.firstElementChild; };
let get_sticky_pad      = function(sticky) { return sticky.lastElementChild;  };
let get_sticky_pad_msg  = function(sticky) { return sticky.querySelector("."+STICKY_PAD_MSG); };
let get_sticky_pad_num  = function(sticky) { return sticky.querySelector("."+STICKY_PAD_NUM); };






let   t_sticky_STORE_NOW = function()
{
    let fixed_arr = [];
    for(let sticky_num=1;   sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let                 sticky = sticky_array[sticky_num];
        if(                !sticky ) continue;
        if(                 sticky.style.position == "fixed")
            fixed_arr.push( sticky );
    }


    sticky_FIXED_STOP();


    for(let i=0; i < fixed_arr.length; ++i)
    {
        t_sticky_MAGNET(fixed_arr[i], "STORING");
    }

    t_sticky_STORE();
};


let   t_sticky_STORE = function()
{

let   caller = "t_sticky_STORE";
let log_this = DOM_STICKY_LOG || LOG_MAP.T0_STORE;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) log("%c"+caller, lbH+lf3);


    if(!t_sticky_LOAD_has_been_called)
    {
if( log_this) log("%c IGNORING EARLY CALL .. t_sticky_LOAD has not been called yet", lbH+lf8);

        return "";
    }

    let some_change   = "";
    let show_seekzone = t_prop.get(t_data.SHOW_SEEKZONE);
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {

        let sticky = sticky_array[sticky_num];
        if(!sticky) continue;



        let l_x          = sticky_num;
        let key          = "sticky_"+sticky.num;
        let stored_value = t_store.t_store_getItem( key );
        let pinned       = sticky.classList.contains( CSS_PINNED );
        if(!pinned) {
            if( stored_value )
            {
if( tag_this) log("REMOVE UNPINNED STORAGE FOR key=["+key+"] .. className=["+sticky.className+"]" +" .. display=["+sticky.style.display+"]");

                t_store.t_store_set_value(key, null);
            }
            continue;
        }


        let value = sticky_get_value( sticky );

        if( value.anchor_node ) value.anchor_node_path = get_node_path( value.anchor_node );
        delete                  value.anchor_node;


        let sticky_json   = JSON.stringify( value );
        if( stored_value == sticky_json)
        {
if( log_this) log("%c "+t_data.SDX[sticky_num]+" %c UNCHANGED ["+key+"]", lfX[l_x], lfX[l_x]);

            continue;
        }


if( tag_this) {
    value.callers = t_log.get_callers();
    log_key_val_group(t_data.SDX[sticky_num]+" STORING "+key, value, lbX[l_x], true);
}

        some_change += t_store.t_store_set_value(key, sticky_json) ? (" "+key) : "";

        if(show_seekzone && t_prop.get(t_data.FLOATLOG)) t_sticky_LOG_TOOLTIP(sticky, "STORE");

    }
if((log_this || DOM_STICKY_TAG) && some_change) logBIG(caller+": some_change=["+some_change+"]", lf3);
    return some_change;
};




const T_STICKY_LOAD_FORMAT_PAD_DELAY = 1000;
const T_STICKY_LOAD_SET_DIMMED_DELAY = 3000;

let t_sticky_LOAD_has_been_called;


let t_sticky_LOAD_ANCHORS_CHANGED = function() { t_sticky_LOAD(true); };
let t_sticky_LOAD = function(anchors_changed)
{

let   caller = "t_sticky_LOAD";
let log_this = DOM_STICKY_LOG || LOG_MAP.T0_STORE;

if( log_this) log("%c"+t_data.SD5+"%c "+caller+"(anchors_changed "+anchors_changed+")", lbS+lf5, lbH+lf5);
    t_sticky_LOAD_has_been_called = true;

    sticky_remove_all();

    for(let sticky_num=1; sticky_num <= STICKY_MAX; ++sticky_num)
    {

        let sticky      = sticky_GET(sticky_num);
        let         key = "sticky_"+sticky.num;
        let sticky_json = t_store.t_store_getItem( key );

        if(!sticky_json ) {
if( log_this) log("%c"+t_data.SYMBOL_ELLIPSIS+t_data.SYMBOL_WARNING+" %c sticky num="+sticky.num+" NOT IN STORE", lfX[sticky.num], lb0);
            continue;
        }



        let silent = !(log_this || DOM_STICKY_TAG);
        let value  = JSON_parse(sticky_json, silent);
        if(!value ) continue;

        if( value.pinned )
        {
            if(anchors_changed) delete value.anchor_node_path;
            sticky_set_value(sticky, value);

if( log_this) t_sticky_LOG(sticky);
        }

    }



    sticky_MAGNET();


    setTimeout( function() { t_sticky_format_pad_all(); } , T_STICKY_LOAD_FORMAT_PAD_DELAY);


    t_sticky_SET_DIMMED(false, "STICKY ON LOAD", T_STICKY_LOAD_SET_DIMMED_DELAY);

};



let   sticky_get_value = function(sticky)
{

let   caller = "sticky_get_value";
let log_this = DOM_STICKY_LOG || LOG_MAP.T0_STORE;


        let          xy = get_el_xy(sticky, caller);
        let          to = get_el_transformOrigin( sticky );
        xy.x           += to.x;
        xy.y           += to.y;


        let              msg = btoa_msg(sticky.msg);

        let value
            = {           xy : xy
              ,          msg : msg
              ,          num : sticky.num
              ,        pad_H : sticky.pad_H
              ,        pad_W : sticky.pad_W
              ,       pinned : sticky.classList.contains( CSS_PINNED )
              ,      date_MS : sticky.date_MS
              ,     offset_x : sticky.offset_x
              ,     offset_y : sticky.offset_y
              ,     pad_flow : sticky.pad_flow
              ,    dir_class : sticky_get_POINT_DIR( sticky )
              ,    pad_msg_H : sticky.pad_msg_H
              ,    pad_msg_W : sticky.pad_msg_W
              ,  anchor_node : sticky.anchor_node
              , msg_fontSize : sticky.msg_fontSize
            };

if( log_this) log_key_val(caller+" "+sticky.num+"=["+ellipsis_16(sticky.msg)+"] .. ANCHOR="+get_node_txt_id_or_tag_path(sticky.anchor_node), value, lfX[sticky.num]);
    return value;
};




let last_set_fontSize;


let   sticky_set_value = function(sticky,value)
{

let   caller = "sticky_set_value";
let log_this = DOM_STICKY_LOG || LOG_MAP.T0_STORE;

if( log_this) log_key_val(caller, value, lbH+lf4);


    sticky.xy           = value.xy;
    let     x           = value.xy.x;
    let     y           = value.xy.y;

if( log_this) log("%c xy=["+x+" "+y+"]", lbH+lf8);


    if(!sticky.anchor_node && value.anchor_node_path)
    {

        let anchor_node
            = get_node_path_target(value.anchor_node_path, sticky.num);

        sticky_ATTACH5_ANCHOR(sticky, anchor_node, value.offset_x, value.offset_y, value.z_min);
    }


    let anchor_xy;
    if( sticky.anchor_node ) {

        anchor_xy = sticky_get_anchor_xy(sticky, sticky.anchor_node, sticky.offset_x, sticky.offset_y);
        if( anchor_xy ) {
if( log_this) log("%c XY "+x+" "+y+"%c anchor_xy "+(anchor_xy ? (anchor_xy.x+" "+anchor_xy.y) : "[]")+"%c"+get_n_lbl(sticky.anchor_node)
                  ,lbL+lf4         ,lbR+lf4                                                           ,lbH+lf4                                 );

            x = anchor_xy.x;
            y = anchor_xy.y;
        }


        else {
            log("%c ANCHOR NOT FOUND: %c"+get_n_lbl(sticky.anchor_node), lbH+lf2, lf4);

            add_el_class(sticky, CSS_ANCHOR_NOT_FOUND);
        }


        let sticky_anchor_node_path = get_node_path(sticky.anchor_node);
        if(value.anchor_node_path && (value.anchor_node_path != sticky_anchor_node_path))
        {
            let lfx = (value.anchor_node_path != sticky_anchor_node_path) ? lf2 : lf8;
log(sticky.num+" STORED: %c"+ value.anchor_node_path, lf4);
log(sticky.num+" ANCHOR: %c"+sticky_anchor_node_path+" %c"+get_n_txt(sticky.anchor_node), lfx, lb8);
        }

    }


    else {
log("%c ANCHOR UNSET", lbH+lf2);

        add_el_class(sticky, CSS_ANCHOR_UNSET);
    }


    let to = get_el_transformOrigin( sticky );
    x      = Math.max(STICKY_FIX_RESOLUTION/2 - to.x, x);
    y      = Math.max(STICKY_FIX_RESOLUTION/2 - to.y, y);

if( log_this) log("%c xy=["+x+" "+y+"] .. (MAGNET TO GRID)", lbH+lf8);


    sticky.msg_fontSize = value.msg_fontSize;
    last_set_fontSize   = sticky.msg_fontSize;

if( log_this) log("%c msg_fontSize=["+sticky.msg_fontSize+"]", lbH+lf8);


    sticky_PIN_x_y_pos_date_msg( sticky
                               , x
                               , y
                               , "absolute"
                               ,                 value.date_MS
                               , atob_msg(value.msg    ));



    sticky.pad_W        = value.pad_W;
    sticky.pad_H        = value.pad_H;
    sticky.pad_msg_W    = value.pad_msg_W;
    sticky.pad_msg_H    = value.pad_msg_H;

if( log_this) log("%c pad_WH=["+sticky.pad_W+" "+sticky.pad_H+"] pad_msg_WH=["+sticky.pad_msg_W+" "+sticky.pad_msg_H+"]", lbH+lf8);

    sticky_SETSIZE_PAD_WH (sticky, sticky.pad_msg_W, sticky.pad_msg_H);
    sticky_RESIZE6_MSG_FIT(sticky, caller);


    sticky_set_DIR_CLASS(sticky, value.dir_class || last_set_dir_class || CSS_POINT_DEFAULT);
if( log_this) log("%c dir_class=["+sticky.dir_class+"]", lbH+lf8);

    let show_seekzone = t_prop.get(t_data.SHOW_SEEKZONE);
    set_el_class_on_off(sticky, t_data.SHOW_SEEKZONE, show_seekzone);

    if(show_seekzone)
        sticky_format_pad_anchor_path(sticky);


    sticky_set_WS_CLASS(sticky, value.pad_flow   || last_set_pad_flow  || CSS_WS_DEFAULT   );



    if(show_seekzone && t_prop.get(t_data.FLOATLOG)) t_sticky_LOG_TOOLTIP(sticky, "LOAD");


};


let   sticky_get_anchor_xy = function(sticky, anchor_node, offset_x=0, offset_y=0)
{

let   caller = "sticky_get_anchor_xy";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+t_data.SD5+"%c "+caller+"("+get_n_lbl(sticky)+", "+get_n_lbl(anchor_node)+", offset_x "+offset_x+" , offset_y "+offset_y+")"
                  ,lbS+lf5        ,lbH+lf5);

    if(!anchor_node) return null;






    let  to = get_el_transformOrigin( sticky );
    let   x = sticky.xy.x - to.x;
    let   y = sticky.xy.y - to.y;



    let bcr = anchor_node.getBoundingClientRect();
    if((bcr.width > 0) && (bcr.height > 0))
    {
        let aCenter_X = window.scrollX + Math.round(bcr.x + anchor_node.offsetWidth  / 2);
        let aCenter_Y = window.scrollY + Math.round(bcr.y + anchor_node.offsetHeight / 2);

        let anchor_W  = anchor_node.offsetWidth ;
        let anchor_H  = anchor_node.offsetHeight;

        x = Math.round(aCenter_X + anchor_W * offset_x);
        y = Math.round(aCenter_Y + anchor_H * offset_y);

        x -= to.x;
        y -= to.y;

if( log_this) log_key_val_group(    caller
                                , { ANCHORNODE_XY_WH : "aCenter_XY=["+aCenter_X+"  "+aCenter_Y+"] .. anchor_WH=["+anchor_W+"  "+anchor_H+"]"
                                  , ANCHOR_CENTER_DX : "x .. offset_x=["+offset_x+"] * anchor_W=["+anchor_W+"]"
                                  , ANCHOR_CENTER_DY : "y .. offset_y=["+offset_y+"] * anchor_H=["+anchor_H+"]"
                                  ,  transformOrigin : to
                                  ,                x : x+" .. (default sticky.xy.x=["+sticky.xy.x+"]"
                                  ,                y : y+" .. (default sticky.xy.y=["+sticky.xy.y+"]"
                                }, lf4, false);
    }
    else {

if( log_this) log_key_val_group(    caller
                                , {      anchor_node : "invalid layout .. "+get_n_lbl(anchor_node)
                                  ,  transformOrigin : to
                                  ,                x : x+" .. (default sticky.xy.x=["+sticky.xy.x+"]"
                                  ,                y : y+" .. (default sticky.xy.y=["+sticky.xy.y+"]"
                                }, lf3, false);
    }


    return { x , y };
};



let   sticky_remove_all = function()
{

let   caller = "sticky_remove_all";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log(caller);


    let sticky_count = 0;
    for(let i=0; i <= sticky_array.length; ++i)
    {
        let sticky  = sticky_array[i];
        if(!sticky ) continue;

        sticky_count += 1;

        sticky.parentElement.removeChild(sticky);
        sticky_array[i] = null;
        t_tools.t_set_CSS_PINNED(sticky, false);
    }
    sticky_array = [];
    t_sticky_clr_SEEK_NEXT();

if( log_this && sticky_count) log("%c REMOVED ALL "+sticky_count+" CURRENT STICKY", lbH+lf8);

};






let t_sticky_set_onWork_STICKY = function(el,e)
{

let   caller = "t_sticky_set_onWork_STICKY";
let log_this = DOM_STICKY_LOG;


if( log_this) log("%c"+caller+"%c"+get_id_or_tag(el), lbL+lf1, lbR+lf1);

    sticky_CLEAR_HIGHLIGHT();

    onWork_STICKY = get_el_parent_with_class(el, CSS_STICKY_TOOL);
    if(!onWork_STICKY)
    {
if( log_this) log("...NOT A STICKY");

        return null;
    }


    if( !has_el_class(onWork_STICKY, CSS_PINNED) )
    {
logBIG(caller+"...NOT CSS_PINNED: "+get_n_lbl(onWork_STICKY));

        onWork_STICKY = null;
        return null;
    }


    sticky_set_onWork_STICKY_touched(el, e, onWork_STICKY);



    sticky_set_SEEK_TARGET( onWork_STICKY );



    sticky_update_dat(onWork_STICKY);



if( log_this ) {
    let l_x
        = (onWork_STICKY.touched == STICKY_HAND   ) ? 1
        : (onWork_STICKY.touched == STICKY_PAD    ) ? 2
        : (onWork_STICKY.touched == STICKY_ROTATE ) ? 6
        : (onWork_STICKY.touched == STICKY_FIX    ) ? 7
        : (onWork_STICKY.touched == STICKY_PEN    ) ? 8
        : (onWork_STICKY.touched == STICKY_REFONT ) ? 9
        : (onWork_STICKY.touched == STICKY_REFLOW ) ? 9
        : (onWork_STICKY.touched == STICKY_RESIZE ) ? 9
        :                                             0;

    log("...onWork_STICKY %c"+get_n_lbl(onWork_STICKY)+"%c.touched "+onWork_STICKY.touched
        ,                 lbL                                 ,lbR+lfX[l_x]                      );

}

    return onWork_STICKY;
};


let   sticky_set_onWork_STICKY_touched = function(el,e,sticky)
{

let   caller = "sticky_set_onWork_STICKY_touched";
let log_this = DOM_STICKY_LOG;




    let e_target = e ? e.path[0] : undefined;
    let sticky_pad_msg = get_sticky_pad_msg( sticky );
    let event_on_scrollbar
        =  e
        && (e_target == sticky_pad_msg)
        && is_event_on_scrollbar(e)
    ;


    if( event_on_scrollbar )
        t_sticky_scroll_STICKY_PAD_MSG( e_target );


    sticky.touched
        = event_on_scrollbar ? get_id_or_tag(e_target)+".scrollbar"
        : get_el_parent_with_class(el, STICKY_HAND   ) ? STICKY_HAND
        : get_el_parent_with_class(el, STICKY_ROTATE ) ? STICKY_ROTATE
        : get_el_parent_with_class(el, STICKY_FIX    ) ? STICKY_FIX
        : get_el_parent_with_class(el, STICKY_REFONT ) ? STICKY_REFONT
        : get_el_parent_with_class(el, STICKY_REFLOW ) ? STICKY_REFLOW
        : get_el_parent_with_class(el, STICKY_RESIZE ) ? STICKY_RESIZE
        : get_el_parent_with_class(el, STICKY_PEN    ) ? STICKY_PEN
        : get_el_parent_with_class(el, STICKY_PAD    ) ? STICKY_PAD
        :                                                       sticky.touched
    ;

    if( sticky.touched == STICKY_RESIZE) {
        sticky.touched_dir
            = get_el_parent_with_class(e_target, CSS_POINT_NW) ? CSS_POINT_NW
            : get_el_parent_with_class(e_target, CSS_POINT_NE) ? CSS_POINT_NE
            : get_el_parent_with_class(e_target, CSS_POINT_SE) ? CSS_POINT_SE
            : get_el_parent_with_class(e_target, CSS_POINT_SW) ? CSS_POINT_SW
            :                                                           undefined
            ;
    }


if( log_this) {
    let l_x
        = (onWork_STICKY.touched == STICKY_HAND   ) ? 1
        : (onWork_STICKY.touched == STICKY_PAD    ) ? 2
        : (onWork_STICKY.touched == STICKY_ROTATE ) ? 6
        : (onWork_STICKY.touched == STICKY_FIX    ) ? 7
        : (onWork_STICKY.touched == STICKY_PEN    ) ? 8
        : (onWork_STICKY.touched == STICKY_REFONT ) ? 9
        : (onWork_STICKY.touched == STICKY_REFLOW ) ? 9
        : (onWork_STICKY.touched == STICKY_RESIZE ) ? 9
        :                                             0;

    log_key_val_group(caller+" .. "+ sticky.touched
                , { el                  : get_node_path(el            )
                  , e_target            : get_node_path(e_target      )
                  , sticky_pad_msg      : get_node_path(sticky_pad_msg)
                  , event_on_scrollbar
                  , sticky
                  , sticky_touched      : sticky.touched
                   , callers            : t_log.get_callers()
                }, lbH+lfX[l_x], true);
}

};


let t_sticky_get_onWork_STICKY = function()
{
    return      onWork_STICKY;
};









let onDown_XY        = { x:0, y:0 };
let onDown_STICKY_XY = { x:0, y:0 };


let t_sticky_onDown = function(e)
{

let   caller = "t_sticky_onDown";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) log("%c"+caller+"(e) .. onWork_STICKY=["+get_id_or_tag(onWork_STICKY)+"]", lbF+lb4);


    onDown_STICKY_XY = { x:0, y:0 };

    let sticky = onWork_STICKY;
    if(!sticky ) {
        t_sticky_SET_DIMMED(false, "DOWN NO PICKED STICKY");

        return "";
    }

    let sticky_dimmed = has_el_class(sticky, CSS_DIMMED    );
if( log_this) log("%c TOUCHED "+sticky.touched+"%c sticky_dimmed=["+sticky_dimmed+"]", lbL+lf5, lbR+lf5);



    let consumed_by;
    if(has_el_class(sticky, CSS_HAS_FOCUS))
    {

        if(sticky.touched == STICKY_PAD)
        {
            consumed_by = "WHILE EDITING: IGNORING TOUCHED "+sticky.touched+" "+sticky.id;

if( tag_this) log("%c "+consumed_by, lf5);
        }


        else {
            t_sticky_EDIT_DONE();

if( tag_this) log("%c DONE EDITING "+sticky.id, lbH+lf5);


        }

    }


    if(!consumed_by && sticky_dimmed)
    {
        consumed_by = "MOVING A HIDING STICKY "+sticky.id;

        t_sticky_set_onWork_STICKY(sticky, e);

        t_sticky_SET_DIMMED(false, consumed_by);

        t_tools.t_add_tool_pointermove_listener(caller);
    }


    if(!consumed_by)
    {
        if(sticky.touched == STICKY_HAND)
        {
            consumed_by = "MOVING STICKY "+sticky.id;

            t_tools.t_add_tool_pointermove_listener(caller);
        }
    }


    if(!consumed_by)
    {
        let change_dir
            =  (sticky.touched == STICKY_ROTATE)
            || (sticky.touched == STICKY_PAD   ) && has_el_class(sticky, CSS_FIXED );

        if( change_dir ) {
            consumed_by = "POINTING STICKY "+sticky.id;

            t_tools.t_add_tool_pointermove_listener(caller);
        }
    }


    if(!consumed_by)
    {
        let change_layout
            =  (sticky.touched == STICKY_REFONT)
            || (sticky.touched == STICKY_REFLOW)
            || (sticky.touched == STICKY_RESIZE)
        ;

        if( change_layout ) {
            consumed_by = "RESIZING STICKY "+sticky.id;

            let xy = t_util.get_event_XY(e);
            onDown_XY.x = xy.x;
            onDown_XY.y = xy.y;

            let   pad_msg = get_sticky_pad_msg( sticky );
            onDown_XY.pad_msg_w = pad_msg.width;

if( log_this) log("%c onDown_XY=["+onDown_XY.x+" "+onDown_XY.y+"]", lbH+lf6);

            xy  = sticky
                ? get_el_xy(sticky, caller)
                : { x:0 , y:0 };
            onDown_STICKY_XY.x   = xy.x;
            onDown_STICKY_XY.y   = xy.y;
if( log_this) log("%c onDown_STICKY_XY=["+onDown_STICKY_XY.x+" "+onDown_STICKY_XY.y+"]", lbH+lf5);

            t_tools.t_add_tool_pointermove_listener(caller);
        }
    }


if( tag_this ) {

    let l_1
        = (sticky.touched == STICKY_HAND  ) ? 1
        : (sticky.touched == STICKY_PAD   ) ? 2
        : (sticky.touched == STICKY_ROTATE) ? 6
        : (sticky.touched == STICKY_FIX   ) ? 7
        : (sticky.touched == STICKY_PEN   ) ? 8
        : (sticky.touched == STICKY_REFONT) ? 9
        : (sticky.touched == STICKY_REFLOW) ? 9
        : (sticky.touched == STICKY_RESIZE) ? 9
        : (sticky.touched == STICKY_PASTE ) ? 0
        :                                     0;

    let l_2
        = consumed_by && consumed_by.startsWith("MOV"  ) ? 5
        : consumed_by && consumed_by.startsWith("POINT") ? 6
        :                                                  7;

    log("%c DOWN %c"+sticky.touched +"%c"+(consumed_by || "TOUCHING "+sticky.touched), lbb+lb1, lbL+lfX[l_1], lbR+lfX[l_2]);
}

    return consumed_by;
};





let t_sticky_move_z_on_top = function(sticky_on_top)
{

let   caller = "t_sticky_move_z_on_top";
let log_this = DOM_STICKY_LOG;



    let state_sticky_ring_deployed
        = sticky_ring_array.length && t_tools.t_dimm_mask_displayed();

    let zindex_zero
        = state_sticky_ring_deployed
        ?  t_data.ZINDEX_ABOVE_TOOLS
        :  t_data.ZINDEX_STICKY_TOOL_ZERO;

    let s_array
        = state_sticky_ring_deployed
        ?  sticky_ring_array
        :  sticky_array;

    let zIndex_on_top = 1;
    for(let i= 0; i < s_array.length; ++i)
    {
        let sticky  = s_array[i];
        if(!sticky                                 ) continue;
        if(!has_el_class(sticky, CSS_PINNED)) continue;

        sticky.style.zIndex = zindex_zero + zIndex_on_top;
        zIndex_on_top += 1;
    }
    if(sticky_on_top)
    {
if( log_this) log("%c"+caller+" %c "+zIndex_on_top+" %c "+sticky_on_top.id
            ,      lbL         ,lbR                 ,lbH+lfX[sticky_on_top.style.zIndex - zindex_zero]);

        sticky_on_top.style.zIndex = zindex_zero + zIndex_on_top;
    }
};



let t_sticky_onMove = function(x,y)
{

let   caller = "t_sticky_onMove";
let log_this = DOM_STICKY_LOG;

    let sticky = onWork_STICKY;
    if(!sticky ) return;

log_this = log_this && !sticky_was_moved;
    sticky_was_moved = true;
if( log_this) log("%c"+caller+"("+x+", "+y+") .. onWork_STICKY=["+get_n_lbl(sticky)+"]", lbH+lf2);







    sticky_MOVE_FLIP({sticky, x,y, layout_changed:false });


    sticky_MAGNET();

    t_sticky_reorder();


};


let t_sticky_TRACK_DIR = function(sticky,dir)
{

let   caller = "t_sticky_TRACK_DIR";
let log_this = DOM_STICKY_LOG;

if( log_this) log("%c"+caller+"("+get_n_lbl(sticky)+", "+dir+")", lb4);

    let prev_class = sticky_clr_DIR_CLASS(sticky);

    let dir_class;
    switch(dir)
    {
    default:
    case "CYCLE":
    dir_class
        = (prev_class == ""          ) ? CSS_POINT_SE
        : (prev_class == CSS_POINT_EE) ? CSS_POINT_SE
        : (prev_class == CSS_POINT_SE) ? CSS_POINT_SW
        : (prev_class == CSS_POINT_SW) ? CSS_POINT_WW
        : (prev_class == CSS_POINT_WW) ? CSS_POINT_NW
        : (prev_class == CSS_POINT_NW) ? CSS_POINT_NE
        : CSS_POINT_EE
    ;
    break;

    case    "UP":
    dir_class
        = (prev_class == ""          ) ? CSS_POINT_NE
        : (prev_class == CSS_POINT_EE) ? CSS_POINT_NE
        : (prev_class == CSS_POINT_SE) ? CSS_POINT_EE
        : (prev_class == CSS_POINT_SW) ? CSS_POINT_WW
        : (prev_class == CSS_POINT_WW) ? CSS_POINT_NW
        : (prev_class == CSS_POINT_NW) ? CSS_POINT_NW
        : CSS_POINT_NE
    ;
   break;

    case  "DOWN":
    dir_class
        = (prev_class == ""          ) ? CSS_POINT_SE
        : (prev_class == CSS_POINT_EE) ? CSS_POINT_SE
        : (prev_class == CSS_POINT_SE) ? CSS_POINT_SE
        : (prev_class == CSS_POINT_SW) ? CSS_POINT_SW
        : (prev_class == CSS_POINT_WW) ? CSS_POINT_SW
        : (prev_class == CSS_POINT_NW) ? CSS_POINT_WW
        : CSS_POINT_EE
    ;
   break;

    case "RIGHT":
    dir_class
        = (prev_class == ""          ) ? CSS_POINT_EE
        : (prev_class == CSS_POINT_EE) ? CSS_POINT_EE
        : (prev_class == CSS_POINT_SE) ? CSS_POINT_EE
        : (prev_class == CSS_POINT_SW) ? CSS_POINT_SE
        : (prev_class == CSS_POINT_WW) ? CSS_POINT_EE
        : (prev_class == CSS_POINT_NW) ? CSS_POINT_NE
        : CSS_POINT_EE
    ;
      break;

    case  "LEFT":
    dir_class
        = (prev_class == ""          ) ? CSS_POINT_WW
        : (prev_class == CSS_POINT_EE) ? CSS_POINT_WW
        : (prev_class == CSS_POINT_SE) ? CSS_POINT_SW
        : (prev_class == CSS_POINT_SW) ? CSS_POINT_WW
        : (prev_class == CSS_POINT_WW) ? CSS_POINT_WW
        : (prev_class == CSS_POINT_NW) ? CSS_POINT_WW
        : CSS_POINT_NW
    ;
     break;

    }



    if(dir_class)
        sticky_set_DIR_CLASS(sticky, dir_class);
};


let sticky_MOVE_FLIP = function({ sticky, x,y, layout_changed})
{

let   caller = "sticky_MOVE_FLIP";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"("+get_id_or_tag(sticky)+", XY=["+x+" "+y+"], layout_changed=["+layout_changed+"])");


    let margin_urdl
        = {             u : t_data.STICKY_TOOL_MARGIN_U
            ,           r : t_data.STICKY_TOOL_MARGIN_R
            ,           d : t_data.STICKY_TOOL_MARGIN_D
            ,           l : t_data.STICKY_TOOL_MARGIN_L
            , can_move_in : true
        };

    let bordering = t_view.t_view4_move_panel_CONFINED(sticky, x, y, margin_urdl);


    if(!bordering) return;

if(log_this && (bordering.new_URDL || !bordering.new_XY))
    log_key_val("bordering", bordering);



    if( bordering.new_XY )
    {
        if((sticky.style.position != "fixed"))
            sticky_DETACHED_START(sticky);

    }


    if(     t_prop.get( t_data.SHOW_SEEKZONE )
        && (bordering.u || bordering.l || bordering.d || bordering.r)
      )
        add_el_class(sticky, CSS_BORDERING);
    else
        del_el_class(sticky, CSS_BORDERING);



    if(layout_changed || bordering.new_URDL)
    {

        let pointing_X = sticky.className.includes("point_");
        let pointing_N
            =   pointing_X
            && !has_el_class(sticky, CSS_POINT_SE)
            && !has_el_class(sticky, CSS_POINT_SW)
        ;
        let pointing_E
            =   pointing_X
            && !has_el_class(sticky, CSS_POINT_SW)
            && !has_el_class(sticky, CSS_POINT_WW)
            && !has_el_class(sticky, CSS_POINT_NW)
        ;



        let switching_N = !pointing_N && bordering.d;
        let switching_E = !pointing_E && bordering.l;
        let switching_S =  pointing_N && bordering.u;
        let switching_W =  pointing_E && bordering.r || !pointing_X;

        if(   switching_N
           || switching_E
           || switching_S
           || switching_W
          ) {
if( log_this)
            log_key_val("SET POINTING DIRECTION"
                        , {sticky, pointing_E, pointing_N, switching_N, switching_S, switching_E, switching_W });

            sticky_set_POINT_DIR(sticky, pointing_E, pointing_N, switching_N, switching_S, switching_E, switching_W);
        }

    }

};





const RESIZE_TYPE_FONT       = "RESIZE FONT";
const RESIZE_TYPE_FLOW       = "RESIZE FLOW";
const RESIZE_TYPE_WIDTH      = "RESIZE WIDTH";
const RESIZE_TYPE_HEIGHT     = "RESIZE HEIGHT";

const STICKY_RESIZE_INTERVAL = 1000;

const STICKY_W_MIN           =   64;
const STICKY_H_MIN           =   12;
const STICKY_MARGIN          =   64;


let   sticky_RESIZE_request;



let t_sticky_RESIZE = function(sticky)
{

let   caller = "t_sticky_RESIZE";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) log("%c "+caller+"("+get_n_lbl(sticky)+")", lf1);


    if( sticky_RESIZE_request )
        sticky_RESIZE8_CANCEL();

    let resize_type
        = (sticky.touched == STICKY_REFONT) ? RESIZE_TYPE_FONT
        : (sticky.touched == STICKY_REFLOW) ? RESIZE_TYPE_FLOW
        : (sticky.touched == STICKY_RESIZE) ? RESIZE_TYPE_WIDTH
        : (sticky.touched == STICKY_RESIZE) ? RESIZE_TYPE_HEIGHT
        :                                     sticky.touched
    ;

    let requestID
        = requestAnimationFrame( sticky_RESIZE2_AnimationFrame );

    sticky_RESIZE_request = { sticky , resize_type , requestID };

if( tag_this) log_key_val(caller, sticky_RESIZE_request, lb1);
};



let   sticky_RESIZE2_AnimationFrame = function(timestamp)
{

let   caller = "sticky_RESIZE2_AnimationFrame";
let log_this = DOM_STICKY_LOG;

if( log_this) log(caller+"("+timestamp+")");

    if(!sticky_RESIZE_request) return;


    if( sticky_RESIZE_request )
        setTimeout( function() {
            if(sticky_RESIZE_request) sticky_RESIZE_request.requestID = requestAnimationFrame( sticky_RESIZE2_AnimationFrame );
        }, 1000/60);

    let consumed_by
        = (sticky_RESIZE_request.resize_type == RESIZE_TYPE_FONT  ) ? sticky_RESIZE3_PAD_FONT_handler()
        : (sticky_RESIZE_request.resize_type == RESIZE_TYPE_FLOW  ) ? sticky_RESIZE4_PAD_FLOW_handler()
        : (sticky_RESIZE_request.resize_type == RESIZE_TYPE_WIDTH ) ? sticky_RESIZE5_PAD_SIZE_handler()
        : (sticky_RESIZE_request.resize_type == RESIZE_TYPE_HEIGHT) ? sticky_RESIZE5_PAD_SIZE_handler()
        :                                                             undefined
    ;

    if(consumed_by) sticky_RESIZE6_MSG_FIT(sticky_RESIZE_request.sticky, consumed_by);


if(log_this && consumed_by) {
    let lfx
        = (sticky_RESIZE_request.resize_type == RESIZE_TYPE_FLOW  ) ? lf3
        : (sticky_RESIZE_request.resize_type == RESIZE_TYPE_FONT  ) ? lf4
        : (sticky_RESIZE_request.resize_type == RESIZE_TYPE_WIDTH ) ? lf5
        : (sticky_RESIZE_request.resize_type == RESIZE_TYPE_HEIGHT) ? lf6
        :                                                             lf2
    ;
    log("%c"+(consumed_by || "NOT CONSUMED"), lbH+lfx);
}

};




const STICKY_FONT_MIN =  8;
const STICKY_FONT_MAX = 64;


let   sticky_RESIZE3_PAD_FONT_handler = function()
{

let   caller = "sticky_RESIZE3_PAD_FONT_handler";
let log_this = DOM_STICKY_LOG;

if( log_this) log("%c "+caller, lf3);


    let  sticky = sticky_RESIZE_request.sticky;
    let pad_msg = sticky_RESIZE3_pad_msg;
    if(!pad_msg) {
        pad_msg = get_sticky_pad_msg( sticky );
        delete pad_msg.last_set_w;
        delete pad_msg.last_set_h;

        sticky_RESIZE3_pad_msg = pad_msg;
        sticky_RESIZE3_pad_msg.onDown_fontSize_px = parseFloat(pad_msg.style.fontSize) || STICKY_FONT_MIN;
if( log_this) log("%c onDown_fontSize_px=["+sticky_RESIZE3_pad_msg.onDown_fontSize_px+"]", lbH+lf8);
    }


    if(typeof sticky_RESIZE_request.touched == "undefined")
        sticky_start_RESIZING( sticky );



    let onMoveDXY = t_tools.get_onMoveDXY();
    let d_y
        = onMoveDXY.y
        * (sticky_RESIZE_request.from_ABOVE ? -1 : 1);

    return sticky_RESIZE3_PAD_FONT(sticky, d_y).consumed_by;
};


let   sticky_start_RESIZING = function(sticky)
{
    sticky_set_RESIZING(sticky);

    sticky_RESIZE_request.touched    = sticky.touched;

    sticky_RESIZE_request.from_ABOVE
        =  has_el_class(sticky, CSS_POINT_NE)
        || has_el_class(sticky, CSS_POINT_NW)
        || has_el_class(sticky, CSS_POINT_EE)
        || has_el_class(sticky, CSS_POINT_WW)

    ;

    sticky_RESIZE_request.from_LEFT
        =  has_el_class(sticky, CSS_POINT_NW)
        || has_el_class(sticky, CSS_POINT_SW)
        || has_el_class(sticky, CSS_POINT_WW)
    ;

};



let RESIZE_PAD_FONT_D_Y_TO_FIT = 0;


let   sticky_RESIZE3_PAD_FONT_TO_FIT = function(sticky,_caller)
{


    sticky_RESIZE7_STICKY_LAYOUT(sticky);

    if(sticky_RESIZE3_pad_msg)
    {
        sticky_RESIZE3_pad_msg.onDown_fontSize_px
            = parseFloat(sticky_RESIZE3_pad_msg.style.fontSize) || STICKY_FONT_MIN;

    }

    let resized;
    do {
        resized = sticky_RESIZE3_PAD_FONT(sticky, RESIZE_PAD_FONT_D_Y_TO_FIT);
    }
    while(!resized.contained_V && !resized.font_unchanged);

};


let   sticky_RESIZE3_PAD_FONT = function(sticky,d_y)
{

let   caller = "sticky_RESIZE3_PAD_FONT";
let log_this = DOM_STICKY_LOG;

if( log_this) caller +="("+sticky.id+" , "+d_y+")";



    let pad_msg = get_sticky_pad_msg( sticky );




    let h_max = window.innerHeight * 0.7;

    let shrinking      = (d_y < 0);
    let ratio          = (d_y / h_max);
    let fontSize_delta = ratio * parseFloat(STICKY_FONT_MAX - STICKY_FONT_MIN);



    let fontSize_from
        =  (sticky_RESIZE3_pad_msg && sticky_RESIZE3_pad_msg.onDown_fontSize_px)
        || parseFloat(pad_msg.style.fontSize)
        || STICKY_FONT_MIN;





    let fontSize_px        = parseFloat(pad_msg.style.fontSize) || STICKY_FONT_MIN;
    fontSize_px            = Math.max( STICKY_FONT_MIN, fontSize_px);
    fontSize_px            = Math.min( STICKY_FONT_MAX, fontSize_px);
    fontSize_px            = fontSize_px.toFixed(1);

    let fontSize_next      = fontSize_from + fontSize_delta;
    fontSize_next          = Math.min(STICKY_FONT_MAX, fontSize_next);
    fontSize_next          = Math.max(STICKY_FONT_MIN, fontSize_next);
    fontSize_next          = fontSize_next.toFixed(1);

    let fontSize_contained = fontSize_px;

    let pad_too_high       = (pad_msg.offsetHeight >= h_max          );
    let font_too_small     = (fontSize_px          <= STICKY_FONT_MIN);
    if(pad_too_high || font_too_small) sticky_set_RESIZE_CAP(sticky);

    let font_unchanged     = (fontSize_next == fontSize_px );


    let consumed_by;
    if( font_unchanged   )
    {
        consumed_by = "FONT UNCHANGED";

    }


    let contained_H;
    let contained_V;
    if(!consumed_by) {
        [  contained_H , contained_V] = is_contained_by_parent(pad_msg);

        if(contained_V || shrinking) {
            sticky.msg_fontSize    = fontSize_next;
            pad_msg.style.fontSize = fontSize_next+"px";
            last_set_fontSize      = sticky.msg_fontSize;
        }
        if(contained_V) fontSize_contained = fontSize_next;
    }


    let expanding_too_big = !shrinking && (pad_too_high || !contained_V);



    if(!consumed_by && expanding_too_big)
    {
        if     (fontSize_from     ) pad_msg.style.fontSize = fontSize_from     +"px";
        else if(fontSize_contained) pad_msg.style.fontSize = fontSize_contained+"px";

        consumed_by = "EXPANDING TOO BIG";
    }


    if(!consumed_by && shrinking && contained_V)
    {
        consumed_by = "SHRINKED CONTAINED";

    }


    if(pad_too_high || (fontSize_next >= STICKY_FONT_MAX) || (fontSize_next <= STICKY_FONT_MIN)) sticky_set_RESIZE_CAP( sticky );
    else                                                                                         sticky_clr_RESIZE_CAP( sticky );



    let result
        = {   consumed_by       : consumed_by || pad_msg.style.fontSize
            , expanding_too_big
            , fontSize_to       : parseFloat( pad_msg.style.fontSize )
            , contained_H
            , contained_V
            , shrinking
            , pad_too_high

            , fontSize_contained
            , fontSize_delta
            , fontSize_from
            , fontSize_next
            , fontSize_px
            , font_too_small

            , font_unchanged
            , STICKY_FONT_MIN
            , STICKY_FONT_MAX
            , pad_msg_offsetHeight : pad_msg.offsetHeight
            , h_max

        };


if( log_this) {
    let l_x
        = font_unchanged ?     lf8
        : shrinking      ? lbH+lf5
        :                  lbH+lf4;

    log_key_val( caller
                 + t_data.TAB + (consumed_by || "FONT CHANGED")
                 + " .. "        + pad_msg.style.fontSize
                 + t_data.TAB
                 , result
                 , l_x);
}

    return result;
};




const PAD_FLOW_DX_MIN = 100;

let   sticky_RESIZE3_pad_msg;

let   sticky_RESIZE4_PAD_FLOW_handler = function()
{

    if(!sticky_RESIZE_request || !sticky_RESIZE_request.sticky)
    {
        log("%c !sticky_RESIZE_request.sticky", lb2);

        return false;
    }
    let  sticky = sticky_RESIZE_request.sticky;


    if(typeof sticky_RESIZE_request.touched == "undefined")
        sticky_start_RESIZING( sticky );



    let         onMoveDXY = t_tools.get_onMoveDXY();
    if(Math.abs(onMoveDXY.x) < PAD_FLOW_DX_MIN)
        return false;



    let pad_msg = sticky_RESIZE3_pad_msg;
    if(!pad_msg) {
        pad_msg = get_sticky_pad_msg( sticky );
        delete pad_msg.last_set_w;
        delete pad_msg.last_set_h;

        sticky_RESIZE3_pad_msg = pad_msg;
    }


    let consumed_by = sticky_RESIZE4_PAD_FLOW_NEXT(sticky);


    return consumed_by;
};


let   sticky_RESIZE4_PAD_FLOW_NEXT = function(sticky)
{

let   caller = "sticky_RESIZE4_PAD_FLOW_NEXT";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) caller +="("+sticky.id+")";





    let    this_MS = new Date().getTime();
    let    delayMS = sticky_RESIZE_request.last_RESIZE_ms
        ? (this_MS - sticky_RESIZE_request.last_RESIZE_ms) : 0;
    if(    delayMS && (delayMS < STICKY_RESIZE_INTERVAL))
        return false;

    sticky_RESIZE_request.last_RESIZE_ms = this_MS;


    let       onMoveDXY = t_tools.get_onMoveDXY();
    let d_x = onMoveDXY.x * (sticky_RESIZE_request.from_LEFT ? -1 : 1);

    let curr_class             = sticky_clr_WS_CLASS(sticky) || CSS_WS_DEFAULT;
    let                 next   = 0;
    while(   (          next   < CSS_WS_XX.length)
          && (CSS_WS_XX[next] != curr_class      ))
        next                  += 1;

    next     += (d_x > 0) ? 1 : -1;






    if(   (next >= CSS_WS_XX.length)
       || (next <  0               )
      ) {
        add_el_class(sticky, curr_class);

        if((next <  0) || (next >= CSS_WS_XX.length)) sticky_set_RESIZE_CAP( sticky );
        else                                          sticky_clr_RESIZE_CAP( sticky );
        return false;
    }


    t_tools.zap_onMoveDXY();



    let previous_pad_flow = sticky.pad_flow;
    last_set_pad_flow     = CSS_WS_XX[next];

    sticky_set_WS_CLASS(sticky, last_set_pad_flow);


    if(sticky.pad_flow == CSS_WS_NOWRAP)
    {
        set_pad_msg_nowrap_height( sticky );
    }

    else if(previous_pad_flow == CSS_WS_NOWRAP)
    {
        let pad_msg = get_sticky_pad_msg( sticky );
        if( pad_msg.nowrap_saved_minHeight)
        {
if( tag_this) log("%c LEAVING ["+previous_pad_flow+"] .. RESTORING HEIGHT "+pad_msg.nowrap_saved_minHeight+" .. SETTING ["+sticky.pad_flow+"] %c"+caller, lbH+lf3, lbH);
            pad_msg.style.minHeight = pad_msg.nowrap_saved_minHeight;
            pad_msg.style.maxHeight = pad_msg.nowrap_saved_maxHeight;
            delete pad_msg.nowrap_saved_minHeight;
            delete pad_msg.nowrap_saved_maxHeight;
        }
        else {
if( tag_this) log("%c LEAVING ["+previous_pad_flow+"] .. NO SAVED HEIGHT "+pad_msg.style.height           +" .. SETTING ["+sticky.pad_flow+"] %c"+caller, lbH+lf3, lbH);
            if( parseInt(pad_msg.style.height) ) {
                pad_msg.style.minHeight = pad_msg.style.height;
                pad_msg.style.maxHeight = pad_msg.style.height;
            }
            else {
                pad_msg.style.minHeight = WH_CONFINED_PERCENT;
                pad_msg.style.maxHeight = WH_CONFINED_PERCENT;
            }
        }
    }

    sticky_RESIZE6_MSG_FIT(sticky, caller);

    sticky_RESIZE3_PAD_FONT_TO_FIT(sticky, caller);

if( log_this) log(caller+"("+d_x+") %c"+(next + 1)+"/"+CSS_WS_XX.length+" %c"+sticky.pad_flow, lfX[next+1], lbH+lfX[next+1]);
    return "FLOW "+sticky.pad_flow;

};


let set_pad_msg_nowrap_height = function(sticky)
{

let   caller = "set_pad_msg_nowrap_height";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) caller +="("+sticky.id+")";


    let pad_msg         = get_sticky_pad_msg( sticky );
    if(!pad_msg.nowrap_saved_minHeight && parseInt(pad_msg.style.minHeight))
    {
        pad_msg.nowrap_saved_minHeight = pad_msg.style.minHeight;
        pad_msg.nowrap_saved_maxHeight = pad_msg.style.maxHeight;
if( tag_this) log("%c SAVING HEIGHT ["+pad_msg.nowrap_saved_minHeight+"] %c"+caller, lbH+lf3, lbH);
    }


    if( pad_msg.style.maxHeight != "fit-content")
    {
        pad_msg.style.height     = "fit-content";
        pad_msg.style.minHeight  = "fit-content";
        pad_msg.style.maxHeight  = "fit-content";

if( tag_this) log("%c SETTING height=["+pad_msg.style.height+"] %c"+caller, lbH+lf4, lbH);
    }

};




const PAD_SIZE_DXY_MIN = 5;


let   sticky_RESIZE5_PAD_SIZE_handler = function()
{

    if(!sticky_RESIZE_request || !sticky_RESIZE_request.sticky)
    {
        log("%c !sticky_RESIZE_request.sticky", lb2);

        return false;
    }
    let  sticky = sticky_RESIZE_request.sticky;


    if(typeof sticky_RESIZE_request.touched == "undefined")
    {
        sticky_start_RESIZING( sticky );

        let dragging_top
            =        (sticky.touched_dir == CSS_POINT_NW)
            ||       (sticky.touched_dir == CSS_POINT_NE);

        let sticky_is_bellow
            =   has_el_class(sticky, CSS_POINT_SE)
            ||  has_el_class(sticky, CSS_POINT_SW) ;

        sticky_RESIZE_request.from_ABOVE
            =   dragging_top
            && !sticky_is_bellow
        ;


    }


    let             onMoveDXY    = t_tools.get_onMoveDXY();
    if(   (Math.abs(onMoveDXY.x) < PAD_SIZE_DXY_MIN)
       && (Math.abs(onMoveDXY.y) < PAD_SIZE_DXY_MIN)
      )
        return false;



    let pad_msg = sticky_RESIZE3_pad_msg;
    if(!pad_msg) {
        pad_msg = get_sticky_pad_msg( sticky );
        delete pad_msg.last_set_w;
        delete pad_msg.last_set_h;

        sticky_RESIZE3_pad_msg = pad_msg;
    }


    let consumed_by = sticky_RESIZE5_PAD_WH(sticky);


    return consumed_by;
};


let   sticky_RESIZE5_PAD_WH = function(sticky)
{

    let   pad_msg = get_sticky_pad_msg( sticky );
    let       bcr = pad_msg.getBoundingClientRect();
    let onMoveDXY = t_tools.get_onMoveDXY();



    let      last_set_w =  pad_msg.last_set_w
        ?                  pad_msg.last_set_w
        :                  bcr.width;

    let             d_x = onMoveDXY.x * (sticky_RESIZE_request.from_LEFT  ? -1 : 1);
    let               w = last_set_w + d_x;
 w = Math.max(STICKY_W_MIN, w);
    let                            w_max = window.innerWidth  * 0.7;
 w = Math.min(w_max , w);
 w = parseInt(w);



    let      last_set_h =  pad_msg.last_set_h
        ?                  pad_msg.last_set_h
        :                  bcr.height;

    let             d_y = onMoveDXY.y * (sticky_RESIZE_request.from_ABOVE ? -1 : 1);
    let               h = last_set_h + d_y;
 h = Math.max(STICKY_H_MIN, h);
    let                            h_max = window.innerHeight * 0.7;
 h = Math.min(h_max , h);
 h = parseInt(h);



    let capped
        =  ((h >= h_max) || (h <= STICKY_H_MIN))
        || ((w >= w_max) || (w <= STICKY_W_MIN))
    ;
    if( capped ) sticky_set_RESIZE_CAP( sticky );
    else         sticky_clr_RESIZE_CAP( sticky );



    if(   ((w >= w_max) || (w <= STICKY_W_MIN))
       && ((h >= h_max) || (h <= STICKY_H_MIN))
      ) {

        return false;
    }


    t_tools.zap_onMoveDXY();


    return sticky_SETSIZE_PAD_WH(sticky,w,h);
};


let   sticky_SETSIZE_PAD_WH = function(sticky,w,h)
{

let   caller = "sticky_SETSIZE_PAD_WH";
let log_this = DOM_STICKY_LOG;



    let pad_msg = get_sticky_pad_msg( sticky );
    w = w || sticky.pad_msg_W;
    h = h || sticky.pad_msg_H;
    if(!w || !h) {
        let bcr   = pad_msg.getBoundingClientRect();
        w = w || bcr.width;
        h = h || bcr.height;
    }


    pad_msg.last_set_w          = w;

    pad_msg.style.width         = w+"px";
    pad_msg.style.minWidth      = w+"px";
    pad_msg.style.maxWidth      = w+"px";

    if( has_el_class(sticky, CSS_WS_NOWRAP) )
    {
        set_pad_msg_nowrap_height( sticky );
    }
    else {
        pad_msg.last_set_h      = h;
        pad_msg.style.height    = h+"px";

        pad_msg.style.minHeight = h+"px";
        pad_msg.style.maxHeight = h+"px";
    }

    sticky.pad_msg_W            = w;
    sticky.pad_msg_H            = h;

if( log_this) log(caller , { w , maxWidth  : pad_msg.style.maxWidth
                           , h , maxHeight : pad_msg.style.maxHeight });
    return "WH=["+w+" "+h+"]";

};



let   sticky_RESIZE6_MSG_FIT = function(sticky, consumed_by)
{

let   caller = "sticky_RESIZE6_MSG_FIT";
let log_this = DOM_STICKY_LOG;

if( log_this)
    log("%c "+caller+"( %c"+get_n_lbl(sticky)+"%c) %c"+consumed_by
        ,lf5           ,lbH+lf5                      ,lbA,lb4            );




    let         pad_msg = get_sticky_pad_msg( sticky );
    if( has_el_class(sticky, CSS_WS_NOWRAP) )
    {
        set_pad_msg_nowrap_height(sticky);
    }
    else {
        pad_msg.style.width  = "fit-content";
        pad_msg.style.height = "fit-content";

    }

    let             bcr = pad_msg.getBoundingClientRect();


    let      last_set_w = pad_msg.last_set_w
        ?                 pad_msg.last_set_w
        :                 bcr.width
    ;
    let               w = parseInt(last_set_w);
 w = Math.max(STICKY_W_MIN, w);
    let                            w_max = window.innerWidth * 0.7;
 w = Math.min(w_max, w);

    if((w >=        w_max) || (w <= STICKY_W_MIN)) sticky_set_RESIZE_CAP( sticky );
    else                                           sticky_clr_RESIZE_CAP( sticky );


    let      last_set_h = pad_msg.last_set_h
        ?                 pad_msg.last_set_h
        :                 bcr.height
    ;
    let               h = parseInt(last_set_h);
 h = Math.max(STICKY_H_MIN, h);
    let                            h_max = window.innerHeight * 0.7;
 h = Math.min(h_max, h);

    if((h >=        h_max) || (h <= STICKY_H_MIN)) sticky_set_RESIZE_CAP( sticky );
    else                                           sticky_clr_RESIZE_CAP( sticky );


    let                 shrinking = (w < last_set_w);
    let pad_too_high = !shrinking && (pad_msg.offsetHeight >= w_max);
    if( pad_too_high )
    {

if(log_this) log("pad_too_high=["+pad_too_high+"] .. (pad_msg.offsetHeight >= h_max)=["+pad_msg.offsetHeight+"]");
        return;
    }



if( log_this && (pad_msg.last_set_w  != w)) {
    let cs = window.getComputedStyle(pad_msg);
    log("%c WH "+cs.width+" "+cs.height,lf3);
}

    if( pad_msg.last_set_w    != w) {
        pad_msg.style.width    = w+"px";
        pad_msg.style.minWidth = w+"px";
        pad_msg.style.maxWidth = w+"px";
        pad_msg.last_set_w     = w;

if( log_this) log(caller, { w , maxWidth : pad_msg.style.width });
    }



    sticky_RESIZE7_STICKY_LAYOUT(sticky);
};




const PAD_W_MIN = 32;
const PAD_H_MIN = 32;


let   sticky_RESIZE7_STICKY_LAYOUT = function(sticky)
{

let   caller = "sticky_RESIZE7_STICKY_LAYOUT";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) log("%c"+caller+"("+get_n_lbl(sticky)+")",lbH+lf6);



    let sticky_pad   = get_sticky_pad    ( sticky );
    let pad_num      = get_sticky_pad_num( sticky );
    let pad_msg      = get_sticky_pad_msg( sticky );
    let pad_dat      = get_el_child_with_class(sticky_pad, STICKY_PAD_DAT);



    if( sticky.msg_fontSize )
        pad_msg.style.fontSize = sticky.msg_fontSize+"px";



    let dat_bcr = pad_dat.getBoundingClientRect();
    let msg_bcr = pad_msg.getBoundingClientRect();
    let num_bcr = pad_num.getBoundingClientRect();



    let     h = PAD_H_MIN +                 msg_bcr.height + dat_bcr.height;
    let     w = PAD_W_MIN + num_bcr.width + msg_bcr.width;

    let h_max = parseInt(window.innerHeight * 0.7 + STICKY_MARGIN);
    let w_max = parseInt(window.innerWidth  * 0.7 + STICKY_MARGIN);

    h         = parseInt( Math.min(h, h_max) );
    w         = parseInt( Math.min(w, w_max) );

    sticky_pad.style.width  = w+"px";
    sticky_pad.style.height = h+"px";

    sticky.pad_W            = w;
    sticky.pad_H            = h;


if( tag_this) {
    let sticky_has_scrollbar = has_scrollbar( get_sticky_pad_msg(sticky) );
    log_key_val_group( caller
                       , {   sticky_pad
                           , pad_num
                           , pad_msg
                           , pad_dat
                           , num_bcr
                           , msg_bcr
                           , dat_bcr
                           , w
                           , h
                           , sticky_pad_style_width  : sticky_pad.style.width
                           , sticky_pad_style_height : sticky_pad.style.height
                           , sticky_has_scrollbar
                       }, lbH+lfX[sticky_has_scrollbar ? 5:6], true);

}


};



let   sticky_RESIZE8_END = function()
{
    if(onWork_STICKY && sticky_RESIZE3_pad_msg)
        sticky_RESIZE3_PAD_FONT_TO_FIT(onWork_STICKY, "sticky_RESIZE8_END");

    if( sticky_RESIZE_request )
        sticky_RESIZE8_CANCEL();

    sticky_RESIZE3_pad_msg = null;

};


let   sticky_RESIZE8_CANCEL = function()
{

let   caller = "sticky_RESIZE8_CANCEL";
let log_this = DOM_STICKY_LOG;

if( log_this) log("%c"+caller,lbH+lf5);

    if(!sticky_RESIZE_request) return;

    if(sticky_RESIZE_request.requestID)
        cancelAnimationFrame( sticky_RESIZE_request.requestID );

    sticky_clr_RESIZING();
    sticky_clr_RESIZE_CAP();
    sticky_RESIZE_request = null;
};






let sticky_was_moved;
let set_dimm_was_postponed_by;


let t_sticky_onUp = function(sticky)
{
    if(!t_sticky_GET_COUNT()) return;

let   caller = "t_sticky_onUp";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) log("%c"+caller+"("+get_id_or_tag(sticky)+") .. onWork_STICKY=["+get_id_or_tag(onWork_STICKY)+"]", lbF+lb5);
if( log_this) t_fly.t_log_event_status(caller, lf5);



    sticky_RESIZE8_END();



    sticky_was_moved = false;
    sticky_MAGNET0_PINNED_onMoveDXY_clear();



    let onDown_EL     = t_tools.t_get_onDown_EL();
    let onDown_sticky
        = (onDown_EL && onDown_EL.id.startsWith("sticky_"))
        && onDown_EL;

if( log_this) log("...onDown_sticky=["+get_id_or_tag(onDown_sticky)+"]");


    if     (sticky       ) del_el_class(sticky       , t_data.CSS_PRESSED);
    else if(onWork_STICKY) del_el_class(onWork_STICKY, t_data.CSS_PRESSED);
    else if(onDown_sticky) del_el_class(onDown_sticky, t_data.CSS_PRESSED);



    if( scrolling_sticky  ) {
        del_el_class(scrolling_sticky, t_data.CSS_SCROLLING);

        scrolling_sticky = null;
    }


    if     (sticky       ) t_sticky_MAGNET_NOW();
    else if(onWork_STICKY) t_sticky_MAGNET(onWork_STICKY, "POINTER UP");



    if(!onWork_STICKY && !onDown_sticky && !sticky_ALL_DIMMED())
    {
        if(set_dimm_was_postponed_by == DIMM_POSTPONED_BY_SCROLLING)
        {
if( tag_this) log("%c UP %c EXTRA DIMM-DELAY .. "+set_dimm_was_postponed_by, lbb+lb4, lf5);

            t_sticky_SET_DIMMED(true, "SCROLLING DONE", DIMM_POSTPONED_BY_SCROLLING_DELAY);
        }
        else if( set_dimm_was_postponed_by )
        {
if( tag_this) log("%c UP %c DEFAULT DIMM-DELAY .. "+get_n_lbl(set_dimm_was_postponed_by), lbb+lb4, lf5);

            t_sticky_SET_DIMMED(true,"POINTER UP");
        }
        else {
if( tag_this) log("%c UP %c INSTANT DIMM .. (not postponed)", lbb+lb4, lf5);

            sticky_SET_DIMMED_NOW( "POINTER UP");
        }
    }

    set_dimm_was_postponed_by = false;


    if((onWork_STICKY || onDown_sticky) && !sticky_ALL_DIMMED()) sticky_set_STICKY_RAISED();
    else                                                         sticky_clr_STICKY_RAISED();




    if(!t_sticky_is_EDITING( onWork_STICKY )) onWork_STICKY = null;


};





let t_sticky_CLICK_CB = function(sticky=onWork_STICKY)
{

let   caller = "t_sticky_CLICK_CB";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) caller += "("+(sticky ? sticky.id:"")+")";
if( log_this) log("%c"+caller, lbH+lf0);
if( log_this) t_fly.t_log_event_status(caller, lf1);


    let sel_text = t_tools.t_get_current_sel_text() || t_tools.t_get_onDown_SEL_TEXT();



    let state0_is_bouncing_EDIT     =  dom_tools.t_is_bouncing_e_type("STICKY_DONE", caller, 500);
    let state0_is_editing           = !state0_is_bouncing_EDIT && t_sticky_is_EDITING();
    let state0_clicked_tool_panel   = !t_tools.t_some_tool_clicked();
    let state1_sticky_ring_deployed =  t_tools.t_dimm_mask_displayed();
    let state2_sticky_has_focus     =  has_el_class(sticky  , CSS_HAS_FOCUS   );
    let state3_clicked_hand         =  sticky  && (sticky.touched == STICKY_HAND     );
    let state3_clicked_pen          =  sticky  && (sticky.touched == STICKY_PEN      );
    let state3_clicked_rotate       =  sticky  && (sticky.touched == STICKY_ROTATE   );
    let state3_onSticky_touched     =  sticky  ?   sticky.touched  : ""               ;
    let state4_clicked_pad          =  sticky  && (sticky.touched == STICKY_PAD      );
    let state5_clicked_sticky_fix   =  sticky  && (sticky.touched == STICKY_FIX      );
    let state6_clicked_sticky_ring  =  has_el_class(sticky  , CSS_STICKY_RING );
    let state7_target_fixed         =  has_el_class(sticky  , CSS_FIXED       );
    let state8_target_dimmed        =  has_el_class(sticky  , CSS_DIMMED      )
  || has_el_class(sticky  , CSS_DIMMED_OFF  );
    let state9_target_fixed         = (sticky.style.position      == "fixed"         );



    let action0_sticky_ring_select      =  state6_clicked_sticky_ring && !state5_clicked_sticky_fix;
    let action1_sel_text_on_touched     = !state6_clicked_sticky_ring &&  state3_onSticky_touched && (sel_text != "");
    let action2_pad_not_fixed_choose    = !state6_clicked_sticky_ring &&  state4_clicked_pad  && !state7_target_fixed && !state8_target_dimmed;
    let action3_clicked_pen_EDITING     = !state0_is_bouncing_EDIT    &&  state3_clicked_pen && !state0_is_editing;
    let action4_sticky_fix_unpin        =  state5_clicked_sticky_fix;
    let action5_clicked_handle_or_fixed = !state6_clicked_sticky_ring && (state3_clicked_hand || state3_clicked_rotate || state7_target_fixed);



 let transition; let l_x;
    if     ( action0_sticky_ring_select      ) { transition = "STICKY RING"                 +" .. STOP CHOOSER"   ; l_x = 9; }
    else if( action1_sel_text_on_touched     ) { transition = "STICKY PAD WITH SELECTION"   +" .. PASTE SELECTION"; l_x = 1; }
    else if( action2_pad_not_fixed_choose    ) { transition = "STICKY PAD"                  +" .. START CHOOSER"  ; l_x = 2; }
    else if( action3_clicked_pen_EDITING     ) { transition = "STICKY CLICK PEN"            +" .. EDIT STICKY"    ; l_x = 3; }
    else if( action4_sticky_fix_unpin        ) { transition = "STICKY PIN"                  +" .. UNPIN STICKY"   ; l_x = 4; }
    else if( action5_clicked_handle_or_fixed ) { transition = "STICKY CLICK HAND OR FIXED"  +" .. TOGGLE FIXED"   ; l_x = 5; }



if(tag_this)
{
    log_key_val(  "CLICK"
              , { className : "["+(sticky ? sticky.className : "")+"]"
                , state0_is_bouncing_EDIT
                , state0_is_editing
                , state0_clicked_tool_panel
                , state1_sticky_ring_deployed
                , state2_sticky_has_focus
                , state3_clicked_hand
                , state3_clicked_pen
                , state3_clicked_rotate
                , state3_onSticky_touched
                , state4_clicked_pad
                , state5_clicked_sticky_fix
                , state6_clicked_sticky_ring
                , state7_target_fixed
                , state8_target_dimmed
                , state9_target_fixed
                , sel_text                         : "["+ellipsis_short(sel_text)+"]"
                , action0_sticky_ring_select
                , action1_sel_text_on_touched
                , action2_pad_not_fixed_choose
                , action3_clicked_pen_EDITING
                , action4_sticky_fix_unpin
                , action5_clicked_handle_or_fixed
              }
              , lbX[l_x], false);

    if(sticky) t_sticky_LOG(sticky, transition, lfX[l_x]);
}


    if     ( action0_sticky_ring_select      ) { sticky_RING_select     (sticky          ); }
    else if( action1_sel_text_on_touched     ) { sticky_set_sel_text    (sticky, sel_text); }
    else if( action2_pad_not_fixed_choose    ) { t_sticky_CHOOSE        (                ); }
    else if( action3_clicked_pen_EDITING     ) { t_sticky_EDIT          (sticky          ); }
    else if( action4_sticky_fix_unpin        ) { sticky_unpin_sticky_num(sticky.num      ); t_sticky_reorder();   }
    else if( action5_clicked_handle_or_fixed ) { sticky_FIXED_TOGGLE    (sticky          ); }
    else if(tag_this)                            logBIG("NOTHING TO DO", lf8);


    if(action4_sticky_fix_unpin && state1_sticky_ring_deployed && !t_sticky_RING_layout())
    {
        t_sticky_RING_stop (caller);
        t_tools.t_dimm_stop(caller);
    }


    return transition;
};






const STICKY_TOOL_HALF_HEIGHT = 36;


let sticky_scrollTo = function(sticky_num, fixed_x, fixed_y)
{

let   caller = "sticky_scrollTo";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) t_fly.t_log_event_status(caller+"(sticky_num=["+sticky_num+"], fixed_xy=["+fixed_x+" "+fixed_y+"])", lf5);


    let sticky = sticky_GET( sticky_num );

    t_sticky_set_onWork_STICKY(sticky);



    let xy = get_el_xy(sticky, caller);
    let  x = Math.floor(xy.x                      );
    let  y = Math.floor(xy.y + sticky.offsetHeight / 2);

    if( !t_view.t_view1_is_xy_in_viewport(x, y) )
    {
        let scrollBehavior
            = t_view.t_view2_is_xy_near_viewport(x, y)
            ? "smooth"
            : ""
        ;

        let { w_W,w_H } = t_tools.t_cache_wph_WH();
        x -= w_W / 2;
        y -= w_H / 2;

        x  = Math.max(0, x);
        y  = Math.max(0, y);

        t_tools.t_window_scrollTo(x, y, scrollBehavior);
    }

};






let   STICKY_ONLAYOUT_DELAY = 250;

let   sticky_onLayout_timer;

let t_sticky_onLayout = function()
{
    sticky_set_SLOW_LAYOUT();

    if(sticky_onLayout_timer) clearTimeout( sticky_onLayout_timer );
    sticky_onLayout_timer   =   setTimeout( sticky_onLayout_handler, STICKY_ONLAYOUT_DELAY);
};


let   sticky_onLayout_handler = function()
{

let   caller = "sticky_onLayout_handler";
let log_this = DOM_STICKY_LOG;

if( log_this) log("%c"+caller, lbH+lf4);

    sticky_onLayout_timer = null;
    let show_seekzone = t_prop.get(t_data.SHOW_SEEKZONE);

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {

        let sticky = sticky_array[sticky_num];
        if(!sticky                          ) continue;

        set_el_class_on_off(sticky, t_data.SHOW_SEEKZONE, show_seekzone);

        if(!has_el_class(sticky, CSS_PINNED)) continue;
        if( has_el_class(sticky, CSS_FIXED )) continue;

if( log_this) log(sticky_num+"%c sticky=["+get_n_lbl(sticky)+"] "+sticky.classList, lbH+lf5);


        let value = sticky_get_value( sticky );

        sticky_set_value(sticky, value);

    }
    t_tools.t_save_update_post(caller);

    setTimeout(function() { sticky_clr_SLOW_LAYOUT(); }, 1000);
};


let t_sticky_reorder = function()
{

let   caller = "t_sticky_reorder";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbH+lf6);


if( log_this) log("%c NOT SORTED .. sticky_array.length=["+sticky_array.length+"]...", lf3);
    let targets = [];
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky     = sticky_array[ sticky_num ];
        if(!sticky                                 ) continue;


        targets.push( sticky );
    }





if( log_this) log("SORT ON POSITION");
    targets
        = targets.sort(
                       function(a,b) {
                           if(!a.offsetTop)                 return  1;
                           if(!b.offsetTop)                 return -1;

                        let    a_offsetTop  = a.offsetTop  + ((a.style.position == "fixed") ? window.scrollY : 0);
                        let    b_offsetTop  = b.offsetTop  + ((b.style.position == "fixed") ? window.scrollY : 0);

                           if( a_offsetTop  > b_offsetTop ) return  1;
                           if( a_offsetTop  < b_offsetTop ) return -1;

                        let    a_offsetLeft = a.offsetLeft + ((a.style.position == "fixed") ? window.scrollX : 0);
                        let    b_offsetLeft = b.offsetLeft + ((b.style.position == "fixed") ? window.scrollX : 0);
                           if( a_offsetLeft > b_offsetLeft) return  1;
                           if( a_offsetLeft < b_offsetLeft) return -1;
                           else                             return  0;
                       }
                      );



    sticky_array = [];
    for(let sticky_num= 0, i= 0; i < targets.length; ++i)
    {
        let sticky                    =   targets[i];
        sticky.num                    = ++sticky_num;
        sticky_reorder_num_label_color(   sticky );
        sticky.style.zIndex           =   sticky.num + t_data.ZINDEX_STICKY_TOOL_ZERO;

        sticky_array[ sticky_num ]    = sticky;


    }


if( log_this) log("%c ... SORTED .. sticky_array.length=["+sticky_array.length+"]...", lf4);
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky     =  sticky_array[ sticky_num ];
        if(!sticky     )  continue;

        sticky.num =           sticky_num;
        sticky.id  = "sticky_"+sticky_num;


    }

    t_tools.t_save_update_post(caller);
};


let   sticky_reorder_num_label_color = function(sticky)
{

let   caller = "sticky_reorder_num_label_color";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this)
    log(caller+"%c"+sticky.id+"%c num=["+sticky.num+"] %c msg=["+ellipsis_short(strip_HTML(sticky.msg))+"]"
        ,        lbL+lf8      ,lbC+lf3                ,lbR+lf3                                             );


    let sticky_pad_num = get_sticky_pad_num( sticky );
    if( sticky_pad_num )
        sticky_pad_num.innerHTML = (sticky.num == 10) ? "X" : sticky.num;



    let sticky_pad = get_sticky_pad( sticky );
    sticky_pad.className
        = "sticky_pad bg"+(sticky.num % 10)
    ;

};


let t_sticky_reorder_required_on_scroll = function()
{
    sticky_CLEAR_HIGHLIGHT();

    let count        = 0;
    let fixed_count  = 0;
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky = sticky_array[ sticky_num ];
        if(!sticky                                 ) continue;
        if(!has_el_class(sticky, CSS_PINNED)) continue;

        count       += 1;
        fixed_count += (sticky.style.position == "fixed");
    }


    return  fixed_count
        && (fixed_count != count)
    ;
};





let t_sticky_SHOW_SEEKZONE_sync = function(state)
{
    for(let i= 0; i < sticky_array.length; ++i)
    {
        let sticky  = sticky_array[i];
        if(!sticky) continue;
        if(!has_el_class(sticky, CSS_PINNED)) continue;

        if(state) sticky_format_pad_anchor_path( sticky );
        else      sticky_format_pad            ( sticky );

        set_el_class_on_off(sticky, t_data.SHOW_SEEKZONE, state);
    }

    if(!state) t_sticky_format_pad_all();
};







let t_sticky_set_MOVING = function(sticky)
{
    sticky.touched = STICKY_HAND;
};


let t_sticky_is_MOVING = function(sticky)
{
    return sticky && (sticky.touched == STICKY_HAND);
};


let t_sticky_is_RESIZING = function(sticky)
{
    return (sticky && (sticky.touched == STICKY_REFONT))
        || (sticky && (sticky.touched == STICKY_REFLOW))
        || (sticky && (sticky.touched == STICKY_RESIZE))
        ||  sticky_RESIZE_request
    ;
};


let t_sticky_is_ORIENTING = function(sticky)
{
    return (sticky.touched == STICKY_ROTATE)
        || (sticky.touched == STICKY_PAD ) && has_el_class(sticky, CSS_FIXED )
    ;
};


let t_sticky_is_EDITING = function(sticky)
{
    return !t_tools.t_get_onDown_EL()
        &&  sticky && (sticky.touched == STICKY_PAD)
        && !scrolling_sticky
        && !sticky_RESIZE_request
    ;
};




let last_set_dir_class;
let last_set_pad_flow;





let sticky_set_SLOW_LAYOUT   = function(                      ) {        t_tools.t_dom_tools_html_set_el_class_on_off(CSS_SLOW_LAYOUT  , true ); };
let sticky_clr_SLOW_LAYOUT   = function(                      ) {        t_tools.t_dom_tools_html_set_el_class_on_off(CSS_SLOW_LAYOUT  , false); };
let sticky_set_STICKY_RAISED = function(                      ) {        t_tools.t_dom_tools_html_set_el_class_on_off(CSS_STICKY_RAISED, true ); };
let sticky_clr_STICKY_RAISED = function(                      ) {        t_tools.t_dom_tools_html_set_el_class_on_off(CSS_STICKY_RAISED, false); };


let sticky_set_DIR_CLASS     = function(sticky,dir_class      ) {        set_el_class_removing(sticky, dir_class, CSS_POINT_XX); sticky.dir_class = dir_class; last_set_dir_class = dir_class; };
let sticky_clr_DIR_CLASS     = function(sticky                ) { return set_el_class_removing(sticky, ""       , CSS_POINT_XX); };


let sticky_set_WS_CLASS      = function(sticky,ws_class       ) {        set_el_class_removing(sticky,  ws_class, CSS_WS_XX   ); sticky.pad_flow  = ws_class;  last_set_pad_flow  = ws_class;  };
let sticky_clr_WS_CLASS      = function(sticky                ) { return set_el_class_removing(sticky, ""       , CSS_WS_XX   ); };


let sticky_set_RESIZING      = function(sticky                ) { if(!sticky_RESIZE_request) sticky_RESIZE_request = { sticky };   add_el_class(sticky                      , CSS_RESIZING  ); };
let sticky_clr_RESIZING      = function(                      ) { if(!sticky_RESIZE_request) return;                               del_el_class(sticky_RESIZE_request.sticky, CSS_RESIZING  ); };
let sticky_set_RESIZE_CAP    = function(sticky                ) { if(!sticky_RESIZE_request) sticky_RESIZE_request = { sticky };   add_el_class(sticky_RESIZE_request.sticky, CSS_RESIZE_CAP); };
let sticky_clr_RESIZE_CAP    = function(                      ) { if(!sticky_RESIZE_request) return;                               del_el_class(sticky_RESIZE_request.sticky, CSS_RESIZE_CAP); };





let sticky_set_POINT_DIR = function(sticky, pointing_E, pointing_N, switching_N, switching_S, switching_E, switching_W)
{

    set_el_class_removing(sticky, "", CSS_POINT_XX);

    let dir_class;

    if     (switching_N  ) dir_class = pointing_E ? CSS_POINT_NE : CSS_POINT_NW;
    else if(switching_S  ) dir_class = pointing_E ? CSS_POINT_SE : CSS_POINT_SW;

    else if(switching_E  ) dir_class = pointing_N ? CSS_POINT_NE : CSS_POINT_SE;
    else dir_class = pointing_N ? CSS_POINT_NW : CSS_POINT_SW;

    if(dir_class) sticky_set_DIR_CLASS(sticky, dir_class);
};


let sticky_get_POINT_DIR = function(sticky)
{
    return sticky.classList.contains(CSS_POINT_EE) ? CSS_POINT_EE
        :  sticky.classList.contains(CSS_POINT_SE) ? CSS_POINT_SE
        :  sticky.classList.contains(CSS_POINT_SW) ? CSS_POINT_SW
        :  sticky.classList.contains(CSS_POINT_WW) ? CSS_POINT_WW
        :  sticky.classList.contains(CSS_POINT_NW) ? CSS_POINT_NW
        :  sticky.classList.contains(CSS_POINT_NE) ? CSS_POINT_NE
        :                                        ""
    ;
};





let t_sticky_get_SEEK_NEXT = function(log_this=false)
{

let   caller = "t_sticky_get_SEEK_NEXT";


    let dismissed_by
        = (                      !sticky_SEEK_TARGET                          ) ? "NO sticky_SEEK_TARGET"
        : ( has_el_class(  sticky_SEEK_TARGET   , CSS_FIXED         )  ) ? "has_el_class(  sticky_SEEK_TARGET,CSS_FIXED      )"
        : (!has_el_class(  sticky_SEEK_TARGET   , CSS_SEEK_TARGET   )  ) ? "!has_el_class(  sticky_SEEK_TARGET,CSS_SEEK_TARGET)"
        : (                       sticky_SEEK_TARGET.touched == STICKY_HAND   ) ? "touched=["+sticky_SEEK_TARGET.touched+"]"
        : (                       sticky_SEEK_TARGET.touched == STICKY_ROTATE ) ? "touched=["+sticky_SEEK_TARGET.touched+"]"
        :                                                                         ""
    ;

if(log_this && dismissed_by) log(caller+" %c"+dismissed_by, lbH+lf2);
    return dismissed_by ? null : sticky_SEEK_TARGET;
};


let t_sticky_clr_SEEK_NEXT = function(sticky)
{
    if     (!sticky                      ) sticky_set_SEEK_TARGET(null);
    else if( sticky == sticky_SEEK_TARGET) sticky_set_SEEK_TARGET(null);
};


let t_sticky_set_SEEK_NEXT = function(sticky_from, onDown_SCROLL_XY, dir=1)
{

    let caller = "t_sticky_SEEK_NEXT";
let log_this = LOG_MAP.T3_LAYOUT;

let tag_this = DOM_STICKY_TAG || log_this;


    del_el_class(sticky_from, CSS_SEEK_TARGET);

    let sticky = dir
        ?     sticky_get_next_pinned(sticky_from, dir)
        :     sticky_from
    ;
    if( sticky ) {

if( tag_this) log("%c"+caller+"%c"+sticky.num, lbL+lf3, lbR+lf4);
        sticky_set_SEEK_TARGET( sticky );

        t_seek.t_seeker_onMove2_ON_NEXT_STICKY(sticky, onDown_SCROLL_XY);



        let sticky_num = t_sticky_GET_NUM(sticky);
        let    fixed_x = sticky.offsetLeft - onDown_SCROLL_XY.x;
        let    fixed_y = sticky.offsetTop  - onDown_SCROLL_XY.y;

        sticky_scrollTo(sticky_num, fixed_x, fixed_y);

        t_sticky_move_z_on_top( sticky );
        t_sticky_SET_DIMMED(false, "SEEK");
        if(t_prop.get(t_data.SHOW_SEEKZONE) && t_prop.get(t_data.FLOATLOG)) t_sticky_LOG_TOOLTIP(sticky, "SEEK");
    }
    return sticky;
};


let       sticky_SEEK_TARGET;
let   sticky_set_SEEK_TARGET = function(sticky)
{
    if(sticky_SEEK_TARGET) del_el_class(sticky_SEEK_TARGET, CSS_SEEK_TARGET);

    sticky_SEEK_TARGET = sticky;


    if(sticky_SEEK_TARGET) add_el_class(sticky_SEEK_TARGET, CSS_SEEK_TARGET);
};


let   sticky_get_next_pinned = function(sticky_from, dir)
{

    let caller = "sticky_get_next_pinned";
let log_this = LOG_MAP.T3_LAYOUT;



    if(!dir) return sticky_from;

    let idx_from
        = t_sticky_GET_NUM(sticky_from)
        + dir
        - 1
    ;



    let sticky;
    for(let step = 0; step < STICKY_MAX; ++step)
    {
        let sticky_num = 1 + (idx_from + step*dir + STICKY_MAX) % STICKY_MAX;
        sticky         = sticky_GET(sticky_num);

        if( has_el_class(sticky, CSS_PINNED) ) break;
        else                    sticky = null;
    }

if( log_this) log("%c"+caller+"("+sticky_from.id+" dir="+dir+") %c return "+(sticky ? sticky.num : undefined), lbL+lf9, lbR+(sticky ? lf3:lf2));
    return sticky;
};





const DIMM_POSTPONED_BY_SCROLLING       = "DIMM_POSTPONED_BY_SCROLLING";
const DIMM_POSTPONED_BY_SCROLLING_DELAY = 3000;



let t_sticky_SET_DIMMED_IS_PENDING = function()
{
    return (sticky_SET_DIMMED_timer != null);
};



const T_SEEKER_SET_DIMMED_DELAY = 1000;

let   sticky_SET_DIMMED_timer;
let   sticky_SET_DIMMED_callers;

let t_sticky_SET_DIMMED = function(dimmed, _caller, delay)
{
    if(!t_sticky_GET_COUNT()) return;

let   caller = "t_sticky_SET_DIMMED";
let log_this = LOG_MAP.T3_LAYOUT;



    if(sticky_SET_DIMMED_timer) clearTimeout(sticky_SET_DIMMED_timer);
       sticky_SET_DIMMED_timer = null;

    if( dimmed && sticky_ALL_DIMMED ()) { if(log_this) log("%c"+caller+"("+dimmed+") .. sticky_ALL_DIMMED" , lb8); return; }
    if(!dimmed && sticky_NONE_DIMMED()) { if(log_this) log("%c"+caller+"("+dimmed+") .. sticky_NONE_DIMMED", lb0); return; }

if( log_this && (sticky_SET_DIMMED_callers != _caller))
    log("%c"+caller+"("+dimmed+" , "+_caller+", delay=["+delay+"])", lbH+lf3);

    delay =  delay
        || ( dimmed
             ?  T_SEEKER_SET_DIMMED_DELAY
             :  0)
    ;

    sticky_SET_DIMMED_callers += (sticky_SET_DIMMED_callers ? " ":"")+_caller;

    sticky_SET_DIMMED_timer = setTimeout(function() { sticky_SET_DIMMED_handler(dimmed); }, delay);
};


let   sticky_SET_DIMMED_NOW = function(_caller)
{

let   caller = "sticky_SET_DIMMED_NOW";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"("+_caller+")", lbH+lf3);


    if( sticky_ALL_DIMMED() ) return;

    if(sticky_SET_DIMMED_timer) clearTimeout(sticky_SET_DIMMED_timer);

    t_sticky_SET_DIMMED(true, _caller, 0);
};


let   sticky_SET_DIMMED_handler = function(dimmed)
{

let caller   = "sticky_SET_DIMMED_handler";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"("+dimmed+")", lbH+lfX[dimmed ? 0:9]);
if( log_this) t_fly.t_log_event_status(caller, lf8);



    if(!sticky_SET_DIMMED_timer) {
if( log_this) log("%c has been canceled", lbH+lf8);

        return;
    }

    sticky_SET_DIMMED(dimmed);

    sticky_SET_DIMMED_timer   = null;
    sticky_SET_DIMMED_callers = "";
};


let   sticky_SET_DIMMED = function(dimmed)
{

let   caller = "sticky_SET_DIMMED";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this)
    log_key_val_group(caller+"("+dimmed+")"
                      , {   set_dimm_was_postponed_by
                          , sticky_SET_DIMMED_callers
                      }, lbH+lf3, false);



    if(dimmed && sticky_some_fixed())
    {
if( log_this) log("%c"+caller+": DIMMING CANCELED %c SOME FIXED"
                  ,lbL+lf3                       ,lbR+lf9);

        return;
    }


    let should_postpone = t_tools.t_dimm_should_postpone( dimmed );
    if( should_postpone )
    {
        set_dimm_was_postponed_by
            = t_sticky_get_SCROLLING_STICKY()
            ?  DIMM_POSTPONED_BY_SCROLLING
            :  should_postpone;

if( log_this) log("%c"+caller+": DIMMING POSTPONED %c"+set_dimm_was_postponed_by
                  ,lbL+lf6                       ,lbR+lf6);

        t_sticky_SET_DIMMED(dimmed, sticky_SET_DIMMED_callers, T_SEEKER_SET_DIMMED_DELAY);
        return;
    }


    let some_pressed_sticky = sticky_SOME_PRESSED();
if( log_this) log("%c some_pressed_sticky=["+some_pressed_sticky+"]", lbH+lf8);




    let some_not_dimmed_reason;
    let show_seekzone = t_prop.get(t_data.SHOW_SEEKZONE);

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let  sticky = sticky_array[ sticky_num ];
        if( !sticky                                 ) continue;
        if( !has_el_class(sticky, CSS_PINNED)) continue;


        if(!dimmed || some_pressed_sticky || show_seekzone)
        {
            sticky_set_dimmed_state(sticky, false);
        }

        else if(dimmed)
        {

            if(      has_el_class(sticky, CSS_PASTE_TARGET   )) some_not_dimmed_reason = sticky.id +" "+ CSS_PASTE_TARGET;
            else if( has_el_class(sticky, CSS_HAS_FOCUS      )) some_not_dimmed_reason = sticky.id +" "+ CSS_HAS_FOCUS;
            else if( has_el_class(sticky, CSS_PRESSED        )) some_not_dimmed_reason = sticky.id +" "+ CSS_PRESSED;
            else if( has_el_class(sticky, CSS_ANCHOR_DETACHED)) some_not_dimmed_reason = sticky.id +" "+ CSS_ANCHOR_DETACHED;
            else {
                sticky_set_dimmed_state(sticky, true);
            }
        }
    }


    if(  !dimmed
       || some_not_dimmed_reason
       || some_pressed_sticky
      ) {
        let reason =   !dimmed                 ?  "ALL UNDIMMED"
                     :  some_not_dimmed_reason ? ("SOME NOT DIMMED ["+ some_not_dimmed_reason                  +"]")
                     :  some_pressed_sticky    ? ("SOME PRESSED ["   + some_pressed_sticky.id +" "+ CSS_PRESSED+"]")
                     :                     ""
        ;
if( log_this) log("...%c"+reason, lbH+lf8);

        t_sticky_SET_DIMMED(true, "TRY DIMMING LATER: "+reason);
    }

};


let sticky_set_dimmed_state = function(sticky, state)
{
    if(state) {
        add_el_class(sticky, CSS_DIMMED); del_el_class(sticky, CSS_DIMMED_OFF);
    }
    else {
        del_el_class(sticky, CSS_DIMMED); add_el_class(sticky, CSS_DIMMED_OFF);
        setTimeout( function() {          del_el_class(sticky, CSS_DIMMED_OFF); } , 2000);
    }
};



let sticky_some_fixed = function()
{
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let  sticky = sticky_array[ sticky_num ];
        if( !sticky ) continue;
        if(  has_el_class(sticky, CSS_FIXED ) ) return true;
    }
    return false;
};


let sticky_ALL_DIMMED = function()
{
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let  sticky = sticky_array[ sticky_num ];
        if( !sticky ) continue;
        if( !has_el_class(sticky, CSS_DIMMED) ) return false;
    }
    return true;
};


let sticky_NONE_DIMMED = function()
{
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let  sticky = sticky_array[ sticky_num ];
        if( !sticky ) continue;
        if(  has_el_class(sticky, CSS_DIMMED) ) return false;
    }
    return true;
};


let sticky_SOME_PRESSED = function()
{
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let  sticky = sticky_array[ sticky_num ];
        if( !sticky ) continue;
        if(  has_el_class(sticky, CSS_PRESSED) ) return true;
    }
    return false;
};





let t_sticky_unpin_all = function()
{

let   caller = "t_sticky_unpin_all";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log("%c"+caller, lbH+lf2);

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
        sticky_unpin_sticky_num( sticky_num );

    t_tools.t_save_update_post(caller);
};


let   sticky_unpin_sticky_num = function(sticky_num)
{

let   caller = "sticky_unpin_sticky_num";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log("%c"+caller+"("+sticky_num+")", lbH+lf5);


    let sticky = sticky_array[ sticky_num ];
    if(!sticky ) return;

if( log_this) log("...unchecking sticky.num["+sticky.num+"] .. sticky_num["+sticky_num+"] .. sticky.id=["+sticky.id+"]");

    t_tools.t_set_CSS_PINNED(sticky, false);
    sticky.style.display = "none";
    t_sticky_clr_SEEK_NEXT(sticky);

    sticky.date_MS = 0;


};




let sticky_FIXED_START  = function(sticky) { sticky_FIXED_TOGGLE(sticky, true); };
let sticky_FIXED_STOP   = function(      ) { sticky_FIXED_TOGGLE(null  ,false); };
let sticky_FIXED_TOGGLE = function(sticky_to_toggle,state)
{

let   caller = "sticky_FIXED_TOGGLE";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this                    ) log("%c"+caller+"("+(sticky_to_toggle ? sticky_to_toggle.id : "null")+" , state "+state+")", lbH+lf9);
if( log_this && sticky_to_toggle) log("...%c"+sticky_to_toggle.id+".className=["     +sticky_to_toggle.className     +"]", lf8);
if( log_this && sticky_to_toggle) log("...%c"+sticky_to_toggle.id+".style.position=["+sticky_to_toggle.style.position+"]", lf8);


    if( state == undefined) {
        state  = (sticky_to_toggle.style.position != "fixed");

if( log_this) log("...%c state=["+state+"]", lf8);
    }
    let some_unfixed;

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {

        let  sticky = sticky_array[ sticky_num ];
        if( !sticky ) continue;



        if( state )
        {
            if(sticky == sticky_to_toggle)
            {
                add_el_class(sticky, CSS_TOUCHED);

                if((sticky.style.position != "fixed")) {
                    sticky.style.position  = "fixed";
                    add_el_class(sticky, CSS_FIXED);
if( tag_this) log("%c FIXING "+sticky.id, lbH+lf4);

                    let      to = get_el_transformOrigin( sticky );
                    let  x = to.x + Math.min(sticky.offsetLeft - window.scrollX, window.innerWidth - STICKY_FIX_RESOLUTION);
                    let  y = to.y + Math.min(sticky.offsetTop  - window.scrollY, window.innerHeight- STICKY_FIX_RESOLUTION);
                    sticky_MOVE_FLIP({ sticky, x,y, layout_changed:true });
                }
            }
        }


        else {

            if( has_el_class(sticky, CSS_TOUCHED) )
                del_el_class(sticky, CSS_TOUCHED);

            if( sticky.style.position == "fixed"   ) {
                sticky.style.position  = "absolute";
                del_el_class(sticky, CSS_FIXED);
if( tag_this) log("%c UNFIXING "+sticky.id, lbH+lf6);
                some_unfixed = (some_unfixed ? some_unfixed+" ":"") + sticky.id;

                sticky.style.left      = (sticky.offsetLeft + window.scrollX)+"px";
                sticky.style.top       = (sticky.offsetTop  + window.scrollY)+"px";


                sticky_DETACHED_STOP(sticky);
            }
        }

        if(state) sticky_update_dat( sticky );
    }

    if( some_unfixed )
    {
if( tag_this) log("%c MAGNET TO GRID: some_unfixed=["+some_unfixed+"]", lbH+lf3);

        sticky_MAGNET();
    }

};



let sticky_DETACHED_START = function(sticky) { sticky_DETACHED_SET(sticky,  true); };
let sticky_DETACHED_STOP  = function(sticky) { sticky_DETACHED_SET(sticky, false); };
let sticky_DETACHED_SET   = function(sticky,state)
{

let   caller = "sticky_detach_from_anchor";
let log_this = DOM_STICKY_LOG;



    if( state )
    {
        sticky.detached    = true;
        add_el_class(sticky, CSS_ANCHOR_DETACHED);


        sticky.anchor_node = null;
    }


    else {
        sticky.detached    = false;
        del_el_class(sticky, CSS_ANCHOR_DETACHED);


        if(!sticky.anchor_node) logBIG(caller+"("+sticky.id+") HAS NO ANCHOR ATTACHED",2);
    }


if( log_this) log_key_val_group(caller+"("+state+" "+sticky.id+")"
                               , {        position : sticky.style.position
                                 ,             top : sticky.style.top
                                 ,            left : sticky.style.left
                                 ,       className : sticky.className
                               }
                               , lbH+lf3, false);


};




const STICKY_FIX_RESOLUTION =   10;
const STICKY_FIX_DELAY      =  500;

let sticky_MAGNET0_timer;


let t_sticky_MAGNET_NOW = function()
{
    if(sticky_MAGNET0_timer) clearTimeout(sticky_MAGNET0_timer);

    sticky_MAGNET0_PINNED_handler();
};


let sticky_MAGNET = function()
{

    if(sticky_MAGNET0_timer) clearTimeout(sticky_MAGNET0_timer);

    sticky_MAGNET0_timer   = setTimeout(sticky_MAGNET0_PINNED_handler, STICKY_FIX_DELAY);
};


let sticky_MAGNET0_PINNED_handler = function()
{

let   caller = "sticky_MAGNET0_PINNED_handler";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbH+lf0);


    sticky_MAGNET0_timer   = null;

    if(onWork_STICKY && has_el_class(onWork_STICKY, CSS_HAS_FOCUS))
    {
if( log_this) log("...MAGNET HANDLING CANCLED WHILE EDITING STICKY "+onWork_STICKY.id);

        return;
    }

    sticky_MAGNET0_PINNED();
};



let sticky_MAGNET0_PINNED_onMoveDXY;


let sticky_MAGNET0_PINNED = function(re_attached_by)
{

let   caller = "sticky_MAGNET0_PINNED";
let log_this = LOG_MAP.T3_LAYOUT;
    log_this = log_this || t_prop.get(t_data.SHOW_SEEKZONE);

if( log_this) log("%c"+t_data.SD0+"%c "+caller,lbS+lf2 ,lbH+lf0);


    let show_seekzone = t_prop.get(t_data.SHOW_SEEKZONE);
    let     onMoveDXY = t_tools.get_onMoveDXY();

    if(    sticky_MAGNET0_PINNED_onMoveDXY
       && (sticky_MAGNET0_PINNED_onMoveDXY.x == onMoveDXY.x)
       && (sticky_MAGNET0_PINNED_onMoveDXY.y == onMoveDXY.y)
      ) {


        if(!show_seekzone) return;
    }
    else {
       sticky_MAGNET0_PINNED_onMoveDXY = { x:onMoveDXY.x , y:onMoveDXY.y };
    }


    let count             = 0;
    let fixed_count       = 0;
    let some_sticky_moved = false;
if( log_this) log("%c show_seekzone=["+show_seekzone+"]", lbH+lf8);

    let from_num = 1;
    let   to_num = STICKY_MAX;
    if(onWork_STICKY) {
        from_num = onWork_STICKY.num;
        to_num   = from_num;
    }

    for(let sticky_num = from_num; sticky_num <= to_num; ++sticky_num)
    {

        let sticky = sticky_array[sticky_num];
        if(!sticky                                             ) continue;
        if(!has_el_class(sticky, CSS_PINNED)            ) continue;

        count       += 1;
        fixed_count += (sticky.style.position == "fixed");




        some_sticky_moved
            =  t_sticky_MAGNET(sticky, re_attached_by)
            || some_sticky_moved
        ;


    }


if( log_this) log("%c some_sticky_moved=["+some_sticky_moved+"]  .. count=["+count+"] .. fixed_count=["+fixed_count+"]", lbH+lfX[(some_sticky_moved ? 4 : 8)]);

    if( some_sticky_moved || fixed_count) t_sticky_reorder();
    if( some_sticky_moved               ) t_tools.t_save_update_post(caller);


};


let t_sticky_MAGNET = function(sticky, re_attached_by)
{

let   caller = "t_sticky_MAGNET";
let log_this = LOG_MAP.T3_LAYOUT;



    let x = sticky.offsetLeft;
    let y = sticky.offsetTop;

    x = STICKY_FIX_RESOLUTION * Math.floor((x + STICKY_FIX_RESOLUTION / 2) / STICKY_FIX_RESOLUTION);
    y = STICKY_FIX_RESOLUTION * Math.floor((y + STICKY_FIX_RESOLUTION / 2) / STICKY_FIX_RESOLUTION);

    let to = get_el_transformOrigin( sticky );
    x = Math.max(STICKY_FIX_RESOLUTION/2-to.x, x);
    y = Math.max(STICKY_FIX_RESOLUTION/2-to.y, y);

    let show_anchors
        =  t_prop.get(t_data.PIN_SEEKSPOT)
        && (   re_attached_by
            || ((onWork_STICKY == sticky) ? "(onWork_STICKY == sticky)" : false ))
    ;

    if(   !show_anchors
       && (x == sticky.offsetLeft)
       && (y == sticky.offsetTop )
      )
        return false;

    let some_sticky_moved = true;

    sticky.style.left     = x+"px";
    sticky.style.top      = y+"px";


    let magnetizing
        =  sticky.detached
        || re_attached_by
        || show_anchors
    ;
if( log_this) log_key_val(  caller+"("+get_id_or_tag(sticky)+" "+(re_attached_by || "")+")"
                          , { magnetizing , re_attached_by , detached:sticky.detached , sticky , onWork_STICKY , callers:t_log.get_callers() }
                          , lbH+lf7);

    if( magnetizing )
        sticky_MAGNET1_XY_sticky(sticky,x,y,show_anchors);


    return some_sticky_moved;
};


let sticky_MAGNET0_PINNED_onMoveDXY_clear = function()
{
    sticky_MAGNET0_PINNED_onMoveDXY = null;

};



let sticky_transformOrigin_XY;


let sticky_MAGNET1_XY_sticky = function(sticky,x,y,show_anchors)
{

let   caller = "sticky_MAGNET1_XY_sticky";
let log_this = DOM_STICKY_LOG;
    log_this = log_this || t_prop.get(t_data.SHOW_SEEKZONE);



if( log_this) log("%c"+t_data.SD1+"%c "+caller+"%c "+x+" "+y+" %c"+ get_n_lbl(sticky)+" %c show_anchors "+show_anchors
                  ,lbS+lf1        ,lbH+lf1     ,lbH+lf1       ,lbH+lf1                        ,lbH+lf7                       );


    if(!sticky_transformOrigin_XY)
    {


        sticky_transformOrigin_XY = get_el_transformOrigin(sticky);

    }

    x += sticky_transformOrigin_XY.x;
    y += sticky_transformOrigin_XY.y;


    delete sticky.skipped_csv;
    delete sticky.search_ms;
    let el_at_XY
        = (sticky.style.position == "fixed")
        ?  get_document_el_at_XY(x               , y               )
        :  get_document_el_at_XY(x-window.scrollX, y-window.scrollY)
    ;

    let anchor_next = el_at_XY;
    let anchor_node = el_at_XY;


    let why_not  = "";
    if( anchor_node.nodeType   != Node.ELEMENT_NODE) { why_not += ""    +anchor_node.tagName+" NOT AN ELEMENT_NODE "; anchor_node = anchor_node.parentElement; }
    if( anchor_node.tagName    == "STYLE"          ) { why_not += ""    +anchor_node.tagName+" HAS A STYLE TAG"     ; anchor_node = anchor_node.parentElement; }
    if( anchor_node.tagName    == "SCRIPT"         ) { why_not += ""    +anchor_node.tagName+" HAS A SCRIPT TAG"    ; anchor_node = anchor_node.parentElement; }
    if( anchor_node.shadowRoot                     ) { why_not += " .. "+anchor_node.tagName+" HAS A SHADOWROOT "   ; anchor_node = anchor_node.parentElement; }
    if(!anchor_node.parentElement                  ) { why_not += " .. "+anchor_node.tagName+" HAS NO PARENT "      ; anchor_node = document.body;             }

if( log_this) log_anchor_step(sticky, 0, "XY["+x+" "+y+"]"+why_not, el_at_XY, anchor_node);



    anchor_next = anchor_node;
    let { closestnode , anchor_nodes_in_viewport , z_min }
        = sticky_MAGNET1_XY_sticky_CLOSEST_CHILD(sticky,x,y, anchor_node, log_this);
    if(   closestnode ) anchor_node = closestnode;

if( log_this) {
    if( closestnode ) log_anchor_step(sticky, 3,    "CLOSEST NODE", anchor_next, anchor_node);

}


    if( anchor_node )
    {
        x -= window.scrollX;
        y -= window.scrollY;

        sticky_MAGNET4_XY_anchor_offset_XY(sticky, x, y, anchor_node, z_min);
    }


    if( show_anchors )
        sticky_SHOW_ANCHOR(anchor_node, closestnode, anchor_nodes_in_viewport);


if( log_this) csv_log(sticky.skipped_csv, sticky.id+".skipped_csv");
};


let sticky_MAGNET1_XY_sticky_CLOSEST_CHILD = function(sticky,x,y, anchor_node, log_this)
{

    let { closestnode , anchor_nodes_in_viewport , z_min }
        = sticky_MAGNET3_closest_in_viewport(sticky,x,y, anchor_node, sticky.style.position);

    if(   closestnode )
    {

        while((closestnode != document.body) && not_an_anchor_target( closestnode ))
            closestnode     = closestnode.parentElement;

        if( closestnode    != anchor_node)
        {
            if( highlighted_anchor_node ) del_el_class( highlighted_anchor_node , CSS_ANCHOR_NODE);
            if( highlighted_anchor_node ) del_el_class( highlighted_anchor_node , CSS_ANCHOR_BACK);
            if(             anchor_node ) del_el_class(             anchor_node , CSS_ANCHOR_NODE);
            if(             anchor_node ) del_el_class(             anchor_node , CSS_ANCHOR_BACK);

 add_el_class(             closestnode , CSS_ANCHOR_NODE);
 highlighted_anchor_node        = closestnode;
        }

    }
    return { closestnode , anchor_nodes_in_viewport , z_min };
};


let sticky_MAGNET3_closest_in_viewport = function(sticky,x,y,anchor_node, position)
{

let   caller = "sticky_MAGNET3_closest_in_viewport";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) t_log.console_clear(caller);
if( log_this) log("%c"+t_data.SD3+"%c "+caller+"%c "+x+" "+y+" %c"+ get_id_or_node_path_tail(anchor_node)
                  ,lbS+lf3 ,lbH+lf3     ,lbH+lf3       ,lbH+lf3);


    if(!anchor_node || !anchor_node.children.length || (anchor_node.children.length >= ANCHOR_CHILDREN_MAX))
    {
if( log_this) {
    let result
        = !anchor_node                 ? "!anchor_node"
        : !anchor_node.children.length ? "!anchor_node.children.length"
        : (anchor_node.children.length+" > ANCHOR_CHILDREN_MAX=["+ANCHOR_CHILDREN_MAX+"]")
    ;

    log("%c"+result+" %c"+get_id_or_node_path_tail(anchor_node)
        ,lbL+lf3     ,lbR+lf3);
}

        return { closestnode:null , anchor_nodes_in_viewport:[] };
    }


    let z_min;
    let z_container;
    if( check_xy_in_node_rect(x, y, anchor_node) )
    {
        let      cs = window.getComputedStyle(anchor_node);
        z_min       = parseInt(cs.zIndex) || 0;

        z_container = anchor_node;
    }


    let o = {};
    o.t   =       window.scrollY;
    o.l   =       window.scrollX;
    o.b   = o.t + window.innerHeight;
    o.r   = o.l + window.innerWidth;

    if(position == "fixed")
{
        x += window.scrollX;
        y += window.scrollY;
    }


    let { anchor_in_view_array , search_ms } = get_el_anchor_in_view_array(document.body);
    sticky.search_ms = search_ms;

    let dxy_min;
    let closestnode;
    let p = {};

    let anchor_nodes_in_viewport = [];
    let anchor_num_last = (anchor_in_view_array.length+1);
    for(let anchor_num = 1; anchor_num < anchor_num_last; ++anchor_num)
    {

        let node  = anchor_in_view_array[anchor_num-1];
        let why_not = not_an_anchor_target(node);
        if( why_not ) {
if( log_this) log("%c "+anchor_num+" .. "+get_id_or_tag(node)+" .. "+why_not, lbH+lf0);

            continue;
        }

        anchor_nodes_in_viewport.push(node);

        let bcr = node.getBoundingClientRect();
        p.t     =       bcr.top   + window.scrollY;
        p.l     =       bcr.left  + window.scrollX;
        p.b     = p.t + bcr.height;
        p.r     = p.l + bcr.width ;



        let cs = window.getComputedStyle(node);
        if(        check_xy_in_node_rect(x, y, node)
           && (   (z_min == undefined                     )
               || (z_min  <          cs.zIndex            )
              )
          ) {
            z_min         = parseInt(cs.zIndex) || 0;

            z_container   = node;
        }


        let      dxy = get_xy_tlbr_dist(x,y,p);
        if(     (z_container == node     )
             || (dxy_min     == undefined)
             || (dxy          < dxy_min  )
          ) {

            if(!z_container || is_el_or_child_of_parent_el(node, z_container))
            {
                dxy_min     = dxy;
                closestnode = node;
            }
            else {
if( log_this) log("%c "+anchor_num+" .. "+get_id_or_tag(node)+" .. [dxy "+dxy+"] < [dxy_min "+dxy_min+"] .. but not a child of z_container", lbH+lf9);
            }

        }


if( log_this) {

let new_z_container = (z_container == node);
let new_closestnode = (closestnode == node);
let worth_logging
    =  (anchor_num == anchor_num_last-1)
    || (new_z_container                )
    || (new_closestnode                )
;

if(worth_logging) {
    let l_x
        = ((anchor_num == anchor_num_last-1) ? lbb    : "")
        + (   (new_z_container             ) ?     lbH+lf7
           :  (new_closestnode             ) ?     lbH+lf5
           :                                           lf8);

    let z_container_label = get_id_or_node_path_tail( z_container );
    let closestnode_label = get_id_or_node_path_tail( closestnode );
    let node_label        = get_id_or_node_path_tail( node        );

    log_key_val_group( anchor_num+"/"+anchor_in_view_array.length+t_data.TAB+"[Z "+z_min+"] [DXY "+dxy_min+"] .. "+closestnode_label
                       , {    new_z_container : new_z_container+" .. z_min=["+z_min+"] "+z_container_label
                           ,  new_closestnode : new_closestnode+" .. "+                  closestnode_label
                           ,             node :                                          node_label
                           ,              DXY : "[dxy_min "+dxy_min+"] .. [dxy "+dxy+"]"
                           ,     viewport_dxy : get_xy_tlbr_dist(x,y,o)
                           ,                o :   log_json_one_liner(o)
                           ,                p :   log_json_one_liner(p)
                       }
                       , l_x, true);

}
}

    }



return { closestnode , anchor_nodes_in_viewport , z_min };
};


let sticky_MAGNET4_XY_anchor_offset_XY = function(sticky,x,y,anchor_node,z_min)
{

let   caller = "sticky_MAGNET4_XY_anchor_offset_XY";
let log_this = LOG_MAP.T3_LAYOUT;
    log_this = log_this || t_prop.get(t_data.SHOW_SEEKZONE);

if( log_this) log("%c"+t_data.SD4+"%c "+caller+"%c"+get_n_lbl(sticky)+"%c XY "+x+" "+y
                  ,lbS+lf4        ,lbL+lf4    ,lbC+lf4                       ,lbR+lf4        );

if( log_this) log("...anchor_node: %c"+get_id_or_tag(anchor_node), lb8);
if( log_this) log(".....node_path: %c"+get_node_path(anchor_node), lb8);



    let      a_r = anchor_node.getBoundingClientRect();
    let      a_x = Math.round(a_r.left + a_r.width  / 2);
    let      a_y = Math.round(a_r.top  + a_r.height / 2);

    let       dx = x - a_x;
    let       dy = y - a_y;

    let offset_x = (dx / a_r.width ).toFixed(3);
    let offset_y = (dy / a_r.height).toFixed(3);



    let anchor_changed
        =  (anchor_node != sticky.anchor_node)
    ;

    sticky_ATTACH5_ANCHOR(sticky, anchor_node, offset_x, offset_y, z_min);


    t_seek.t_seekzone6_show_anchor_node( anchor_changed );

    if(t_prop.get(t_data.SHOW_SEEKZONE) && t_prop.get(t_data.FLOATLOG)) t_sticky_LOG_TOOLTIP(sticky, "MOVE");


};





let highlighted_anchor_node;
let highlighted_closestnode;
let highlighted_anchor_children = [];



let sticky_ATTACH5_ANCHOR = function(sticky, anchor_node, offset_x, offset_y, z_min)
{

    let   caller = "sticky_ATTACH5_ANCHOR";
    let log_this = DOM_STICKY_LOG || LOG_MAP.T3_LAYOUT;
    log_this = log_this || t_prop.get(t_data.SHOW_SEEKZONE);

    if( log_this) log("%c"+t_data.SD5+"%c "+caller+"("+sticky.id+", "+get_n_lbl(anchor_node)+", offset_x "+offset_x+" , offset_y "+offset_y+" , z_min "+z_min+")", lbB+lf5, lbH+lf5);


    if(anchor_node)
    {
if( log_this) t_log.log_not_an_anchor_target(anchor_node);

        sticky.anchor_node = anchor_node;
        sticky.offset_x    = offset_x;
        sticky.offset_y    = offset_y;



        sticky_DETACHED_STOP(sticky);

if( log_this) log(caller+"%c sticky.className=["+sticky.className+"]", lbH+lf8);

t_log.log_not_an_anchor_target(anchor_node);
    }
    del_el_class(    sticky, CSS_ANCHOR_NOT_FOUND);
    del_el_class(    sticky, CSS_ANCHOR_UNSET);
};


let sticky_CLEAR_HIGHLIGHT = function()
{
    if( highlighted_anchor_node ) {
        del_el_class(highlighted_anchor_node, CSS_ANCHOR_NODE);
        del_el_class(highlighted_anchor_node, CSS_ANCHOR_BACK);

        highlighted_anchor_node = null;
    }
    if( highlighted_closestnode ) {
        del_el_class(highlighted_closestnode, CSS_ANCHOR_CLOSEST);

        highlighted_closestnode = null;
    }

    for(let i=0; i < highlighted_anchor_children.length; ++i)
    {
        let                 child = highlighted_anchor_children[i];
        del_el_class(child, CSS_ANCHOR_CHILD+(i+1) % 10);
    }
    highlighted_anchor_children = [];
};


let sticky_SHOW_ANCHOR = function(anchor_node, closestnode, anchor_nodes_in_viewport)
{

let log_this = LOG_MAP.T3_LAYOUT;
    log_this = log_this || t_prop.get(t_data.SHOW_SEEKZONE);

let tag_this = DOM_STICKY_TAG || log_this;


    sticky_CLEAR_HIGHLIGHT();
    if( anchor_node ) {
        add_el_class(anchor_node, CSS_ANCHOR_NODE);

        highlighted_anchor_node = anchor_node;
    }


    if( closestnode ) {
        add_el_class(closestnode, CSS_ANCHOR_CLOSEST);

        highlighted_closestnode = closestnode;
    }


    if(anchor_nodes_in_viewport && anchor_nodes_in_viewport.length)
    {
        for(let i=0; i < anchor_nodes_in_viewport.length; ++i)
        {
            let child  = anchor_nodes_in_viewport[i];
            add_el_class(child, CSS_ANCHOR_CHILD+(i+1) % 10);
            highlighted_anchor_children.push( child );
        }
    }


if( tag_this)
    log_key_val("SHOW_ANCHOR .. "+get_node_path_tail(anchor_node)
                , { anchor_node                 : get_node_path(anchor_node)
                  , closestnode                 : get_node_path(closestnode)
                  , anchor_nodes_in_viewport : "#"+anchor_nodes_in_viewport.length
                  , highlighted_anchor_children : "#"+highlighted_anchor_children.length
                }
                , lb7);

};





let t_sticky_EDIT = function(sticky_target)
{

let   caller = "t_sticky_EDIT("+get_n_lbl(sticky_target)+")";
let log_this = DOM_STICKY_LOG;

if( log_this) t_fly.t_log_event_status(caller, lf7);



    sticky_RING_select( sticky_target );



    let sticky_pad_msg = get_sticky_pad_msg( sticky_target );
if( log_this) log("MAKE CURRENT WINDOW SELECTION OUT OF sticky_pad_msg %c"+ellipsis_short(strip_CR_LF( sticky_pad_msg.innerHTML )), lb7);




    add_el_class(sticky_target, CSS_HAS_FOCUS);


    add_el_class   (sticky_target, CSS_FIXED );



    sticky_pad_msg.contentEditable = true;

    set_el_class(sticky_pad_msg, STICKY_PAD_MSG);

    selectNodeContents( sticky_pad_msg );



    t_tools.t_add_input_listener( sticky_pad_msg );



    add_el_class(sticky_pad_msg, CSS_STICKY_MSG_EDIT);


};



let t_sticky_EDITING = function()
{
    return onWork_STICKY && has_el_class(onWork_STICKY, CSS_HAS_FOCUS);
};


let t_sticky_EDIT_DONE = function()
{

let   caller = "t_sticky_EDIT_DONE";
let log_this = DOM_STICKY_LOG;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) log(caller+": onWork_STICKY=["+get_n_lbl(onWork_STICKY)+"] .. HAS FOCUS: "+has_el_class(onWork_STICKY, CSS_HAS_FOCUS));

    if(!onWork_STICKY) return false;


    let sticky_pad_msg = get_sticky_pad_msg( onWork_STICKY );
    if(!sticky_pad_msg || !sticky_pad_msg.textContent.trim())
    {
logBIG(caller+": onWork_STICKY has no msg");

        return false;
    }


logBIG(caller+": sticky.touched=["+onWork_STICKY.touched+"]");
    let touched_DONE
        =  (onWork_STICKY.touched == STICKY_PEN)
        || (onWork_STICKY.touched == STICKY_FIX);

    if(!touched_DONE) {


        let selection            = window.getSelection();
        if( selection.anchorNode ) selection.collapseToEnd();
        else                       selectNodeContents(sticky_pad_msg);

        return false;
    }
    dom_tools.t_is_bouncing_e_type("STICKY_DONE", caller);



    if( has_el_class(onWork_STICKY, CSS_HAS_FOCUS))
        del_el_class(onWork_STICKY, CSS_HAS_FOCUS);

    t_tools.t_blur( sticky_pad_msg );


    if( has_el_class(sticky_pad_msg, CSS_STICKY_MSG_EDIT) )
    {
        del_el_class(sticky_pad_msg, CSS_STICKY_MSG_EDIT);

        let msg = strip_contentEditable( sticky_pad_msg.innerHTML );
        sticky_change_msg(onWork_STICKY, msg);

if( tag_this) log("%c MSG SET TO: %c"+t_data.LF+onWork_STICKY.msg, lbH+lf7,lb9);
    }


    t_tools.t_save_update_post("STICKY UPDATED");


    return true;
};


let sticky_update_dat = function(sticky)
{

let   caller = "sticky_update_dat";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this)
    log(caller+"%c"+sticky.id+"%c num=["+sticky.num+"] %c date_MS=["+sticky.date_MS+"] %c msg=["+ellipsis(strip_HTML(sticky.msg), 16)+"]"
        ,       lbL+lf8       ,lbC+lf3                ,lbR+lf3                        ,lbH+lf9                                           );


    let delay = "";
    if( sticky.date_MS )
    {
        let date   = new Date(sticky.date_MS);
        let now    = new Date();

        let diff   = now - date;

        let span = {};
        span.years   =  Math.floor(diff /   YEARS_MS); diff -=   YEARS_MS * span.years;
        span.months  =  Math.floor(diff /  MONTHS_MS); diff -=  MONTHS_MS * span.months;
        span.days    =  Math.floor(diff /    DAYS_MS); diff -=    DAYS_MS * span.days;
        span.hours   =  Math.floor(diff /   HOURS_MS); diff -=   HOURS_MS * span.hours;
        span.minutes =  Math.floor(diff / MINUTES_MS); diff -= MINUTES_MS * span.minutes;
        span.seconds =  Math.floor(diff / SECONDS_MS);

        let dy = span.years;
        let dm = span.months;
        let dd = span.days;
        let dh = span.hours;
        let dn = span.minutes;
        let ds = span.seconds;
        delay = ""
            + " <span>"
            + (dy ? ("<span class='weight1 size1'>"+ dy +"y </span>") : "")
            + (dm ? ("<span class='weight3 size1'>"+ dm +"m </span>") : "")
            + (dd ? ("<span class='weight2 size1'>"+ dd +"d </span>") : "")
            + (dh ? ("<span class='weight3 size3'>"+ dh +"h </span>") : "")
            + (dn ? ("<span class='weight2 size2'>"+ dn +"m </span>") : "")
            + (ds ? ("<span class='weight3 size1'>"+ ds +"s </span>") : "")
            + "</span>"
        ;
    }


    if(delay)
    {
        let sticky_pad = get_sticky_pad( sticky );
        let sticky_pad_dat = sticky_pad ? get_el_child_with_class(sticky_pad, STICKY_PAD_DAT) : undefined;
        if( sticky_pad_dat )
            sticky_pad_dat.innerHTML = delay;

if( log_this)
    log_key_val_group("delay .. "+ellipsis(strip_HTML(delay),16)
                      , {   sticky_pad
                          , sticky_pad_dat
                      }
                      , lf8
                      , false);

    }

};





let t_sticky_e_target_STICKY = function(el)
{
    return get_el_parent_with_class(el, CSS_STICKY_TOOL);
};


let t_sticky_onDown_a_scrollable_STICKY = function(sticky,e_target)
{
    let sticky_pad_msg = sticky          ? get_sticky_pad_msg(sticky) : null;
    let onDown_pad_msg = sticky_pad_msg && (             e_target == sticky_pad_msg );
    let        visible = onDown_pad_msg && (window.getComputedStyle( sticky_pad_msg ).visibility == "visible");
    let     scrollable = visible        && (has_scrollbar(    sticky_pad_msg ));
    let         result = scrollable;


    return result;
};


let t_sticky_onDown_a_STICKY_PAD = function(sticky)
{
    return sticky && (sticky.touched == STICKY_PAD);
};



let scrolling_sticky;


let t_sticky_scroll_STICKY_PAD_MSG = function(e_target)
{
    t_sticky_SET_DIMMED(false, "SCROLLING STICKY");

    scrolling_sticky      = get_el_parent_with_class(e_target        , t_data.CSS_STICKY_TOOL);
    if( scrolling_sticky  ) add_el_class            (scrolling_sticky, t_data.CSS_SCROLLING  );
};


let t_sticky_get_SCROLLING_STICKY = function()
{
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky = sticky_array[ sticky_num ];
        if( has_el_class( sticky, t_data.CSS_SCROLLING) ) return sticky;
    }
    return null;
};


let t_sticky_set_SEL_PASTE_TARGET_STATE = function(state)
{

let   caller = "t_sticky_set_SEL_PASTE_TARGET_STATE";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"("+state+")");

    let sticky_title
        = state
        ?  i18n_get( t_i18n.STICKY_PASTE_TOOLTIP )
        :  "";

    let some_paste_indicator_changed;
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {

        let sticky = sticky_array[ sticky_num ];
        if(!sticky ) continue;
        if( state ) {
            some_paste_indicator_changed
                =   some_paste_indicator_changed
                || !has_el_class(sticky, CSS_PASTE_TARGET);


            add_el_class(sticky, CSS_PASTE_TARGET);


            sticky_set_dimmed_state(sticky, false);

            sticky.title = sticky_title ? sticky_title : sticky.id;
        }


        else {

            some_paste_indicator_changed
                =   some_paste_indicator_changed
                ||  has_el_class(sticky, CSS_PASTE_TARGET);

            del_el_class(sticky, CSS_PASTE_TARGET, CSS_PASTE_TARGET);
            del_el_class(sticky, CSS_HAS_FOCUS   , CSS_HAS_FOCUS);

            sticky.title = sticky.id;
        }

    }
if( log_this) log(".. return some_paste_indicator_changed=["+some_paste_indicator_changed+"]");
    return some_paste_indicator_changed;
};



let last_edited_sticky;


let sticky_set_last_edited = function(sticky)
{
    if(sticky == last_edited_sticky) return;

    if( last_edited_sticky )
        sticky_RESIZE_last_edited();

    last_edited_sticky = sticky;
};


let sticky_RESIZE_last_edited = function()
{
    if(!last_edited_sticky) return;

    sticky_RESIZE7_STICKY_LAYOUT(last_edited_sticky);

    last_edited_sticky = null;
};


let t_sticky_get_tooltip = function(sticky)
{
    return has_el_class(sticky,              CSS_PASTE_TARGET ) ? i18n_get( t_i18n.STICKY_PASTE_TOOLTIP    )
        :                     (sticky.touched == STICKY_FIX   ) ? i18n_get( t_i18n.STICKY_FIX_TOOLTIP      )
        :                     (sticky.touched == STICKY_HAND  ) ? i18n_get( t_i18n.STICKY_HAND_MOV_TOOLTIP )
        :                     (sticky.touched == STICKY_PAD   ) ? i18n_get( t_i18n.STICKY_PAD_TOOLTIP      )
        :                     (sticky.touched == STICKY_PEN   ) ? i18n_get( t_i18n.STICKY_PEN_TOOLTIP      )
        :                     (sticky.touched == STICKY_REFLOW) ? i18n_get( t_i18n.STICKY_REFLOW_TOOLTIP   )
        :                     (sticky.touched == STICKY_REFONT) ? i18n_get( t_i18n.STICKY_REFONT_TOOLTIP   )
        :                     (sticky.touched == STICKY_RESIZE) ? i18n_get( t_i18n.STICKY_RESIZE           )
        :                     (sticky.touched == STICKY_ROTATE) ? i18n_get( t_i18n.STICKY_ROTATE           )
        :                                                         sticky.title
    ;
};


let   sticky_set_sel_text = function(sticky, sel_text)
{

let   caller = "sticky_set_sel_text";
let log_this = DOM_STICKY_LOG;

if( log_this) log("%c"+caller+"("+get_n_lbl(sticky)+","+ellipsis_short(sel_text)+")", lbH+lf4);



    sel_text = ellipsis(sel_text, STICKY_SEL_TEXT_LEN_MAX);


    let msg = escapeHTML( sel_text );
    sticky_change_msg(sticky, msg);


    t_tools.t_window_getSelection_removeAllRanges();
};


let   sticky_change_msg = function(sticky,msg)
{


    if(sticky.msg) {
        if(     !sticky.msg_history                       ) sticky.msg_history   = [ sticky.msg ];
        else if(!sticky.msg_history.includes( sticky.msg )) sticky.msg_history.push( sticky.msg );
    }


    sticky.msg = msg;


    sticky_format_pad(sticky);

};


let t_sticky_format_pad_all = function()
{
    t_sticky_SET_DIMMED(false,"t_sticky_format_pad_all");

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky  = sticky_array[sticky_num];
        if( sticky && has_el_class(sticky, CSS_PINNED))
            sticky_format_pad(sticky);
    }
};


let t_sticky_format_pad = function(sticky=onWork_STICKY)
{
    if( has_el_class(sticky, CSS_HAS_FOCUS)) t_sticky_EDIT_DONE();
    else                                            sticky_format_pad(sticky);

    let pad_msg = get_sticky_pad_msg( sticky );
    let     bcr = pad_msg.getBoundingClientRect();
    sticky_SETSIZE_PAD_WH(sticky,bcr.width,bcr.height);

    t_sticky_STORE();
};



const SECONDS_MS =  1000;
const MINUTES_MS =  60 * SECONDS_MS;
const   HOURS_MS =  60 * MINUTES_MS;
const    DAYS_MS =  24 *   HOURS_MS;
const  MONTHS_MS =  30 *    DAYS_MS;
const   YEARS_MS = 365 *  MONTHS_MS;


let   sticky_format_pad = function(sticky)
{

let   caller = "sticky_format_pad";
let log_this = DOM_STICKY_LOG;

if( log_this)
    log("%c"+caller+"("+sticky.id+") %c num=["+sticky.num+"] %c msg=["+encode_LF(ellipsis_short(strip_HTML(sticky.msg)))+"]"
        ,lbH+lf8                    ,lbL+lf3                ,lbR+lf3                                                        );


    let show_seekzone = t_prop.get(t_data.SHOW_SEEKZONE);
    if( show_seekzone ) {
        log("show_seekzone .. CALLING sticky_format_pad_anchor_path");
        sticky_format_pad_anchor_path( sticky );
        return;
    }


    sticky_update_dat( sticky );



    sticky_set_msg(sticky, (sticky.msg || ""));



if( log_this) t_sticky_LOG(sticky);
};


let   sticky_format_pad_anchor_path = function(sticky)
{

let   caller = "sticky_format_pad_anchor_path";
let log_this = DOM_STICKY_LOG || LOG_MAP.T0_STORE;



    let parent_path  = sticky.anchor_node ? get_node_path( sticky.anchor_node.parentElement ) :               "";
    let anchor_path  = sticky.anchor_node ? get_node_path( sticky.anchor_node               ) : "NO anchor_node";

    if( parent_path && anchor_path.startsWith( parent_path ))
        anchor_path  = anchor_path.substring ( parent_path.length + 1);

    parent_path      = vbar_to_LF( parent_path );
    anchor_path      = vbar_to_LF( anchor_path );

    let f_x          = (parseInt(anchor_path) % 10) || 9;

    let msg
        = ellipsis_short( sticky.msg ) +"<br><br><br>"
        +"<em  class='cc9 small'>MOVED ON ANCHOR:</em>"
        +"<pre class='show_seekzone tiny'>"

        +(sticky.skipped_csv
          ? t_data.LF
          + "<u     class='bg8'>SKIPPED:</u>"+t_data.LF
          + "<pre class='fg9 max_width_30' style='margin-left:1em;'>"+ comma_to_LF(sticky.skipped_csv) +"</pre>"
          : "")

        +(sticky.search_ms
          ?  t_data.LF
          + "<u     class='bg8'>search time:</u>"
          + " <span class='fg9'>"+ sticky.search_ms +"ms</span>"+t_data.LF
          : "")

        +(parent_path
          ?  t_data.LF
          + "<u     class='bg4'>PARENT:</u>"+t_data.LF
          + "<span class='fg9'>"+ parent_path +"</span>"+t_data.LF
          : "")

        +(anchor_path
          ? t_data.LF
          +"<u class='bg7'>ANCHOR:</u>"
          +" <span class='fg"+f_x+"'>"+ anchor_path +"</span>"
          : "")

        +"</pre>";



    sticky_set_msg(sticky, msg);



if( log_this) {
    log_key_val_group(  caller+" "+ get_n_lbl( sticky.anchor_node )
                     , { sticky_anchor_node : get_node_txt_id_or_tag_path( sticky.anchor_node )
                       , STICKY_XY          : [ sticky.offsetLeft  , sticky.offsetTop   ]
                       , ANCHOR_XY          : [ sticky.offset_x    , sticky.offset_y    ]
                       , parent_path
                       , anchor_path
                       , callers            : t_log.get_callers()
                     }
                     , lbH+lf1
                     , true
                     );
}

};


let   sticky_set_msg = function(sticky, msg)
{

let caller = "sticky_set_msg";
let log_this = DOM_STICKY_LOG || LOG_MAP.T0_STORE;

let tag_this = DOM_STICKY_TAG || log_this;
if( log_this) caller +="("+sticky.id+")";


    if( last_set_fontSize )
    {
        if( tag_this) log("%c...applying last set font size: "+ last_set_fontSize +"px", lbH+lf8);

        sticky.msg_fontSize = last_set_fontSize;
    }


    let sticky_pad_msg = get_sticky_pad_msg( sticky );

    let bcr
        = sticky_pad_msg
        ? sticky_pad_msg.getBoundingClientRect()
        : null
    ;



    let       sticky_pad = get_sticky_pad( sticky );
    let               s1 =            STICKY0_HTML;
    let               s2 = s1.replace(STICKY_PLACE_HOLDER_PAD_NUM , "0123456789X"[sticky.num]);
    let               s3 = s2.replace(STICKY_PLACE_HOLDER_PAD_MSG , msg);

    sticky_pad.innerHTML = s3;
    sticky_pad.className = "sticky_pad bg"+(sticky.num % 10);


    if(!bcr) {
if( tag_this) log("%c NO [WH] TO KEEP for ["+sticky.pad_flow+"] "+caller, lbH+lf8);

    }
    else {

        sticky_pad_msg = get_sticky_pad_msg( sticky );

        if(sticky.pad_flow == CSS_WS_NOWRAP)
        {
if( tag_this) log("%c KEEPING W=["+bcr.width .toFixed(0)+"] for ["+sticky.pad_flow+"] "+caller, lbH+lf5);

            sticky_pad_msg.style.maxWidth  = bcr.width  +"px";
            sticky_pad_msg.style.minWidth  = bcr.width  +"px";
            sticky_pad_msg.style.width     = bcr.width  +"px";
        }
        else {
if( tag_this) log("%c NOT KEEPING [W] for ["+sticky.pad_flow+"] "+caller, lbH+lf8);
        }





        if(sticky.pad_flow != CSS_WS_NOWRAP)
        {
if( tag_this) log("%c CONFINING BOUNDS INTO "+WH_CONFINED_PERCENT+" OF PARENT for ["+sticky.pad_flow+"] "+caller, lbH+lf9);

            sticky_pad_msg.style.maxHeight = WH_CONFINED_PERCENT;
            sticky_pad_msg.style.maxWidth  = WH_CONFINED_PERCENT;

        }

    }

    sticky_RESIZE7_STICKY_LAYOUT(sticky);
};





let sticky_ring_array = [];
let sticky_ring_selected;


let t_sticky_CHOOSE = function()
{

let   caller = "t_sticky_CHOOSE";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) t_fly.t_log_event_status(caller, lf7);


    if(!sticky_ring_array.length)
        sticky_RING_init_sticky_ring_array();

    t_tools.t_dimm_start_sticky(caller);
    sticky_RING_repin();
    sticky_RING_select();
    sticky_RING_collapse();
    sticky_RING_re_point();
    t_sticky_RING_layout();

};


let sticky_RING_init_sticky_ring_array = function()
{

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky = sticky_CREATE(sticky_num, t_data.ZINDEX_ABOVE_TOOLS, "ring_");

        sticky.style.position = "fixed";

        add_el_class(sticky, CSS_STICKY_RING);

        sticky_ring_array[sticky_num] = sticky;


    }
};


let sticky_RING_re_point = function()
{

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let ring_sticky = sticky_ring_array[sticky_num];

        if     (sticky_num < 3) sticky_set_DIR_CLASS(ring_sticky, CSS_POINT_NE);
        else if(sticky_num < 5) sticky_set_DIR_CLASS(ring_sticky, CSS_POINT_EE);
        else if(sticky_num < 6) sticky_set_DIR_CLASS(ring_sticky, CSS_POINT_SE);
        else if(sticky_num < 7) sticky_set_DIR_CLASS(ring_sticky, CSS_POINT_SW);
        else if(sticky_num < 9) sticky_set_DIR_CLASS(ring_sticky, CSS_POINT_WW);
        else                    sticky_set_DIR_CLASS(ring_sticky, CSS_POINT_NW);
    }
};


let t_sticky_RING_layout = function()
{

let   caller = "t_sticky_RING_layout";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);



    let { w_W,w_H } = t_tools.t_cache_wph_WH();
    let center_x  = w_W / 2;
    let center_y  = w_H / 2;
    let radius    = Math.min(w_W,w_H) / 5;


    let deg_delta = 360 / 12;
    let deg_start = -90 + deg_delta;
    let rad_delta = deg_delta * Math.PI / 180;
    let rad_start = deg_start * Math.PI / 180;




    let sticky_ring_deployed = 0;
    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {

        let ring_sticky = sticky_ring_array[sticky_num];
        if(!ring_sticky ) continue;

        let sticky_ring_hand = get_sticky_hand( ring_sticky );
        let sticky_ring_pad  = get_sticky_pad ( ring_sticky );

        if(sticky_ring_selected) {
            sticky_ring_deployed += sticky_RING_provision(sticky_num, sticky_ring_hand, sticky_ring_pad);
        }
        else {
            sticky_ring_deployed += sticky_RING_clone(sticky_num, sticky_ring_hand, sticky_ring_pad);
        }



        let rad_angle = rad_start + rad_delta * (sticky_num-1);



        ring_sticky.xy.x = center_x + radius * Math.cos(rad_angle);
        ring_sticky.xy.y = center_y + radius * Math.sin(rad_angle);
        t_tools.t_pin_panel_at_XY(ring_sticky, ring_sticky.xy.x,ring_sticky.xy.y);

        ring_sticky.style.zIndex = t_data.ZINDEX_ABOVE_TOOLS + sticky_num;

    }

if( log_this) log("%c"+caller+"%c"+sticky_ring_deployed+" deployed to choose from", lbL+lf9, lbR+lfX[sticky_ring_deployed % 10]);
    return sticky_ring_deployed;
};


let sticky_RING_provision = function(sticky_num, sticky_ring_hand, sticky_ring_pad)
{

let   caller = "sticky_RING_provision";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"(sticky_num=["+sticky_num+"], sticky_ring_hand=["+get_n_lbl(sticky_ring_hand)+"], sticky_ring_pad=["+get_n_lbl(sticky_ring_pad)+"])");

    let sticky_ring_deployed = 0;


    let     num = (sticky_num == 10) ? "X" : sticky_num;
    let flipped = (sticky_num <  6) ?     "" : "flipped";

    sticky_ring_hand.innerHTML = "<span class='"+flipped+" fg"+sticky_num+"'>"+num+".</span>";
    sticky_ring_pad .innerHTML = "<span>TODO</span>";


    return sticky_ring_deployed;
};


let sticky_RING_clone = function(sticky_num, sticky_ring_hand, sticky_ring_pad)
{

let   caller = "sticky_RING_clone";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"(sticky_num=["+sticky_num+"], sticky_ring_hand=["+get_n_lbl(sticky_ring_hand)+"], sticky_ring_pad=["+get_n_lbl(sticky_ring_pad)+"])");

    let sticky_ring_deployed = 0;


    add_el_class(sticky_ring_hand, "size4");

    let     num = (sticky_num == 10) ?   "X" : sticky_num;
    let flipped = (sticky_num <  6) ?     "" :  "flipped";
    sticky_ring_hand.innerHTML
        = "<span class='"+flipped+" fg"+sticky_num+"'>"+num+".</span>";



    let sticky = sticky_array[ sticky_num ];

    if( sticky && has_el_class(sticky, CSS_PINNED)) {
        let sticky_div       = sticky.querySelectorAll("DIV")[0];
        sticky_ring_pad.innerHTML    = sticky_div.innerHTML;
        sticky_ring_deployed += 1;

    }
    else {
        sticky_ring_pad.innerHTML   = "";
    }


    return sticky_ring_deployed;
};


let sticky_RING_collapse = function(sticky)
{

    let state_sticky_ring_deployed = sticky_ring_array.length && t_tools.t_dimm_mask_displayed();
    if(!state_sticky_ring_deployed) return;




    let css_point_dir = CSS_POINT_00;


    if( sticky )
        css_point_dir
            = has_el_class(sticky, CSS_POINT_EE) ? CSS_POINT_EE
            : has_el_class(sticky, CSS_POINT_SE) ? CSS_POINT_SE
            : has_el_class(sticky, CSS_POINT_SW) ? CSS_POINT_SW
            : has_el_class(sticky, CSS_POINT_WW) ? CSS_POINT_WW
            : has_el_class(sticky, CSS_POINT_NW) ? CSS_POINT_NW
            : has_el_class(sticky, CSS_POINT_NE) ? CSS_POINT_NE
            : ""
    ;


    let { w_W,w_H } = t_tools.t_cache_wph_WH();
    let x = sticky ? (sticky.offsetLeft - window.scrollX) : w_W / 2;
    let y = sticky ? (sticky.offsetTop  - window.scrollY) : w_H / 2;



    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let ring_sticky             = sticky_ring_array[sticky_num];

        ring_sticky.style.left      = x+"px"  ;
        ring_sticky.style.top       = y+"px"  ;
        ring_sticky.style.zIndex    = t_data.ZINDEX_STICKY_TOOL_ZERO;

        sticky_set_DIR_CLASS(    ring_sticky, css_point_dir);
        t_tools.t_set_CSS_PINNED(ring_sticky, false);
    }

};



const STICKY_RING_SELECTED  = "sticky_ring_selected";


let sticky_RING_select = function(sticky_target)
{

let   caller = "sticky_RING_select";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"("+get_n_lbl(sticky_target)+")");


    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky  = sticky_ring_array[sticky_num];

        if( sticky == sticky_target) add_el_class(sticky, STICKY_RING_SELECTED);
        else                         del_el_class(sticky, STICKY_RING_SELECTED);
    }


    if( sticky_target )
    {
        t_sticky_RING_stop(caller);

        t_tools.t_dimm_stop(caller);
    }

    sticky_ring_selected
        = (sticky_target && !has_el_class(sticky_target, CSS_STICKY_RING))
        ?  sticky_target
        :  null;

};


let t_sticky_RING_stop = function(_caller)
{

let   caller = "t_sticky_RING_stop";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+": ...sticky_ring_selected=["+get_n_lbl(sticky_ring_selected)+"]");
if( log_this) log_caller();


    let sticky_seeked_to;

    if(sticky_ring_array.length)
    {
        for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
        {
            let ring_sticky = sticky_ring_array[sticky_num];
            add_el_class(ring_sticky, CSS_COLLAPSING);

            if(has_el_class(ring_sticky, STICKY_RING_SELECTED))
            {

                sticky_seeked_to = sticky_GET( sticky_num );
                if( has_el_class(sticky_seeked_to, CSS_PINNED) )
                {
                    let onDown_SCROLL_XY = t_tools.t_get_onDown_SCROLL_XY();
                    t_sticky_set_SEEK_NEXT(sticky_seeked_to, onDown_SCROLL_XY, 0);
                }
            }
        }
    }


    sticky_RING_collapse( sticky_seeked_to );


    setTimeout(sticky_RING_unpin_handler, (sticky_seeked_to ? RING_COLLAPSING_DELAY : 0));


    sticky_FIXED_STOP();
};


const RING_COLLAPSING_DELAY = 2000;

let sticky_RING_unpin_handler = function()
{
    if(!sticky_ring_array.length) return;

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let ring_sticky = sticky_ring_array[sticky_num];
        del_el_class(ring_sticky, CSS_COLLAPSING);

        t_tools.t_set_CSS_PINNED(ring_sticky , false);

        ring_sticky.style.display    = "none";

        ring_sticky.style.zIndex     = t_data.ZINDEX_ABOVE_TOOLS + sticky_num;
    }
};


let sticky_RING_repin = function()
{

    for(let sticky_num = 1; sticky_num <= STICKY_MAX; ++sticky_num)
    {
        let sticky = sticky_ring_array[sticky_num];
        t_tools.t_set_CSS_PINNED(sticky, true);
        sticky.style.display = "block";
    }
};






let t_sticky_LOG = function(num_or_el, msg="", lfx=undefined)
{

    let arg_type;
    let from = 0;
    let to   = 0;

    let sticky_num = parseInt( num_or_el );
    if(!isNaN(sticky_num) && (sticky_num > 0))
    {

        arg_type = sticky_num;
        from     = sticky_num;
        to       = from;
    }


    else if(num_or_el && num_or_el.num)
    {
        arg_type = num_or_el.id;
        from     = num_or_el.num;
        to       = from;
    }


    else if( num_or_el )
    {
        arg_type = "All instances";
        from     = 1;
        to       = STICKY_MAX;
    }



    else if( onWork_STICKY )
    {
        arg_type = "current onWork_STICKY";
        from     = onWork_STICKY.num;
        to       = from;
    }


    if(!from || !to)
    {
        arg_type = "All instances";
        from     = 1;
        to       = STICKY_MAX;

    }




    lfx  = lfx || lfX[from];

log("%c LOG "+msg+"%c "+arg_type+" %c from "+from+" %c to "+to+" %c out of "+STICKY_MAX
    ,lbL+lfx      ,lbR+lfx        ,lbL+lfX[from]   ,lbC+lfX[to] ,lbR+lf8               );



    for(sticky_num = from; sticky_num <= to; ++sticky_num)
    {
        let sticky     =  sticky_array[ sticky_num ];

        if(!sticky)
            continue;


        let clone              = Object.assign({}, sticky);

        let sticky_pad = get_sticky_pad( sticky );
        if( sticky_pad ) {
            clone.sticky_pad   = strip_HTML(sticky_pad.innerHTML);
            clone.sticky_pad_W = sticky_pad.offsetWidth +" … "+ sticky_pad.clientWidth  +" … "+ sticky_pad.scrollWidth ;
            clone.sticky_pad_H = sticky_pad.offsetHeight+" … "+ sticky_pad.clientHeight +" … "+ sticky_pad.scrollHeight;
        }

        clone.className        = sticky.className;
        clone    ._____        = "Offset … Client … Scroll";
        clone    .W            = sticky.offsetWidth     +" … "+  sticky.clientWidth  +" … "+  sticky.scrollWidth ;
        clone    .H            = sticky.offsetHeight    +" … "+  sticky.clientHeight +" … "+  sticky.scrollHeight;

        if( clone.skipped_csv )
            clone.skipped_csv  = comma_to_LF(               sticky.skipped_csv);
        clone.anchor_node_path =  vbar_to_LF(get_node_path( sticky.anchor_node ), "…");

        let          anchor_xy = sticky_get_anchor_xy(sticky, sticky.anchor_node, sticky.offset_x, sticky.offset_y);
        clone.X                = sticky.offsetLeft      +" … offset_x=["+sticky.offset_x+"] ➔ x=["+(anchor_xy ? anchor_xy.x : "…")+"]";
        clone.Y                = sticky.offsetTop       +" … offset_y=["+sticky.offset_y+"] ➔ y=["+(anchor_xy ? anchor_xy.y : "…")+"]";

        if(from == to)
            clone.  callers    = t_log.get_callers();

        log_key_val_group( sticky_num+" sticky.num["+sticky.num+"] … msg: "+(sticky.msg ? ellipsis(strip_CR_LF(sticky.msg) , 16) : "[]")
                           , clone
                           , lfX[sticky_num]
                           , true);

        if(from != to) log("...");
    }

    return sticky_array[from];
};



const STICKY_LOG_TOOLTIP_DELAY =  500;
const STICKY_CSS_CNUM
    = [   [ CSS_PRESSED      , 1 ]
        , [ CSS_DIMMED       , 1 ]
        , [ CSS_SEEK_TARGET  , 1 ]

        , [ CSS_FIXED        , 2 ]
        , [ CSS_ANCHOR_NODE  , 2 ]

        , [ CSS_TOUCHED      , 3 ]
        , [ CSS_HAS_FOCUS    , 4 ]
        , [ CSS_PASTE_TARGET , 5 ]

        , [ CSS_STICKY_RING  , 9 ]

        , [ CSS_POINT_EE     , 8 ]
        , [ CSS_POINT_SE     , 8 ]
        , [ CSS_POINT_SW     , 8 ]
        , [ CSS_POINT_WW     , 8 ]
        , [ CSS_POINT_NW     , 8 ]
        , [ CSS_POINT_NE     , 8 ]
        , [ CSS_POINT_00     , 8 ]
    ];

let   sticky_LOG_TOOLTIP_timer;

let t_sticky_LOG_TOOLTIP = function(sticky,title)
{
    if(sticky_LOG_TOOLTIP_timer) clearTimeout(sticky_LOG_TOOLTIP_timer);

    sticky_LOG_TOOLTIP_timer   = setTimeout(function() { sticky_LOG_TOOLTIP_handler(sticky, title); }, STICKY_LOG_TOOLTIP_DELAY);
};


let   sticky_LOG_TOOLTIP_handler = function(sticky,title)
{

let   caller = "sticky_LOG_TOOLTIP_handler";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log_key_val(caller+": "+title+" .. "+sticky.id , sticky);



    let state_css_list = "";
    for(let i=0; i <     STICKY_CSS_CNUM.length ; ++i) {
        let [css, l_x] = STICKY_CSS_CNUM[i];
        if( !sticky.classList.contains( css ) ) continue;

        state_css_list += "<em class='fg"+l_x+"'>"+css+"</em> ";
    }


    let l_t
        = (sticky.touched == STICKY_HAND   ) ? 1
        : (sticky.touched == STICKY_PAD    ) ? 2
        : (sticky.touched == STICKY_ROTATE ) ? 6
        : (sticky.touched == STICKY_FIX    ) ? 7
        : (sticky.touched == STICKY_PEN    ) ? 8
        : (sticky.touched == STICKY_REFLOW ) ? 9
        : (sticky.touched == STICKY_PASTE  ) ? 9
        :                                      0;



    let anchor_node_path
        = sticky.anchor_node
        ?  vbar_to_LF("… "+get_node_path( sticky.anchor_node ), "… ")
        :  "";
    anchor_node_path = t_TEXT_LINES_to_COLORED_HTML( anchor_node_path );



    let l_s = (sticky.num % 10);

    let em_title
        = "<em class='big cc9'>"  + title     +"</em>";

    let em_id
        = "<em class='fg"+l_s+"'>"+ sticky.id +"</em>";

    let span_touched
        =  sticky.touched
        ?   "<em class='fg"+l_t+"'>touched: "+ sticky.touched +"</em>"
        :   "";

     let span_msg
        = "<span class='bg0'>"+ ellipsis( strip_HTML( sticky.msg ),16) +"</span>";

    let status_html = ""
        + em_title+" "+em_id + t_data.LF
        + span_msg           + t_data.LF
        + state_css_list     + t_data.LF
        + span_touched
    ;

if( log_this) log("%c status_html: %c"+t_data.LF+strip_HTML(status_html), lb5, lf5);



    let anchor_label = get_n_txt( sticky.anchor_node );
    let anchor_xy    = sticky.offset_x+" "+sticky.offset_y;
    let sticky_pos_x_y
        =       sticky.style.position
        +" "+   sticky.offsetLeft
        +" "+   sticky.offsetTop
    ;
    let anchor_children_span
        = highlighted_anchor_children.length
        ? "… <span>"+ highlighted_anchor_children.length+" anchors in viewport</span>"
        : ""
    ;

    let msg_pos_anchor_lines = ""
        + anchor_node_path
        + "<span class='bg0'>"+ ellipsis( anchor_label, 48) +"</span>"+t_data.LF
        + t_data.SYMBOL_BULB+" "+                sticky_pos_x_y              +t_data.LF
        + t_data.SYMBOL_BULB+" anchor "+         anchor_xy                   +t_data.LF
        +                                 anchor_children_span
    ;

if( log_this) log("%c msg_pos_anchor_lines: %c"+t_data.LF+strip_HTML(msg_pos_anchor_lines), lb6, lf6);



    t_fly.t_fly_tooltip_update(   "<pre class='fg0'>"
                                +  status_html
                                + "<hr>"
                                +  msg_pos_anchor_lines
                                +"</pre>"
                                , CSS_STICKY_LOG);


};





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_sticky"
    , logging : function(state) { return DOM_STICKY_LOG = t_store_set_state("DOM_STICKY_LOG",state); }
    , tagging : function(state) { return DOM_STICKY_TAG = t_store_set_state("DOM_STICKY_TAG",state); }
    , t_sticky_IMPORT


        , STICKY_MAX

        , CSS_LAYOUT_NE
        , CSS_LAYOUT_NW
        , CSS_LAYOUT_SE
        , CSS_LAYOUT_SW

        , CSS_ROTATE_NE
        , CSS_ROTATE_NW
        , CSS_ROTATE_SE
        , CSS_ROTATE_SW
        , CSS_ROTATE_XX

        , CSS_POINT_EE
        , CSS_POINT_SE
        , CSS_POINT_SW
        , CSS_POINT_WW
        , CSS_POINT_NW
        , CSS_POINT_NE
        , CSS_POINT_00
        , CSS_POINT_XX



    ,     t_sticky_LOAD
    ,     t_sticky_LOAD_ANCHORS_CHANGED
    ,     t_sticky_STORE
    ,     t_sticky_STORE_NOW
    ,     t_sticky_unpin_all
    ,     t_sticky_GET_COUNT
    ,     t_sticky_GET_NUM
    ,     t_sticky_NEW_XY_SEL_TEXT
    ,     t_sticky_LOG
    ,     t_sticky_scroll_STICKY_PAD_MSG

    ,     t_sticky_EDIT
    ,     t_sticky_EDITING
    ,     t_sticky_EDIT_DONE
    ,     t_sticky_set_SEL_PASTE_TARGET_STATE

    ,     t_sticky_get_tooltip
    ,     t_sticky_LOG_TOOLTIP



    ,     t_sticky_MAGNET
    ,     t_sticky_MAGNET_NOW
    ,     t_sticky_RESIZE
    ,     t_sticky_SET_DIMMED
    ,     t_sticky_SET_DIMMED_IS_PENDING
    ,     t_sticky_TRACK_DIR
    ,     t_sticky_e_target_STICKY
    ,     t_sticky_format_pad
    ,     t_sticky_format_pad_all
    ,     t_sticky_get_SCROLLING_STICKY
    ,     t_sticky_move_z_on_top
    ,     t_sticky_onDown_a_scrollable_STICKY
    ,     t_sticky_onLayout
    ,     t_sticky_onMove
    ,     t_sticky_reorder
    ,     t_sticky_reorder_required_on_scroll



    ,     t_sticky_onDown
    ,     t_sticky_onDown_a_STICKY_PAD
    ,     t_sticky_set_onWork_STICKY
    ,     t_sticky_get_onWork_STICKY
    ,     t_sticky_clr_SEEK_NEXT
    ,     t_sticky_get_SEEK_NEXT
    ,     t_sticky_set_SEEK_NEXT
    ,     t_sticky_onUp
    ,     t_sticky_CLICK_CB



    ,     t_sticky_is_EDITING
    ,     t_sticky_is_MOVING
    ,     t_sticky_is_ORIENTING
    ,     t_sticky_is_RESIZING
    ,     t_sticky_set_MOVING
    ,     t_sticky_SHOW_SEEKZONE_sync

    ,     t_sticky_CHOOSE
    ,     t_sticky_RING_layout
    ,     t_sticky_RING_stop




    , sticky_get_value       : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; return sticky_get_value       (sticky          ); }
    , layout                 : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; sticky_RESIZE7_STICKY_LAYOUT  (sticky          ); }
    , format_pad_anchor_path : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; sticky_format_pad_anchor_path (sticky          ); }
    , break_next             : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; sticky_RESIZE4_PAD_FLOW_NEXT  (sticky, 1       ); }
    , break_prev             : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; sticky_RESIZE4_PAD_FLOW_NEXT  (sticky,-1       ); }
    , magnet                 : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; t_sticky_MAGNET               (sticky,"console"); }
    , font                   : function(sticky_num=1,d_y=5)   { let sticky = sticky_array[sticky_num]; sticky_RESIZE3_PAD_FONT       (sticky, d_y     ); }
    , size                   : function(sticky_num=1,w=0,h=0) { let sticky = sticky_array[sticky_num]; sticky_SETSIZE_PAD_WH         (sticky, w, h    ); }
    , edit                   : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; t_sticky_EDIT                 (sticky          ); }
    , edit_done              : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; onWork_STICKY=sticky; t_sticky_EDIT_DONE(); }

    , format_pad             : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; t_sticky_format_pad           (sticky          ); }
    , fit_font               : function(sticky_num=1,d_y=5)   { let sticky = sticky_array[sticky_num]; sticky_RESIZE3_PAD_FONT_TO_FIT(sticky,"console"); }
    , msg_fit                : function(sticky_num=1)         { let sticky = sticky_array[sticky_num]; sticky_RESIZE6_MSG_FIT        (sticky,"console"); }

    , sticky_FIXED_TOGGLE
    , sticky_MAGNET0_PINNED
    , sticky_RESIZE8_END
    , sticky_MAGNET0_PINNED_onMoveDXY_clear

    , anchor                        : function(sticky_num=1) { let sticky = sticky_array[sticky_num];
        log("%c"+get_node_path(sticky.anchor_node)+" %c"+ellipsis_short(get_n_txt(sticky.anchor_node)), lf3,lb8);
        console.dir(sticky.anchor_node);
    }

    , sticky_remove_all
    , sticky_unpin_sticky_num
    };



}());

/*INLINE}}}*/
//@ sourceURL=dom_sticky.js
`
)
 .replace(/%u/g,"\\u")
;
/*}}}*/
/**  19 SEEK     JS dom_seek_js_data .. ESCAPE=[onWork_EL slot #"+slot] {{{*/
/*
../script/dom_seek.js
*/
let dom_seek_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/





















const DOM_SEEK_JS_ID        = "dom_seek_js";
const DOM_SEEK_JS_TAG       = DOM_SEEK_JS_ID    +" (220216:15h:55)";

let dom_seek    = (function() {
"use strict";
let   DOM_SEEK_LOG          = false;
let   DOM_SEEK_TAG          = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;

let t_i18n     = {}        ;
let t_prop     = {}        ;




let t_select   = {}        ;
let t_slot     = {}        ;



let t_sticky   = {}        ;







let t_tools    = {}        ;


let t_seek_IMPORT   = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;

    t_i18n    = dom_i18n   ;
    t_prop    = dom_prop   ;




    t_select  = dom_select ;

    t_slot    = dom_slot   ;



    t_sticky  = dom_sticky ;







    t_tools   = dom_tools  ;


    seek_INTERN();

    DOM_SEEK_LOG = DOM_SEEK_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_SEEK_LOG"));
    DOM_SEEK_TAG = DOM_SEEK_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_SEEK_TAG"));


if(log_this) log("%c 17 SEEK", lbH+lf7);
};





let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let   seek_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


    seek_DEPEND();
};




let CSS_SEEKZONE_ARRAY;
let CSS_CORNER_ARRAY;

let   seek_DEPEND = function()
{

    CSS_SEEKZONE_ARRAY
        = [   t_data.CSS_ANCHOR_NODE
            , t_data.CSS_BORDERING

            , t_data.CSS_DBLCLICK
            , t_data.CSS_LONGPRESS
            , t_data.CSS_MISCLICK
            , t_data.CSS_MISCLICK1
            , t_data.CSS_MISCLICK2
            , t_data.CSS_MISCLICK3
        ];

    CSS_CORNER_ARRAY
        = [   t_data.CSS_CORNER_U_R
            , t_data.CSS_CORNER_R_D
            , t_data.CSS_CORNER_D_L
            , t_data.CSS_CORNER_L_U
        ];

};







const CSS_SEEK0_ONDOC           = "seek0_onDOC";
const CSS_SEEK1_ONRESUME        = "seek1_onResume";
const CSS_SEEK2_ONSLOTEL        = "seek2_onSlotEL";
const CSS_SEEK3_ONTOOL          = "seek3_onTOOL";
const CSS_SEEK4_ONJUMPEL        = "seek4_onJumpEL";
const CSS_SEEK5_ONSEEKER        = "seek5_onSeeker";
const CSS_SEEK6_ONSTICKY        = "seek6_onSticky";



const TARGET_TYPE_RESUME = "RESUME";
const TARGET_TYPE_SELECT = "SELECT";
const TARGET_TYPE_STICKY = "STICKY";










let seek_TOOL = (function() {

let t_seektool_clr_TARGET = function()
{
    onWork_SEEK_TARGET  = null;

};


let t_seektool_has_TARGET = function()
{
    return !!onWork_SEEK_TARGET;
};


let t_seektool_get_TARGET_label = function()
{

    return t_util.get_n_lbl(onWork_SEEK_TARGET);
};


let t_seektool_get_STICKY = function()
{
    return (                    onWork_SEEK_TARGET
            && (               (onWork_SEEK_TARGET == seeker_PU) || (onWork_SEEK_TARGET == seeker_CU)
                ||             (onWork_SEEK_TARGET == seeker_PD) || (onWork_SEEK_TARGET == seeker_CD)
                || t_util.has_el_class(onWork_SEEK_TARGET, t_data.CSS_STICKY_TOOL)
               )
           )
            ?   onWork_SEEK_TARGET
            :   null;

};


let    onWork_SEEK_TARGET = null;
let t_seektool_set_TARGET = function(onWork_EL)
{

let   caller = "t_seektool_set_TARGET";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this ) log("%c"+caller+"("+t_util.get_n_lbl(onWork_EL)+")", lf9);




    if( onWork_EL !=    onWork_SEEK_TARGET)
    {
        let last_slot = onWork_SEEK_TARGET ? onWork_SEEK_TARGET.last_slot : 0;
        let last_num  = onWork_SEEK_TARGET ? onWork_SEEK_TARGET.last_num  : 0;

        if     (                 seeker_PU == onWork_EL                          ) { onWork_SEEK_TARGET = onWork_EL; }
        else if(                 seeker_CU == onWork_EL                          ) { onWork_SEEK_TARGET = onWork_EL; }
        else if(          t_util.has_el_class(onWork_EL,  t_data.CSS_STICKY_TOOL)) { onWork_SEEK_TARGET = onWork_EL; }
        else if(onWork_EL &&                  onWork_EL.id.startsWith("seekzone")) { onWork_SEEK_TARGET = onWork_EL; }
        else if(    t_select.is_a_select_tool(onWork_EL)                         ) { onWork_SEEK_TARGET = onWork_EL; }
        else if(  t_select.t_is_node_selected(onWork_EL)                         ) { onWork_SEEK_TARGET = onWork_EL; }

        if( onWork_SEEK_TARGET ) {
            onWork_SEEK_TARGET.last_slot = last_slot;
            onWork_SEEK_TARGET.last_num  = last_num ;
        }
    }


    if(onWork_EL) seektool_state_transition( onWork_EL );

if( log_this) log("%c onWork_SEEK_TARGET %c "+t_util.get_n_lbl(onWork_SEEK_TARGET)+"]", lbL+lf6, lbR+lfX[(onWork_SEEK_TARGET ? 4:0)]);
};


let t_seektool_set_STICKY = function(sticky)
{
    if(sticky) onWork_SEEK_TARGET = sticky;
};


let t_seektool_set_XY_LABEL_TARGET_TYPE = function(xy, seek_label, target_type=TARGET_TYPE_RESUME)
{
    onSeekXYLT.label = seek_label;
    onSeekXYLT.x     = xy.x.toFixed(0);
    onSeekXYLT.y     = xy.y.toFixed(0);

    if(target_type  != TARGET_TYPE_RESUME)
        onSeekXYLT.target_type = target_type;


};



let    seektool_state_transition = function(onWork_EL)
{

let caller = "seektool_state_transition";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) t_log.console_clear(caller+"("+t_util.get_id_or_tag(onWork_EL)+")");

if( log_this) t_tools.t_log_event_status(caller+" "+t_data.SYMBOL_RIGHT_ARROW+" BEFORE", lbb+lf0);


    let slot         = t_tools.t_get_onWork_EL_slot();
    let num          = t_tools.t_get_onWork_EL_num ();

    let slot_changed = onWork_SEEK_TARGET && onWork_SEEK_TARGET.last_slot && slot && (slot != onWork_SEEK_TARGET.last_slot);
    let  num_changed = onWork_SEEK_TARGET && onWork_SEEK_TARGET.last_num  &&  num && ( num != onWork_SEEK_TARGET.last_num );


    if( onWork_SEEK_TARGET) {
        onWork_SEEK_TARGET.last_slot = slot;
        onWork_SEEK_TARGET.last_num  =  num;
    }

    let slot_hasCCS
        = !!t_select.t_select_get_slot_pattern(slot)
    ;
if((slot >= 0) && !slot_hasCCS) logBIG(caller+": [slot "+slot+"] .. !slot_hasCCS .. ["+t_util.get_id_or_tag_and_className(onWork_EL)+"]", 2);

    let seeker_isOn_SLOT_EL = t_seeker_isOn_SLOT_EL(onWork_EL);


    let seek7_PUactive = t_seeker_PU_is_active();



    let            sticky = t_sticky.t_sticky_get_onWork_STICKY();

    let     seek6_onSticky
        =               (sticky != undefined      )
        &&              (sticky == onWork_EL      )

    ;


    let     seek5_onSeeker
        =  !seek6_onSticky
        && (    (seeker_CU == onWork_EL) || (seeker_PU == onWork_EL)
            ||  (seeker_CD == onWork_EL) || (seeker_PD == onWork_EL))
    ;



    let     seek4_onJumpEL
        =   seek7_PUactive
        && !seek6_onSticky
        && !seek5_onSeeker
        &&  seeker_isOn_SLOT_EL
        && (slot_changed || num_changed)
    ;



    let     seek3_onTOOL
        =  !seek6_onSticky
        && !seek5_onSeeker
        && !seek4_onJumpEL
        &&  t_tools.t_is_a_tool_el(onWork_EL, caller)
    ;



    let     seek2_onSlotEL
        =  !seek6_onSticky
        && !seek5_onSeeker
        && !seek4_onJumpEL
        && !seek3_onTOOL
        &&  slot
        &&  slot_hasCCS
    ;



    let     seek1_onResume
        =   seek7_PUactive
        && !seek6_onSticky
        && !seek5_onSeeker
        && !seek4_onJumpEL
        && !seek3_onTOOL
        && !seek2_onSlotEL
    ;



    let     seek0_onDOC
        =  !seek6_onSticky
        && !seek5_onSeeker
        && !seek4_onJumpEL
        && !seek1_onResume
        && !seek2_onSlotEL
    ;




    let target_type
        = seek5_onSeeker      ? TARGET_TYPE_RESUME
        : seek6_onSticky      ? TARGET_TYPE_STICKY
        : seeker_isOn_SLOT_EL ? TARGET_TYPE_SELECT
        :                       TARGET_TYPE_RESUME;



    let lfx
        =   seek6_onSticky ? lf6
        :   seek5_onSeeker ? lf5
        :   seek4_onJumpEL ? lf4
        :   seek3_onTOOL   ? lf3
        :   seek2_onSlotEL ? lf2
        :   seek1_onResume ? lf1
        :   seek0_onDOC    ? lf0
        :                    lf8
    ;

    let the_highest
        = seek6_onSticky   ? CSS_SEEK6_ONSTICKY
        : seek5_onSeeker   ? CSS_SEEK5_ONSEEKER
        : seek4_onJumpEL   ? CSS_SEEK4_ONJUMPEL
        : seek3_onTOOL     ? CSS_SEEK3_ONTOOL
        : seek2_onSlotEL   ? CSS_SEEK2_ONSLOTEL
        : seek1_onResume   ? CSS_SEEK1_ONRESUME
        : seek0_onDOC      ? CSS_SEEK0_ONDOC
        :                    "<seek_state_unexpected>"
    ;

if( log_this || DOM_SEEK_TAG) {
    log_key_val_group(   the_highest+" .. "+target_type+" ← "+onSeekXYLT.target_type
                     , { TOOLS               : "----------------------------------------"
                       , onWork_EL           : t_util.get_n_lbl(onWork_EL)
                       , onWork_EL_last_used : t_util.get_n_lbl(t_tools.t_get_onWork_EL_last_used())
                       , onWork_PANEL        : t_util.get_n_lbl(t_tools.t_get_onWork_PANEL())
                       , onWork_SEEK_TARGET  : t_util.get_n_lbl(onWork_SEEK_TARGET)
                       , sticky              : t_util.get_n_lbl(sticky)
                       , seek7_PUactive

                       , SLOT_NUM            : "----------------------------------------"
                       , slot                : "slot="+slot+" .. changed="+slot_changed+" .. last="+(onWork_SEEK_TARGET ? onWork_SEEK_TARGET.last_slot : 0)
                       , num                 : " num="+ num+" .. changed="+ num_changed+" .. last="+(onWork_SEEK_TARGET ? onWork_SEEK_TARGET. last_num : 0)
                       , slot_hasCCS
                       , seeker_isOn_SLOT_EL

                       , STATE               : "----------------------------------------"
                       , seek0_onDOC
                       , seek1_onResume
                       , seek2_onSlotEL
                       , seek3_onTOOL
                       , seek4_onJumpEL
                       , seek5_onSeeker
                       , seek6_onSticky
                     }
                     , lbb+lfx, true);

}



    t_util.del_el_class(seeker_PU, t_tools.CSS_FADING        );
    t_util.del_el_class(seeker_PU, t_data .CSS_HIDING        );
    t_util.del_el_class(seeker_PU, t_tools.CSS_ON_COOLDOWN   );
    t_util.del_el_class(seeker_PU, t_data .CSS_ON_HIDDEN_NODE);

    t_util.del_el_class(seeker_PU, CSS_SEEK6_ONSTICKY);
    t_util.del_el_class(seeker_PU, CSS_SEEK5_ONSEEKER);
    t_util.del_el_class(seeker_PU, CSS_SEEK4_ONJUMPEL);
    t_util.del_el_class(seeker_PU, CSS_SEEK3_ONTOOL  );
    t_util.del_el_class(seeker_PU, CSS_SEEK2_ONSLOTEL);
    t_util.del_el_class(seeker_PU, CSS_SEEK1_ONRESUME);

    if     ( seek6_onSticky      ) seektool_set6_onSticky(lbH+lfx, log_this);
    else if( seek5_onSeeker      ) seektool_set5_onSeeker(lbH+lfx, log_this);
    else if( seek4_onJumpEL      ) seektool_set4_onJumpEL(lbH+lfx, log_this);
    else if( seek3_onTOOL        ) seektool_set3_onTOOL  (lbH+lfx, log_this);
    else if( seek2_onSlotEL      ) seektool_set2_onSlotEL(lbH+lfx, log_this);
    else if( seek1_onResume      ) seektool_set1_onResume(lbH+lfx, log_this);
    else if( seek0_onDOC         ) seektool_set0_onDOC   (lbH+lfx, log_this);






    t_tools.t_clr_container_selected();


    let onDown_XY = t_tools.t_get_onDown_XY();
    let xy
        = {   x : onDown_XY.x + window.scrollX
            , y : onDown_XY.y + window.scrollY
        };

    if     ( seek6_onSticky   ) t_seektool_set_XY_LABEL_TARGET_TYPE(xy, CSS_SEEK6_ONSTICKY, target_type);
    else if( seek5_onSeeker   ) t_seektool_set_XY_LABEL_TARGET_TYPE(xy, CSS_SEEK5_ONSEEKER, target_type);
    else if( seek4_onJumpEL   ) t_seektool_set_XY_LABEL_TARGET_TYPE(xy, CSS_SEEK4_ONJUMPEL, target_type);
    else if( seek3_onTOOL     ) t_seektool_set_XY_LABEL_TARGET_TYPE(xy, CSS_SEEK3_ONTOOL  , target_type);
    else if( seek2_onSlotEL   ) t_seektool_set_XY_LABEL_TARGET_TYPE(xy, CSS_SEEK2_ONSLOTEL, target_type);
    else if( seek1_onResume   ) t_seektool_set_XY_LABEL_TARGET_TYPE(xy, CSS_SEEK1_ONRESUME, target_type);
    else if( seek0_onDOC      ) t_seektool_set_XY_LABEL_TARGET_TYPE(xy, CSS_SEEK0_ONDOC   , target_type);
    else                        t_seektool_set_XY_LABEL_TARGET_TYPE(xy, ""                , target_type);

     t_prop.set(CSS_SEEK0_ONDOC   , seek0_onDOC   );
     t_prop.set(CSS_SEEK3_ONTOOL  , seek3_onTOOL  );
     t_prop.set(CSS_SEEK2_ONSLOTEL, seek2_onSlotEL);
     t_prop.set(CSS_SEEK1_ONRESUME, seek1_onResume);
     t_prop.set(CSS_SEEK4_ONJUMPEL, seek4_onJumpEL);
     t_prop.set(CSS_SEEK5_ONSEEKER, seek5_onSeeker);
     t_prop.set(CSS_SEEK6_ONSTICKY, seek6_onSticky);



if( log_this || DOM_SEEK_TAG) t_tools.t_log_event_status_if_changed(caller+" "+t_data.SYMBOL_RIGHT_ARROW+" CHANGED", lbb+lfx);
};


let   seektool_set6_onSticky = function(lfx,log_this)
{

let caller = "seektool_set6_onSticky";

if( log_this) log("%c"+t_data.SYMBOL_RIGHT_ARROW_HOOK+" "+caller, lfx);

    t_util.add_el_class(seeker_PU, CSS_SEEK6_ONSTICKY);

    let sticky = t_sticky.t_sticky_get_onWork_STICKY();
    if( sticky ) {

        t_seeker_onMove1_grab( false );
    }

    if(t_select.get_last_selected_slot() > 0)
    {
if( log_this) log("...done with %c SEEK SLOT %c start %c SEEK STICKY", lf2,lbA,lfx);

        t_select.clear_last_selected_slot();
    }
};


let   seektool_set5_onSeeker = function(lfx,log_this)
{

let caller = "seektool_set5_onSeeker";

if( log_this) log("%c"+t_data.SYMBOL_RIGHT_ARROW_HOOK+" "+caller, lfx);

    t_util.add_el_class(seeker_PU, CSS_SEEK5_ONSEEKER);

    t_seeker_onMove1_grab("ON SEEKER");
};


let   seektool_set4_onJumpEL = function(lfx,log_this)
{

let caller = "seektool_set4_onJumpEL";

if( log_this) log("%c"+t_data.SYMBOL_RIGHT_ARROW_HOOK+" "+caller, lfx);


    t_util.add_el_class(seeker_PU, CSS_SEEK4_ONJUMPEL);



    t_seeker_SELECT_onWork_EL();

    t_seeker_onMove1_grab( false );
};


let   seektool_set3_onTOOL = function(lfx,log_this)
{

let caller = "seektool_set3_onTOOL";

if( log_this) log("%c"+t_data.SYMBOL_RIGHT_ARROW_HOOK+" "+caller, lfx);


};


let   seektool_set2_onSlotEL = function(lfx,log_this)
{

let caller = "seektool_set2_onSlotEL";

if( log_this) log("%c"+t_data.SYMBOL_RIGHT_ARROW_HOOK+" "+caller, lfx);


    t_util.add_el_class(seeker_PU, CSS_SEEK2_ONSLOTEL);
    t_seeker_onMove1_grab( false );
};


let   seektool_set1_onResume = function(lfx,log_this)
{

let caller = "seektool_set1_onResume";

if( log_this) log("%c"+t_data.SYMBOL_RIGHT_ARROW_HOOK+" "+caller, lfx);

    t_util.add_el_class(seeker_PU, CSS_SEEK1_ONRESUME);

    t_tools.t_set_onWork_EL(seeker_PU, caller);

    t_seeker_onMove1_grab(caller);
};


let   seektool_set0_onDOC = function(lfx,log_this)
{

let caller = "seektool_set0_onDOC";

if( log_this) log("%c"+t_data.SYMBOL_RIGHT_ARROW_HOOK+" "+caller, lfx);


    t_seektool_clr_TARGET();

    let slot = t_tools.t_get_onWork_EL_slot();
    if( slot > 0)
    {


        let onWork_EL = t_tools.t_get_onWork_EL();
        let onDown_EL = t_tools.t_get_onDown_EL();

        if((onDown_EL   == onWork_EL) && onWork_EL.parentElement) {
            onDown_EL    =               onWork_EL.parentElement;
            onWork_EL    =               onWork_EL.parentElement;
        }

        onWork_EL.scale  = t_util.t_get_panel_scale(onWork_EL);
    }
};


return { t_seektool_set_TARGET
    ,    t_seektool_clr_TARGET
    ,    t_seektool_get_TARGET_label
    ,    t_seektool_get_STICKY
    ,    t_seektool_has_TARGET
    ,    t_seektool_set_STICKY
    ,    t_seektool_set_XY_LABEL_TARGET_TYPE
};
}());









let t_seeker_onLoad = function()
{
    let id;
    id = "seeker_PD" ;  seeker_PD  = t_tools.t_get_tool(id);
    id = "seeker_CD" ;  seeker_CD  = t_tools.t_get_tool(id);

    id = "seeker_PU" ;  seeker_PU  = t_tools.t_get_tool(id);
    id = "seeker_CU" ;  seeker_CU  = t_tools.t_get_tool(id);

    id = "seekspot_D";  seekspot_D = t_tools.t_get_tool(id);
    id = "seekspot_A";  seekspot_A = t_tools.t_get_tool(id);
    id = "seekspot_U";  seekspot_U = t_tools.t_get_tool(id);

    id = "seekzone"  ;  seekzone   = t_tools.t_get_tool(id);
};














let t_seekzone_clr_onWork_EL_pressed = function()
{
    if(seekzone) t_util.del_el_class(seekzone, t_data.CSS_PRESSED);
};


let t_seeker_get_tool_panel = function(el)
{
    let tool_panel;

    if     (t_util.is_el_or_child_of_parent_el(el, seeker_PU)) tool_panel = seeker_PU;
    else if(t_util.is_el_or_child_of_parent_el(el, seeker_PD)) tool_panel = seeker_PD;

    return tool_panel;
};





let t_seeker_could_be_magnified = function(panel)
{
    if(panel == seeker_PD) return  true;
    else                   return false;
};








let t_seeker_onDown_1_INIT_CTRL_DEBOUNCE_INPUT = function(onWork_EL, onDown_XY)
{

let   caller = "t_seeker_onDown_1_INIT_CTRL_DEBOUNCE_INPUT";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c"+caller, lbF+lb1);


    seek_TOOL.t_seektool_set_TARGET(onWork_EL);



    if( t_prop.get(t_data.PIN_SEEKSPOT) )
    {
        seekzone_set_pressed();

        seekspot1_show_onDown_XY  (onDown_XY.x , onDown_XY.y);
        t_seekzone1_show_onDown_XY(onDown_XY.x , onDown_XY.y);
    }

};


let   seekzone_set_pressed = function()
{
    if(seekzone) t_util.add_el_class(seekzone, t_data.CSS_PRESSED);
};





let   seeker_GRAB_STATE;


let t_seeker_onMove1_grab    = function(grab_state)
{

let   caller = "t_seeker_onMove1_grab";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller+"("+grab_state+")");

    seeker_GRAB_STATE = grab_state;

if( log_this) {
    let label = seek_TOOL.t_seektool_get_TARGET_label();
    if(seeker_GRAB_STATE) log(label+" %c GRABBED BY "+seeker_GRAB_STATE, lb5);
    else                  log(label+" %c GRABBED false"                , lb9);
}
};
let t_seeker_onMove1_grabbed = function()
{

let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) {
    let label = seek_TOOL.t_seektool_get_TARGET_label();
    if(seeker_GRAB_STATE) log(label+" %c GRABBED STATE=["+seeker_GRAB_STATE+"]", lbb+lb5);
    else                  log(label+" %c GRABBED false"                        , lbb+lb9);
}

    return seeker_GRAB_STATE;
};


let t_seeker_onMove2_DXY = function(onMoveDXY)
{

let   caller = "t_seeker_onMove2_DXY";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) t_tools.t_log_event_status(caller, lf8);






    let slot =  t_tools.t_get_onWork_EL_slot();
    let  num =  t_tools.t_get_onWork_EL_num();
if(log_this) log("%c"+caller+": slot=["+slot+"] num=["+ num+"]", lbH+lfX[((slot > 0) && (num  > 0)) ? 5:2]);

    if((slot <= 0) || (num  <= 0)) return;


    let  dir = (Math.abs(onMoveDXY.x) > Math.abs(onMoveDXY.y)) ? ((onMoveDXY.x > 0) ? t_tools.DIR_NUM_NEXT  : t_tools.DIR_NUM_PREV )
        :                                                        ((onMoveDXY.y > 0) ? t_tools.DIR_SLOT_NEXT : t_tools.DIR_SLOT_PREV);
if( log_this)
    log_key_val_group(caller+"("+onMoveDXY.x+" "+onMoveDXY.y+")"
                      ,{ slot
                       , num
                       , dir
                      }, lf2, false);

    t_seeker_onMove2_SLOT_NUM_DIR(slot, num, dir);

};


let t_seeker_onMove2_SLOT_NUM_DIR = function(slot, num, dir)
{

let   caller = "t_seeker_onMove2_SLOT_NUM_DIR";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) caller += "(slot=["+slot+"] , num=["+num+"] , dir=["+dir+"])";

    let slot_nodes_length = t_select.t_select_get_slot_nodes_length(slot);
    if( slot_nodes_length < 1) return;

    seeker_CU.innerHTML        = num +"<sup>/"+ slot_nodes_length+"</sup>";




    seeker3_PU_sync_look_dir( dir );




    for(let i = 1; i <= t_select.SELECT_SLOT_MAX; ++i)
        t_tools.t_set_id_class_on_off(seeker_PU.id, "slot_color"+i, false);

    let slot_color = slot;
    if((dir == t_tools.DIR_SLOT_PREV) || (dir == t_tools.DIR_SLOT_NEXT))
    {
        let pre_or_next_slot
            = (dir == t_tools.DIR_SLOT_PREV)
            ?  t_slot.get_prev_populated_slot( slot )
            :  t_slot.get_next_populated_slot( slot );
if( log_this) log(caller+": ...pre_or_next_slot %c"+ pre_or_next_slot, lbb+lbH+((dir == t_tools.DIR_SLOT_PREV) ? lf5 : lf4));

        if(pre_or_next_slot)
            slot_color = pre_or_next_slot;
    }
    t_tools.t_set_id_class_on_off(seeker_PU.id, "slot_color"+slot_color, true);
    t_util.set_el_class_on_off(seeker_PU,  t_data.SHOW_SEEKZONE , t_prop.get( t_data.SHOW_SEEKZONE ));

};



let seeker_thumbs;
let last_seeked_slot_num = { slot:-1 , num:-1 };


let t_seeker_onMove3_ON_SLOT_NUM = function(slot, num)
{

let   caller = "t_seeker_onMove3_ON_SLOT_NUM";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) {
    log("%c"+caller+"%c slot "+slot+"%c num "+num
        ,lbL+lf5    ,lbC+lfX[slot]  ,lbR+lfX[num]);

    log_caller();
}
if( !seeker_PU || !seeker_PD || !seeker_CD || !seeker_CU) return;


    let visible = t_select.t_is_slot_num_visible(slot, num);

if( log_this) log("%c...visible=["+visible+"]", lfX[visible ? 5:3]);


    t_tools.t_window_getSelection_removeAllRanges(caller);



    let slot_nodes_length = t_select.t_select_get_slot_nodes_length( slot );
    let num_visible_count = t_select.t_get_slot_num_visible_count  ( slot );

    if(!num_visible_count || (num_visible_count == slot_nodes_length))
    {
        seeker_CU.innerHTML
            = num
            +"<sup>/"+ slot_nodes_length +"</sup>";
    }
    else {
        let visible_num = t_select.t_get_slot_num_visible_num(slot,num);

        if(visible)
            seeker_CU.innerHTML
                =  visible_num         +"<sup>/"+   num_visible_count +"</sup>"
                +                       "<sub>..."+ slot_nodes_length +"</sub>";
        else
            seeker_CU.innerHTML
                =                       "<sup>"+    num               +"</sup>"
                +                       "<sup> / "+ slot_nodes_length +"</sup>";
    }


    last_seeked_slot_num = { slot , num };
    t_util.set_el_class(seeker_CU
                 ,   "cc"+(      slot % t_select.SELECT_SLOT_MAX)
                 + " num"+(1+(num+11) % 12             )
                );




    if(!seeker_thumbs)
    {
        seeker_CD.innerHTML = ""

            + "<span class='seeker_handle  left' ></span>"
            + "<div     id='seeker_thumbs'       ></div>"
            + "<span class='seeker_handle  right'></span>"

        ;
        seeker_thumbs = t_tools.t_get_tool("seeker_thumbs");
    }


    if(seeker_thumbs)
    {
        let                        slot_first_id = "thumb_s_"+slot+"_1";
        let seeker_thumbs_includes_slot_first_id = seeker_thumbs.innerHTML.includes( slot_first_id );
if( log_this) log("...seeker_thumbs_includes_slot_first_id=["+seeker_thumbs_includes_slot_first_id+"]");
        if(!seeker_thumbs_includes_slot_first_id)
            seeker_thumbs.innerHTML = t_tools.t_pattern2_get_sel_bag_thumbs_EM(slot,"thumb_s");
    }


    if( !visible ) {
        t_util.add_el_class(seeker_PU, t_data.CSS_ON_HIDDEN_NODE);
        t_util.add_el_class(seeker_PD, t_data.CSS_ON_HIDDEN_NODE);
    }


    else {
        let node = t_select.t_select_get_slot_num_node(slot, num);
        if( node ) {
            if(typeof dom_details != "undefined")
            {
                if( dom_details.details_has_closed_el_parent ( node ))
                    dom_details.details_open_closed_el_parent( node );
            }


            setTimeout(function() { t_seeker_onMove3_ON_SLOT_NUM_handler(node); }, 0);
        }
    }


    t_select.t_set_last_selected_slot_num(slot, num);



    let container = t_select.get_slot_num_container(slot, num);

    t_tools.t_seek_set_container_selected(container, caller);

    if( log_this)
        log_key_val_group(caller+"("+slot+" , "+num+")"
                          , {   slot
                              , num
                              , visible
                              , slot_nodes_length
                              , num_visible_count
                          }, lf3, false);

    t_seeker_sync_SEL_BACK(caller);
};


let t_seeker_onMove3_ON_SLOT_NUM_handler = function(node)
{

let   caller = "t_seeker_onMove3_ON_SLOT_NUM_handler";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;
let tag_this = DOM_SEEK_TAG || log_this;



    delete node.scrolledIntoViewHandled;
    t_tools.t_scrollIntoViewIfNeeded(node,0);


    let bcr = node.getBoundingClientRect();
    let   x = bcr.x + window.scrollX;
    let   y = bcr.y + window.scrollY;

if( tag_this)
    log_key_val_group(  caller+" "+x.toFixed(0)+"@"+y.toFixed(0)+""
                        ,{ node
                            ,  bcr
                            ,  window_scrollX : window.scrollX
                            ,  window_scrollY : window.scrollY
                            ,  x
                            ,  y
                        }, lf7, true);

    if((x > 0) || (y > 0))
    {
        let node_W = node.offsetWidth;
        let node_H = node.offsetHeight;

        let node_L = x;
        let node_C = node_L + node_W/2;
        let node_T = y;
        let node_B = node_T + node_H;


        if(!t_seeker_PU_is_active() && seeker_onClick_PD_is_hiding())
            t_seeker_PU_show();


        let no_room_above = (node_T < 1.5 * seeker_PU.offsetHeight);
        if( no_room_above )     seeker_move_below_XY(seeker_PU, { x:node_C , y:node_B }, node);
        else                    seeker_move_above_XY(seeker_PU, { x:node_C , y:node_T }, node);


        if(!seeker_onClick_PD_is_hiding()) {
            if( no_room_above ) seeker_move_below_XY(seeker_PD, { x:node_C , y:node_B+seeker_PU.offsetHeight}, node);
            else                seeker_move_below_XY(seeker_PD, { x:node_C , y:node_B                       }, node);
        }

        t_util.del_el_class(seeker_PU, t_data.CSS_ON_HIDDEN_NODE);
        t_util.del_el_class(seeker_PD, t_data.CSS_ON_HIDDEN_NODE);

    }
};


let t_seeker_onMove2_ON_NEXT_STICKY = function(sticky, onDown_SCROLL_XY)
{

let   caller = "t_seeker_onMove2_ON_NEXT_STICKY";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c"+caller+"("+t_util.get_n_lbl(sticky)+")", lbH+lf1);

    let     to   = t_util.get_el_transformOrigin( sticky );
    let x = to.x + sticky.offsetLeft - onDown_SCROLL_XY.x;
    let y = to.y + sticky.offsetTop  - onDown_SCROLL_XY.y;

    x +=  t_util.has_el_class(sticky, t_sticky.CSS_POINT_EE) ?  20
        : t_util.has_el_class(sticky, t_sticky.CSS_POINT_SE) ?  10
        : t_util.has_el_class(sticky, t_sticky.CSS_POINT_SW) ? -10
        : t_util.has_el_class(sticky, t_sticky.CSS_POINT_WW) ? -20
        : t_util.has_el_class(sticky, t_sticky.CSS_POINT_NW) ? -10
        : t_util.has_el_class(sticky, t_sticky.CSS_POINT_NE) ?  10
        :                                        0;

    y +=  t_util.has_el_class(sticky, t_sticky.CSS_POINT_SE) ?  10
        : t_util.has_el_class(sticky, t_sticky.CSS_POINT_SW) ?  10
        : t_util.has_el_class(sticky, t_sticky.CSS_POINT_NW) ? -10
        : t_util.has_el_class(sticky, t_sticky.CSS_POINT_NE) ? -10
        :                                        0;


    let sticky_num = t_sticky.t_sticky_GET_NUM(sticky);

    seeker_CU.innerHTML
        = (t_prop.get(t_data.TOOLS_TIER2) ? "<sup>"+t_data.SYMBOL_LEFT_CHEVRON+"</sup>" : "")
        + sticky_num
    ;


    t_util.set_el_class(seeker_CU, "cc"+(sticky_num % 10));




    let no_room_above = (y < 1.5 * seeker_PU.offsetHeight);
    if( no_room_above ) seeker_move_below_XY(seeker_PU, { x:x+onDown_SCROLL_XY.x , y:y+onDown_SCROLL_XY.y }, sticky);
    else                seeker_move_above_XY(seeker_PU, { x:x+onDown_SCROLL_XY.x , y:y+onDown_SCROLL_XY.y }, sticky);

    seek_TOOL.t_seektool_set_STICKY( sticky );

};



let t_seeker_get_last_seeked_slot_num = function()
{
    return last_seeked_slot_num;
};





let seeker_move_above_XY_timer;

let   seeker_move_above_XY = function(tool, xy)
{

let   caller = "seeker_move_above_XY";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;


    t_seeker_PU_show();

    let x = xy.x;
    let y = xy.y;

    let   body_zoom_percent = t_tools.t_get_body_zoom_percent();
    x *= (body_zoom_percent  / 100);
    y *= (body_zoom_percent  / 100);
if( log_this) log(caller+"("+t_util.get_n_lbl(tool)+", "+x+" "+y+"): body_zoom_percent=["+body_zoom_percent+"]");

    let      tool_W = tool.offsetWidth ;
    let      tool_H = tool.offsetHeight;
    x               = Math.max((x-tool_W/2), tool_W/2);
    y               = Math.max((y-tool_H  ), tool_W/2);
    tool.style.left = x+"px";
    tool.style.top  = y+"px";

    t_util.del_el_class(tool, "seek_bellow");
    t_util.add_el_class(tool, "seek_above" );






};


let t_seeker_move_above_XY_cancel = function(_caller)
{

let   caller = "t_seeker_move_above_XY_cancel";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;


    if( seeker_move_above_XY_timer )
    {
if( log_this) log(caller+": PENDING RECENTER INTERRUPTED BY "+ _caller);

        clearTimeout(seeker_move_above_XY_timer);
        seeker_move_above_XY_timer = null;
    }

};


let   seeker_move_below_XY = function(tool, xy)
{

let   caller = "seeker_move_below_XY";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;


    t_seeker_PU_show();

    let x = xy.x;
    let y = xy.y;

    let   body_zoom_percent = t_tools.t_get_body_zoom_percent();
    x *= (body_zoom_percent  / 100);
    y *= (body_zoom_percent  / 100);
if( log_this) log(caller+"("+t_util.get_n_lbl(tool)+", "+x+" "+y+"): body_zoom_percent=["+body_zoom_percent+"]");

    let      tool_W = tool.offsetWidth ;
    tool.style.left = (x-tool_W/2)+"px";
    tool.style.top  = (y         )+"px";

    t_util.del_el_class(tool, "seek_above" );
    t_util.add_el_class(tool, "seek_bellow");


};


let   seeker3_PU_clear = function()
{
    if(!seeker_PU) return;

    seeker_PU.style.marginLeft = 0;
    seeker_PU.style.marginTop  = 0;

    seeker3_PU_sync_look_dir(null);
};


let   seeker3_PU_sync_look_dir = function( dir )
{

    t_tools.t_set_id_class_on_off(seeker_PU.id, t_data.CSS_SEEKER_PU2_LOOK_UP   , (dir == t_tools.DIR_SLOT_PREV));
    t_tools.t_set_id_class_on_off(seeker_PU.id, t_data.CSS_SEEKER_PU3_LOOK_RIGHT, (dir == t_tools.DIR_NUM_NEXT ));
    t_tools.t_set_id_class_on_off(seeker_PU.id, t_data.CSS_SEEKER_PU4_LOOK_DOWN , (dir == t_tools.DIR_SLOT_NEXT));
    t_tools.t_set_id_class_on_off(seeker_PU.id, t_data.CSS_SEEKER_PU5_LOOK_LEFT , (dir == t_tools.DIR_NUM_PREV ));
};







let t_seeker_onUp8_ON_MOUSEUP_DONE = function(e)
{

let   caller = "t_seeker_onUp8_ON_MOUSEUP_DONE";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

    if(!seeker_PU ) return;


    let     long_press_armed = t_util.has_el_class(seeker_CU, t_tools.LONG_PRESS_ARM);
    let       seekspot_trace = t_prop.get( t_data.PIN_SEEKSPOT );
    let       was_a_misclick = t_tools.t_was_a_misclick();
    let          was_a_click = t_tools.t_was_a_click() && !was_a_misclick;
    let            has_moved = t_tools.t_get_has_moved();
    let         onWork_PANEL = t_tools.t_get_onWork_PANEL();
    let         on_dimm_mask = !!(onWork_PANEL && (onWork_PANEL == t_tools.t_get_dimm_mask()));
    let  seeker_PD_is_hiding = seeker_onClick_PD_is_hiding();
    let is_a_hide_click
        =   was_a_click
        && !was_a_misclick
        && !has_moved
        && !on_dimm_mask
        && seeker_PD_is_hiding
    ;



if( log_this) {
    let lfx = lfX[is_a_hide_click ? 7:8];

    t_tools.t_log_event_status(caller, lbH+lfx);

    let details
        = (is_a_hide_click ? "HIDE ON CLICK" : "HIDE ON UP")
        + (        has_moved ? " .. has_moved" : ""        )
    ;

    log_key_val_group(details
                      , { seekspot_trace
                         , long_press_armed
                         , was_a_click
                         , was_a_misclick
                         , has_moved
                         , is_a_hide_click : (is_a_hide_click + t_log.L_ARR+      "has_moved.."+(has_moved ? has_moved:"[]")
                                              +                 t_log.L_ARR+    "was_a_click.."+           was_a_click
                                              +                 t_log.L_ARR+ "was_a_misclick.."+           was_a_misclick      )
                         , on_dimm_mask    : (on_dimm_mask    + t_log.L_ARR+   "onWork_PANEL.."+ t_util.get_n_lbl(onWork_PANEL))
                         , seeker_PD_is_hiding
                      }
                     , lfx, true);
}


    if( seekspot_trace )
    {
        if( was_a_misclick ) t_seeker_show("onUP .. [was_a_misclick]");
        else                 t_seekzone5_hide();
    }


    if( long_press_armed )
    {
if( log_this) logBIG("REVIVE SEEKER .. f(t_tools.LONG_PRESS_ARM)");

        t_util.del_el_class(seeker_CU, t_tools.LONG_PRESS_ARM);

        t_seeker_PU_show();
    }
    t_util.del_el_class(seeker_CU, t_tools.LONG_PRESS_ARM);

    seeker3_PU_clear();


    for(let i = 1; i <= t_select.SELECT_SLOT_MAX; ++i)
        t_tools.t_set_id_class_on_off(seeker_PU.id, "slot_color"+i, false);

    t_util.set_el_class_on_off(seeker_PU,  t_data.SHOW_SEEKZONE , false);


    if( is_a_hide_click ) t_seeker_PU_hide("instant");
    else                  t_seeker_PU_hide();


};




let t_seeker_onClick = function()
{

let   caller = "t_seeker_onClick";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

    let onDown_EL = t_tools.t_get_onDown_EL();
    let bag_id = t_seeker_get_node_bag_id(onDown_EL);

if( log_this) t_tools.t_log_event_status(caller, lbH+lf5);
if( log_this) log("%c "+caller+": %c onDown_EL ["+t_util.get_n_lbl(onDown_EL)+"] %c bag_id ["+bag_id+"]"
                  ,lb5           ,lb2                                    ,lb3                    );

    let result = "";
    switch(bag_id) {
        case "seeker_PU":
        {

            if((onDown_EL == seeker_CU) && seeker_onClick_PD_is_hiding())
            {
                t_tools.seek_pat_bag();

                result = "SEEKER ANIMATION";
            }





            else if( t_seeker_PU_is_active() )
            {
if(log_this) t_log.log_TR_EVENT_add("_<em class='cc8'>HIDE seeker_PU</em> "+onSeekXYLT.label);

                t_seeker_PU_hide("instant");

                result = "HIDE seeker_PU";
            }

        }
        break;

        case "seeker_PD":
        {

            let e_target_is_seeker_handle_left_or_right
                =  onDown_EL.classList.contains( t_data.CSS_SEEKER_HANDLE)
                && (   t_util.has_el_class(onDown_EL  , t_data.CSS_LEFT         )
                    || t_util.has_el_class(onDown_EL  , t_data.CSS_RIGHT        ));

            if( e_target_is_seeker_handle_left_or_right )
            {
if(log_this) t_log.log_TR_EVENT_add(".switch <em class='cc1'>TOGGLE "+t_data.SEL_BACK+"</em>");

                t_prop.toggle( t_data.SEL_BACK );
if(log_this) t_log.log_TR_SELECT_add("_<em class='cc3'>SELECT <em class='cc9'>"+(t_prop.get( t_data.SEL_BACK ) ? "BACKWARD" : "FORWARD")+"</em></em>");

                t_seeker_sync_SEL_BACK(caller);

                result = "TOGGLE t_data.SEL_BACK";
            }


            else if(onDown_EL.id.startsWith("thumb_s_"))
            {
if(log_this) t_log.log_TR_EVENT_add(".switch <em class='cc1'>SCROLL TO "+onDown_EL.id+"</em>");

                t_tools.t_onclick_target_handle_scroll_to_slot_num(onDown_EL, caller);

                result = "SCROLL TO ["+onDown_EL.id+"]";
            }


            else if( !t_tools.t_is_panel_magnified(seeker_PD) )
            {
if(log_this) t_log.log_TR_EVENT_add(".switch <em class='cc1'>MAGNIFY seeker_PD</em>");

                t_tools.t_toggle_panel_magnified(seeker_PD, "toggle");

                result = "MAGNIFY [seeker_PD]";
            }


            else {
if(log_this) t_log.log_TR_EVENT_add("_<em class='cc8'>HIDE seeker_PD</em>");

                seeker_onClick_PD_hide();

                result = "HIDE [seeker_PD]";
            }

        }
        break;

    }
    return result;
};


let   seeker_onClick_move_on_last_highlight_slot_num = function()
{
let   caller = "seeker_onClick_move_on_last_highlight_slot_num()";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller);

    let last_selected_slot  = t_select.get_last_selected_slot();
    if( last_selected_slot >= 0)
        t_seeker_onMove3_ON_SLOT_NUM(last_selected_slot, t_select.get_last_highlighted_num());
};


let   seeker_onClick_PD_show = function()
{
let caller = "seeker_onClick_PD_show";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller);

    if( !seeker_PD ) return;

    if(seeker_onClick_PD_hide_timer) {
        clearTimeout( seeker_onClick_PD_hide_timer );
 seeker_onClick_PD_hide_timer = null;
    }

    t_seeker_sync_SEL_BACK(caller);

    t_util.del_el_class(seeker_PD, t_tools.CSS_FADING);
    t_util.del_el_class(seeker_PD, t_data.CSS_HIDING);

    seeker_PD.style.display = "block";
};


const SEEKER_ONCLICK_PD_HIDE_DELAY = 500;

let   seeker_onClick_PD_hide_timer;
let   seeker_onClick_PD_hide = function()
{
    if( !seeker_PD ) return;

    if(seeker_onClick_PD_hide_timer) clearTimeout( seeker_onClick_PD_hide_timer  );
    seeker_onClick_PD_hide_timer   =   setTimeout( seeker_onClick_PD_hide_handler, SEEKER_ONCLICK_PD_HIDE_DELAY);
};


let   seeker_onClick_PD_hide_handler = function()
{
    if( !seeker_PD ) return;

    seeker_onClick_PD_hide_timer = null;

    t_util.del_el_class(seeker_PD, t_tools.CSS_FADING);
    t_util.add_el_class(seeker_PD, t_data.CSS_HIDING);

    seeker_PD.style.display = "none";

};


let   seeker_onClick_PD_is_hiding = function()
{
    return !seeker_PD
        ||  seeker_PD.classList.contains(t_data.CSS_HIDING)
        ||  seeker_PD.style.display   != "block"
    ;
};













const HIDE_SEEKZONE_DELAY = 1000;
const SHOW_SEEKZONE_DELAY = 500;

const SEEKSPOT_H_MIN      = 32;
const SEEKSPOT_SPACING    =  2;
const SEEKSPOT_W_MIN      = 32;




let t_seeker_show_msg      = [];
let t_seeker_show_msg_last = "";
let t_seeker_show_msg_num  = 0;
let t_seeker_show_timer    = 0;

let t_seeker_show = function(msg="")
{

let caller = "t_seeker_show";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;



    if( t_prop.get( t_data.SHOW_SEEKZONE ) )
    {
        if(t_prop.get( t_data.LOG_SEEKSPOT ) && msg && (t_seeker_show_msg_last != msg))
        {
if( log_this) log("%c"+caller+"("+msg+")", lbH+lf1);

            t_seeker_show_msg.push(    msg );
            t_seeker_show_msg_last  =  msg;
        }
        if(!t_seeker_show_timer && t_seeker_show_msg.length)
            t_seeker_show_timer = setTimeout(seek_show_handler, SHOW_SEEKZONE_DELAY);
    }


    else {

        if(t_seeker_show_msg.length)
        {
if( log_this) log("%c"+caller+"("+msg+"): t_data.LOG_SEEKSPOT OFF .. HISTORY CLEANUP", lbH+lf1);
            t_seeker_show_msg     = [];
            t_seeker_show_msg_num = 0;
        }


        if(seekspot_U.innerHTML || seekspot_D.innerHTML)
        {
            seekspot_U.innerHTML     = "";
            seekspot_D.innerHTML     = "";
        }

    }

};


let   seekspot_U_or_D;
let   seek_show_handler = function()
{

let   caller = "seek_show_handler";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) t_tools.t_log_event_status(caller, lf8);
if( log_this) log("%c"+t_data.SYMBOL_BULB+"%c "+caller+"%c container_selected %c "+ t_util.get_id_or_tag(container_selected)+"%c onSeekXYLT %c "+onSeekXYLT.x+" "+onSeekXYLT.y
                  ,lb2             ,lbL         ,lbL                  ,lbR+lf4                                 ,lbL         ,lbR+lf4                         );

    t_seeker_show_timer = null;

    if(!t_prop.get( t_data.SHOW_SEEKZONE ) ) {
if( log_this) logBIG("aborted by t_prop.get(t_data.SHOW_SEEKZONE)");
        return;
    }

    seekzone5_hide_cancel();








    seekzone.style.borderWidth      = SEEKSPOT_SPACING;

    seekzone.style  .display        = "block";
    seekspot_U.style.display        = "table-cell";
    seekspot_D.style.display        = "table-cell";



    let onDown_XY = t_tools.t_get_onDown_XY();
    let seek_X    = container_selected ? container_selected.x            : onDown_XY.x;

    let seek_H    = container_selected ? container_selected.scrollHeight : SEEKSPOT_H_MIN;
    let seek_W    = container_selected ? container_selected.scrollWidth  : SEEKSPOT_W_MIN;

    if(container_selected)
        seekzone.style.borderRadius = parseInt(window.getComputedStyle(container_selected).borderRadius) +"px";

    let page_H    = document.body.parentElement.clientHeight;

    let above_H   = Math.max(SEEKSPOT_SPACING, onSeekXYLT.y);
    let inset_H   = Math.max(SEEKSPOT_SPACING, seek_H);
    let inset_W   = Math.max(SEEKSPOT_SPACING, seek_W);

    above_H       = Math.min(page_H - inset_H, above_H);

    let below_H   = Math.max(SEEKSPOT_SPACING, page_H - (above_H + inset_H));




    seekspot_U.style.height         = (above_H     - SEEKSPOT_SPACING   ) +"px";

    if( t_prop.get( t_data.PIN_SEEKSPOT ) )
    {
        seekspot_A.style.display    = "block";
        seekspot_A.style.top            = (above_H                          ) +"px";
        seekspot_A.style.marginLeft     = (seek_X      - SEEKSPOT_SPACING   ) +"px";
    }

    if(container_selected)
    {
        seekzone.style.left         = (seek_X                           ) +"px";
        seekzone.style.top          = (above_H                          ) +"px";
        seekzone.style.width        = (        inset_W                  ) +"px";
        seekzone.style.height       = (        inset_H                  ) +"px";

        t_util.add_el_class(seekzone, t_data.CSS_ON_CONTAINER);
    }
    else {
        seekzone.style.left         = (onDown_XY.x                      ) +"px";
        seekzone.style.top          = (onDown_XY.y                      ) +"px";
        seekzone.style.width        = (              seek_W             ) +"px";
        seekzone.style.height       = (              seek_H             ) +"px";

        t_util.del_el_class(seekzone, t_data.CSS_ON_CONTAINER);
    }

    seekspot_D.style.height         = (                below_H - SEEKSPOT_SPACING   ) +"px";


    if( t_prop.get( t_data.LOG_SEEKSPOT ) )
    {
        let msg = t_seeker_show_msg.shift();
        if( msg )
        {
            seekspot_U_or_D
                = (seekspot_U_or_D   ==   seekspot_U)
                ? (above_H < (page_H/4)) ? seekspot_D : seekspot_U
                : (below_H < (page_H/4)) ? seekspot_U : seekspot_D
            ;

            let empty_caption = (seekspot_U_or_D == seekspot_D) ? seekspot_U : seekspot_D;
            empty_caption.innerHTML = "";


            let ccx = (++t_seeker_show_msg_num) % 10;
log("t_data.SHOW_SEEKZONE %c"+t_seeker_show_msg_num +"%c"+ msg, lbH+lfX[ccx], lbH+lf9);
            seekspot_U_or_D.innerHTML
                = "<pre><em class='big cc"+ccx+"'>"+t_seeker_show_msg_num+"</em> "+(msg ? ("<em class='big cc7'>"+msg+"</em>") : "")
                +          (t_prop.get( t_data.PIN_SEEKSPOT ) ? " <em class='cc8' style='float:right;'>"+t_data.SYMBOL_PUSH_PIN+"</em>" : "")
                + t_data.LF+     ".. WH ["  + window.innerWidth +" "+ window.innerHeight +"]"
                +         ".. SEEK ["+ onSeekXYLT.x       +" "+ onSeekXYLT.y        +"]"
                +         ".. XY ["  + onDown_XY.x       +" "+ onDown_XY.y        +"]"
                + t_data.LF + "-----------------------------------------------------------"
                + t_data.LF + t_tools.t_log_tools_status_get()
                + t_data.LF + t_tools.t_log_event_status_get()
                + "</pre>"
            ;


            if( t_seeker_show_msg.length)
                t_seeker_show_timer = setTimeout(seek_show_handler, SHOW_SEEKZONE_DELAY);
        }
    }
    else {
        seekspot_U.style.display = "none";
        seekspot_D.style.display = "none";
    }

};


let   seekspot1_show_onDown_XY = function(x,y)
{

let  caller = "seekspot1_show_onDown_XY";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf1);


    let container_selected
        = t_tools.t_get_container_selected();

    let container_symbol
        = container_selected
        ? container_selected.tagName+" "+ t_data.SYMBOL_HEAVY_RIGHT_ARROW+" "
        : ""
    ;

    let onWork_EL
        = t_tools.t_get_onWork_EL();

    let container_msg
        = t_util.get_n_txt(onWork_EL) +" "+t_data.SYMBOL_BLACK_CIRCLE+" "+t_util.get_n_lbl(onWork_EL)
    ;



    let sym;
    let msg;
    switch( onSeekXYLT.label )
    {
        case CSS_SEEK2_ONSLOTEL : { sym = t_data.SYMBOL_BLACK_R_HAND ; msg = "SEEK SLOT #"+t_tools.t_get_onWork_EL_slot(); } break;
        case CSS_SEEK4_ONJUMPEL : { sym = "ON"                       ; msg = t_util.get_id_or_tag(onWork_EL)             ; } break;
        case CSS_SEEK6_ONSTICKY : { sym = "ON"                       ; msg = t_util.get_id_or_tag(onWork_EL)             ; } break;
        case CSS_SEEK5_ONSEEKER : { sym = container_symbol           ; msg = container_msg                               ; } break;
        case CSS_SEEK1_ONRESUME : { sym = t_data.SYMBOL_GEAR         ; msg = "RESUME"                                    ; } break;
        case CSS_SEEK0_ONDOC    : { sym = t_data.SYMBOL_BLACK_R_HAND ; msg = "SEEK DOC"                                  ; } break;
        default                 : { sym = t_data.SYMBOL_CIRCLE       ; msg = onSeekXYLT.label || "NOT SEEKING"           ; } break;
    }

    t_seeker_show(sym +" "+ msg);



    if( t_prop.get( t_data.PIN_SEEKSPOT ) )
    {
        seekspot_A.style.marginLeft = x +"px";
        seekspot_A.style.top        = y +"px";
        seekspot_A.style.display    = "block";
    }

};


let t_seekzone1_show_onDown_XY = function(x,y)
{

let   caller = "t_seekzone1_show_onDown_XY";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c"+t_data.SYMBOL_BULB+"%c onSeekXYLT %c "+onSeekXYLT.x+" "+onSeekXYLT.y
                  ,lbb+lf1         ,lbL         ,lbR+lf4                         );
if( log_this) t_tools.t_log_event_status(caller, lf1);


    seekzone5_hide_cancel();

    t_util.del_el_class(seekzone, t_data.CSS_ON_CONTAINER);


    seekzone.style.display = "block";
    seekzone.style.left    = (x                )+"px";
    seekzone.style.top     = (y                )+"px";
    seekzone.style.width   = (  SEEKSPOT_W_MIN )+"px";
    seekzone.style.height  = (  SEEKSPOT_H_MIN )+"px";
    seekzone.innerHTML     = "";


};


let t_seekzone2_show_misclick = function(pressMS, misclick_MS)
{

let  caller = "t_seekzone2_show_misclick";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf2);


    let css_class;
    if     (pressMS < misclick_MS * 0.25) css_class = t_data.CSS_MISCLICK1;
    else if(pressMS < misclick_MS * 0.50) css_class = t_data.CSS_MISCLICK2;
    else if(pressMS < misclick_MS * 0.75) css_class = t_data.CSS_MISCLICK3;
    else                                  css_class = t_data.CSS_MISCLICK ;

    t_util.set_el_class_removing(seekzone,       css_class, CSS_SEEKZONE_ARRAY);


};


let t_seekzone3_show_dblclick = function(pressMS, misclick_MS)
{

let  caller = "t_seekzone3_show_dblclick";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf3);


    t_util.set_el_class_removing(seekzone, t_data.CSS_DBLCLICK, CSS_SEEKZONE_ARRAY);

};


let t_seekzone4_show_longpress = function()
{

let  caller = "t_seekzone4_show_longpress";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf4);


    t_util.set_el_class_removing(seekzone, t_data.CSS_LONGPRESS, CSS_SEEKZONE_ARRAY);

};


let t_seekzone5_hide_timer;
let t_seekzone5_hide = function(flags)
{

let  caller = "t_seekzone5_hide";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf5);


    if(!seekzone                   ) return;

    if     (flags == "restart"     ) seekzone5_hide_cancel();
    else if( t_seekzone5_hide_timer ) return;

    if(flags != "instant") { t_seekzone5_hide_timer =   setTimeout(seekzone5_hide_handler, HIDE_SEEKZONE_DELAY); }
    else                   { t_seekzone5_hide_timer = null;        seekzone5_hide_handler();                     }
};


let   seekzone5_hide_handler = function()
{

    t_seekzone5_hide_timer = null;

    if(!seekzone) return;



    if( t_tools.t_get_onWork_EL() )
    {
        t_seekzone5_hide_timer = setTimeout(seekzone5_hide_handler, HIDE_SEEKZONE_DELAY);
        return;
    }


    seekzone.className = "";


    seekzone  .style.display = "none";
    seekspot_U.style.display = "none";
    seekspot_A.style.display = "none";
    seekspot_D.style.display = "none";

    seek_TOOL.t_seektool_clr_TARGET();
};


let   seekzone5_hide_cancel = function()
{
    if(!t_seekzone5_hide_timer   ) return;

    clearTimeout( t_seekzone5_hide_timer );

    t_seekzone5_hide_timer = null;
};



let t_seekzone6_show_anchor_node = function()
{

let  caller = "t_seekzone6_show_anchor_node";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf6);


    t_util.set_el_class_removing(seekzone, t_data.CSS_ANCHOR_NODE, CSS_SEEKZONE_ARRAY);

};


let container_selected;
let t_seekzone7_show_container = function(container)
{

let  caller = "t_seekzone7_show_container";
let log_this = DOM_SEEK_LOG;

    if(container == container_selected) return;

if( log_this) log("%c"+caller, lbH+lf7);




    container_selected = container;

    let bcr = container_selected.getBoundingClientRect();
    let xy = { x: bcr.x + window.scrollX
             , y: bcr.y + window.scrollY };

    let seek_label = "CONTAINER ["+t_util.get_n_lbl(container_selected)+"]";

    seek_TOOL.t_seektool_set_XY_LABEL_TARGET_TYPE(xy, seek_label);

    t_seeker_show(t_data.SYMBOL_BLACK_CIRCLE+" "+seek_label);
};


let t_seekzone8_show_gutter_xywh = function(x, y, w, h)
{

let  caller = "t_seekzone8_show_gutter_xywh";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf8);


    if(!seekzone) return;


    seekzone5_hide_cancel();



    seekzone.style.display = "block";
    seekzone.style.left    = x +"px";
    seekzone.style.top     = y +"px";
    seekzone.style.width   = w +"px";
    seekzone.style.height  = h +"px";

    t_util.del_el_class(seekzone, t_data.CSS_ON_CONTAINER);
    t_util.add_el_class(seekzone, t_data.CSS_GUTTER);
    t_tools.t_store_consider_page_items_worth_storing("HOTSPOT  TO GUTTER");
};


let t_seekzone8_hide_gutter = function()
{

let  caller = "t_seekzone8_hide_gutter";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf8);


    t_util.del_el_class(seekzone, t_data.CSS_GUTTER    );
    t_util.del_el_class(seekzone, t_data.MARKED_TO_HIDE);

    t_seekzone5_hide("instant");
};


let t_seekzone8_isOn_gutter = function()
{
    return t_util.has_el_class(seekzone, t_data.CSS_GUTTER);
};


let t_seekzone9_show_bordering = function(css_corner)
{

let  caller = "t_seekzone9_show_bordering";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller+"("+css_corner+")", lbH+lf9);

    t_util.set_el_class_removing(seekzone, t_data.CSS_BORDERING, CSS_SEEKZONE_ARRAY);
    t_util.set_el_class_removing(seekzone, css_corner   , CSS_CORNER_ARRAY  );

    t_util.del_el_class(         seekzone, t_data.CSS_PRESSED);
};


let t_seekzone0_show_MASK_OR_HIDE = function()
{

let  caller = "t_seekzone0_show_MASK_OR_HIDE";
let log_this = DOM_SEEK_LOG;

if( log_this) log("%c"+caller, lbH+lf0);


    if( t_prop.get( t_data.MASK_OR_HIDE ) )
        t_util.del_el_class(seekzone, t_data.MARKED_TO_HIDE);
    else
        t_util.add_el_class(seekzone, t_data.MARKED_TO_HIDE);
};







let t_seeker_is_seeker_PU = function(el)
{
    return (el ==  seeker_PU);
};


let t_seeker_is_seeker_PU_ONSEEKER = function()
{
    return  t_util.has_el_class(seeker_PU, CSS_SEEK5_ONSEEKER);
};




let onSeekXYLT = { target_type: "" , x:0 , y:0 , label:"" };

let t_seeker_get_onSeekXYL = function()
{
    return onSeekXYLT;
};

let t_seeker_get_seeker_PU_XY = function()
{
    let bcr = seeker_PU.getBoundingClientRect();

    return { x : (window.scrollX + bcr.left + bcr.width  / 2).toFixed(0)
        ,    y : (window.scrollY + bcr.top  + bcr.height    ).toFixed(0) };
};

let t_seeker_is_onSticky = function()
{
    let result = (onSeekXYLT.target_type == TARGET_TYPE_STICKY);

    return result;
};



let t_seekzone_set_selected = function()
{
    if(seekzone) t_util.add_el_class(seekzone, t_tools.CSS_CONTAINER_SELECTED);
};


let t_seekzone_clr_selected = function()
{
    if(seekzone) t_util.del_el_class(seekzone, t_tools.CSS_CONTAINER_SELECTED);
};







let seeker_CD;
let seeker_CU;
let seeker_PD;
let seeker_PU;

let seekzone;
let  seekspot_A;
let  seekspot_U;
let  seekspot_D;




let t_seeker_get_node_bag_id = function(node)
{
    let bag_id = "";
    if     (t_util.is_el_or_child_of_parent_el(node, seeker_PU)) bag_id = "seeker_PU";
    else if(t_util.is_el_or_child_of_parent_el(node, seeker_PD)) bag_id = "seeker_PD";


    return bag_id;
};




const T_SEEKER_PU_HIDE_LONG_DELAY = 5000;
const T_SEEKER_PU_HIDE_FAST_DELAY = 5000;
const T_SEEKER_PU_FADE_DELAY      = 3000;
const T_SEEKER_SYNC_DELAY         = 500;

let   t_seeker_PU_fade_timer;
let   t_seeker_PU_hide_timer;
let   t_seeker_sync_timer;


let t_seeker_sync = function()
{
    if(!seeker_PU) return;

    if(t_seeker_sync_timer) clearTimeout( t_seeker_sync_timer );
    t_seeker_sync_timer   =   setTimeout( seeker_sync_handler , T_SEEKER_SYNC_DELAY);
};


let t_seeker_sync_is_pending = function()
{
    return (t_seeker_sync_timer != null);
};


let   seeker_sync_handler = function()
{
    t_seeker_sync_timer = null;

    if     (  t_seeker_PU_is_active() ) t_seeker_PU_show();
    else if(  t_tools.t_scroll_not_done_yet() ) t_seekzone5_hide("instant");
};


let t_seeker_hide = function()
{
    let el;
        if(    el = seeker_PD          ) el.style.display = "none";
        if(    el = seeker_PU          ) el.style.display = "none";
};


let   seeker_set_PU_locked_on_screen = false;

let t_seeker_set_PU_locked_on_screen = function(state)
{
    if(!seeker_set_PU_locked_on_screen && state) t_seeker_PU_show();

    seeker_set_PU_locked_on_screen = state;

    if(!seeker_set_PU_locked_on_screen         ) t_seeker_PU_hide();
};


let is_seeker_set_PU_locked_on_screen = function(_caller)
{
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) {
    let l_x = seeker_set_PU_locked_on_screen ? lbL+lf7 : lbL+lf0;
    let l_y = seeker_set_PU_locked_on_screen ? lbR+lf7 : lbR+lf0;
    log("%c SEEKER LOCKED ON SCREEN "+seeker_set_PU_locked_on_screen+" %c"+_caller
                  ,l_x                                                ,l_y        );
}

    return seeker_set_PU_locked_on_screen;
};


let t_seeker_PU_show = function()
{

let   caller = "t_seeker_PU_show";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("t_seeker_PU_show");


    if( is_seeker_set_PU_locked_on_screen(caller) )
        return;



    if(t_seeker_PU_hide_timer) seeker_PU_hide_cancel();

    t_util.del_el_class(seeker_PU, t_tools.CSS_FADING);
    t_util.del_el_class(seeker_PU, t_data.CSS_HIDING);



    seeker_PU.style.display = "block";


    t_seeker_PU_hide();
};


let t_seeker_PU_hide = function(instant="")
{

let   caller = "t_seeker_PU_hide";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;



    if( is_seeker_set_PU_locked_on_screen(caller) )
        return;



    if(!t_seeker_PU_is_active() ) return;

    if(t_seeker_PU_hide_timer) seeker_PU_hide_cancel();

    let delay
        = instant                   ? 0
        : t_prop.get( t_data.SHOW_SEEKZONE ) ? T_SEEKER_PU_HIDE_FAST_DELAY
        :                             T_SEEKER_PU_HIDE_LONG_DELAY
    ;

if( log_this) log(caller+"("+instant+"): %c delay %c"+delay+"] %c t_prop.get( t_data.SHOW_SEEKZONE ) %c"+t_prop.get( t_data.SHOW_SEEKZONE )
                  ,                      lbL     ,lbR         ,lbL                         ,lbR                          );


    if( delay ) {
        t_seeker_PU_hide_timer = setTimeout(seeker_PU_hide_handler, delay);
        t_seeker_PU_fade_timer = setTimeout(seeker_PU_fade_handler, T_SEEKER_PU_FADE_DELAY);
    }

    else {
        seeker_PU_hide_handler( instant );
    }

};


let   seeker_PU_hide_cancel = function()
{
    if(          !t_seeker_PU_hide_timer ) return;

    clearTimeout( t_seeker_PU_hide_timer );
 t_seeker_PU_hide_timer = null;

    if(t_seeker_PU_fade_timer) seeker_PU_fade_cancel();
};


let   seeker_PU_fade_cancel = function()
{
    if(          !t_seeker_PU_fade_timer ) return;

 t_seeker_PU_fade_timer = null;
    clearTimeout( t_seeker_PU_fade_timer );
};


let   seeker_PU_fade_handler = function()
{

let   caller = "seeker_PU_fade_handler";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller+": ["+t_util.get_n_lbl(t_tools.t_get_onWork_EL())+"]");


    t_seeker_PU_fade_timer = null;

    if( is_seeker_set_PU_locked_on_screen(caller) )
        return;




    if( t_tools.t_get_onWork_EL() ) return;

    t_util.add_el_class(seeker_PU, t_tools.CSS_FADING);
    t_util.del_el_class(seeker_PU, t_data.CSS_HIDING);
};


let   seeker_PU_hide_handler = function(instant="")
{

let   caller = "seeker_PU_hide_handler("+instant+")";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller+": onWork_EL=["+t_util.get_n_lbl(t_tools.t_get_onWork_EL())+"]");


    if( is_seeker_set_PU_locked_on_screen(caller) )
        return;



    t_seeker_PU_hide_timer = null;

    if(!instant && t_tools.t_get_onWork_EL()) return;

    t_util.del_el_class(seeker_PU, t_tools.CSS_FADING);
    t_util.add_el_class(seeker_PU, t_data.CSS_HIDING);
    seeker_PU.style.display = "none";



    seek_TOOL.t_seektool_clr_TARGET();



    if(!t_prop.get( t_data.SHOW_SEEKZONE ) || !t_prop.get( t_data.PIN_SEEKSPOT ) || t_tools.t_dimm_mask_displayed())
    {
        t_seekzone5_hide("instant");
    }


    else {
        seekspot_A.style.display = "none";

    }



    t_sticky.t_sticky_clr_SEEK_NEXT();



    t_tools.t_clr_container_selected();



    t_seeker_SELECT_CLEAR(caller);

    t_select.clear_last_selected_slot();


    t_seeker_onMove1_grab( false );


if( log_this) log("%c RELEASING LAST SEEKED SLOT", lbH+lf5);
};




let t_seeker_PU_arm = function()
{

let   caller = "t_seeker_PU_arm";
let log_this = DOM_SEEK_LOG;

if( log_this) log(caller+": [t_seeker_PU_is_active() "+t_seeker_PU_is_active()+"]");

    if( !t_seeker_PU_is_active() ) return;

    t_seeker_PU_show();

    t_util.add_el_class(seeker_CU, t_tools.LONG_PRESS_ARM);
};


let t_seeker_PU_disarm = function()
{

let   caller = "t_seeker_PU_disarm";
let log_this = DOM_SEEK_LOG;

if( log_this) log(caller);


    t_util.del_el_class(seeker_CU, t_tools.LONG_PRESS_ARM);
};


let t_seeker_is_active = function()
{
    let result = t_seeker_PU_is_active();

    return result;
};


let t_seeker_PU_is_active = function()
{

let   caller = "t_seeker_PU_is_active";
let log_this = DOM_SEEK_LOG || LOG_MAP.EV5_TOOL_CB;



    let reject_reason = "";

    if     (!seeker_PU                               ) reject_reason = "[seeker_PU] NOT INITIALIZED";
    else if( seeker_PU.style.display    != "block"   ) reject_reason = "[seeker_PU] NOT DISPLAYED";
    else if( seeker_PU.classList.contains(t_data.CSS_HIDING)) reject_reason = "[seeker_PU] IS HIDING" ;

    let is_active = (reject_reason == "");

if(!is_active && log_this) log(caller+": ...return "+is_active+" %c "+reject_reason, lb2);
    return is_active;
};


let t_seeker_PU_is_looking_somewhere = function()
{
    let result
        =  t_util.has_el_class(seeker_PU, t_data.CSS_SEEKER_PU2_LOOK_UP   )
        || t_util.has_el_class(seeker_PU, t_data.CSS_SEEKER_PU3_LOOK_RIGHT)
        || t_util.has_el_class(seeker_PU, t_data.CSS_SEEKER_PU4_LOOK_DOWN )
        || t_util.has_el_class(seeker_PU, t_data.CSS_SEEKER_PU5_LOOK_LEFT )
    ;


    return result;
};





const regexp_SELECT_ID = new RegExp("(select|thumb_s_)[0-9]+_[0-9]+");


let t_seeker_isOn_SLOT_EL = function(el)
{
let caller = "t_seeker_isOn_SLOT_EL";
let log_this = DOM_SEEK_LOG;


    if(!el) return false;

    let picked_el = null;


    if((el == seeker_PU) || (el == seeker_CU))
    {
        picked_el = el;
    }


    else {
        for(           picked_el  = el
              ;        picked_el != null
              ;        picked_el  = picked_el.parentNode
           ) {
            if(       !picked_el.id                          ) continue;
            if( String(picked_el.id).match(regexp_SELECT_ID) )    break;
        }
    }

    let result = (picked_el != null);

if( log_this) log(caller+"("+t_util.get_n_lbl(el)+"): ...return "+ result + (picked_el ? " ["+picked_el.id+"]" : ""));
    return result;
};




let t_seeker_set_class = function(css, state)
{
    t_util.set_el_class_on_off(seeker_PU, css, state);
};




let t_seeker_is_a_tool_el = function(el)
{
    if(!el) return "";

    return (el == seeker_PU) || (el == seeker_CU)
        || (el == seeker_PD) || (el == seeker_CD)
        || (el.id && el.id.startsWith("seekzone"))
        ?   el.id
        :   ""
    ;
};





const SEEKER_SYNC_SEL_BACK_ARROW_DELAY = 750;
const SEEKER_SYNC_SEL_BACK_DELAY       = 500;
let   seeker_sync_SEL_BACK_timeout;



let t_seeker_sync_SEL_BACK = function(_caller)
{

    if(seeker_sync_SEL_BACK_timeout) clearTimeout( seeker_sync_SEL_BACK_timeout );
    seeker_sync_SEL_BACK_timeout   =   setTimeout( seeker_sync_SEL_BACK_handle  , SEEKER_SYNC_SEL_BACK_DELAY);
};


let   seeker_sync_SEL_BACK_handle = function()
{

    seeker_sync_SEL_BACK_timeout = null;

    let prop_SEL_BAK = t_prop.get(t_data.SEL_BACK);

    let node_list;
    let shadow_root = t_tools.t_get_shadow_root();
    if( shadow_root ) node_list = shadow_root.querySelectorAll(".seeker_handle");
    else              node_list = document   .querySelectorAll(".seeker_handle");
    for(let i=0; i <  node_list.length; ++i) {
        let     el =  node_list[i];

        if(   t_util.has_el_class(el, t_data.CSS_LEFT )
           || t_util.has_el_class(el, t_data.CSS_RIGHT)
          ) {
            if( el.innerText != t_data.SYMBOL_DOWN_ARROW) el.innerText = t_data.SYMBOL_DOWN_ARROW;

            t_util.del_el_class(el, t_data.CSS_PRESSED);

            if( prop_SEL_BAK ) t_util.add_el_class(el, t_tools.CSS_BACK);
            else               t_util.del_el_class(el, t_tools.CSS_BACK);

            setTimeout(seeker_sync_SEL_BACK_ARROW_handle, SEEKER_SYNC_SEL_BACK_ARROW_DELAY);
        }



    }
};


let   seeker_sync_SEL_BACK_ARROW_handle = function()
{
    let sel_bag = t_tools.t_get_tool("sel_bag");
    if( t_prop.get( t_data.SEL_BACK ) )
    {
        t_util.add_el_class(sel_bag      , t_tools.CSS_BACK);
        t_util.add_el_class(seeker_CD    , t_tools.CSS_BACK);
        t_util.add_el_class(seeker_thumbs, t_tools.CSS_BACK);
    }
    else {
        t_util.del_el_class(sel_bag      , t_tools.CSS_BACK);
        t_util.del_el_class(seeker_CD    , t_tools.CSS_BACK);
        t_util.del_el_class(seeker_thumbs, t_tools.CSS_BACK);
    }

};




let t_seeker_set_CSS_ON_COOLDOWN = function( state )
{
    if(state) t_util.add_el_class(seeker_PU, t_tools.CSS_ON_COOLDOWN);
    else      t_util.del_el_class(seeker_PU, t_tools.CSS_ON_COOLDOWN);
};







let t_seeker_SELECT_CLEAR = function(_caller)
{

    let                      ccs_length = t_select.t_select_get_ccs_length();
    for(let slot = 1; slot < ccs_length; ++slot)
    {
        let num_selected = t_select.t_select_get_slot_num_selected(slot);
        if( num_selected > 0)
        {
            let node = t_select.t_select_get_slot_num_node(slot, num_selected);
            t_util.del_el_class(node, t_tools.CSS_NUM_SELECTED);
        }
    }

};


let t_seeker_SELECT_onWork_EL = function()
{
let caller = "t_seeker_SELECT_onWork_EL";

    let slot = t_tools.t_get_onWork_EL_slot();
    if(!slot) return false;

    if(!t_select.t_select_get_slot_nodes_length(slot))
    {
logBIG(caller+": SLOT #"+slot+" NOT CURRENLTY INITIALIZED");

        if(t_tools.t_preventDefault_caller) t_tools.t_restoreDefault("NOT CURRENLTY INITIALIZED");
        return false;
    }


    let num = t_tools.t_get_onWork_EL_num();

    if(!num ) return false;


    t_util.add_el_class(seeker_PU, CSS_SEEK4_ONJUMPEL);



    seeker_set_slot_num_selected(slot, num);

    t_seeker_onMove3_ON_SLOT_NUM(slot, num);


    let container =  t_select.get_slot_num_container(slot, num);
    t_tools.t_seek_set_container_selected(container, caller);



    t_tools.t_window_getSelection_removeAllRanges(caller);


    return true;
};


let   seeker_set_slot_num_selected = function(slot, num)
{


    let num_selected = t_select.t_select_get_slot_num_selected(slot);
    if( num_selected > 0) {
        let node = t_select.t_select_get_slot_num_node(slot, num_selected);
        t_util.del_el_class(node, t_tools.CSS_NUM_SELECTED);
    }


    if( num > 0) {
        t_select.t_select_set_slot_num_selected(slot, num);
        let node = t_select.t_select_get_slot_num_node(slot, num);
        t_util.add_el_class(node, t_tools.CSS_NUM_SELECTED);
    }

};



let t_seeker_from_to_slot_num = function(from_slot, from_num, to_slot, to_num)
{


    let num_selected = t_select.t_select_get_slot_num_selected(from_slot);
    if( num_selected > 0) {

        let node = t_select.t_select_get_slot_num_node(from_slot, num_selected);
        t_util.del_el_class(node, t_tools.CSS_NUM_SELECTED);
    }


    if(from_num > 0) {
        t_select.t_select_set_slot_num_selected(from_slot, from_num);

        let node = t_select.t_select_get_slot_num_node(from_slot, from_num);
        t_util.add_el_class(node, t_tools.CSS_NUM_SELECTED);

    }



    if( to_num > 0) {

        let node = t_select.t_select_get_slot_num_node(to_slot, to_num);
        t_util.del_el_class(node, t_tools.CSS_NUM_SELECTED);
    }

};






let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_seek"
    , logging : (state) => DOM_SEEK_LOG = t_store_set_state("DOM_SEEK_LOG",state)
    , tagging : (state) => DOM_SEEK_TAG = t_store_set_state("DOM_SEEK_TAG",state)
    , t_seek_IMPORT

    ,    CSS_SEEK0_ONDOC
    ,    CSS_SEEK1_ONRESUME
    ,    CSS_SEEK2_ONSLOTEL
    ,    CSS_SEEK3_ONTOOL
    ,    CSS_SEEK4_ONJUMPEL
    ,    CSS_SEEK5_ONSEEKER
    ,    CSS_SEEK6_ONSTICKY

    ,    t_seeker_clr_TOOL       : seek_TOOL.t_seektool_clr_TARGET
    ,    t_seeker_get_TOOL_label : seek_TOOL.t_seektool_get_TARGET_label
    ,    t_seeker_get_STICKY     : seek_TOOL.t_seektool_get_STICKY
    ,    t_seeker_has_TARGET     : seek_TOOL.t_seektool_has_TARGET
    ,    t_seeker_set_TOOL       : seek_TOOL.t_seektool_set_TARGET

    ,    t_seeker_onDown_1_INIT_CTRL_DEBOUNCE_INPUT

    ,    t_seeker_onMove2_ON_NEXT_STICKY
    ,    t_seeker_onMove1_grab
    ,    t_seeker_onMove1_grabbed
    ,    t_seeker_onUp8_ON_MOUSEUP_DONE
    ,    t_seeker_onMove3_ON_SLOT_NUM
    ,    t_seeker_onClick
    ,    t_seeker_onMove2_DXY
    ,    t_seeker_onMove2_SLOT_NUM_DIR
    ,    t_seeker_onLoad

    ,    t_seeker_SELECT_CLEAR
    ,    t_seeker_from_to_slot_num
    ,    t_seeker_isOn_SLOT_EL

    ,    t_seeker_PU_arm
    ,    t_seeker_PU_disarm
    ,    t_seeker_PU_hide
    ,    t_seeker_PU_is_active
    ,    t_seeker_PU_is_looking_somewhere
    ,    t_seeker_set_PU_locked_on_screen
    ,    t_seeker_PU_show
    ,    t_seeker_is_active

    ,    t_seeker_show
    ,    t_seeker_hide
    ,    t_seeker_set_CSS_ON_COOLDOWN
    ,    t_seeker_set_class
    ,    t_seeker_sync
    ,    t_seeker_sync_is_pending

    ,    t_seeker_could_be_magnified
    ,    t_seeker_get_node_bag_id
    ,    t_seeker_get_onSeekXYL
    ,    t_seeker_get_seeker_PU_XY
    ,    t_seeker_get_tool_panel

    ,    t_seeker_is_a_tool_el
    ,    t_seeker_is_onSticky
    ,    t_seeker_is_seeker_PU
    ,    t_seeker_is_seeker_PU_ONSEEKER

    ,    t_seekzone0_show_MASK_OR_HIDE
    ,    t_seekzone1_show_onDown_XY
    ,    t_seekzone2_show_misclick
    ,    t_seekzone3_show_dblclick
    ,    t_seekzone4_show_longpress
    ,    t_seekzone5_hide
    ,    t_seekzone6_show_anchor_node
    ,    t_seekzone7_show_container
    ,    t_seekzone8_hide_gutter
    ,    t_seekzone8_isOn_gutter
    ,    t_seekzone8_show_gutter_xywh
    ,    t_seekzone9_show_bordering
    ,    t_seekzone_clr_onWork_EL_pressed
    ,    t_seekzone_clr_selected
    ,    t_seekzone_set_selected

    ,    t_seeker_sync_SEL_BACK
    ,    t_seeker_get_last_seeked_slot_num
    ,    t_seeker_move_above_XY_cancel

    ,    t_seeker_get_seeker_PU_height : () => (seeker_PU ? seeker_PU.offsetHeight : 0)

};


}());

/*INLINE}}}*/
//@ sourceURL=dom_seek.js
`
)
 .replace(/%u/g,"\\u")
;
/*}}}*/
/**  20 SHARE    JS dom_share_js_data {{{*/
/*
../script/dom_share.js
*/
let dom_share_js_data ="data:text/javascript;charset='utf-8',"+ `
/*INLINE{{{*/



















const DOM_SHARE_JS_ID       = "dom_share_js";
const DOM_SHARE_JS_TAG      = DOM_SHARE_JS_ID   +" (211122:16h:48)";

let dom_share   = (function() {
"use strict";
let   DOM_SHARE_LOG         = false;
let   DOM_SHARE_TAG         = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;

let t_prop     = {}        ;
let t_store    = {}        ;
let t_fly      = {}        ;







let t_sticky   = {}        ;







let t_tools    = {}        ;


let t_share_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;

    t_prop    = dom_prop   ;
    t_store   = dom_store  ;
    t_fly     = dom_fly    ;








    t_sticky  = dom_sticky ;







    t_tools   = dom_tools  ;


    share_INTERN();

    DOM_SHARE_LOG = DOM_SHARE_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_SHARE_LOG"));
    DOM_SHARE_TAG = DOM_SHARE_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_SHARE_TAG"));


if(log_this) log("%c 18 SHARE", lbH+lf8);
};




let CSS_FLY_CLIPBOARD;
let CSS_MAILTO;
let DOUBLE_QUOTE;
let LF = String.fromCharCode(10);
let SYMBOL_CHECK_MARK;
let SYMBOL_HEAVY_RIGHT_ARROW;
let SYMBOL_HID;
let SYMBOL_NOT_CHECKED;
let TAB= String.fromCharCode( 9);


let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let   share_INTERN = function()
{

    CSS_FLY_CLIPBOARD           = t_data.CSS_FLY_CLIPBOARD;
    CSS_MAILTO                  = t_data.CSS_MAILTO;
    DOUBLE_QUOTE                = t_data.DOUBLE_QUOTE;
    LF                          = t_data.LF;
    SYMBOL_CHECK_MARK           = t_data.SYMBOL_CHECK_MARK;
    SYMBOL_HEAVY_RIGHT_ARROW    = t_data.SYMBOL_HEAVY_RIGHT_ARROW;
    SYMBOL_HID                  = t_data.SYMBOL_HID;
    SYMBOL_NOT_CHECKED          = t_data.SYMBOL_NOT_CHECKED;
    TAB                         = t_data.TAB;



    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;

};













const MAILTO_SUBJ          = "RTabs export: ";
const MAILTO_BODY_DOMAIN   =       "domain: ";
const MAILTO_BODY_HOSTNAME =     "hostname: ";
const MAILTO_BODY_PAGE_PFX =     "page_pfx: ";


const DATA_TEXT_LENGH_MAX        = 8192;

const MAILER_SEP_LINE
    =     "________________________________________________________________________________";

const MAILER_IMPORT_INSTRUCTIONS
    =     MAILER_SEP_LINE
    + LF+ "RECEIVING MAIL PROCEDURE .. (IMPORT-SIDE):"
    + LF+ "1 . copy this message body to the clipboard .. (select all is ok)"
    + LF+ "2 . then click navigator import button"
    + LF+ MAILER_SEP_LINE
;

const NAVIGATOR_PASTE_INSTRUCTIONS
    =     MAILER_SEP_LINE
    + LF
    + LF+ "NAVIGATOR IMPORT INSTRUCTIONS:"
    + LF
    + LF+ "1 . copy mail body to the clipboard"
    + LF+ "2 . click here when ready"
    + LF+ "3 . then paste clipboard content here"
;



const FOOTER_EXPORT_INSTRUCTION
    = LF+"PASTE CLIPBOARD CONTENTS HERE"+LF;






let t_share1_EXPORT = function(e_target)
{

let   caller = "t_share1_EXPORT";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf1);

    let domain   = t_util.get_url_domain(String(window.location) );
    let site_pfx = t_store.t_store_get_site_pfx();
    let page_pfx = t_store.t_store_get_page_pfx();


if(log_this) {
    log_key_val_group("LOCATION .. URL DOMAIN HOST PAGE"
                      , {   "location" : window.location
                          ,     "href" : window.location.href
                          , "protocol" : window.location.protocol
                          ,   "origin" : window.location.origin
                          ,              domain
                          , "hostname" : window.location.hostname
                          , "pathname" : window.location.pathname
                          ,              site_pfx
                          ,              page_pfx
                      }
                      , lf1
                      , true);

}



    let export_email
        = "ivanw@orange.fr";

    let export_subject
        =     MAILTO_SUBJ + page_pfx;

    let mailto_onclick_js
        =  "document.location="
        +             DOUBLE_QUOTE
        +             "mailto:?to="     + encodeURI( export_email              )
        +                    "&subject="+ encodeURI( export_subject            )
        +                    "&body="   + encodeURI( FOOTER_EXPORT_INSTRUCTION )
        +             DOUBLE_QUOTE;



    if(                        e_target
       && !t_util.has_el_class(e_target, CSS_MAILTO))
    {
        t_util.add_el_class(   e_target, CSS_MAILTO);
                               e_target.setAttribute("onclick", mailto_onclick_js);
    }


    let mailto_link
        = "<em class='"         + CSS_MAILTO+" cc5 big'"+LF
        +  " onclick='"         + mailto_onclick_js     +"'"+LF
        + ">CLICK TO EXPORT TO "+ export_email          +"</em>"
    ;

if(log_this) log("%c"+mailto_link, lbF+lf1);

    t_fly.t_fly_tooltip_add( mailto_link );





if( log_this) t_log.log_BOT(caller, lf1);
};




let export_mail_body;


let t_share2_MAILTO_UI = function(e_target)
{

let   caller = "t_share2_MAILTO_UI";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf2);

    let site_pfx        = t_store.t_store_get_site_pfx();
    let page_pfx        = t_store.t_store_get_page_pfx();
    let page_pfx_length = page_pfx.length;

if(log_this || DOM_SHARE_TAG) {
    t_fly.t_fly_tooltip_add("<span class='fg0'>Site</span> <span class='fg8'>"+ site_pfx +"</span>");
    t_fly.t_fly_tooltip_add("<span class='fg0'>Page</span> <span class='fg8'>"+ page_pfx +"</span>");
}


    let export_key_val_array = [];
    let tooltip_keys         = [];
    for(let i=localStorage.length-1; i>=0; --i)
    {
        let key = localStorage.key(i);
        let val = localStorage[key];

        if(!key.startsWith(site_pfx) && !key.startsWith(page_pfx)) continue;

        let {shared_item, not_shared_item, tool_item} = share_FILTER(key,val);

        if(  shared_item || tool_item || !not_shared_item)
        {
if( log_this) log("%c export_key_val_array.push({"+key+", "+val+"})", lf4);

            export_key_val_array.push({ key , val });
        }

        let a_stored_bag_array = (key.indexOf("_arr") >= 0);
        let not_sel_bag        = (key.indexOf("sel_") <  0);

        if(a_stored_bag_array && not_sel_bag)
            tooltip_keys.push( key );
    }


if(log_this || DOM_SHARE_TAG) {
    tooltip_keys         = tooltip_keys        .sort();
    tooltip_keys.forEach( (key) => {
        let       val = localStorage[key];
        let       csv = (val == null) ? "" : JSON.parse(val).join(",");
        let className = "";

        if( key.startsWith(page_pfx) )
        {
            key       = key.slice(page_pfx_length+1);
            className = key;
        }

        let l_x
            = (key.indexOf("pat") >= 0) ? 4
            : (key.indexOf("off") >= 0) ? 5
            : (key.indexOf("alt") >= 0) ? 6
            : (key.indexOf("bak") >= 0) ? 2
            : 0;

        let html
            = "<div class='exp_bag "+className+"'>"
            +  "<em class='cc"+l_x+"'>"+ key +"</em>"
            +  "<br>"
            +  "<span class='fg"+l_x+"'>"+ t_util.strip_to_lines(csv) +"</span>"
            + "</div>"
        ;

        t_fly.t_fly_tooltip_add( html );


    });
}


    let export_key_val_array_string_multiline;
    if( export_key_val_array.length > 0)
    {
        if( e_target)
            e_target.innerHTML += SYMBOL_CHECK_MARK;

        export_key_val_array_string_multiline = share2_MAILTO_CLIPBOARD( export_key_val_array );
    }


    else {
        if( e_target) {
            e_target.innerHTML += SYMBOL_NOT_CHECKED;
            e_target.onclick    = "";
            t_util.del_el_class(e_target, CSS_MAILTO);
        }

        let msg = "NOTHING TO EXPORT";
        t_tools.t_copy_innerHTML_to_clipboard(msg);

        t_fly.t_fly("<em class='big cc2'>"+msg+"</em>");
if( log_this) log("%c"+msg, lbH+lf2);
    }

if( log_this) t_log.log_BOT(caller, lf2);
    return export_key_val_array_string_multiline;
};


let share2_MAILTO_CLIPBOARD = function(export_key_val_array)
{

let   caller = "share2_MAILTO_CLIPBOARD";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf2);

    export_key_val_array                      = export_key_val_array.sort();
    let page_pfx                              = t_store.t_store_get_page_pfx();
    let page_url                              = String(window.location          || t_store.SITE_URL_TEMPLATE);
    let hostname                              =        window.location.hostname || t_store.SITE_URL_TEMPLATE;
    let domain                                = t_util.get_url_domain( page_url );
    let export_key_val_array_string           = JSON.stringify( export_key_val_array );

    let export_key_val_array_string_multiline = share_PRETTY_PRINT( export_key_val_array_string );

    let export_description
        =                             MAILTO_SUBJ          + page_pfx
        +                          LF                      + page_url
        +                          LF+MAILTO_BODY_DOMAIN   + domain
        + ((hostname != domain) ? (LF+MAILTO_BODY_HOSTNAME + hostname) : "")
        +                          LF+MAILER_SEP_LINE
        +                          LF
    ;

    export_mail_body
        =     "NOW, YOU CAN SEND THIS MAIL"
        +LF + MAILER_IMPORT_INSTRUCTIONS
        +LF + export_description
        +LF + export_key_val_array_string_multiline;

    t_tools.t_copy_innerHTML_to_clipboard( export_mail_body );



    let transcript2 = t_tools.t_get_transcript2();
    if( t_tools.t_tools_panel_is_selected( transcript2 ) )
    {
        t_log.log_TR_RESULT_set("<pre>"+ export_key_val_array_string_multiline +"</pre>");
    }


if( log_this ) {
    log_key_val_group("export_key_val_array"
                     , export_key_val_array
                     , lf2
                     , true);

    let export_key_val_array_parsed = JSON.parse( export_key_val_array_string );
    log_key_val_group("export_key_val_array_parsed"
                     , export_key_val_array_parsed
                     , lf7
                     , true);
}

if( log_this) t_log.log_BOT(caller, lf2);
return export_key_val_array_string_multiline;
};




let mailto_target;
let import_clipboard;


let t_share3_IMPORT_UI = function(e_target)
{

let   caller = "t_share3_IMPORT_UI";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller+": e_target=["+e_target.id+"]", lf3);

    if(!import_clipboard)
    {
if( log_this) log("CREATE CLIPBOARD CUT-PASTE CONTAINER");

        mailto_target = e_target;

        import_clipboard = document.createElement("PRE");
        import_clipboard.id          = CSS_FLY_CLIPBOARD;
        import_clipboard.setAttribute("contenteditable", "true");
        import_clipboard.onpaste     = share3_PASTE;

    }
    else {
        t_util.del_el_class(import_clipboard, t_tools.CSS_FADING  );
        t_util.del_el_class(import_clipboard, t_tools.CSS_REMOVING);
    }


if( log_this) log("SHOWING NAVIGATOR_PASTE_INSTRUCTIONS");
    import_clipboard.innerHTML = NAVIGATOR_PASTE_INSTRUCTIONS;
    import_clipboard.blur_HTML = null;



    t_fly.t_fly_tooltip_append_child( import_clipboard );

    t_tools.t_focus( import_clipboard );


if( log_this) log("SHOWING BAGS");
    t_tools.t_pat_bag_open(caller, "POPULATING BAGS FROM IMPORTED CSV");


if( log_this) t_log.log_BOT(caller, lf3);
};





let share3_PASTE = function(event)
{

let   caller = "share3_PASTE";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf5);

    let data_text = (event.clipboardData || window.clipboardData).getData("text");
    if( data_text.length > DATA_TEXT_LENGH_MAX) data_text = data_text.substring(0,DATA_TEXT_LENGH_MAX);

if( log_this) log("data_text:"+LF+"%c"+data_text, lf5);



    import_clipboard.blur_HTML =      null;
    import_clipboard.pasteHTML = SYMBOL_CHECK_MARK+ " <em class='big fg0'>IMPORTING "+data_text.length+" chars</em><br>";



    share5_DATA_TEXT( data_text );


if( log_this) t_log.log_BOT(caller, lf5);
};



let t_share4_IMPORT_TEXT = function(data_text)
{

let   caller = "t_share4_IMPORT_TEXT";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf5);

    if( data_text ) {

        if( data_text.length > DATA_TEXT_LENGH_MAX)
            data_text = data_text.substring(0,DATA_TEXT_LENGH_MAX);

if( log_this) log("data_text:"+LF+"%c"+data_text, lf5);

        share5_DATA_TEXT( data_text );
    }
    else {
        logBIG(caller+": NO TEXT TO IMPORT");
    }

if( log_this) t_log.log_BOT(caller, lf5);
};




let share5_DATA_TEXT = function(data_text)
{

let   caller = "share5_DATA_TEXT";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;

if( log_this) log(caller);


    let data_text_one_liner
        = t_util.strip_CR_LF( data_text );

    let import_key_val_array_string
        = share6_PATCH( data_text_one_liner );


    let { import_key_val_array , free_form_user_keywords } = share7_PARSE( import_key_val_array_string );



    let { data_hostname , data_page_pfx } = share_get_host_page_from_data_text( data_text );




if( log_this) log("%c import_key_val_array.length=["+import_key_val_array.length+"]", lbH+lf8);
    if( import_key_val_array.length > 0)
    {

        if( mailto_target )
            mailto_target.innerHTML    += SYMBOL_CHECK_MARK;

        if(import_clipboard)
            import_clipboard.pasteHTML += SYMBOL_CHECK_MARK+ " <em class='big fg0'>"+import_key_val_array.length+" {key , value} pairs</em>";


        share8_BACKUP(free_form_user_keywords);



        let import_failed
            = share9_IMPORT(import_key_val_array, data_hostname, data_page_pfx);



        if( import_failed && !free_form_user_keywords )
        {
            t_fly.t_fly("<em class='cc2'>EMPTY .. RESTORING SAVED</em>");

            share8_RESTORE(data_hostname, data_page_pfx);
        }

    }


    log_this = (log_this || DOM_SHARE_TAG);

    let msg;
    msg = "IMPORT: SELECT TOOLS PANELS"; if(log_this) logBIG(msg, lf7); t_tools .t_TOOLS_panels_reload   (           );

    msg = "IMPORT: RELOAD PATTERN-CSV" ; if(log_this) logBIG(msg, lf2); t_tools .t_store_get_patterns_csv(        msg);
    msg = "IMPORT: OPEN   PATTERN-BAGS"; if(log_this) logBIG(msg, lf3); t_tools .t_pat_bag_open          (caller, msg);
    msg = "IMPORT: RESELECT PATTERNS"  ; if(log_this) logBIG(msg, lf5); t_tools .t_sel_pat_bag_all       (           );
    msg = "IMPORT: RELOAD STICKY TOOLS"; if(log_this) logBIG(msg, lf6); t_sticky.t_sticky_LOAD           (           );


};


let share6_PATCH = function(import_key_val_array_string)
{

let   caller = "share6_PATCH";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf6);

    if( import_key_val_array_string.startsWith(",")) {
        import_key_val_array_string = import_key_val_array_string.substring(1);

if( log_this) log("%c REMOVING LEADING COMMA", lbb+lf8);
    }

if( log_this) t_log.console_dir("import_key_val_array_string", import_key_val_array_string);

    if( import_key_val_array_string.startsWith("{")) {
        import_key_val_array_string = "["+import_key_val_array_string;

if( log_this) log("%c PATCHING START WITH A LEADING  BRACKET %c"+LF+share_PRETTY_PRINT(import_key_val_array_string), lbb+lf8, lf2);
    }


    if( import_key_val_array_string.endsWith  ("}")) {
        import_key_val_array_string =     import_key_val_array_string+"]";

if( log_this) log("%c PATCHING END   WITH A TRAILING BRACKET %c"+LF+share_PRETTY_PRINT(import_key_val_array_string), lbb+lf8, lf3);
    }


    let format_start_ok = import_key_val_array_string.startsWith("[{");
    let format_ends_ok  = import_key_val_array_string.endsWith  ("}]");
    let s_idx;
    let e_idx;

    if(format_start_ok && format_ends_ok)
    {
if( log_this) log("%c GOT STRICT JSON ARRAY SYNTAX %c"+LF+share_PRETTY_PRINT(import_key_val_array_string), lbH+lf8, lf4);

    }


    if(!format_start_ok)
    {
        if(     (s_idx = import_key_val_array_string.indexOf(    "[{" )) >= 0)
        {
            import_key_val_array_string =      import_key_val_array_string.substring(s_idx  );
if( log_this) log("%c SKIPPING MESSAGE HEADER %c"+LF+share_PRETTY_PRINT(import_key_val_array_string), lbH+lf8, lf5);
        }

        else if((s_idx = import_key_val_array_string.indexOf(    " ,{")) >= 0)
        {
            import_key_val_array_string = "[" +import_key_val_array_string.substring(s_idx+2);
if( log_this) log("%c SKIPPING FIRST DAMAGED ITEM %c"+LF+share_PRETTY_PRINT(import_key_val_array_string), lbH+lf8, lf6);
        }
    }


    if(!format_ends_ok)
    {
        if(     (e_idx = import_key_val_array_string.indexOf(    "}]" )) >  0)
        {
            import_key_val_array_string =      import_key_val_array_string.substring(0, e_idx+2);
if( log_this) log("%c SKIPPING MESSAGE TRAILER %c"+LF+share_PRETTY_PRINT(import_key_val_array_string), lbH+lf6, lf7);
        }

        else if((e_idx = import_key_val_array_string.lastIndexOf("} ,")) >  0)
        {
            import_key_val_array_string = import_key_val_array_string.substring(0, e_idx+1) + "]";
if( log_this) log("%c SKIPPING LAST DAMAGED ITEM %c"+LF+share_PRETTY_PRINT(import_key_val_array_string), lbH+lf6, lf7);
        }
    }


    import_key_val_array_string
        = t_util.underline_from_utf8( import_key_val_array_string );



if( log_this)
    log_key_val_group( "format"
                       , {   format_start_ok
                           , s_idx
                           , format_ends_ok
                           , e_idx
                       }
                       , lf6, false);


if( log_this) t_log.log_BOT(caller, lf6);
    return import_key_val_array_string.trim();
};


let share7_PARSE = function( key_val_array_string )
{

let   caller = "share7_PARSE";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf7);

    let silent = !(log_this || DOM_SHARE_TAG);
    let import_key_val_array = t_util.JSON_parse(key_val_array_string, silent);

    if(!Array.isArray( import_key_val_array ))
        import_key_val_array = [];

if( log_this) console.table( import_key_val_array );



    let free_form_user_keywords = (import_key_val_array.length == 0);

    if( free_form_user_keywords )
    {
        let page_pfx = t_store.t_store_get_page_pfx();

        import_key_val_array = t_util.get_import_key_val_array_from_free_form_data_text(page_pfx, key_val_array_string);


if(log_this || DOM_SHARE_TAG) log("FALLBACK TO FREE-FORM USER KEYWORDS:"+LF+import_key_val_array[0].val);
    }

if( log_this) t_log.log_BOT(caller, lf7);

    return { import_key_val_array , free_form_user_keywords };
};




let share8_BACKUP = function(free_form_user_keywords)
{

let   caller = "share8_BACKUP";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf8);

    if(localStorage.length == 0)
    {

if(log_this || DOM_SHARE_TAG) log("%c"+caller+"%c NO STORED ITEMS TO SAVE AND REMOVE", lbL+lf8, lbR);
    }


    else {
        share8_REMOVE(free_form_user_keywords);
    }

if( log_this) t_log.log_BOT(caller, lf8);
};



let removed_items_key_array = [];


let share8_REMOVE = function(free_form_user_keywords)
{

let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;



if( log_this || DOM_SHARE_TAG) log("%c REMOVING CURRENT STORAGE"+(free_form_user_keywords ? " (FREE FORM USER KEYWORDS)":""), lbb+lbH+lf8);

    removed_items_key_array = [];
    for(let i = localStorage.length-1; i >= 0; --i)
    {
        let key = localStorage.key(i);
        let val = localStorage[key];
        let {shared_item, not_shared_item, tool_item} = share_FILTER(key,val);

        let   tool_item_to_remove = tool_item   && !free_form_user_keywords;
        let shared_item_to_remove = shared_item && !free_form_user_keywords;

if(log_this)
    log_key_val_group("FILTERED "+shared_item+" "+not_shared_item
                      , {   free_form_user_keywords
                          , key
                          , not_shared_item
                          , shared_item
                          , shared_item_to_remove
                          , tool_item_to_remove
                          , val : t_util.ellipsis(val)
                      }, lf0,true);


        if(shared_item_to_remove || tool_item_to_remove)
        {

if( log_this || DOM_SHARE_TAG) {
    let lfx
        = shared_item ? lf4
        : tool_item   ? lf7
        :               lf3
    ;
    log("%c REMOVING %c"+t_util.mPadStart(key,32)+"%c"+t_util.ellipsis(val,32)
        ,lbH+lf0    ,lbL+lfx                      ,lbR+lfx                    );
}

            removed_items_key_array.push(key);
        }
        else {

if( log_this) {
    let lfx = shared_item ? lf4 : lf8;
    log("%c LEAVING  "+shared_item+" "+not_shared_item+"%c"+t_util.mPadStart(key,32)+"%c"+t_util.ellipsis(val,32)
        ,lbH+lfx                                       ,lbL+lfx                      ,lbR+lfx                    );
}

        }
    }

    for(let i = 0; i < removed_items_key_array.length; ++i)
        localStorage.removeItem( removed_items_key_array[i] );



if( log_this || DOM_SHARE_TAG) log("%c REMOVING PATTERN AND STICKY", lbH+lf8);
        t_tools.t_dump_csv_and_sticky();



if( log_this) {
    console.groupCollapsed("%c"+SYMBOL_HEAVY_RIGHT_ARROW+"%c"+removed_items_key_array.length+" ITEM SAVED AND REMOVED", lbb+lbH+lf8, lbb+lbH+lf8);

    log("removed_items_key_array:");
    console.table( removed_items_key_array );

    console.groupEnd();
}

};




let share8_RESTORE = function()
{

let   caller = "share8_RESTORE";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;

    if(removed_items_key_array.length == 0)
    {
if( log_this) log("%c"+caller+": NO SAVED ITEMS TO RESTORE", lbb+lbH+lf8);

        return;
    }

    let site_pfx = t_store.t_store_get_site_pfx();
    let page_pfx = t_store.t_store_get_page_pfx();
    let count    = 0;

if( log_this) t_log.log_TOP(caller, lf8);


    for(let i = 0; i < removed_items_key_array.length; ++i)
    {
        let prefixed_key = removed_items_key_array[i];


        if(!t_store.t_store_is_a_shared_item(site_pfx,page_pfx,i+1,prefixed_key,log_this) )
            continue;

        let idx
            = prefixed_key.lastIndexOf(".");
        let key
            = (idx > 0)
            ?  prefixed_key.substring(idx + 1)
            :  "";

        if(key) {
            let val = removed_items_key_array[i];

if( log_this) log("...t_store.t_store_set_value('"+key+"' , '"+val+"')");
            t_store.t_store_set_value(key, val);
        }

        count += 1;
    }


if( log_this) {
    let action = "ITEMS RESTORED";
    console.groupCollapsed("%c"+SYMBOL_HEAVY_RIGHT_ARROW+"%c"+count+" "+action, lbb+lbH+lf8, lbb+lbH+lf8);

    log("removed_items_key_array:");
    console.table( removed_items_key_array );

    console.groupEnd();
}

if( log_this) t_log.log_BOT(caller, lf8);
};




let share9_IMPORT = function(import_key_val_array, data_hostname, data_page_pfx)
{

let   caller = "share9_IMPORT";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


if( log_this) t_log.log_TOP(caller, lf9);

    let site_pfx    = t_store.t_store_get_site_pfx();
    let site_filter = (data_hostname && (data_hostname != "*")) ?  site_pfx : "";

    let page_pfx    = t_store.t_store_get_page_pfx();
    let page_filter = (data_page_pfx && (data_page_pfx != "*")) ?  page_pfx : "";

if( log_this) log("%c site_filter...=["+ site_filter  +"]", lbH+lf3);
if( log_this) log("%c page_filter...=["+ page_filter  +"]", lbH+lf3);


if( log_this || DOM_SHARE_TAG) log("%c IMPORTING "+import_key_val_array.length+" ITEM"+((import_key_val_array.length > 1) ? "S":""), lbb+lbH+lf9);

    let t_fly_lines = "";
    let   data_keys = 0;
    let   site_keys = 0; let not_site_keys = 0;
    let   page_keys = 0; let not_page_keys = 0;

    for(let i = 0; i < import_key_val_array.length; ++i)
    {

        let  prefixed_key = import_key_val_array[i].key;
        if( !prefixed_key ) continue;

        let not_site_key = (site_filter && !prefixed_key.startsWith( site_filter ));
        let not_page_key = (page_filter && !prefixed_key.startsWith( page_filter ));

        if( not_site_key && not_page_key )
        {
            if( not_site_key ) not_site_keys += 1;
            if( not_page_key ) not_page_keys += 1;
            continue;
        }

        data_keys += 1;
        site_keys += (site_filter && prefixed_key.startsWith( site_filter )) ? 1 : 0;
        page_keys += (page_filter && prefixed_key.startsWith( page_filter )) ? 1 : 0;

        let val = import_key_val_array[i].val;



            let idx =              prefixed_key.lastIndexOf(".");
            let key = (idx > 0) ?  prefixed_key.substring  (idx + 1) :  "";
if( log_this) log("%c key...........=["+          key +"]", lbH+lf2);

            if( key ) {

if( log_this || DOM_SHARE_TAG) {
    let lfx = lfX[i % 10];
    log("%c IMPORTING %c"+t_util.mPadStart(key,32)+"%c"+t_util.ellipsis(val,32)
        ,lbH+lf9     ,lbL+lfx                      ,lbR+lfx                    );
}


                t_store.t_store_set_value(key, val);
                t_fly_lines +="<em class='fg9'>"+key+"</em> .. <em class='fg4'>"+val+"</em><br>";
            }

    }
if( log_this) t_log.log_BOT(caller, lf9);


if(DOM_SHARE_TAG || DOM_SHARE_LOG)
    log("%c IMPORTED: %c"+data_keys+" data_keys %c"+site_keys+" site_keys %c"+page_keys+" page_keys"
                      ,lbH+lf9     ,lbL+lf9                  ,lbC+lf6                  ,lbR+lf5                   );

if(LOG_MAP.EV8_FLOATLOG || t_prop.get(t_data.FLOATLOG))
    t_fly.t_fly("<p class='bg9 info'>"
                + (                " <em class='fg3 big'>"+data_keys+" ITEMS IMPORTED   </em>"     )
                + "<br>"
                + (    site_keys ? " <em class='fg3'>"+    site_keys+"     for this SITE</em>" : "")
                + (not_site_keys ? " <em class='fg2'>"+not_site_keys+" not for this SITE</em>" : "")
                + "<br>"
                + (    page_keys ? " <em class='fg4'>"+    page_keys+"     for this PAGE</em>" : "")
                + (not_page_keys ? " <em class='fg2'>"+not_page_keys+" not for this PAGE</em>" : "")
                + "<hr>"
                + t_fly_lines
                +"</p>"
               );

if( log_this) t_store.t_store_log_site_and_page();




    return false;
};



let share_FILTER = function(key,val)
{

let   caller = "share_FILTER";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;



    let       idx =                         key.lastIndexOf          ( "."     )       ;
    let        id = idx                   ? key.substring            ( idx + 1 ) : ""  ;
    let tool_item = id                    ? t_tools.t_get_shadow_tool( id      ) : null;


    let shared_item
        = key.includes(     "pat_arr"   ) ? "pat_arr"
        : key.includes(     "alt_arr"   ) ? "alt_arr"
        : key.includes(     "bak_arr"   ) ? "bak_arr"
        : key.includes(     "bin_arr"   ) ? "bin_arr"
        :                                   ""
    ;

    let not_shared_item
        = key.includes("fly_div"        ) ? "fly_div"
        : key.includes("sel_arr"        ) ? "sel_arr"
        : key.includes("SNAPSHOT"       ) ? "SNAPSHOT"
        : key.endsWith("_LOG"           ) ? "LOGGING"
        : key.endsWith("_TAG"           ) ? "TAGGING"

        :                                   ""
    ;






if(log_this && id) {

    let l_x = (shared_item || not_shared_item) ? lbH : "";
    if     (   shared_item                   ) l_x += lf4;
    else if(   not_shared_item               ) l_x += lf7;
    else                                       l_x += lf0;

    log_key_val(  caller+"("+key+") .. SHARED ["+shared_item+"] .. NOT_SHARED ["+not_shared_item+"]"
                , { key
                  , id
                  , tool_item

                  , className : (tool_item && tool_item.className)
                  , shared_item
                  , not_shared_item
                } , l_x);
}


    return { shared_item , not_shared_item , tool_item };
};


const regex_JSON_BLOCK = new RegExp("\} *, *\{", "g");

let share_PRETTY_PRINT = function(s)
{
    return s.replace(regex_JSON_BLOCK, "}"+LF+",{");
};


let share_get_host_page_from_data_text = function(data_text)
{

let   caller = "share_get_host_page_from_data_text";
let log_this = DOM_SHARE_LOG || LOG_MAP.T7_SHARE;


    let idx_from;
    let idx_to;


    idx_from          = data_text.indexOf(MAILTO_BODY_HOSTNAME);
    idx_to            = data_text.indexOf(LF, idx_from);
    let data_hostname
        = ((idx_from > 0) && (idx_to   > 0))
        ? data_text.substring(idx_from + MAILTO_BODY_HOSTNAME.length, idx_to).trim()
        : "";


    idx_from          = data_text.indexOf(MAILTO_BODY_PAGE_PFX);
    idx_to            = data_text.indexOf(LF, idx_from);
    let data_page_pfx
        = ((idx_from > 0) && (idx_to   > 0))
        ? data_text.substring(idx_from + MAILTO_BODY_PAGE_PFX.length, idx_to).trim()
        : "";

if( log_this) log_key_val_group(caller, { data_hostname , data_page_pfx });
    return { data_hostname , data_page_pfx };
};





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_share"
    , logging : (state) => DOM_SHARE_LOG = t_store_set_state("DOM_SHARE_LOG",state)
    , tagging : (state) => DOM_SHARE_TAG = t_store_set_state("DOM_SHARE_TAG",state)
    , t_share_IMPORT

    , t_share1_EXPORT
    , t_share2_MAILTO_UI
    , t_share3_IMPORT_UI
    , t_share4_IMPORT_TEXT
    , t_share_get_import_clipboard : () => import_clipboard

    , share_FILTER
};



}());
/*INLINE}}}*/
//@ sourceURL=dom_share.js
`
 .replace(/\\/g,"\\\\")

 .replace(/%u/g,"\\u")
;
/*}}}*/

/**   21 DETAILS  JS dom_details_js_data .. ESCAPE case "#document"] {{{*/
/*
../script/dom_details.js
*/
let dom_details_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/
















const DOM_DETAILS_JS_ID        = "dom_details_js";
const DOM_DETAILS_JS_TAG       = DOM_DETAILS_JS_ID  +" (220308:16h:37)";

let dom_details         = (function() {
"use strict";
let   DOM_DETAILS_LOG   = false;
let   DOM_DETAILS_TAG   = false;





let t_details_IMPORT    = function(_log_this,import_num)
{

    DOM_DETAILS_LOG     = DOM_DETAILS_LOG   || localStorage_getItem("DOM_DETAILS_LOG");
    DOM_DETAILS_TAG     = DOM_DETAILS_TAG   || localStorage_getItem("DOM_DETAILS_TAG");


    details_INTERN();
if(_log_this) log("➔ "+(import_num ? (import_num+" ") : "")+"t_details_IMPORT");
};





let lb0="", lb1="", lb2="", lb3="", lb4="", lb5="", lb6="", lb7="", lb8="", lb9="", lbX="";
let lbA="", lbB="", lbC="", lbF="", lbH="", lbL="", lbR="", lbS="", lbb=""                ;
let lf0="", lf1="", lf2="", lf3="", lf4="", lf5="", lf6="", lf7="", lf8="", lf9="", lfX="";

let log=console.log, logBIG=log, log_key_val=log, log_key_val_group=log;




let add_el_class;
let del_el_class;
let get_el_child_with_tag;
let get_el_sibling_with_tag;
let get_id_or_tag;
let get_id_or_tag_and_className;
let get_nodeXPath;
let get_tool;
let is_el_or_child_of_parent_el;




let localStorage_delItem = (key    ) =>           localStorage.removeItem(key    );
let localStorage_getItem = (key    ) =>           localStorage.getItem   (key    );
let localStorage_setItem = (key,val) => { if(val) localStorage.setItem   (key,val); else localStorage.removeItem(key); };




let   details_INTERN    = function()
{

let caller = "details_INTERN";



    let dom_log_js
        = (typeof dom_log != "undefined")
        ?         dom_log
        :         dom_details_log;

    if( dom_log_js )
    {
        if(dom_log_js.LOG_BG_CSS) {
            ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = dom_log_js.LOG_BG_CSS);
            ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = dom_log_js.LOG_FG_CSS);
            ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = dom_log_js.LOG_XX_CSS);

            ({  log
             ,  logBIG



             ,  log_key_val
             ,  log_key_val_group

            } = dom_log_js);

        }
if(DOM_DETAILS_LOG || DOM_DETAILS_TAG) logBIG(caller+": ["+dom_log_js.name+"]" , 4);
    }
    else {

logBIG(caller+": [dom_log UNDEFINED]"   , 2);
    }


    let dom_util_js
        = (typeof dom_util != "undefined")
        ?         dom_util
        :         dom_details_util;

    if( dom_util_js )
    {
        ({  add_el_class
         ,  del_el_class
         ,  get_el_child_with_tag
         ,  get_el_sibling_with_tag
         ,  get_id_or_tag
         ,  get_id_or_tag_and_className
         ,  get_nodeXPath
         ,  get_tool
         ,  is_el_or_child_of_parent_el
        } = dom_util_js);

if(DOM_DETAILS_LOG || DOM_DETAILS_TAG) logBIG(caller+": ["+dom_util_js.name+"]"    , 4);
    }
    else {

logBIG(caller+": [dom_util UNDEFINED]"      , 2);
    }


    if(typeof dom_store != "undefined")
    {
        localStorage_getItem =          dom_store.t_store_getItem;
        localStorage_setItem =          dom_store.t_store_set_value;
        localStorage_delItem = (key) => dom_store.t_store_set_value(key,null);

if(DOM_DETAILS_LOG || DOM_DETAILS_TAG) logBIG(caller+": ["+dom_store.name+"]"      , 4);
    }


};





const DETAILS_RADIO_ID = "details_radio";






let details_handler = (function() {

let details_onload = function()
{

let caller = "details_onload";
let log_this = DOM_DETAILS_LOG;

if(log_this) logBIG(caller, 8);


    let        details_array = document.querySelectorAll("DETAILS");
    Array.from(details_array).forEach( (el) => {
        let    open = el.id && localStorage_getItem(el.id+"_open");
        el    .open = open;
if(log_this && open) log("➔ "+el.id+(el.open ? " OPENED":" NOT OPENED"));
    });



    Array.from(details_array).forEach( (el) => {
        if(!el.id) return;
        el.addEventListener("mousedown", details_onmousedown);
        el.addEventListener("toggle"   , details_ontoggle   );
    });



    details_radio_set_from_localStorage();



    details_add_hash_link_onclick_listener();


};



 let details_onmousedown_shiftKey;
 let details_onmousedown_altKey;


 let details_onmousedown = function(e)
 {
     details_onmousedown_shiftKey  = e.shiftKey;
     details_onmousedown_altKey    = e.altKey;

 };



const DETAILS_ONTOGGLE_COOLDOWN = 500;

let   details_ontoggle_timeStamp;

let details_ontoggle = function(e)
{
if(details_ontoggle_listener_mutex) return;

let caller = "details_ontoggle";
let log_this= DOM_DETAILS_LOG;

    let details_el = e.target;
    if(!details_el ) return;

if( log_this) log(caller+"("+e.target.tagName+") .. open=["+e.target.open+"] ➔ details_el=["+(details_el.id || details_el.firstElementChild.textContent)+"] .. open=["+details_el.open+"]");
if( log_this) log(                    "...details_radio_el=["+get_id_or_tag_and_className(details_radio_el)+"]");
if( log_this) log(details_radio_el ? ("...details_radio_el.checked=["+details_radio_el.checked+"]") : "");


    if(details_el.id) {

        if(details_el.open) localStorage_setItem(details_el.id+"_open", "true");
        else                localStorage_delItem(details_el.id+"_open"        );



    }



    let elapsed      = (e.timeStamp - details_ontoggle_timeStamp).toFixed(0);
    if( elapsed      < DETAILS_ONTOGGLE_COOLDOWN)
    {
if(log_this) log("%c...ON COOLDOWN: elapsed=["+elapsed+"ms]", "color:#888;");

        return;
    }
if(log_this) log("%c..."+details_el.tagName+" #"+details_el.id+" .. open "+details_el.open+" .. elapsed=["+elapsed+"]" , (details_el.open ? "color:lightgreen;":"color:red;"));

    details_ontoggle_timeStamp = e.timeStamp;


    if(details_onmousedown_shiftKey == undefined) return;



    if( details_onmousedown_altKey )
    {
        let state = details_el.open ? "open" : "close";

        details_ontoggle_set_siblings_state(details_el, state);
    }


    else {

        let close_others_behavior
            =       details_radio_el
            && (    details_radio_el.checked
                 || details_radio_el              .classList.contains("checked")
                 || details_radio_el.parentElement.classList.contains("checked")
               );

        let reversed
            =   close_others_behavior && details_onmousedown_shiftKey;

        let close_others
            =  (close_others_behavior && ( details_el.open && !reversed)) ? "OPENED ➔ [NO SHIFT] ➔ CLOSE OTHERS"
            :  (close_others_behavior && (!details_el.open &&  reversed)) ? "CLOSED ➔ [++ SHIFT] ➔ CLOSE OTHERS"
            :  false;


if(log_this) {
    let style =           "border: "+(close_others_behavior ? "2px solid orange" : "1px solid gray")+";"
        +                  "color: "+(close_others          ?              "red" : "gray"          )+";"
        +           "border-style: "+(reversed              ?           "dashed" : "solid"         )+";"
    ;
    log(" ➔ close_others %c["+ close_others +"]", style);
}


        if     (!details_el.open ) details_ontoggle_close_children    ( details_el         );
        else if( close_others    ) details_ontoggle_set_siblings_state( details_el, "close");
    }

};


let details_ontoggle_set_siblings_state = function(details_el,state)
{

let   caller = "details_ontoggle_set_siblings_state";
let log_this = DOM_DETAILS_LOG;

if(log_this || DOM_DETAILS_TAG) logBIG(caller+"("+get_id_or_tag_and_className(details_el)+", "+state+")");


    let details_parent
        = (details_el.parentElement.tagName == "LI")
        ?  details_el.parentElement.parentElement
        :  details_el.parentElement;

if(log_this) log("%c...details_parent: ["+(details_parent.id || details_parent.tagName)+"]", "background-color:#800;");


    for(let i=0; i<details_parent.children.length; ++i)
    {

        let details_sibling  = details_parent.children[i];
        if( details_sibling.tagName == "LI") details_sibling = details_sibling.children[0];




        if(details_sibling == details_el) continue;



        if(details_sibling.tagName == "DETAILS")
        {
            details_sibling.open = (state == "open");

            if(details_sibling.id)
            {
                if(details_sibling.open) localStorage_setItem(details_sibling.id+"_open", "true");
                else                     localStorage_delItem(details_sibling.id+"_open"        );

            }
        }

    }

};


let details_ontoggle_close_children = function(parent_details)
{

let   caller = "details_ontoggle_close_children";
let log_this = DOM_DETAILS_LOG;

if( log_this) logBIG(caller+"("+get_id_or_tag_and_className(parent_details)+") .. open=["+parent_details.open+"]", 2);


    let el_array
        = Array.from( parent_details.querySelectorAll("DETAILS[open]") );

    el_array.forEach( (child_details) => {

        child_details.open = false;

        if(child_details.id)
        {
            let key = child_details.id+"_open";
            localStorage_delItem( key );
        }
    });
};

return { details_onload };
})();





let details_radio_toggle = function(e)
{

if(DOM_DETAILS_LOG) log("details_radio_toggle("+e.target.tagName+")");



    let { input , details_radio_el } = get_details_radio_checkbox(e);



    let state
        = input
        ? ((e.target != input) ? input.checked : !input.checked)
        : details_radio_el.classList.includes("checked");



    state = !state;

    if( input && (!e || (input != e.target)))
        input.checked = state;



    let el = (input || details_radio_el);
    if( el )
    {
        if(state) add_el_class(   el.parentElement, "checked");
        else      del_el_class(   el.parentElement, "checked");
    }



    if(state) localStorage_setItem(DETAILS_RADIO_ID, "true");
    else      localStorage_delItem(DETAILS_RADIO_ID        );



if(DOM_DETAILS_LOG || DOM_DETAILS_TAG)
    log_key_val_group("details_radio_toggle: ...state=["+state+"]"
        , { state
          , input
          , details_radio_el
          , e
          , e_target : (e ? e.target : "")
        }
        , (state ? 4:8)
        , false);

};


let details_radio_set_from_localStorage = function()
{

if(DOM_DETAILS_LOG) log("details_radio_set_from_localStorage");



    let {  input , details_radio_el } = get_details_radio_checkbox();

    if(!input) return;


    let state = localStorage_getItem( DETAILS_RADIO_ID );



    input.checked = state;

    if(state)     add_el_class(input.parentElement, "checked");
    else          del_el_class(input.parentElement, "checked");


if(DOM_DETAILS_LOG)
    log_key_val_group("details_radio_set_from_localStorage: ...state=["+state+"]"
        , { state
          , input
          , details_radio_el
        }
        , (state ? 4:8)
        , false);

};



let details_radio_el;


let get_details_radio_checkbox = function(e)
{

let caller = "get_details_radio_checkbox";



    if(!details_radio_el)
        details_radio_el = get_tool( DETAILS_RADIO_ID );

    let el
        = (e)
        ?  e.target
        :  details_radio_el;

if(DOM_DETAILS_LOG) log(caller+": ["+DETAILS_RADIO_ID+"] ➔ el=["+get_id_or_tag(el)+"]");
    if(!el) return {};



    let input
        =                         ((el.tagName == "INPUT") && el)
        || get_el_child_with_tag  ( el          , "INPUT")
        || get_el_sibling_with_tag( el          , "INPUT");




if(DOM_DETAILS_LOG)
    log_key_val_group(caller+": ...return ["+(input ? input.tagName : "")+"]"
        , { e
          , e_target         : (e ? e.target : "")
          , el
          , details_radio_el : get_nodeXPath( details_radio_el )+" ["+get_id_or_tag( details_radio_el )+"]"
          , input            : get_nodeXPath( input            )+" ["+get_id_or_tag( input            )+"]"
        }
        , 4
        , true);

    return { input , details_radio_el };
};






let details_has_closed_el_parent = function(el)
{
    let   details_el = el.parentElement;
    while(details_el)
    {

        if(details_el.nodeName == "DETAILS")
        {


            let details_el_summary
                = details_el.firstElementChild;

            let el_in_a_visible_summary
                = is_el_or_child_of_parent_el(el, details_el_summary);

            if(   !details_el.open
               && !el_in_a_visible_summary)
                return true;
        }

        details_el = details_el.parentElement;
    }
    return false;
};


let details_open_closed_el_parent = function(el)
{

    let   details_el = el.parentElement;
    while(details_el)
    {
        if(details_el.nodeName == "DETAILS")
        {
            if(!details_el.open)
            {
if(DOM_DETAILS_LOG) logBIG("details_open_closed_el_parent("+get_id_or_tag_and_className(el)+") ➔ open details_el "+get_nodeXPath(details_el));

                details_el.open = true;
            }
        }
        details_el = details_el.parentElement;
    }
    el.open = true;
};


let details_add_hash_link_onclick_listener = function(el=document)
{

let caller = "details_add_hash_link_onclick_listener";

if(DOM_DETAILS_LOG) log(caller+"(el "+get_id_or_tag_and_className(el)+")");


    let           details_hash_links = document.querySelectorAll("A[href^='#']");
    Array.from(   details_hash_links)
        .forEach((details_hash_link ) => {
  details_hash_link.addEventListener("click", details_hash_link_onclick);
        });

if(DOM_DETAILS_LOG || DOM_DETAILS_TAG) logBIG(caller+": "+details_hash_links.length+" details_hash_links", 7);
};


let details_hash_link_onclick = function(e)
{
let caller = "details_hash_link_onclick";

    let        link = e.target;
    if(              !link.hash) return;

    let  name_or_id = link.hash.substr(1);
    let   id_target = document.getElementById(          name_or_id     );
    let name_target = document.querySelector ( "[name="+name_or_id+"]" );
    let link_target = id_target || name_target;

if(DOM_DETAILS_LOG)
    log_key_val(caller
                , {  name_or_id
                   , id_target
                   , name_target
                   , link_target
                });
if(DOM_DETAILS_LOG) log("%c"+caller+" %c"+name_or_id+"%c➔%c"+get_nodeXPath(link_target), lbH+lf3, lbH, lbL+lf4, lbR+lf5);


    if( link_target )
        details_open_closed_el_parent( link_target );

};






let details_close_opened = function()
{
    prevent_details_ontoggle_listener();
    let       el_array = Array.from( document.querySelectorAll("DETAILS[open]") );
    if(      !el_array.length) {
if(DOM_DETAILS_LOG) log("FOUND NO OPENED DETAILS TO CLOSE");
        return;
    }
if(DOM_DETAILS_LOG) log("CLOSING "+el_array.length+" OPENED DETAILS");

    el_array.forEach( (el) => { el.open = false; });

    setTimeout(restore_details_ontoggle_listener, 0);
};


let details_open_closed = function()
{
    prevent_details_ontoggle_listener();
    let       el_array = Array.from( document.querySelectorAll("DETAILS:not([open])") );
    if(      !el_array.length) {
if(DOM_DETAILS_LOG) log("FOUND NO OPENED DETAILS TO OPEN");
        return;
    }
if(DOM_DETAILS_LOG) log("OPENING "+el_array.length+" CLOSED DETAILS");

    el_array.forEach( (el) => { el.open =  true; });

    setTimeout(restore_details_ontoggle_listener, 0);
};



const DETAILS_ONTOGGLE_LISTENER_DELAY = 500;
let   details_ontoggle_listener_mutex;


let prevent_details_ontoggle_listener = function()
{

if(DOM_DETAILS_LOG) logBIG("prevent_details_ontoggle_listener",7);
    details_ontoggle_listener_mutex   =  true;
};


let restore_details_ontoggle_listener = function()
{

    setTimeout(function() {
if(DOM_DETAILS_LOG) logBIG("restore_details_ontoggle_listener",6);
            details_ontoggle_listener_mutex = false;
        }
        , DETAILS_ONTOGGLE_LISTENER_DELAY);
};






let t_store_set_state = function(label,state)
{
    if(    state != undefined)
    {
        if(state) localStorage.setItem   (label, "true");
        else      localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return    localStorage.getItem   (label        );
    }
};

return { name    : "dom_details"
    ,    logging : (state) => DOM_DETAILS_LOG = t_store_set_state("DOM_DETAILS_LOG", state)
    ,    tagging : (state) => DOM_DETAILS_TAG = t_store_set_state("DOM_DETAILS_TAG", state)
    ,    t_details_IMPORT


    ,    details_onload                 : details_handler.details_onload
    ,    details_radio_toggle
    ,    details_has_closed_el_parent
    ,    details_open_closed_el_parent
    ,    details_close_opened
    ,    details_open_closed
};

}());



/*INLINE}}}*/
//@ sourceURL=dom_details.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
/**   22 WOT      JS dom_wot_js_data .. ESCAPE case "#document"] {{{*/
/*
../script/dom_wot.js
*/
let dom_wot_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/

















const DOM_WOT_JS_ID      = "dom_wot_js";
const DOM_WOT_JS_TAG     = DOM_WOT_JS_ID  +" (220422:17h:54)";

let dom_wot             = (function() {
"use strict";
let   DOM_WOT_LOG       = false;
let   DOM_WOT_TAG       = false;





let t_wot_IMPORT        = function(_log_this,import_num)
{

    DOM_WOT_LOG         = DOM_WOT_LOG       || localStorage_getItem("DOM_WOT_LOG");
    DOM_WOT_TAG         = DOM_WOT_TAG       || localStorage_getItem("DOM_WOT_TAG");


    wot_INTERN();
if(_log_this) log("➔ "+(import_num ? (import_num+" ") : "")+"t_wot_IMPORT");
};




const CSS_LINE_NUM = "line_num";
const LF           = String.fromCharCode(10);
const LINES_WOT    = "lines_wot"    ;



let lb0="", lb1="", lb2="", lb3="", lb4="", lb5="", lb6="", lb7="", lb8="", lb9="", lbX="";
let lbA="", lbB="", lbC="", lbF="", lbH="", lbL="", lbR="", lbS="", lbb=""                ;
let lf0="", lf1="", lf2="", lf3="", lf4="", lf5="", lf6="", lf7="", lf8="", lf9="", lfX="";

let log=console.log, logBIG=log, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;

let console_dir=console.dir;




let add_el_class;
let has_el_class;
let get_el_title;
let get_id_or_tag;


let escapeHTML;
let strip_CR_LF;
let get_first_word;


let ellipsis;
let mPadStart;


let is_marked_to_hide;




let localStorage_delItem = (key    ) =>           localStorage.removeItem(key    );
let localStorage_getItem = (key    ) =>           localStorage.getItem   (key    );
let localStorage_setItem = (key,val) => { if(val) localStorage.setItem   (key,val); else localStorage.removeItem(key); };



let t_get_tool = (id) => document.getElementById(id);



let   wot_INTERN        = function()
{

let caller = "wot_INTERN";



    let dom_log_js
        = (typeof dom_log != "undefined")
        ?         dom_log
        :         dom_wot_log;

    if( dom_log_js )
    {
        if(dom_log_js.LOG_BG_CSS) {
            ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = dom_log.LOG_BG_CSS);
            ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = dom_log.LOG_FG_CSS);
            ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = dom_log.LOG_XX_CSS);
        }

        ({  log
         ,  logBIG
         ,  logXXX
         ,  log_caller
         ,  log_json_one_liner
         ,  log_key_val
         ,  log_key_val_group
         ,  console_dir
        } = dom_log_js);

if(DOM_WOT_LOG || DOM_WOT_TAG) logBIG(caller+": ["+dom_log_js.name+"]" , 4);
    }
    else {

logBIG(caller+": [dom_log UNDEFINED]"   , 2);
    }


    let dom_util_js
        = (typeof dom_util != "undefined")
        ?         dom_util
        :         dom_wot_util;

    if( dom_util_js )
    {
        ({  add_el_class
         ,  get_el_title
         ,  get_id_or_tag
         ,  has_el_class
         ,  strip_CR_LF
         ,  escapeHTML
         ,  get_first_word
         ,  ellipsis
         ,  mPadStart
         ,  is_marked_to_hide
        } = dom_util_js);

if(DOM_WOT_LOG || DOM_WOT_TAG) logBIG(caller+": ["+dom_util_js.name+"]"    , 4);
    }
    else {

logBIG(caller+": [dom_util UNDEFINED]"      , 2);
    }


    if(typeof dom_store != "undefined")
    {
        localStorage_getItem =          dom_store.t_store_getItem;
        localStorage_setItem =          dom_store.t_store_set_value;
        localStorage_delItem = (key) => dom_store.t_store_set_value(key,null);

if(DOM_WOT_LOG || DOM_WOT_TAG) logBIG(caller+": ["+dom_store.name+"]"      , 4);
    }


    if(typeof dom_tools != "undefined")
    {
        t_get_tool       = dom_tools.t_get_tool;

if(DOM_WOT_LOG || DOM_WOT_TAG) logBIG(caller+": ["+dom_tools.name+"]"      , 4);
    }

};









const FOLD_OPEN   = "{{{";
const BRACE_OPEN  =   "{";
const BRACE_CLOSE =   "}";
const FOLD_CLOSE  = "}}}";


let is_line_fold_open = function(line)
{
    let result = line.includes( FOLD_OPEN ) ;

    return result;
};



const LEVELS = "123456789";


let is_line_fold_close = function(line)
{
    let result = line.includes( FOLD_CLOSE ) ;


    if(!result)
    {
        let idx    = line.indexOf(     FOLD_OPEN       );
        if( idx ) {
            let s  = line.charAt(idx + FOLD_OPEN.length);
            if((s != "") && (LEVELS.indexOf(s) >= 0))
                result = true;
        }
    }

    return result;
};


let is_line_brace_open = function(line)
{
    let result =  !line.startsWith(" ") && line.endsWith( BRACE_OPEN );

    return result;
};


let is_line_brace_close = function(line)
{
    let result = line.startsWith( BRACE_CLOSE );

    return result;
};








const WALL_OF_TEXT_PARENT   = "wall_of_text_parent";
const WALL_OF_TEXT_SPLIT    = "wall_of_text_split";
const WALL_OF_TEXT_BLOCK    = "wall_of_text_block";
const WALL_OF_TEXT_FOLD     = "wall_of_text_fold";
const WOT_P_LINES_MIN       =    1;
const WOT_LENGTH            =  256;
const PAR_LENGTH_MAX        = 2048;
const REPORTED_COUNT_MAX    =    8;

const regexp_REGIONFOLD     = new RegExp("#region (\\S+).*");
const regexp_FUNCTION_JS    = new RegExp("\\/\\*[_ ]*(\\S+).*\\{\\{\\{\\*\\/");

const regexp_FUNCTION_LUA   = new RegExp(    "--[_ ]*(\\S+).*\\{\\{\\{");

const regexp_IMAGE_ASCIIDOC = new RegExp(    '^image::([^\\[]*)(?:\\[([^\\]]+))\\]?');



let   wot_split_done = false;

let t_WOT_SPLIT = function()
{

    if( wot_split_done ) return;

    wot_split_done = true;


let   caller = "t_WOT_SPLIT";
let log_this = DOM_WOT_LOG;

if( log_this) console.time(caller);


    pre_innerHTML_to_innerText();

    reported_count      = 0;
    reported_filters    = [];

    let            root = document.body;
    let   mDomTraversal = document.createNodeIterator(root, NodeFilter.SHOW_TEXT, mNodeFilter_wall_of_text_block);
    let text_node_array = get_wall_of_text_node_array( mDomTraversal );

if( log_this) log("%c"+caller+" %c "+text_node_array.length+" TEXT NODES FILTER_ACCEPT'ed", lbH, lbH+lf3);



    let node_count = 0;
    let char_count = 0;
    let LF_count   = 0;

    let line_num   = 1;
    let trailNoEOL = "";
    let innerHTML;
    for(let i = 0; i < text_node_array.length; ++i)
    {



        let text_node   = text_node_array[i];

        let textContent = trailNoEOL + text_node.textContent;
        char_count     += textContent.length;


        trailNoEOL
            = textContent.endsWith(LF)
            ? ""
            : textContent.substring( textContent.lastIndexOf(LF)+1 );

        let lines      = textContent.split(LF);
        LF_count      += lines.length;

        let last_line  = lines[lines.length-1];

        if( last_line == trailNoEOL) lines.pop();


if(log_this && (i < 2))
    log_key_val_group("line_num %c"+ line_num
                      , {         textContent_length : textContent.length
                          ,               trailNoEOL : "["+trailNoEOL+"] .. length=["+ trailNoEOL.length+"]"
                          ,               last_line  : "["+last_line +"] .. length=["+ last_line .length+"]"
                          ,  last_line_eq_missingEOL : (last_line == trailNoEOL)
                          ,                STARTWITH : textContent.substring(0                  ,80)
                          ,                ENDS_WITH : textContent.substring(textContent.length -80)
                      }
                      , false);



        let               parent = text_node.parentNode;
        if(              !parent ) continue;
        if( !has_el_class(parent, WALL_OF_TEXT_PARENT) )
        {
            parent.innerHTML = "";
            add_el_class(parent, WALL_OF_TEXT_PARENT);
        }


if( log_this) {
    log("%c"+i, lbb+lbH+lf3);
    console_dir("parent has "+ parent.children.length+" children", parent   );
    console_dir("text_node", text_node);
    log("%c "+get_id_or_tag(parent) +" "+ parent.textContent.length+" characters", lbH);
}


        let fold_open  = is_line_fold_open (text_node.textContent);
        let fold_close = is_line_fold_close(text_node.textContent);
        if( fold_open && fold_close)  [line_num , innerHTML] = get_FOLD_EL_innerHTML(lines, line_num);
        else                          [line_num , innerHTML] = get_lines_innerHTML  (lines, line_num);

        parent.innerHTML += innerHTML;
        node_count += 1;


if( log_this) console_dir("...parent has "+parent.children.length+" children", parent);
if( log_this) log(caller+": %c node_count=["+node_count+"] %c LF_count=["+LF_count+"] %c char_count=["+char_count+"]"
                  ,        lbL                            ,lbC                       ,lbR                            );

    }


    let split_wot = t_get_tool("split_wot");
    if( split_wot )
        split_wot.title
            = get_el_title( split_wot )
                +LF +(LF_count ? (LF_count+" lines have been parsed") : "Found no WOT to parse");


if( log_this && node_count) console.timeEnd(caller);

if( log_this)
    if(node_count) log("%c"+caller+"%c"+node_count+" WALLS OF TEXT %c "+char_count+" characters %c "+LF_count+" LF"
                       ,lbH+lf7    ,lbb+lbH+lf7                   ,lbH+lf7                     ,lbH+lf9            );

};


let t_WOT_FOLD_EL = function(el)
{
    el.textContent = ""+ el.textContent;
    let lines      = el.textContent.split(LF);
    let line_num   = 1;
    let innerHTML;
    [line_num , innerHTML] = get_FOLD_EL_innerHTML(lines, line_num);

    el.innerHTML   = innerHTML;
};






let get_lines_innerHTML = function(lines, line_num)
{
    let with_line_num = localStorage_getItem( LINES_WOT );

    let innerHTML = "";
    let    l = 0;
    while((l < lines.length))
    {


        let paragraph = "";
        let par_lines = 0;

        let this_line = lines[l  ];

        let fold_open  = is_line_fold_open (this_line); let fold_close  ;
        let brace_open = is_line_brace_open(this_line); let brace_close ;

        let may_add_next_line;

        do {

            this_line = lines[l  ];
            let next_line = lines[l+1] || "";



            if(par_lines > WOT_P_LINES_MIN) {
                if( is_line_fold_open  (this_line)) break;
                if( is_line_brace_open (this_line)) break;
            }



            let h_line = escapeHTML(this_line);

            h_line = h_line.replace(regexp_REGIONFOLD    , "<span class='"+WALL_OF_TEXT_BLOCK+"'>$1</span> "+h_line);
            h_line = h_line.replace(regexp_FUNCTION_JS   , "<span class='"+WALL_OF_TEXT_BLOCK+"'>$1</span> "+h_line);
            h_line = h_line.replace(regexp_FUNCTION_LUA  , "<span class='"+WALL_OF_TEXT_BLOCK+"'>$1</span> "+h_line);

            h_line = h_line.replace(regexp_IMAGE_ASCIIDOC, "<img src='$1' alt=$1 title=$2 />");



            if( h_line.includes(  "#region" ) )
            {
                h_line = h_line.replace("'>", " region'>#region ");

            }


            else if(       next_line
                    && (   next_line.includes(" function(")
                        || next_line.includes("function " )
                        || next_line.includes("private "  )
                        || next_line.includes("protected ")
                        || next_line.includes("public "   )
                        || next_line.includes("static "   )
                        || next_line.includes("void "     )
                       )
                   )
            {
                h_line = h_line.replace("'>", " function'>");
            }


            else {
                h_line = "<span class='text_line'>"+h_line+"</span>";
            }


            if(      h_line.includes(FOLD_OPEN) && !h_line.includes(FOLD_CLOSE)) h_line =        "<details><summary>"+h_line+"</summary>";
            else if(!h_line.includes(FOLD_OPEN) &&  h_line.includes(FOLD_CLOSE)) h_line = h_line+"</details>";


            if(with_line_num) {
                let p_line = "<span class='"+CSS_LINE_NUM+"'>"+mPadStart(line_num, 6)+" </span>"+(h_line || "")+LF;
                paragraph += p_line;
            }
            else {
                paragraph += (h_line || "")+LF;
            }

            par_lines += 1;
            line_num  += 1;


            if(par_lines > WOT_P_LINES_MIN) {
                fold_close  = is_line_fold_close ( this_line );
                brace_close = is_line_brace_close( this_line );
            }




            l += 1;

            let next_p_len =  paragraph.length + next_line.length;
            may_add_next_line
                =      (     lines.length  > l)
                && (   ( next_line.length == 0)
                       || (next_p_len        <= PAR_LENGTH_MAX));


        } while(may_add_next_line && !fold_close && !brace_close);

        let className
            = WALL_OF_TEXT_SPLIT
            + ((       ( fold_open &&  fold_close)
                    || (brace_open && brace_close)
               )
               ?    (" "+WALL_OF_TEXT_FOLD)
               :    ""
              )
        ;

        if(paragraph.length) innerHTML += "<pre class='"+className+"'>"+paragraph+"</pre>";

    }
    return [line_num , innerHTML];
};


let get_FOLD_EL_innerHTML = function(lines,line_num)
{
    let with_line_num     = localStorage_getItem( LINES_WOT );
    let innerHTML         = "";
    let    l              = 0;
    while((l < lines.length))
    {
        let paragraph     = "";

        let this_line     = lines[l  ];

        let may_add_next_line;
        do {
            this_line     = lines[l  ];
            let next_line = lines[l+1] || "";
            let h_line    = escapeHTML(this_line);

            let fold_close = is_line_fold_close(this_line);
            let fold_open  = is_line_fold_open (this_line);

            if(fold_open) {
                h_line
                    = (fold_close ? "</details>" : "")
                    + "<details id='fold_"+l+"' class='"+WALL_OF_TEXT_SPLIT+"'>"
                    +  "<summary>"+h_line+"</summary>"
                    +  "<pre>"
                ;
            }
            else if( fold_close )
            {
                h_line
                    =             h_line
                    + "</pre>"
                    + "</details>"
                ;
            }


            if(with_line_num) {
                let p_line = "<span class='"+CSS_LINE_NUM+"'>"+mPadStart(line_num, 6)+" </span>"+(h_line || "")+LF;
                paragraph += p_line;
            }
            else {
                paragraph += (h_line || "")+LF;
            }
            l            += 1;
            line_num     += 1;


            may_add_next_line
                =      (     lines.length  > l)
                && (   ( next_line.length == 0));

        } while(may_add_next_line);
        if(paragraph.length) innerHTML += paragraph;
    }

    return [line_num , innerHTML];
};


let get_wall_of_text_node_array = function(mDomTraversal)
{
    let   node_array = [];
    let   node;

    while(node = mDomTraversal.nextNode())
        node_array.push(node);

    return node_array;
};


let pre_innerHTML_to_innerText = function()
{
    let pre_list = document.getElementsByTagName("PRE");
    let pre_count = 0;
    let pre;

    while(pre = pre_list[pre_count++])
        pre.textContent = ""+ pre.textContent;


};



let reported_count;
let reported_filters;


let mNodeFilter_wall_of_text_block = function(node)
{

let   caller = "mNodeFilter_wall_of_text_block";
let log_this = DOM_WOT_LOG;



    let check_result = NodeFilter.FILTER_ACCEPT;
    let      details = "";

    let npar = node.parentNode;


    if     ((!npar                     )                                                ) { check_result = NodeFilter.FILTER_REJECT; details = "NODE HAS NO PARENT" ; }
    else if(( npar.tagName  == "SCRIPT")                                                ) { check_result = NodeFilter.FILTER_REJECT; details = "SCRIPT TEXT"        ; }
    else if(( npar.tagName  ==  "STYLE")                                                ) { check_result = NodeFilter.FILTER_REJECT; details = "STYLE TEXT"         ; }


    else if(( npar.tagName   !=   "PRE") && (node.nodeType != Node.TEXT_NODE)           ) { check_result = NodeFilter.FILTER_SKIP  ; details = "NOT A TEXT NODE"    ; }

    else if((!node.textContent                    ) ) { check_result = NodeFilter.FILTER_SKIP  ; details = "NO TEXT CONTENT"    ; }
    else if(( node.textContent.length < WOT_LENGTH) ) { check_result = NodeFilter.FILTER_SKIP  ; details = "["+ node.textContent.length+" char] <  [WOT_LENGTH "+WOT_LENGTH+"]"; }
    else if(!get_first_word(      node.textContent) ) { check_result = NodeFilter.FILTER_SKIP  ; details = "["+ node.textContent.length+" char] .. HAS NO WORDS"; }


    else if(  is_marked_to_hide(node) ) { check_result = NodeFilter.FILTER_REJECT; details = "NODE MARKED TO HIDE"; }


    else                                                                                  { check_result = NodeFilter.FILTER_ACCEPT; details = "["+ node.textContent.length+" char]"; }



if(        log_this
   && (    node.textContent.length  > 32                )
   && (   (reported_count           < REPORTED_COUNT_MAX)
       || !reported_filters.includes( check_result      )
      )
  ) {
    reported_count += 1;
    if(!reported_filters.includes( check_result ) ) reported_filters.push( check_result );

    let result
        = (check_result == NodeFilter.FILTER_REJECT) ? "REJECT"
        : (check_result == NodeFilter.FILTER_SKIP  ) ? "__SKIP"
        : (check_result == NodeFilter.FILTER_ACCEPT) ? "ACCEPT"
        :                                               check_result;
    let lfx
        = (check_result == NodeFilter.FILTER_REJECT) ? lf2
        : (check_result == NodeFilter.FILTER_SKIP  ) ? lf8
        : (check_result == NodeFilter.FILTER_ACCEPT) ? lf4
        :                                              lf7;

    log(caller+":%c WOT ("+reported_count+"/"+REPORTED_COUNT_MAX+"...) "+ npar.tagName +"["+npar.textContent.length+"c]."+ node.nodeName +"%c"+result+"%c"+details+"%c "+strip_CR_LF(ellipsis(node.textContent, 64))
        ,        lbL                                                                                                                      ,lbR+lfx    ,lbL         ,lbR                                                          );
}

    return check_result;
};





let t_wot_set_state = function(label,state)
{
    if(    state != undefined)
    {
        if(state) localStorage.setItem   (label, "true");
        else      localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return    localStorage.getItem   (label        );
    }
};


return { name    : "dom_wot"
    ,    logging : (state) => DOM_WOT_LOG = dom_wot.t_wot_set_state("DOM_WOT_LOG", state)
    ,    tagging : (state) => DOM_WOT_TAG = dom_wot.t_wot_set_state("DOM_WOT_TAG", state)
    ,    t_wot_IMPORT
    ,    t_wot_set_state

    ,    t_WOT_FOLD_EL
    ,    t_WOT_SPLIT
    ,    t_WOT_SPLIT_done : () => wot_split_done

    ,    htot             : () => pre_innerHTML_to_innerText()
};

}());

/*INLINE}}}*/
//@ sourceURL=dom_wot.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
  /**  23 SENTENCE JS dom_sentence_js_data .. ESCAPE=[t_data.LF +"Slot #"] {{{*/
/*
../script/dom_sentence.js
*/
let dom_sentence_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/























const DOM_SENTENCE_JS_ID      = "dom_sentence_js";
const DOM_SENTENCE_JS_TAG     = DOM_SENTENCE_JS_ID  +" (220828:20h:20)";

let dom_sentence            = (function() {
"use strict";
let   DOM_SENTENCE_LOG      = false;
let   DOM_SENTENCE_TAG      = false;







let t_util     ;
let t_tools    ;



let t_sentence_IMPORT  = function(_log_this,import_num)
{

    DOM_SENTENCE_LOG = DOM_SENTENCE_LOG || localStorage_getItem("DOM_SENTENCE_LOG");
    DOM_SENTENCE_TAG = DOM_SENTENCE_TAG || localStorage_getItem("DOM_SENTENCE_TAG");



    if     (typeof dom_util           != "undefined") t_util  = dom_util         ;
    else if(typeof dom_sentence_util  != "undefined") t_util  = dom_sentence_util;
    else console.warn("MISSING STUB FOR: [dom_util]");



    if     (typeof dom_tools          != "undefined") t_tools = dom_tools         ;
    else if(typeof dom_sentence_event != "undefined") t_tools = dom_sentence_event;
    else console.warn("MISSING STUB FOR: [dom_tools]");


    sentence_INTERN();
if(_log_this) log("➔ "+(import_num ? (import_num+" ") : "")+"t_sentence_IMPORT: "+t_util.name+", "+t_tools.name);
};




let LOG_MAP = false;

let lf1="", lf2="", lf3="", lf4="", lf5="", lf6="", lf7="", lf8="", lf9="", lf0="";
let lfX = [ lf1 ,lf2 ,lf3 ,lf4 ,lf5 ,lf6 ,lf7 ,lf8 ,lf9, lf0 ];

let lb1="", lb2="", lb3="", lb4="", lb5="", lb6="", lb7="", lb8="", lb9="", lb0="";
let lbX = [ lb1 ,lb2 ,lb3 ,lb4 ,lb5 ,lb6 ,lb7 ,lb8 ,lb9, lb0 ];

const lXX  = "border:1px solid gray; padding:0 .5em; border-radius:1em;";
let lbA=lXX, lbB=lXX, lbC=lXX, lbF=lXX, lbH=lXX, lbL=lXX, lbR=lXX, lbS=lXX, lbb=lXX;

let log                 = console.log;
let log_key_val_group   = console.log;

let console_dir         = (k,v) => { console.log("..."+k+":"); console.dir(v); };


let   sentence_INTERN   = function()
{

    if((typeof dom_log != "undefined") && (dom_log.LOG_BG_CSS))
    {
        LOG_MAP = dom_log.LOG_MAP;

        ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = dom_log.LOG_BG_CSS);
        ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = dom_log.LOG_FG_CSS);
        ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = dom_log.LOG_XX_CSS);

        log                 = dom_log.log;
        log_key_val_group   = dom_log.log_key_val_group;
        console_dir         = dom_log.console_dir;
    }


    else if((typeof dom_log != "undefined") && dom_log.lfX)
    {
        lbH = dom_log.lbH;
        lbL = dom_log.lbL;
        lbR = dom_log.lbR;
        lbC = dom_log.lbC;
        lfX = dom_log.lfX;
        [ lf0 ,lf1 ,lf2 ,lf3 ,lf4 ,lf5 ,lf6 ,lf7 ,lf8 ,lf9 ] = lfX;
    }

};


let localStorage_setItem = function(key,val) { if(val) localStorage.setItem   (key,val); else localStorage.removeItem(key); };
let localStorage_getItem = function(key    ) { return  localStorage.getItem   (key    ); };
let localStorage_delItem = function(key    ) { localStorage.removeItem(key); };





const LF                = String.fromCharCode(10);
const UNICODE_BULLET    = "&#x2022;";

let sentence_containers = [];


const CSS_SENTENCE_CONTAINER = "sentence_container";
const CSS_SENTENCE           = "sentence";
const CSS_CLAUSE             = "clause";
const CSS_LAST_CLAUSE        = "last_clause";
const CSS_OUTLINED           = "outlined";
const CSS_DARK               = "dark";



const E12_FONT_SIZE_LIST = ["fs1", "fs2", "fs3", "fs4", "fs5", "fs6", "fs7", "fs8", "fs9", "fs10", "fs11", "fs12"];

let   e12_font_size      =  "fs8";









let t_SENTENCE_GET_EL_CONTAINER = function(el,_log_this)
{








let   caller = "t_SENTENCE_GET_EL_CONTAINER";
let log_this = _log_this || LOG_MAP.S2_SELECT;

    if(!t_util) console.warn("MISSING STUB FOR: [dom_util]");
    let container;



    if(!container)
    {
        container =  null





            || t_util.get_el_parent_with_tag  (el, "UL"             )
            || t_util.get_el_parent_with_tag  (el, "OL"             )


            || t_util.get_el_parent_with_tag  (el, "PRE"            )
            || t_util.get_el_parent_with_tag  (el, "P"              )



            || t_util.get_el_parent_with_tag  (el,  "TD"            )





            || t_util.get_el_parent_with_tag  (el, "TABLE"          )







            || t_util.get_el_parent_with_tag  (el, "BLOCKQUOTE"      )
            || t_util.get_el_parent_with_tag  (el, "DIR"             )
            || t_util.get_el_parent_with_tag  (el, "DIV"             )



            || t_util.get_el_parent_with_tag  (el, "DETAILS"        )
        ;

    }


    if(!container)
    {
        container
        =  t_util.get_el_parent_with_class(el,  CSS_OUTLINED    );

if(log_this && container) log(caller+": ...CSS_OUTLINED container=["+t_util.get_n_lbl(container)+"]");
    }



    let cells;
    if(container)
    {
        let c_next = container              .nextElementSibling;

        let p_next = container.parentElement
            ?        container.parentElement.nextElementSibling
            :        null
        ;

        let group
            = (!container)                          ? null


            :                                         null
        ;


        let dlist
            = (!container)                          ? null
            : ( container.nodeName == "DL"      )   ? container
            : ( container.nodeName == "DT"      )   ? container.parentElement
            :                                         null
        ;

        let table
            = (!container)                          ? null
            : ( container.nodeName ==  "THEAD"  )   ? container.parentElement
            : ( container.nodeName ==  "TFOOT"  )   ? container.parentElement
            : ( container.nodeName ==  "TBODY"  )   ? container.parentElement
            : ( container.nodeName ==  "CAPTION")   ? container.parentElement
            : ( container.nodeName == "TABLE"   )   ? container
            :                                         null
        ;

        cells
            =   group ?                        group


            :                                        null
        ;


if(log_this && (log_key_val_group != console.log))
    log_key_val_group(caller
                      , {   el
                          ,                   el_tagName : el.tagName
                          , container
                          , container_textContent_length : container.textContent.length
                          , table
                          , dlist
                          , group
                          , cells
                      }, lbH+lf4, false);

if(log_this) log(caller+": ...return container=["+t_util.get_n_lbl(container)+"] .. cells=["+(cells ? "x"+cells.length : "")+"]");


    }



    if(container)
    {
        return { container, cells };
    }
    else {
if(log_this) log(caller+": ...return NO container");
        return "";
    }

};


let t_SENTENCE_GET_EL_SENTENCE_CONTAINER = function(el)
{
    if( show_popup_container_shown )
    {
 let dom_popup_div = dom_popup.log_popup_div_get();
        if(t_util.is_el_or_child_of_parent_el(el, dom_popup_div))
        {
            return show_popup_container_shown;
        }
    }
    return t_util.get_el_parent_with_class(el, CSS_SENTENCE_CONTAINER);
};


let t_SENTENCE_GET_SENTENCE_CONTAINERS = function()
{
    return sentence_containers;
};


let t_SENTENCE_GET_SENTENCE_CONTAINERS_IN_VIEWPORT = function()
{
    if(typeof dom_view == "undefined") return [];

    let el_array = [];
    for(let i=0; i < sentence_containers.length; ++i)
    {
        if(dom_view.t_view1_is_el_topLeft_or_bottomRight_in_viewport(sentence_containers[i]))
            el_array.push( sentence_containers[i] );
    }

    return el_array;
};








const                 WORD = "\\s*(?:\\p{L}|_|\\(|-|\\))"    ;
const             BOUNDARY =     "[\\.,;:?\\n\\r]+(?!\\w)"   ;
const            LAST_WORD = WORD    +"{1,}";
const           FIRST_WORD = WORD    +"+";

const CAPTURING_PREV_END   = "("     + LAST_WORD  +")?"      ;
const CAPTURING_BOUNDARY   = "("     + BOUNDARY   +")"       ;
const CAPTURING_NEXT_START = "(\\n+|"+ FIRST_WORD +")?"      ;





const SYMBOL_GEAR          = "\u2699";
const SYMBOL_THEME         = "\u262F";
const SYMBOL_SCROLL        = "\u2933";

const MAGNIFIED_STYLE      = "font-size  : 200% !important;";
const LINE_HEIGHT_STYLE    = "line-height: 1em  !important;";

const THEME_STYLE_BG_DARK  = "rgba( 32, 32, 32,0.8)";
const THEME_STYLE_FG_DARK  = "rgba(255,255,255,0.8)";
const THEME_STYLE_BG_LIGHT = "rgba(255,255,255,0.8)";
const THEME_STYLE_DARK     = "color: #DDD !important; background-color: "+ THEME_STYLE_BG_DARK  +" !important; border-radius:1em;";
const THEME_STYLE_LIGHT    = "color: #222 !important; background-color: "+ THEME_STYLE_BG_LIGHT +" !important; border-radius:1em;";

let     theme_dark = false;
let     magnified  = false;
let     xpath_show = false;
let  scroll_smooth =  true;
let  last_container;
let regexp_SENTENCE;

let t_SENTENCE_SPLIT = function(container,e=null)
{

let   caller = "t_SENTENCE_SPLIT";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;

let tag_this = DOM_SENTENCE_TAG || log_this;

if( tag_this) log("%c"+caller+"("+t_util.get_n_lbl(container)+")", lbH+lf1);
if( log_this) console_dir("container",container        );
if( log_this && e) log("%c type=["+e.type+"] e.target.id=["+e.target.id+"]", lbH+lf3);


    if( check_tool_event(e) ) return;



    if((typeof dom_prop) != "undefined") theme_dark = dom_prop.get        ("theme_dark");
    else                                 theme_dark = localStorage_getItem("theme_dark");




    document.getElementsByTagName("HTML")[0].style.scrollBehavior
        = scroll_smooth
        ? "smooth"
        : "auto"
    ;


    if(!sentence_containers.includes( container ))
        sentence_containers.push    ( container );



    if(container.nodeName == "DETAILS") container.open = true;



    if(!regexp_SENTENCE ) {
        try {
            regexp_SENTENCE = new RegExp(CAPTURING_PREV_END +  CAPTURING_BOUNDARY +  CAPTURING_NEXT_START,"gu");
        } catch(ex) {
            log(ex);
        }
        if(!regexp_SENTENCE)
            regexp_SENTENCE = new RegExp(             "(\\w*)"+CAPTURING_BOUNDARY+"(\\w*)"               ,"gu");
    }


    let   el;
    while(el = t_util.get_el_child_with_class(container, dom_sentence.CSS_SENTENCE_CONTAINER))
        t_SENTENCE_RESTORE_EL(el, e);

    t_SENTENCE_RESTORE_EL(container, e);



    sentence_color_next = 1;

if( log_this) {
    log("...LAST_WORD            %c"+LAST_WORD           , lbC+lf2);
    log("...BOUNDARY             %c"+BOUNDARY            , lbC+lf3);
    log("...FIRST_WORD           %c"+FIRST_WORD          , lbC+lf2);
    log("...CAPTURING_PREV_END   %c"+CAPTURING_PREV_END  , lbC+lf5);
    log("...CAPTURING_BOUNDARY   %c"+CAPTURING_BOUNDARY  , lbC+lf6);
    log("...CAPTURING_NEXT_START %c"+CAPTURING_NEXT_START, lbC+lf7);
}
if( tag_this) {
    log("regexp_SENTENCE %c prev_end %c boundary %c next_start %c"+LF+regexp_SENTENCE
        ,                lbL+lf5    ,lbC+lf6    ,lbR+lf7      ,"border:1px solid magenta;");
}


    let text = t_util.t_get_htmlEntities( container.textContent.trim() );


    text = strip_HTML( container.innerHTML );

    t_util.t_copy_to_CLIPBOARD( text );

    text = text.replace(regexp_SENTENCE, t_SENTENCE_SPLIT_replace) ;




    container.innerHTML_SAVED
        = container.innerHTML;



    t_util.add_el_class(container, CSS_SENTENCE_CONTAINER);
    if( theme_dark ) {
        t_util.add_el_class(    container, CSS_DARK);
        t_util.add_el_class(document.body, CSS_DARK);
    }

    container.style.touchAction = "none";

    let button_style
        =                " float: right;"
        +            " clear: right;"
        +           " border: none;"
        +           " margin: 0;"
        +          " padding: 0;"
        + " background-color: transparent;"
        +            " color: #A00;"
        +        " font-size: 24px;"
        +      " font-weight: 900;"
        +      " line-height: 1em;"
    ;
    let span_style
        = "pointer-events: none"
    ;



    let tools = ""
        +    "<button id='dom_sentence_theme_dark' title='THEME DARK'    style='"+button_style+"'><span style='"+span_style+"'>"+ SYMBOL_THEME     +"</span></button>"
        +    "<button id='dom_scroll_smooth'       title='SCROLL SMOOTH' style='"+button_style+"'><span style='"+span_style+"'>"+ SYMBOL_SCROLL    +"</span></button>"

        + ((typeof dom_popup != "undefined")
           ? "<button id='dom_sentence_xpath_show' title='XPATH SHOW'    style='"+button_style+"'><span style='"+span_style+"'>"+ SYMBOL_GEAR      +"</span></button>" : "")
    ;

    let   theme_style
        = theme_dark
        ? THEME_STYLE_DARK
        : THEME_STYLE_LIGHT
    ;

    let   magnified_style
        = magnified
        ? MAGNIFIED_STYLE
        : ""
    ;

    container.innerHTML = tools
        + "<pre class='"+CSS_SENTENCE+" bg1' style=' "+LINE_HEIGHT_STYLE+" "+theme_style+" "+magnified_style+"'>"
        +  text
        + "</pre>";

    if( theme_dark )
        t_SENTENCE_SPLIT_set_parent_theme_dark( container );
    else
        t_SENTENCE_SPLIT_clr_parent_theme_dark( container );



    let selector
        = "."+ CSS_CLAUSE   +"+."+ CSS_SENTENCE
        + ","
        + "."+ CSS_SENTENCE +"+."+ CSS_SENTENCE
    ;

    let sentence_array = container.querySelectorAll( selector );
if( tag_this) console_dir("sentence_array .. selector=["+selector+"]",sentence_array);

    for(let i=0; i < sentence_array.length; ++i)
    {
        let last_clause =   sentence_array[i].previousElementSibling;
        t_util.add_el_class(last_clause, CSS_LAST_CLAUSE);

if( log_this) console.log(last_clause);
    }


    t_util.add_el_class(container.lastElementChild.lastElementChild, CSS_LAST_CLAUSE);

    t_SENTENCE_FONTSIZE_APPLY( container );


    let innerHTML
        = container.outerHTML;

    if( xpath_show )
        innerHTML
            += "<hr>"
            + "<pre class='xpath'>"
            +  t_util.get_parent_tag_id_class_chain( container )
            + "</pre>";

if( tag_this) log("container.innerHTML.length: %c"+container.innerHTML.length, lb7);
if( log_this) log("container.innerHTML:%c"+LF+container.innerHTML, lb7);



if( log_this) log_key_val_group(            caller
                               , {              el
                                 , regexp_SENTENCE : String(regexp_SENTENCE)
                                 ,  sentence_array
                                 ,  last_container
                                 ,            text : "(length: "+        text.length+") "       + t_util.ellipsis(text               )
                                 ,       container : "(length: "+container.innerHTML.length+") "+ t_util.ellipsis(container.innerHTML)
                                 ,      theme_dark
                                 ,   scroll_smooth
                                 ,       magnified
                                 ,      xpath_show
                                 ,         callers : dom_log.get_callers && dom_log.get_callers()
                               }, lf4, true);


    show_popup(container, innerHTML);



    clear_popup();


    last_container = container;
    t_tools.t_scrollIntoViewIfNeeded( container );
};



const regexp_BRLI               = new RegExp("(<br>\\n*)+<\/li>"       , "gi");
const regexp_BR                 = new RegExp("<br>"                    , "gi");
const regexp_LI                 = new RegExp("\\s*([\\.,;]\\s*)*<\/li>", "gi");
const regexp_MULTI              = new RegExp("(\\s*:\\n*\\s*)+"        , "gms");

const regexp_HTML               = new RegExp("<[^>]*>"                 , "g" );
const regexp_PUNC               = new RegExp("\\s*([\\.,;]\\s*)"       , "g" );
const regexp_BLANK              = new RegExp("\\s+|(&nbsp;)+"          , "g" );


let strip_HTML = function(text)
{
    if(   !text) return "";


    text = text
        .   replace(regexp_BRLI  , "</li>")
        .   replace(regexp_LI    , "."+LF+UNICODE_BULLET)
        .   replace(regexp_BR    , ":"    )
        .   replace(regexp_MULTI , ":"+LF )
    ;

    text = text
        .   replace(regexp_HTML  , " "    )
        .   replace(regexp_PUNC  , "$1"   )
        .   replace(regexp_BLANK , " "    )
    ;

    return text.trim();
};


let t_SENTENCE_SPLIT_set_parent_theme_dark = function (container)
{

    let el_array = get_parent_chain(container);

    el_array.forEach((el) => {
        el.style.background_saved         = el.style.background;
        el.style.background               = THEME_STYLE_BG_DARK;

        el.style.color_saved              = el.style.color;
        el.style.color                    = THEME_STYLE_FG_DARK;
    });
};


let t_SENTENCE_SPLIT_clr_parent_theme_dark = function (container)
{

    let el_array = get_parent_chain(container);

    el_array.forEach((el) => {
        el.style.background               = el.style.background_saved || "";
        delete                              el.style.background_saved;

        el.style.color                    = el.style.color_saved      || "";
        delete                              el.style.color_saved;
    });
};



let sentence_color_next = 1;


let t_SENTENCE_SPLIT_replace = function(match, prev_end="", boundary="", next_start="")
{

let   caller = "t_SENTENCE_SPLIT_replace";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;
let tag_this = DOM_SENTENCE_TAG || log_this;

if(next_start == LF) next_start = "";

if( tag_this) log(caller+" %c"+prev_end+"%c"+t_util.show_CR_LF(boundary)+"%c"+next_start
                  ,        lbL+lf5      ,lbC+lf6                         ,lbR+lf7       );



    let entering_a_clause
        =  boundary.includes(",")
        || boundary.includes(";")


    ;

    if(!entering_a_clause)
        sentence_color_next += 1;

    let className
        = (entering_a_clause ? CSS_CLAUSE : CSS_SENTENCE)
        + " bg"+(sentence_color_next % 10)
    ;

    return prev_end + boundary +"</span><span style='"+LINE_HEIGHT_STYLE+"' class='"+className+"'>"+ next_start;
};













let outline_text_containers_in_view = function(root=document.body)
{

let   caller = "outline_text_containers_in_view";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;
let tag_this = DOM_SENTENCE_TAG || log_this;

if( tag_this) log("%c"+caller, lbH+lf7);

    t_SENTENCE_restore_text_containers_outlined();
    let { text_container_in_view_array } = get_el_text_container_in_view_array( root );
if(tag_this) console_dir("text_container_in_view_array", text_container_in_view_array);

if(log_this) log("...outlining "+text_container_in_view_array.length+" containers");
    text_container_in_view_array.forEach(
                                         (el) => {
                                             t_util.add_el_class(el, CSS_OUTLINED);
                                             el.addEventListener("transitionend", outlined_transitionend_handler);
                                         }
                                        );

};


let outlined_transitionend_handler = function(e)
{

let   caller = "outlined_transitionend_handler";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;


if(log_this) console_dir(caller+": propertyName=["+e.propertyName+"] .. elapsedTime=["+e.elapsedTime+"]", e);
};


let t_SENTENCE_restore_text_containers_outlined = function()
{

let   caller = "t_SENTENCE_restore_text_containers_outlined";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;
let tag_this = DOM_SENTENCE_TAG || log_this;

if( tag_this) log("%c"+caller, lbH+lf8);

    node_in_view_filter_clear();

    let outlined_containers = document.querySelectorAll("."+CSS_OUTLINED);
    if( outlined_containers.length)
    {
if(log_this) log("...restoring "+outlined_containers.length+" outlined containers");
        for(let i=0; i < outlined_containers.length; ++i)
        {
            let node = outlined_containers[i] ;

            node.classList.remove( CSS_OUTLINED );

            if(typeof node.title_saved != "undefined") { node.title = node.title_saved; delete       node.title_saved; }
        }
    }
    else {
if(log_this) log("...found no outlined containers to restore");
    }

};


let get_el_text_container_in_view_array = function(root=document.body)
{

let   caller = "get_el_text_container_in_view_array("+t_util.get_n_lbl(root)+")";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;

if( log_this) console.time   (caller);
    let time_start = new Date().getTime();

    let text_container_in_view_array = [];
    let node;
    if(node_in_view_filter(root) == NodeFilter.FILTER_ACCEPT)
    {
if( log_this) log("root is a LEAF");
        text_container_in_view_array.push(root);
    }
    else {
        let treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, node_in_view_filter);
        let last_accepted_parent;
        while(node = treeWalker.nextNode())
        {
            if(!last_accepted_parent || !last_accepted_parent.contains(node))
            {
                last_accepted_parent = node;
                text_container_in_view_array.push(node);
            }
        }
    }
    let time_end = new Date().getTime();
if( log_this) console.timeEnd(caller);
if( log_this) console_dir("text_container_in_view_array", text_container_in_view_array);
    return { text_container_in_view_array , search_ms:(time_end - time_start) };
};



const CCS_REJECTED = "rejected";


let node_in_view_filter_clear = function()
{

let   caller = "node_in_view_filter_clear";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;


    let node_array = document.querySelectorAll("."+CCS_REJECTED);
    if(!node_array.length) return;

if(log_this) log(caller+": restoring "+node_array.length+" rejected containers");
    for(let i=0; i < node_array.length; ++i)
    {
        let node = node_array[i];

        node.classList.remove( CCS_REJECTED);

        if(typeof node.title_saved != "undefined") { node.title = node.title_saved; delete       node.title_saved; }
    }
};



const FILTER_TAGS
    = [   "PRE"
        , "P"
        , "TD"
        , "TABLE"
        , "BLOCKQUOTE"
        , "DIR"
        , "DIV"
        , "DETAILS"
    ];

const NodeFilter_RETURN_VALUES
    = {   [NodeFilter.FILTER_ACCEPT] : "FILTER_ACCEPT"
        , [NodeFilter.FILTER_REJECT] : "FILTER_REJECT"
        , [NodeFilter.FILTER_SKIP  ] : "FILTER_SKIP"
    };

const TEXT_LEN_MAX = 1024;


let node_in_view_filter = function(node)
{

let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;
let tag_this = DOM_SENTENCE_TAG || log_this;



    let why = NodeFilter.FILTER_ACCEPT;
    let why_not;



    if     ( node.style.display == "none"        ) { why = NodeFilter.FILTER_REJECT; why_not =     "DISPLAY_NONE"; }
    else if( node.tagName       == "SCRIPT"      ) { why = NodeFilter.FILTER_REJECT; why_not =      node.tagName ; }
    else if( node.tagName       == "STYLE"       ) { why = NodeFilter.FILTER_REJECT; why_not =      node.tagName ; }



    else if( node.tagName       == "TR"          ) { why = NodeFilter.FILTER_SKIP  ; why_not =      node.tagName ; }



    else if( node.style.position == "fixed"      ) { why = NodeFilter.FILTER_ACCEPT; }



    else if( node.children.length  > 0           ) {
        if(node.textContent.length > TEXT_LEN_MAX) { why = NodeFilter.FILTER_SKIP  ; why_not = "BIG_WITH_CHILDREN"; }
    }



    else if( FILTER_TAGS.includes(node.tagName)  ) { why = NodeFilter.FILTER_ACCEPT;                               }



    if(why != NodeFilter.FILTER_REJECT)
    {

        let bcr = node.getBoundingClientRect();
        if(node.children.length == 0)
        {
            if     (bcr.height < 1               ) { why = NodeFilter.FILTER_REJECT; why_not =        "NO HEIGHT"; }
            else if(bcr.width  < 1               ) { why = NodeFilter.FILTER_REJECT; why_not =         "NO WIDTH"; }
            else if(bcr.top > window.innerHeight ) { why = NodeFilter.FILTER_REJECT; why_not =           "BELLOW"; }
            else if(bcr.bottom < 0               ) { why = NodeFilter.FILTER_REJECT; why_not =            "ABOVE"; }
        }

        else if(    bcr.top > window.innerHeight ) { why = NodeFilter.FILTER_REJECT; why_not = "CONTAINER BELLOW"; }


        else if(    bcr.bottom < 0               ) { why = NodeFilter.FILTER_REJECT; why_not =  "CONTAINER ABOVE"; }


    }


if(log_this && why_not) log("node_in_view_filter("+t_util.get_n_lbl(node)+"): .. "+why_not);
if(log_this && why    ) log("node_in_view_filter("+t_util.get_n_lbl(node)+"): .. "+why    );
if(tag_this) {
    if(      why_not ) {
        t_util.add_el_class(node, CCS_REJECTED);
        node.title_saved = node.title || "";
        node.title       = node.tagName+" "+why_not;
    }
    else if( why ) {
        node.title_saved = node.title || "";
        node.title       = node.tagName+" "+NodeFilter_RETURN_VALUES[why];
    }
}

    return why;
};







const SENTENCE_DRAG_MOVED_ENOUGH =  64;
const SENTENCE_DRAG_COOLDOWN_MS  = 500;
let   sentence_drag_last_MS      =   0;

let was_on_cooldown;
let was_is_scrolling;

let t_SENTENCE_drag_DXY = function(dxy)
{

let   caller = "t_SENTENCE_drag_DXY";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.EV0_LISTEN;

let tag_this = DOM_SENTENCE_TAG || log_this;


    let  this_MS = new Date().getTime();

    let time_ellapsed = (this_MS - sentence_drag_last_MS);
    let on_cooldown   = (time_ellapsed <  SENTENCE_DRAG_COOLDOWN_MS);
    let is_scrolling  = (typeof dom_scroll != "undefined") ? dom_scroll.t_scroll_is_scrolling()
        :               (typeof dom_tools  != "undefined") ? dom_tools .t_scroll_is_scrolling()
        :                                                    false;

if( tag_this && (was_on_cooldown  != on_cooldown )) log("%c  COOLDOWN", lbH+lfX[on_cooldown  ? 6:0]);
if( tag_this && (was_is_scrolling != is_scrolling)) log("%c SCROLLING", lbH+lfX[is_scrolling ? 7:0]);
    was_on_cooldown  = on_cooldown ;
    was_is_scrolling = is_scrolling;

    if( on_cooldown || is_scrolling) {
        t_tools.t_add_MOVE_ON_COOLDOWN(SENTENCE_DRAG_COOLDOWN_MS - time_ellapsed);
        sentence_drag_last_MS = this_MS;
        return  true;
    }


    let from_container = document.querySelector("."+CSS_SENTENCE_CONTAINER);

    if(!from_container)
        return false;



    let move_H_or_V  =  Math.abs(dxy.x     ) > Math.abs(dxy.y);
    let move_delta   = move_H_or_V ? dxy.x   :          dxy.y;
    let moved_enough = (Math.abs(move_delta) > SENTENCE_DRAG_MOVED_ENOUGH);

    if(!moved_enough ) {
        t_tools.t_add_NOT_MOVED_ENOUGH();
        return false;
    }
    else {
        t_tools.t_del_NOT_MOVED_ENOUGH();
    }


    let split_or_font = move_H_or_V;
    let split_delta   = (move_delta > 0) ? 1 : -1;


if( log_this) log_key_val_group(  caller
                                  , { move_delta
                                    , split_or_font
                                    , split_delta
                                  }
                                  , lfX[split_or_font ? ((split_delta > 0) ? 3:4) : ((split_delta > 0) ? 5:6)]
                                  , true);




    if( split_or_font )
    {
        t_SENTENCE_split_at_offset(from_container, split_delta);
    }


    else {
        t_SENTENCE_FONTSIZE_OFFSET( split_delta );
        t_tools.t_scrollIntoViewIfNeeded( from_container );
    }

if(tag_this) log("%c  DRAG DONE", lbb+lbH+lf3);
    t_tools.t_del_MOVE_ON_COOLDOWN();
    sentence_drag_last_MS = this_MS;
    return true;
};


let t_SENTENCE_split_at_offset = function(from_container,split_delta)
{

let   caller = "t_SENTENCE_split_at_offset";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.EV0_LISTEN;




    let sibling_container = t_util.get_node_sibling_at_offset(from_container, split_delta);

if( log_this) log_key_val_group( caller+"(split_delta=["+split_delta+"])"
                                , {   from_container
                                  , sibling_container
                                });

    if( sibling_container )
    {
        t_SENTENCE_RESTORE_EL    ( from_container    );
        t_SENTENCE_SPLIT         ( sibling_container );
        t_SENTENCE_FONTSIZE_APPLY( sibling_container );
        t_SENTENCE_OUTLINE       ( sibling_container );

        t_tools.t_scrollIntoViewIfNeeded( sibling_container );
    }
};


let t_SENTENCE_OUTLINE = function(sentence_el)
{
    let sentence_container = t_util.get_el_parent_with_class(sentence_el, CSS_SENTENCE_CONTAINER);
    if( sentence_container ) sentence_container.classList.add(            CSS_OUTLINED          );
};


let t_SENTENCE_FONTSIZE_OFFSET = function(split_delta=0)
{

let   caller = "t_SENTENCE_FONTSIZE_OFFSET";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;



    let num = split_delta + parseInt( e12_font_size.substring(2) );
    num     = Math.max( 1, num);
    num     = Math.min(12, num);

    e12_font_size = "fs"+num;

if( log_this) log(caller+": e12_font_size=["+e12_font_size+"]");


    let node_list = document.querySelectorAll("."+CSS_SENTENCE_CONTAINER);
    for(let i=0; i < node_list.length; ++i)
        t_SENTENCE_FONTSIZE_APPLY(node_list[i]);



    clear_popup();


    return node_list.length;
};


let t_SENTENCE_FONTSIZE_APPLY = function(container)
{
    t_util.clear_el_classList(container, E12_FONT_SIZE_LIST);

    container.classList.add( e12_font_size );

    container.parentElement.style.maxHeight = "fit-content";
};







let t_SENTENCE_RESTORE_EL = function(el,e=null)
{

let   caller = "t_SENTENCE_RESTORE_EL";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;
let tag_this = DOM_SENTENCE_TAG || log_this;
if( tag_this) log("%c"+caller+"("+t_util.get_n_lbl(el)+")", lbH+lf2);
if( log_this && e) log("%c type=["+e.type+"] e.target.id=["+e.target.id+"]", lbH+lf3);

    if(!el) return "";
    let consumed_by = "";

    if( check_tool_event(e) ) return consumed_by;

    let container = t_util.get_el_parent_with_class(el, CSS_SENTENCE_CONTAINER);
    if( container )
    {
        consumed_by = "RESTORING CONTAINER SPLIT SENTENCES";



        t_util.del_el_class(    container, CSS_SENTENCE_CONTAINER);
        t_util.add_el_class(    container, CSS_OUTLINED);
        t_util.del_el_class(    container, CSS_DARK);
        t_util.del_el_class(document.body, CSS_DARK);

        if( container.innerHTML_SAVED )
        {
if( tag_this) log("%c...innerHTML_SAVED=["+t_util.ellipsis(container.innerHTML_SAVED, 16)+"]", lf3);

            container.style.touchAction = "";

            container.innerHTML         =  container.innerHTML_SAVED;
            delete                         container.innerHTML_SAVED;

        }
        t_SENTENCE_SPLIT_clr_parent_theme_dark( container );

        sentence_containers.splice(sentence_containers.indexOf(container), 1);
    }


    t_util.clear_el_classList(el, E12_FONT_SIZE_LIST);

    hide_popup();


if( log_this) log_key_val_group(        caller
                               , {          el
                                 ,   container
                                 , consumed_by
                                 ,     callers : dom_log.get_callers && dom_log.get_callers()
                               }, lf8, true);

if( tag_this) log("...return ["+consumed_by+"]");
    return consumed_by;
};


let t_SENTENCE_RESTORE_ALL = function(e=null)
{

let   caller = "t_SENTENCE_RESTORE_ALL";
let log_this = DOM_SENTENCE_LOG || LOG_MAP.S2_SELECT;

let tag_this = DOM_SENTENCE_TAG || log_this;
if( tag_this) log("%c"+caller, lbH+lf2);
if( log_this && e) log("%c type=["+e.type+"] e.target.id=["+e.target.id+"]", lbH+lf3);

    if( check_tool_event(e) ) return;

    let node_list = document.querySelectorAll("."+CSS_SENTENCE_CONTAINER);
    for(let i = 0; i <      node_list.length; ++i)
        t_SENTENCE_RESTORE_EL(node_list[i], e);


};







const CHECK_TOOL_EVENT_DELAY = 250;

let check_tool_event_timer;

let t_SENTENCE_onresize = function(e=window.event)
{
    if( check_tool_event_timer ) clearTimeout( check_tool_event_timer );
check_tool_event_timer = setTimeout(check_tool_event, CHECK_TOOL_EVENT_DELAY, e);
};


let t_SENTENCE_set_theme_dark = function(_theme_dark)
{
    theme_dark = !!_theme_dark;
    localStorage_setItem("theme_dark", theme_dark);
};


let check_tool_event = function(e=window.event)
{

if(!e) return false;




    if(    last_container
       && (e.type == "resize")
      ) {
        t_SENTENCE_SPLIT( last_container );

        return true;
    }


    if(    last_container
       &&  e
       &&  e.target
       && (e.target.id == "dom_sentence_magnify")
      ) {
        magnified = !magnified;

        t_SENTENCE_SPLIT( last_container );

        return true;
    }


    if(    last_container
       &&  e
       &&  e.target
       && (e.target.id == "dom_sentence_theme_dark")
      ) {


        theme_dark = !theme_dark;


        localStorage_setItem("theme_dark", theme_dark);


        if((typeof dom_prop) != "undefined") dom_prop.set("theme_dark", theme_dark);


        t_SENTENCE_SPLIT( last_container );

        return true;
    }


    if(    last_container
       &&  e
       &&  e.target
       && (e.target.id == "dom_scroll_smooth")
      ) {


        scroll_smooth = !scroll_smooth;


        document.getElementsByTagName("HTML")[0] .style.scrollBehavior
            = scroll_smooth ? "smooth" : "auto";


        let distance = scroll_smooth ? 128 :  32;
        let delay    = scroll_smooth ? 500 : 250;
        window                   .scrollBy(0, distance);
        setTimeout(() => { window.scrollBy(0,-distance); }, delay);

        return true;
    }


    if(    last_container
       &&  e
       &&  e.target
       && (e.target.id == "dom_sentence_xpath_show")
      ) {
        xpath_show = !xpath_show;

        t_SENTENCE_SPLIT( last_container );

        return true;
    }

    return false;
};


let show_popup_container_shown;
let show_popup = function(container,innerHTML)
{
    if(typeof dom_popup == "undefined") return;

    if( xpath_show ) {
        show_popup_container_shown = container;
        dom_popup.log_popup({ message_HTML: innerHTML , options: "fixed" , theme_dark });
    }
    else
        show_popup_container_shown = null;
};


let clear_popup = function()
{
    if(typeof dom_popup == "undefined") return;

    let dom_popup_div = dom_popup.log_popup_div_get();
    if( dom_popup_div ) t_SENTENCE_FONTSIZE_APPLY( dom_popup_div );
};


let hide_popup = function()
{
    if(typeof dom_popup == "undefined") return;

    dom_popup.log_popup_hide();
};


let get_parent_chain = function(el)
{
    let array = [];

    while(          el.parentElement )
    {
        array.push( el.parentElement );
        el        = el.parentElement;
    }

    return array;
};





let t_store_set_state = function(label,state)
{
    if(    state != undefined)
    {
        if(state) localStorage.setItem   (label, "true");
        else      localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return    localStorage.getItem   (label        );
    }
};

return { name : "dom_sentence"
    ,    logging : (state) => DOM_SENTENCE_LOG = t_store_set_state("DOM_SENTENCE_LOG",state)
    ,    tagging : (state) => DOM_SENTENCE_TAG = t_store_set_state("DOM_SENTENCE_TAG",state)
    ,    t_sentence_IMPORT
    ,    CSS_SENTENCE_CONTAINER

    ,    t_SENTENCE_SPLIT

    ,    t_SENTENCE_GET_SENTENCE_CONTAINERS
    ,    t_SENTENCE_GET_SENTENCE_CONTAINERS_IN_VIEWPORT
    ,    t_SENTENCE_GET_EL_CONTAINER


    ,    t_SENTENCE_RESTORE_EL
    ,    t_SENTENCE_RESTORE_ALL
    ,    t_SENTENCE_GET_EL_SENTENCE_CONTAINER
    ,    t_SENTENCE_drag_DXY
    ,    t_SENTENCE_onresize

    ,    t_SENTENCE_set_theme_dark
    ,    t_SENTENCE_restore_text_containers_outlined


    ,    f : node_in_view_filter_clear
    ,    o : outline_text_containers_in_view
    ,    r : t_SENTENCE_restore_text_containers_outlined
};

}());




/*INLINE}}}*/
//@ sourceURL=dom_sentence.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
  /**  24 GRID     JS dom_grid_js_data .. ESCAPE=[color:#AAA] {{{*/
/*
../script/dom_grid.js
*/
let dom_grid_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/














const DOM_GRID_JS_ID        = "dom_grid_js";
const DOM_GRID_JS_TAG       = DOM_GRID_JS_ID    +" (220308:18h:13)";

let dom_grid    = (function() {
"use strict";
let   DOM_GRID_LOG          = false;
let   DOM_GRID_TAG          = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;



















let t_tools    = {}        ;


let t_grid_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;




















    t_tools   = dom_tools  ;


    grid_INTERN();

    DOM_GRID_LOG = DOM_GRID_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_GRID_LOG"));
    DOM_GRID_TAG = DOM_GRID_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_GRID_TAG"));


if(log_this) log("%c 19 grid", lbH+lf9);
};





let LOG_MAP;

let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;

let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let hotspot;
let dom_grid_html;


let CSS_HIDDEN;
let CSS_ON_GRID;
let ZINDEX_ON_GRID;


let   grid_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


    hotspot                     = t_tools.t_get_tool("hotspot");
    dom_grid_html               = t_tools.t_get_tool("dom_grid_html");



    CSS_HIDDEN                  = t_data.CSS_HIDDEN;
    CSS_ON_GRID                 = t_data.CSS_ON_GRID;
    ZINDEX_ON_GRID              = t_data.ZINDEX_ON_GRID;


};






const GRID_CAPTION    = "grid_caption";





let get_tools_map = function()
{
    return t_tools.t_tools_get_map();
};


let t_grid_TOOLS_SELECT = function(e)
{

    if(e.ctrlKey) return;
let log_this = LOG_MAP.T2_GRID;

    let caller = "t_grid_TOOLS_SELECT";
    let     el = t_util.t_get_event_target(e);
    let     caption = el.classList.contains(GRID_CAPTION) ? el : el.parentNode;
if(log_this) log(caller+": el=["+t_util.get_n_lbl(el)+"]");



    let actions = "";
    if( e.preventDefault ) { e.preventDefault();        actions += " preventDefault" ; }
    if( e.stopPropagation) { e.stopPropagation();       actions += " stopPropagation"; }
               { e.cancelBubble = true;     actions += " cancelBubble"   ; }
log_this = t_log.logging_something();
if(log_this) log(caller+": ...actions=["+actions+" ]");


    grid_TOOLS_SELECT_caption( caption );
};


let grid_TOOLS_SELECT_caption = function(caption)
{

    let caller = "grid_TOOLS_SELECT_caption";
let log_this = LOG_MAP.T2_GRID;

if(log_this) log(caller+": caption=["+t_util.get_n_lbl(caption)+"]");
if(log_this) log("...caption.id=["+caption.id+"]");


    let tools_map = get_tools_map();

    for(let i=0; i< tools_map.length; ++i)
    {
        let   map = tools_map[i];
        let panel =       map.panel;
        if( panel == hotspot) continue;
        let caption_id  = panel.id+"_"+GRID_CAPTION;
if(log_this) log("...caption_id=["+caption_id+"]");
        if(caption_id == caption.id) {
            t_grid_TOOLS_SELECT_panel(panel, "toggle");
            grid_caption_sync_opacity(map.selected, caption);

            break;
        }
    }

};


let t_grid_TOOLS_SELECT_panel = function(panel,new_state="toggle")
{
    let caller = "t_grid_TOOLS_SELECT_panel("+t_util.get_n_lbl(panel)+", "+new_state+")";
let log_this = LOG_MAP.T2_GRID;

if( log_this) log(caller);


    let      map  = t_tools.t_tools_map_get(panel);

    if(new_state == "toggle") new_state = !map.selected;

if( log_this) log("%c "+caller+": new_state=["+new_state+"]",lb9+lbF);


    if(map.selected != new_state)
    {
        map.selected = new_state;
if(log_this) log("... %c "+(map.selected ? "SELECTING" : "DESELECTING") + ": "+panel.id, lbF+(map.selected ? lb4 : lb1));

        t_tools.t_cache_armed_by(caller);
    }
};




let grid_caption_layout = function(num, panel, x, y)
{

let caller = "grid_caption_layout(num="+num+" .. "+panel.id+" .. xy=["+x+" "+y+"])";
let log_this = LOG_MAP.T2_GRID;

if( log_this) log(caller);


    let  shadow_root = t_tools.t_get_shadow_root();
    let           gl = grid_getElement(panel.id+"_"+GRID_CAPTION);
    if(!gl) {
        gl           = document.createElement("EM");
        gl.       id = panel.id+"_"+GRID_CAPTION;
        gl.    title = panel.id;
        gl.className = GRID_CAPTION;

        if     (dom_grid_html) { dom_grid_html.appendChild(gl); if(log_this) log("dom_grid_html: "+caller); }
        else if(shadow_root  ) { shadow_root  .appendChild(gl); if(log_this) log(  "shadow_root: "+caller); }
        else                   { document.body.appendChild(gl); if(log_this) log("document.body: "+caller); }

    }


    let ccx = (num % 10);
    gl.innerHTML
        = "<em class='cc"+ccx+"'>"+ num                             +"</em>"
        + "<em class='cc"+ccx+"'>"+ t_util.get_id_caption(panel.id) +"</em>"
        + "<em class='cc"+ccx+"'>"+                       panel.id  +"</em>"
    ;

    gl.style.zIndex    = ZINDEX_ON_GRID;
    gl.style.position  = "fixed";
    gl.style.left      = (x      )+"px";



    gl.style.top       = (y      )+"px";
    gl.style.maxHeight = grid_sized ? (t_gh-t_mg)+"px" : panel.clientHeight+"px";
    gl.style.maxWidth  = grid_sized ? (t_gw-t_mg)+"px" : panel.clientWidth +"px";
    gl.style.minHeight = grid_sized ? (t_gh-t_mg)+"px" : panel.clientHeight+"px";
    gl.style.minWidth  = grid_sized ? (t_gw-t_mg)+"px" : panel.clientWidth +"px";


    return gl;
};


let grid_caption_hide_all = function()
{
    let caller = "grid_caption_hide_all";
let log_this = LOG_MAP.T2_GRID;
if( log_this) log(caller);

    let tools_map = get_tools_map();

    for(let i=0; i< tools_map.length; ++i)
    {
        let   map  = tools_map[i];
        let panel  =       map.panel;
        if( panel == hotspot) continue;
        let    gl  = grid_getElement(panel.id+"_"+GRID_CAPTION);
        if(!gl)  continue;
        gl.classList.remove("grid_caption_show");
        gl.classList.add   ("grid_caption_hide");
    }
};


let grid_caption_sync_opacity = function(selected, gl)
{
    if(selected) gl.classList.add   ("grid_caption_see_through");
    else         gl.classList.remove("grid_caption_see_through");
};




const GRID_ONRESIZE_DELAY = 500;
let   grid_onresize_timer = null;

let t_grid_onresize = function(caller)
{
let log_this = LOG_MAP.T2_GRID;
if( log_this) log("t_grid_onresize(caller "+caller+")");

    if(grid_onresize_timer) clearTimeout(grid_onresize_timer);
    grid_onresize_timer   = setTimeout  (grid_onresize_handle, GRID_ONRESIZE_DELAY);
};

let grid_onresize_handle = function()
{
    let caller = "grid_onresize_handle";

    if( t_grid_IS_ON_GRID(caller) )
        grid_LAYOUT_ON();

    grid_onresize_timer = null;

    t_grid_onWork_EL_changed(caller);
};



const GRID_ONWORK_EL_CHANGED_TIMER_DELAY = 500;
let   grid_onWork_EL_changed_timer       = null;



let t_grid_onWork_EL_changed = function(caller)
{
if(LOG_MAP.T2_GRID) log("t_grid_onWork_EL_changed(caller "+caller+")");
    if(grid_onWork_EL_changed_timer) clearTimeout(grid_onWork_EL_changed_timer);
    grid_onWork_EL_changed_timer   = setTimeout  (grid_onWork_EL_changed_handler, GRID_ONWORK_EL_CHANGED_TIMER_DELAY);
};


let grid_onWork_EL_changed_handler = function()
{
    let caller = "grid_onWork_EL_changed_handler";
if(LOG_MAP.T2_GRID) log("%c "+caller+": LOG_MAP.T2_GRID=["+LOG_MAP.T2_GRID+"]",lb9+lbF);

    if(typeof t_tools.t_get_onWork_EL_last_used == undefined) return;

    let el = grid_getElement("headsup_l_check"); if(!el) return;

    if(!LOG_MAP.T2_GRID) el.innerHTML="GRID LOGGING IS OFF";



    let dom_grid_playground = grid_getElement("dom_grid_playground");
    if(dom_grid_playground) {
        if(!LOG_MAP.T2_GRID) dom_grid_playground.classList.add   ("collapsed");
        else                 dom_grid_playground.classList.remove("collapsed");
    }

    if(!LOG_MAP.T2_GRID) return;

    let ol = t_tools.t_get_onWork_EL_last_used();
    if(!ol) {
        el.innerHTML = "<em>onWork_EL</em> <em class='cc0'>NOT SELECTED</em>";

        return;
    }


    let cw = ol.clientWidth; let ch = ol.clientHeight;
    let ow = ol.offsetWidth; let oh = ol.offsetHeight;
    let sw = ol.scrollWidth; let sh = ol.scrollHeight;

    let t, w, h;

        let style = getComputedStyle(ol);
        t =          style.transform;
        w = parseInt(style.width );
        h = parseInt(style.height);



    let info
        = " transform    <em class='cc7'>"+ t               +"</em> "
        + " computed WxH <em class='cc8'>"+ w+" x "+h       +"</em> "
        + " page height  <em class='cc7'>"+ t_util.getPageHeight() +"</em> "

        ;

    el.innerHTML
        = "<table style='border-spacing:1em;'>"
        + " <tr><th class='cc9' style='font-size:200%; font-weight:900;'>"+t_util.get_n_lbl(ol)+"</th> <td colspan='4'>"+info+"</td> </tr>"
        + " <tr><th>Offset</th> <td class='cc6'>"+ow  +"</td> <td>x</td> <td class='cc3'>"+oh+"</td> <td><span class='cc1'>+VIEWABLE</span> <span class='cc3'>+PADDING</span> <span class='cc4'>+BORDER</span> <span class='cc5'>+SCROLLBAR</span> <span class='ccA'>-margin</span><td></tr>"
        + " <tr><th>Client</th> <td class='cc7'>"+cw  +"</td> <td>x</td> <td class='cc4'>"+ch+"</td> <td><span class='cc1'>+VIEWABLE</span> <span class='cc3'>+PADDING</span> <span class='ccA'>-border</span> <span class='ccA'>-scrollbar</span> <span class='ccA'>-margin</span><td></tr>"
        + " <tr><th>Scroll</th> <td class='cc8'>"+sw  +"</td> <td>x</td> <td class='cc5'>"+sh+"</td> <td><span class='cc2'>+OVERFLOW</span> <span class='cc3'>+PADDING</span> <span class='ccA'>-border</span> <span class='ccA'>-scrollbar</span> <span class='ccA'>-margin</span><td></tr>"
        + "</table>"
    ;

};



let t_grid_ON_OFF_CB = function(new_state)
{
    let caller = "t_grid_ON_OFF_CB("+new_state+")";

let log_this = LOG_MAP.T2_GRID;

    if(new_state == "toggle") new_state = !t_grid_IS_ON_GRID(caller);
if( log_this) log("%c "+caller+": new_state=["+new_state+"]",lb9+lbF);

    if( new_state ) { if(typeof t_tools.t_dimm_start != undefined) t_tools.t_dimm_start(caller); }
    else            { if(typeof t_tools.t_dimm_stop  != undefined) t_tools.t_dimm_stop (caller); }

    if(!new_state )   t_tools.t_update_TOOLS_MAP_GEOMETRY(caller);

    if( new_state ) { grid_SIZE_ON (); grid_LAYOUT_ON (); }
    else            { grid_SIZE_OFF(); grid_LAYOUT_OFF(); }

    call_t_grid_observers(new_state);

};



let grid_observer_callbacks = [];

let t_grid_add_observer_callback = function(observer)
{
if(LOG_MAP.T2_GRID) t_log.console_log("t_grid_add_observer_callback("+(grid_observer_callbacks.length+1)+")");

    if(!grid_observer_callbacks.includes( observer ))
        grid_observer_callbacks.push    ( observer );
};

let call_t_grid_observers = function(state)
{
if(LOG_MAP.T2_GRID) t_log.console_log("call_t_grid_observers("+state+")");

    for(let i=0; i < grid_observer_callbacks.length; ++i)
        grid_observer_callbacks[i]( state );
};


let grid_sized_sync = function(caller)
{
let log_this = LOG_MAP.T2_GRID;
if( log_this) log("%c grid_sized_sync: CALLED BY ["+caller+"] .. grid_sized=["+grid_sized+"]", lb3);

    let tools_map = get_tools_map();

    for(let i=0; i< tools_map.length; ++i)
    {
        let   map = tools_map[i];
        let panel =       map.panel;
        if( panel == hotspot) continue;
        if(!panel           ) continue;

        if(grid_sized) {
            panel.style.maxHeight = (t_gh-t_mg)+"px";
            panel.style.maxWidth  = (t_gw-t_mg)+"px";
            panel.style.minHeight = (t_gh-t_mg)+"px";
            panel.style.minWidth  = (t_gw-t_mg)+"px";
        }
        else {
            panel.style.maxHeight = "";
            panel.style.maxWidth  = "";
            panel.style.minHeight = "";
            panel.style.minWidth  = "";
        }
    }
};




let   grid_sized     = false;

let t_grid_SIZE_TOGGLE = function(e)
{
    let caller = "t_grid_SIZE_TOGGLE("+t_util.get_n_lbl(e.target)+")";
if(LOG_MAP.T2_GRID) t_log.console_log(caller);

    let tools_map = get_tools_map();

    if(!tools_map.length) return;


    t_grid_MEASURE();


    if(grid_sized ) grid_SIZE_OFF();
    else            grid_SIZE_ON ();


    let panel = tools_map[0].panel;
    if( panel.classList.contains("on_grid")) grid_LAYOUT_ON();
    else                                     grid_sized_sync(caller);

};


let t_grid_IS_SIZED = function(caller)
{
if(LOG_MAP.T2_GRID) t_log.console_log("t_grid_IS_SIZED: ...return "+grid_sized+" .. caller=["+caller+"]");

    return grid_sized;
};


let t_grid_IS_ON_GRID = function(_caller)
{
let log_this = LOG_MAP.T2_GRID;

    let tools_map = get_tools_map();

    if(!tools_map.length) t_tools.t_load_TOOLS_MAP("t_grid_IS_ON_GRID");

if( log_this) log("%c t_grid_IS_ON_GRID %c CALLED BY "+_caller+" %c "+grid_sized, lbL, lbR, lbH+(grid_sized ? lf4 : lf8));
    return grid_sized;
};


let   grid_SIZE_ON    = function() { grid_SIZE_STATE(true ); };
let   grid_SIZE_OFF   = function() { grid_SIZE_STATE(false); };
let   grid_SIZE_STATE = function(state)
{
    let caller = "grid_SIZE_STATE("+state+")";
if(LOG_MAP.T2_GRID) log("%c "+caller,lb5+lbF);

    let          checkbox         = grid_getElement("headsup_l_size_checkbox");
    if(checkbox) checkbox.checked = state;

    grid_sized = state;

    t_grid_onWork_EL_changed(caller);


};




let grid_LAYOUT_ON = function()
{

    let caller  = "grid_LAYOUT_ON";
let log_this = LOG_MAP.T2_GRID;


if(log_this) log("%c "+caller,lb9+lbF);


    t_grid_MEASURE();


    let tools_map = get_tools_map();

    let   num=0;
    for(let i=0; i< tools_map.length; ++i)
    {

        let   map = tools_map[i];
        let panel =       map.panel;
        if( panel == hotspot) continue;
        if(!panel           ) continue;

        map.x = panel.offsetLeft;
        map.y = panel.offsetTop;

        num += 1;




        let col = 1 + parseInt((num-1) % t_cols);
        let row = 1 + parseInt((num-1) / t_rows);

        let x      = t_mw + t_gw * (col-1);
        let y      = t_mh + t_gh * (row-1);


if(log_this) log("%c "+num       +"%c col "+col+".."+t_cols+"%c row "+row+".."+t_rows+"%c"+panel.id
                 ,lbH+lfX[num % 10], lbL+lfX[col]           , lbR+lfX[row]            ,lbH         );



        panel.classList.remove( CSS_HIDDEN  );
        panel.classList.add   ( CSS_ON_GRID );




        panel.style.position     = "fixed";

        panel.style.left         = x+"px";
        panel.style.top          = y+"px";

        panel.off_grid_transform = panel.style.transform;
        panel.style.transform    = "none";


        let gl = grid_caption_layout(num, panel, x, y);
        gl.classList.remove("grid_caption_hide");
        gl.classList.add   ("grid_caption_show");

        grid_caption_sync_opacity(map.selected, gl);

    }

    grid_sized_sync(caller);




};


let grid_LAYOUT_OFF = function()
{

    let caller = "grid_LAYOUT_OFF";
if(LOG_MAP.T2_GRID) log("%c "+caller,lb9+lbF);

    let tools_map = get_tools_map();
    if(!tools_map  ) return;



    for(let i=0; i< tools_map.length; ++i)
    {

        let   map = tools_map[i];
        let panel =       map.panel;
        if( panel == hotspot) continue;
        if(!panel           ) continue;




        if(!map.selected) panel.classList.add( CSS_HIDDEN  );
        panel.classList.remove(                CSS_ON_GRID );




        panel.style.position         = map.p     ;

        panel.style.left             = map.x+"px";
        panel.style.top              = map.y+"px";

        if(panel.off_grid_transform) {
            panel.style.transform    = panel.off_grid_transform;
            delete                     panel.off_grid_transform;
        }

    }

    grid_sized_sync(caller);


    grid_caption_hide_all();


};





let t_rows = 0;
let t_cols = 0;
let t_gw   = 0;
let t_gh   = 0;
let t_mw   = 0;
let t_mh   = 0;
let t_mg   = 0;

let t_grid_MEASURE = function()
{
    let caller = "t_grid_MEASURE"; if(LOG_MAP.T2_GRID) t_log.console_log(caller);


    let tools_map = get_tools_map();
    if(!tools_map.length) t_tools.t_load_TOOLS_MAP(caller);

    t_cols  = Math.round(Math.sqrt(tools_map.length));

    if((t_cols*t_cols) < tools_map.length  ) t_cols += 1;

    t_rows  = t_cols;



    let ww = window.innerWidth;
    let wh = window.innerHeight;

    let  cw = Math.round(ww / (t_cols+1));
    let  ch = Math.round(wh / (t_rows+1));
    if((cw == t_gw) && (ch == t_gh)) {
if(LOG_MAP.T2_GRID) t_log.console_warn(caller+": GRID UNCHANGED");
        return;
    }

    t_gw =            cw;
    t_gh =            ch;
    t_mw = Math.round(cw/2);
    t_mh = Math.round(ch/2);
    t_mg = Math.round(ch/8);

if(LOG_MAP.T2_GRID && t_grid_IS_ON_GRID(caller)) t_log.console_log(" ("+t_mw+"+ "+t_cols+"x"+t_gw+" + "+t_mw+") == "+(t_mw + t_cols*t_gw +t_mw)+" == ww= "+ww+"");
if(LOG_MAP.T2_GRID && t_grid_IS_ON_GRID(caller)) t_log.console_log(" ("+t_mh+"+ "+t_rows+"x"+t_gh+" + "+t_mh+") == "+(t_mh + t_rows*t_gh +t_mh)+" == wh= "+wh+"");



    let msg = "<table>"
            + " <tr> <td>("+t_mw+"</td><td>+</td> <th>"+t_cols+"x<em class='cc0'>"+t_gw+"</em></th> <td>+</td> <td>"+t_mw+")</td> <td>==</td> <th class='cc4'>"+(t_mw + t_cols*t_gw +t_mw)+"</th> <td>==</td> <th class='cc5'>ww= "+ww+"</th></tr>"
            + " <tr> <td>("+t_mh+"</td><td>+</td> <th>"+t_rows+"x<em class='cc0'>"+t_gh+"</em></th> <td>+</td> <td>"+t_mh+")</td> <td>==</td> <th class='cc4'>"+(t_mh + t_rows*t_gh +t_mh)+"</th> <td>==</td> <th class='cc5'>wh= "+wh+"</th></tr>"
            + "</table>"
        ;
if(LOG_MAP.T2_GRID) log(msg);
    let el = grid_getElement("headsup_l_table");
    if( el ) el.innerHTML = msg;


};




let t_grid_css_list = function()
{
    let caller = "t_grid_css_list"; if(LOG_MAP.T2_GRID) t_log.console_log(caller);

    let s = "<div>";
    s    += " document.styleSheets.length=["+document.styleSheets.length+"]";
    s    += " <ol>";



    for(let i = 0; i < document.styleSheets.length; ++i)
    {
        let sheet    =  document.styleSheets[i];
        s           += "  <li>";
        s           += "   <ul>";

        if(sheet.title)
            s       += "    <li> title=["+                          sheet.title               +"]</li>";



        if(sheet.ownerNode.id) {
            s       += "    <li> OWNER=<em class='cc"+(i+1) +"'>"+  sheet.ownerNode.id        +"</em></li>";
        }
        else {
            s       += "    <li> OWNER=<em class='cc"+(i+1) +"'>"+  sheet.ownerNode.tagName    +"</em></li>";
            if(sheet.href)
                s   += "    <li> href=[<a href='"+sheet.href+"'>"+  sheet.href                +"</a>]</li>";
        }



        if(sheet.type != "text/css")
            s       += "    <li> type=["+                           sheet.type                +"]</li>";



        if(sheet.disabled)
            s       += "    <li> disabled=["+                       sheet.disabled            +"]</li>";



        try {
            if(sheet.cssRules) {
                s       += "<li>cssRules.length=["+                 sheet.cssRules.length     +"]";
                s       += " <ol>";

                for(let j = 0; j < sheet.cssRules.length; ++j)
                    s   += " <li><em class='cc"+((j+1) % 10)+"'>"+  sheet.cssRules[j].cssText +"</em></li>";

                s       += " </ol>";
                s       += "</li>";
            }
        } catch(ex) {
            s       += "<li style='font-size:50%; color:#AAA;'>"+ex.message+"</li>";
        }

        s           += "   </ul>";
        s           += "  </li>";
    }


    s += " </ol>";
    s += "</div>";


    grid_trace(s);
};


let t_grid_insertRules = function()
{
    let caller = "t_grid_insertRules";
if(LOG_MAP.T2_GRID) t_log.console_log(caller);

    if( grid_css ) t_grid_deleteRules();

    grid_get_t_grid_css();

    let s = caller+":<br>";

    if(!grid_css) {
        s += caller+": <em class='cc2'>FOUND NO grid_css styleSheet</em>";
    }
    else {

        s    += "<div>";
        s    += " <ol>";
        let count = 0;
        let r;
        r    = ".on_grid { min-width  : "+t_gw+"px; }"; s += "  <li>insertRule <em class='cc0'>"+r+"</em></li>"; grid_css.insertRule(r, 0); count += 1;
        r    = ".on_grid { min-height : "+t_gh+"px; }"; s += "  <li>insertRule <em class='cc0'>"+r+"</em></li>"; grid_css.insertRule(r, 0); count += 1;
        r    = ".on_grid { max-width  : "+t_gw+"px; }"; s += "  <li>insertRule <em class='cc0'>"+r+"</em></li>"; grid_css.insertRule(r, 0); count += 1;
        r    = ".on_grid { max-height : "+t_gh+"px; }"; s += "  <li>insertRule <em class='cc0'>"+r+"</em></li>"; grid_css.insertRule(r, 0); count += 1;
        s    += " </ol>";
        s    += "</div>";

        if(count > 0) {
            s +=  "<em class='cc"+(count % 10)+"'>"+count+" RULES INSERTED</em><br>";
        }
    }

    grid_trace_add(s);

if(LOG_MAP.T2_GRID) t_log.console_dir(caller, grid_css);
};


let t_grid_deleteRules = function()
{
    let caller = "t_grid_deleteRules"; if(LOG_MAP.T2_GRID) t_log.console_log(caller);

    let        s  = "";

    if(!grid_css || !grid_css.cssRules)
    {
        s += "<em class='cc2'>NO grid_css rules to delete</em><br>";
    }
    else {
        let count = 0;

        s += "<div>";
        s += " <ol>";
        for(let i = 0; i < grid_css.cssRules.length; ++i)
        {
            if(grid_css.cssRules[i].cssText.includes(".on_grid") )
            {
                s += " <li><em class='cc0'>"+ grid_css.cssRules[i].cssText +"</em></li>";
                grid_css.deleteRule(i);
                count += 1;
                i -= 1;
            }
        }
        s += " </ol>";
        s += "</div>";

        if(count > 0) {
            s = caller+": <em class='cc"+(count % 10)+"'>"+count+" RULES DELETED</em><br>"
              + s;
        }
    }
    grid_trace(s);
};


const GRID_CSS_ID = "grid_css";

let grid_css;

let grid_get_t_grid_css = function()
{
    if(grid_css) return;

    let caller = "grid_get_t_grid_css";
if(LOG_MAP.T2_GRID) t_log.console_log(caller);

    let s = caller+": CREATING <em>"+GRID_CSS_ID+"</em><br>";
    let el   = document.createElement("STYLE");
    el.id    = GRID_CSS_ID;
    el.title = GRID_CSS_ID;
    el.type  = "text/css";
    el.rel   = "stylesheet";

    document.getElementsByTagName("head")[0].appendChild(el);
    grid_css = el.sheet;

    grid_trace(s);
if(LOG_MAP.T2_GRID) t_log.console_dir(caller, grid_css);
};




let t_grid_logging_toggle = function(new_state="toggle")
{
    let caller = "t_grid_logging_toggle";

    LOG_MAP.T2_GRID
    = (new_state == "toggle") ? !LOG_MAP.T2_GRID
    :                            new_state;

log("%c "+caller+": LOG_MAP.T2_GRID set to "+LOG_MAP.T2_GRID, lb7+lbF);

    t_grid_onWork_EL_changed(caller);
    t_tools.t_sync_tool_clones_state(caller);
};


let grid_trace = function(s)
{
    let el;
    if( el = grid_getElement("traces") ) el.innerHTML = s;
    else                                 t_log.console_log( t_util.strip_HTML(s) );
};


let grid_trace_add = function(s)
{
    let el;
    if( el = grid_getElement("traces") ) el.innerHTML += s;
    else                                 t_log.console_log( t_util.strip_HTML(s) );
};


let grid_getElement = function(id)
{

    let el = null;
    let shadow_root      = t_tools.t_get_shadow_root();
    if( shadow_root ) el = shadow_root.querySelector("#"+id);
    if(!el)           el = document.getElementById  (    id);
    return el;
};





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_grid"
    , logging : (state) => DOM_GRID_LOG = t_store_set_state("DOM_GRID_LOG",state)
    , tagging : (state) => DOM_GRID_TAG = t_store_set_state("DOM_GRID_TAG",state)
    ,    t_grid_IMPORT

    ,    t_grid_IS_ON_GRID
    ,    t_grid_IS_SIZED
    ,    t_grid_MEASURE
    ,    t_grid_ON_OFF_CB
    ,    t_grid_TOOLS_SELECT

    ,    t_grid_TOOLS_SELECT_panel
    ,    t_grid_add_observer_callback
    ,    t_grid_logging_toggle
    ,    t_grid_onWork_EL_changed
    ,    t_grid_onresize



    ,    t_grid_SIZE_TOGGLE
    ,    t_grid_css_list
    ,    t_grid_deleteRules
    ,    t_grid_insertRules
    ,    grid_onresize_handle

};



})();

/*INLINE}}}*/
//@ sourceURL=dom_grid.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;

/*}}}*/
/**   25 GUTTER   JS dom_gutter_js_data {{{*/
/*
../script/dom_gutter.js
*/
let dom_gutter_js_data ="data:text/javascript;charset='utf-8',"+ `
/*INLINE{{{*/













const DOM_GUTTER_JS_ID      = "dom_gutter_js";
const DOM_GUTTER_JS_TAG     = DOM_GUTTER_JS_ID  +" (220308:18h:13)";

let dom_gutter  = (function() {
"use strict";
let   DOM_GUTTER_LOG        = false;
let   DOM_GUTTER_TAG        = false;







let t_data     = {}        ;
let t_log      = {}        ;
let t_util     = {}        ;



















let t_tools    = {}        ;


let t_gutter_IMPORT  = function(log_this)
{


    t_data    = dom_data   ;
    t_log     = dom_log    ;
    t_util    = dom_util   ;




















    t_tools   = dom_tools  ;


    gutter_INTERN();

    DOM_GUTTER_LOG = DOM_GUTTER_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_GUTTER_LOG"));
    DOM_GUTTER_TAG = DOM_GUTTER_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_GUTTER_TAG"));


if(log_this) log("%c 20 gutter", lbH+lf0);
};





let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let   gutter_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;

};






let vp                     = { top:0 , left:0 , right:0 , bottom:0 , margin:0 };
let hotspot_last_WINDOW_XY = { x:0, y:0 };
let hotspot_last_GUTTER_XY = { x:0, y:0 };





let layout_has_CHANGED = function(_vp, margin)
{

let caller = "layout_has_CHANGED";
let log_this = DOM_GUTTER_LOG || LOG_MAP.EV2_MOVE;



    vp.top    = _vp.top    + margin;
    vp.left   = _vp.left   + margin;
    vp.right  = _vp.right  - margin;
    vp.bottom = _vp.bottom - margin;
    vp.margin =              margin;

    if(hotspot_last_WINDOW_XY.x || hotspot_last_WINDOW_XY.y) set_WINDOW_XY(hotspot_last_WINDOW_XY.x, hotspot_last_WINDOW_XY.y);
    if(hotspot_last_GUTTER_XY.x || hotspot_last_GUTTER_XY.y) set_GUTTER_XY(hotspot_last_GUTTER_XY.x, hotspot_last_GUTTER_XY.y);

if(log_this) log_gutter(caller+"(vp=["+_vp+"] , margin=["+margin+"])", lf4);
};




let set_WINDOW_XY = function(x, y)
{

let caller = "set_WINDOW_XY";
let log_this = DOM_GUTTER_LOG || LOG_MAP.EV2_MOVE;




    hotspot_last_WINDOW_XY.x = x;
    hotspot_last_WINDOW_XY.y = y;

    if(vp.right && vp.bottom) {
        hotspot_last_WINDOW_XY.x = Math.max(hotspot_last_WINDOW_XY.x , vp.left   + vp.margin);
        hotspot_last_WINDOW_XY.x = Math.min(hotspot_last_WINDOW_XY.x , vp.right  - vp.margin);
        hotspot_last_WINDOW_XY.y = Math.max(hotspot_last_WINDOW_XY.y , vp.top    + vp.margin);
        hotspot_last_WINDOW_XY.y = Math.min(hotspot_last_WINDOW_XY.y , vp.bottom - vp.margin);
    }

if(log_this) log_gutter(caller+"("+x+" "+y+")", lf4);
};


let get_WINDOW_XY = function()
{

let   caller = "get_WINDOW_XY";
let log_this = DOM_GUTTER_LOG || LOG_MAP.EV2_MOVE;



  if(   (hotspot_last_WINDOW_XY.x == 0)
     && (hotspot_last_WINDOW_XY.y == 0)
    ) {
      let w_H = Math.min(window.innerHeight, document.body.parentElement.clientHeight);
      let w_W = Math.min(window.innerWidth , document.body.parentElement.clientWidth );
if( log_this) log(caller+"%c INIT hotspot_last_WINDOW_XY to [w_W w_H] CENTER", lf7);

        hotspot_last_WINDOW_XY.x = w_W / 2;
        hotspot_last_WINDOW_XY.y = w_H / 2;
    }


if( log_this) log(caller+"%c return ["+hotspot_last_WINDOW_XY.x+" "+hotspot_last_WINDOW_XY.y+"]", lf7);
    return hotspot_last_WINDOW_XY;
};




let set_GUTTER_XY = function(x,y)
{

let caller = "set_GUTTER_XY";
let log_this = DOM_GUTTER_LOG || LOG_MAP.EV2_MOVE;




    hotspot_last_GUTTER_XY.x = x;
    hotspot_last_GUTTER_XY.y = y;

    if(vp.right && vp.bottom)
    {
        let    center_x = (vp.left + vp.right ) / 2;
        let    middle_x = (vp.top  + vp.bottom) / 2;
        let x_in_window
            =  (x >              vp.margin )
            && (x < (vp.right  - vp.margin));



        if( x_in_window ) {
            if(y < middle_x) hotspot_last_GUTTER_XY.y = Math.min(hotspot_last_GUTTER_XY.y , vp.top    + vp.margin);
            else             hotspot_last_GUTTER_XY.y = Math.max(hotspot_last_GUTTER_XY.y , vp.bottom - vp.margin);
        }
        else {
            if(x < center_x) hotspot_last_GUTTER_XY.x = Math.min(hotspot_last_GUTTER_XY.x , vp.left   + vp.margin);
            else             hotspot_last_GUTTER_XY.x = Math.max(hotspot_last_GUTTER_XY.x , vp.right  - vp.margin);
        }
    }


if(log_this) log_gutter(caller+"("+x+" "+y+")", lf3);
};


let get_GUTTER_XY = function()
{

let   caller = "get_GUTTER_XY";
let log_this = DOM_GUTTER_LOG || LOG_MAP.EV2_MOVE;


if( log_this) log(caller+"%c return ["+hotspot_last_GUTTER_XY.x+" "+hotspot_last_GUTTER_XY.y+"]", lf7);
    return hotspot_last_GUTTER_XY;
};




let set_CSS_URDL = function(hotring, urdl)
{
    let hiding_tools = !!urdl;
    if( hiding_tools )
    {
        t_util.set_el_class_on_off(hotring, "u", (urdl && urdl.u));
        t_util.set_el_class_on_off(hotring, "r", (urdl && urdl.r));
        t_util.set_el_class_on_off(hotring, "d", (urdl && urdl.d));
        t_util.set_el_class_on_off(hotring, "l", (urdl && urdl.l));

        if(!t_util.has_el_class(hotring, t_data.CSS_GUTTER) )
        {

            t_util.add_el_class(hotring, t_data.CSS_GUTTER);
        }
    }
    else
    {
        t_util.del_el_class(hotring, "u"       );
        t_util.del_el_class(hotring, "r"       );
        t_util.del_el_class(hotring, "d"       );
        t_util.del_el_class(hotring, "l"       );

        if( t_util.has_el_class(hotring, t_data.CSS_GUTTER) ) {

            t_util.del_el_class(hotring, t_data.CSS_GUTTER);
        }
    }
};





let last_gutter_urdl;
let last_reason;


let get_XY_URDL = function(x, y, reason)
{

let   caller = "get_XY_URDL";
let log_this = DOM_GUTTER_LOG || LOG_MAP.EV2_MOVE;



    let  u = (y <= vp.top   );
    let  r = (x >= vp.right );
    let  d = (y >= vp.bottom);
    let  l = (x <= vp.left  );

    let urdl
        = (u || r || d || l) ? {u,r,d,l}
        :                      null
    ;


if(log_this) {
    if(             urdl
                    && (   !last_gutter_urdl
                           || (last_gutter_urdl.u  != urdl.u)
                           || (last_gutter_urdl.r  != urdl.r)
                           || (last_gutter_urdl.d  != urdl.d)
                           || (last_gutter_urdl.l  != urdl.l)
                       )
      )
    {
        t_log.log_label_URDL(caller+"("+x+" "+y+")", urdl);

        last_gutter_urdl = urdl;
    }

    if     (reason == undefined  )   log_caller();
    else if(reason != last_reason) { log(caller+"("+x+" "+y+") %c"+reason, lbH); last_reason = reason; }
}

    return urdl;
};


let is_hotspot_IN = function(hotspot, _caller)
{

let   caller = "is_hotspot_IN";
let log_this = DOM_GUTTER_LOG || LOG_MAP.EV2_MOVE;


    if(!hotspot) return {};
    let urdl  = get_XY_URDL(hotspot.offsetLeft, hotspot.offsetTop, _caller);

if(log_this) {
    let answer = urdl
        ?        "IN-GUTTER "+log_json_one_liner(urdl)
        :        "IN-WINDOW";
    log("%c"+caller+"%c"+_caller+"%c"+hotspot.offsetLeft+"%c"+hotspot.offsetTop+"%c return "+answer
        ,lbL+lf8    ,lbR+lf8     ,lbL+lf4                ,lbR+lf4              ,lbH+lf9            );
}

    return urdl;
};


let t_gutter_is_hotspot_NEAR_BORDER = function(x, y)
{
    let answer = get_XY_URDL(x + vp.margin/2, y + vp.margin/2);


    return answer;
};



let log_gutter = function(_caller, lfx=lf7)
{
    let gutter_L = (vp.right) && (hotspot_last_GUTTER_XY.x <=              vp.margin );
    let gutter_U = (vp.right) && (hotspot_last_GUTTER_XY.y <=              vp.margin );
    let gutter_R = (vp.right) && (hotspot_last_GUTTER_XY.x >= (vp.right  - vp.margin));
    let gutter_D = (vp.right) && (hotspot_last_GUTTER_XY.y >= (vp.bottom - vp.margin));

    let gutter_URDL
        = (gutter_U ? "U" : "_")
        + (gutter_R ? "R" : "_")
        + (gutter_D ? "D" : "_")
        + (gutter_L ? "L" : "_")
    ;

    log_key_val_group(_caller
                      , {                vp_top    : vp.top
                          ,              vp_left   : vp.left
                          ,              vp_bottom : vp.bottom
                          ,              vp_right  : vp.right
                          ,              vp_margin : vp.margin
                          , hotspot_last_GUTTER_XY : hotspot_last_GUTTER_XY.x+" "+hotspot_last_GUTTER_XY.y+" "+gutter_URDL
                          , hotspot_last_WINDOW_XY : hotspot_last_WINDOW_XY.x+" "+hotspot_last_WINDOW_XY.y
                          ,                callers : t_data.LF+t_log.get_callers()
                      }
                      , lfx, false);
};





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_gutter"
    , logging : (state) => DOM_GUTTER_LOG = t_store_set_state("DOM_GUTTER_LOG",state)
    , tagging : (state) => DOM_GUTTER_TAG = t_store_set_state("DOM_GUTTER_TAG",state)
    , t_gutter_IMPORT


    , DOM_GUTTER_JS_ID
    , DOM_GUTTER_JS_TAG


    , layout_has_CHANGED


    , get_WINDOW_XY
    , set_WINDOW_XY


    , get_GUTTER_XY
    , set_GUTTER_XY


    , is_hotspot_IN


    , get_XY_URDL
    , set_CSS_URDL


    , t_gutter_is_hotspot_NEAR_BORDER

};



})();

/*INLINE}}}*/
//@ sourceURL=dom_gutter.js
`

 .replace(/%u/g,"\\u")
;
/*}}}*/

/**   26 IPC      JS dom_ipc_js_data {{{*/
/*
../script/dom_ipc.js
*/
let dom_ipc_js_data ="data:text/javascript;charset='utf-8',"+ `
/*INLINE{{{*/
















const DOM_IPC_JS_ID         = "dom_ipc_js";
const DOM_IPC_JS_TAG        = DOM_IPC_JS_ID     +" (211122:16h:45)";

let dom_ipc     = (function() {
"use strict";
let   DOM_IPC_LOG           = false;
let   DOM_IPC_TAG           = false;







let t_log      = {}        ;























let t_ipc_IMPORT  = function(log_this)
{



    t_log     = dom_log    ;
























    ipc_INTERN();

    DOM_IPC_LOG = DOM_IPC_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_IPC_LOG"));
    DOM_IPC_TAG = DOM_IPC_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_IPC_TAG"));


if(log_this) log("%c 21 ipc", lbH+lf1);
};







let LOG_MAP;
let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;
let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;



let   ipc_INTERN = function()
{

    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;

};





let ipc_add_message_listener = function(script_id)
{
    t_ipc_listener_id = script_id;
    if(DOM_IPC_LOG) console.log("%c "+t_ipc_listener_id+": ADDING IPC MESSAGE LISTENER ", IPC_MSG_COLOR);

    window.addEventListener   ("message", ipc_message_CB, false);
};


let t_ipc_del_message_listener = function(script_id)
{
    if(DOM_IPC_LOG) console.log("%c "+t_ipc_listener_id+": DELETING IPC MESSAGE LISTENER", IPC_MSG_COLOR);

    window.removeEventListener("message", ipc_message_CB, false);
};


let ipc_message_CB = function(event)
{

    if(!window.location.href.startsWith( event.origin ))
    {

        return;
    }
    if(DOM_IPC_LOG) console.log("%c"+t_ipc_listener_id+".ipc_message_CB", IPC_MSG_COLOR);
    if(DOM_IPC_LOG) console.dir(event);


    let message = event.data;
    if(DOM_IPC_LOG) console.log("%c"+t_ipc_listener_id+".ipc_message_CB: %c "+message+" ", IPC_MSG_COLOR, lbF);
    let ipc = t_ipc_PARSE( message );
    if(!ipc ) return;

    if(typeof         ipc.DOM_IPC_LOG != "undefined") {
        DOM_IPC_LOG = ipc.DOM_IPC_LOG;
        console.log("%c ipc_message_CB: %c DOM_IPC_LOG="+DOM_IPC_LOG+" ", IPC_MSG_COLOR, lbF+(DOM_IPC_LOG ? lb2 : lb8));

        return;
    }


    t_handle_ipc_message( ipc );


};





let ipc_MutationObserver;

let t_ipc_add_MutationObserver = function(script_id)
{

    t_ipc_listener_id = script_id;
    if(DOM_IPC_LOG) console.log("%c "+t_ipc_listener_id+": ADDING IPC MutationObserver", IPC_MSG_COLOR);



    ipc_MutationObserver = new MutationObserver( ipc_MutationObserver_CB );

    let config = { attributes            :  true
        ,          characterData         :  true
        ,          childList             : false
        ,          subtree               : false
        ,          attributeOldValue     :  true
        ,          characterDataOldValue :  true
        ,          attributeFilter       : [IPC_EXTENSION_ID]
    };

    ipc_MutationObserver.observe(document.body, config);

};


let t_ipc_del_MutationObserver = function(script_id)
{

    if(ipc_MutationObserver)
    {
        if(DOM_IPC_LOG) console.log("%c "+t_ipc_listener_id+": DISCONNECTING MutationObserver", IPC_MSG_COLOR);
        ipc_MutationObserver.disconnect();
        ipc_MutationObserver = null;
    }
    else {
        if(DOM_IPC_LOG) console.log("%c "+t_ipc_listener_id+": MutationObserver NOT CONNECTED", IPC_MSG_COLOR);
    }

};


let ipc_MutationObserver_CB = function(mutationRecords, observer)
{

    if( DOM_IPC_LOG ) {
        let log_mutationRecord = function( m_r )
        {
            if(typeof log_key_val_group != "undefined") {
                log_key_val_group(t_ipc_listener_id+".ipc_MutationObserver_CB"
                                    , {        attributeName : m_r.attributeName
                                        ,               type : m_r.type
                                        , attributeNamespace : m_r.attributeNamespace
                                        ,           oldValue : m_r.oldValue
                                        ,             target : m_r.target.tagName
                                    }
                                    , lfX[++next]
                                    , false
                                 );
            }
            else {
                console.log(t_ipc_listener_id+".ipc_MutationObserver_CB:");
                console.log("........attributeName=["+ m_r.attributeName      +"]");
                console.log(".................type=["+ m_r.type               +"]");
                console.log(".............oldValue=["+ m_r.oldValue           +"]");
                console.log("...attributeNamespace=["+ m_r.attributeNamespace +"]");
                console.log("...............target=["+ m_r.target.tagName     +"]");
            }
        };

        let next = 0;
        mutationRecords.forEach( log_mutationRecord );
    }


    let message = document.body.attributes[IPC_EXTENSION_ID]
        ?         document.body.attributes[IPC_EXTENSION_ID].textContent : "";
    let ipc = t_ipc_PARSE( message );

    if( ipc ) t_handle_ipc_message( ipc );

};





let t_ipc_listener_id;


let t_ipc_is_IPC_SCRIPT_loaded = function()
{

    if(typeof S != "undefined")
    {
        if(typeof shadow_root != "undefined") {
            if(DOM_IPC_LOG) console.log("%c "+IPC_SCRIPT_ID+" %c already loaded .. f(shadow_root)"                 , IPC_LOG_COLOR, lbA);
            return true;
        }
        else {
            return false;
        }
    }


    if(typeof DOM_LOAD_ID     != "undefined")
    {
        let id = "dom_host_css_tag";
        let el = document.getElementById(id);
        if( el ) {
            if(DOM_IPC_LOG) console.log("%c "+IPC_SCRIPT_ID+" %c already loaded .. f("+el.id+")"                   , IPC_LOG_COLOR, lbA);
            return  true;
        }
        else {
            return false;
        }
    }

    return false;
};






let t_ipc_PARSE = function(message)
{
    if(!message) return null;

    let ipc = null;
    try {
        ipc = JSON.parse(message);

if(DOM_IPC_LOG && (typeof log_key_val_group != "undefined")) log_key_val_group("t_ipc_PARSE("+message+")", ipc, lf7, false);
    }
    catch(ex) {
if(DOM_IPC_LOG) {
    console.log("%c "+t_ipc_listener_id+": t_ipc_PARSE:"                          , lbB+lb2);
    console.log("%c *** "+ex,                                                           lb2);
    console.log("%c "+strip_CR_LF(message)                                        , lbF+lb0);
    console.log("%c 0123456789_123456789_123456789_123456789_123456789_123456789_", lbF+lb8);
    console.log("%c 0_________1_________2_________3_________4_________5_________6", lbF+lb8);
}
    }

    if(ipc && (typeof ipc.cancelreq != "undefined"))
    {
        let removing = (ipc.cancelreq == "ON") ? "(REMOVING) " : "";
        handle_scripts(removing);
        return null;
    }
    else {
        return ipc;
    }
};


let t_ipc_SEND = function(ipc)
{

    let t_get_IPC_sequence_number = parseInt(new Date().getTime() / 1000) % 86400;

    ipc.sequence_number = t_get_IPC_sequence_number;

if(DOM_IPC_LOG && (typeof log_key_val_group != "undefined")) log_key_val_group("t_ipc_SEND", ipc, lf7, false);

    let ipc_json = JSON.stringify( ipc );
    document.body.setAttribute(IPC_SCRIPT_ID, ipc_json);
};


const t_regexp_CR = new RegExp("\\r", "g");
const t_regexp_LF = new RegExp("\\n", "g");
let strip_CR_LF = function(text)
{
    return text
        .   replace(t_regexp_CR,  "")
        .   replace(t_regexp_LF, " ")
        .   trim()
    ;
};



let handle_scripts = function(removing)
{

    try {
        if(DOM_IPC_LOG) console.clear();
        if(DOM_IPC_LOG) console.log("%c CLEARED BY handle_scripts ", IPC_MSG_COLOR);
    } catch(ex) {}

    let elements = document .getElementsByTagName("SCRIPT");
    if(DOM_IPC_LOG) console.log("%c "+ elements.length +" SCRIPT ELEMENTS: "+removing, lbF);

    for(let i=0; i < elements.length; ++i)
    {
        let s_el = elements[i];
        if(DOM_IPC_LOG) try { console.log((i+1)+".........src: "+ s_el.src); } catch(ex) {}
        if(removing) s_el.remove();
    }
};


let ipc_contains_a_startup_message = function(ipc)
{
    let result
        =  (typeof ipc.start != "undefined")
        && (       ipc.start == "ON"       )
    ;

    if(DOM_IPC_LOG) console.log("ipc_contains_a_startup_message ...return %c"+ result, IPC_MSG_COLOR);
    return result;
};


const WAITING_FOR_STARTUP_MESSAGE = "TOOLS WAITING";
let t_wait_for_startup_message_from_extension = function(_caller)
{
    if(DOM_IPC_LOG) console.log("%c "+IPC_SCRIPT_ID+" %c "+WAITING_FOR_STARTUP_MESSAGE, IPC_LOG_COLOR, lbF);

    let ipc = { t_load : WAITING_FOR_STARTUP_MESSAGE
        ,   caller : _caller
    };
    t_ipc_SEND( ipc );

    if(!t_ipc_listener_id) {
        t_ipc_add_MutationObserver(IPC_SCRIPT_ID);

    }
};





let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};

return { name : "dom_ipc"
    , logging : function(state) { return DOM_IPC_LOG = t_store_set_state("DOM_IPC_LOG",state); }
    , tagging : function(state) { return DOM_IPC_TAG = t_store_set_state("DOM_IPC_TAG",state); }
    , t_ipc_IMPORT
    , t_ipc_PARSE
    , t_ipc_add_MutationObserver
    , t_ipc_del_MutationObserver
    , t_ipc_del_message_listener
    , t_ipc_is_IPC_SCRIPT_loaded
    , t_ipc_listener_id : () => t_ipc_listener_id
    , t_ipc_SEND
    , t_wait_for_startup_message_from_extension


    , ipc_contains_a_startup_message
    , ipc_add_message_listener

};


})();
/*INLINE}}}*/
//@ sourceURL=dom_ipc.js
`
 .replace(/\\/g,"\\\\")

 .replace(/%u/g,"\\u")
;
/*}}}*/
/** 27 TOOLS    JS dom_tools_js_data .. ESCAPE=[document.querySelector("#"+id)] {{{*/
/*
../script/dom_tools.js
*/
let dom_tools_js_data ="data:text/javascript;charset='utf-8',"+ escape(`
/*INLINE{{{*/
























































const DOM_TOOLS_JS_ID       = "dom_tools_js" ;
const DOM_TOOLS_JS_TAG      = DOM_TOOLS_JS_ID   +" (221201:14h:51)";

let dom_tools   = (function() {
"use strict";




let t_data     = {}        ;

let t_log      = {}        ;
let t_popup    = {}        ;
let t_util     = {}        ;
let t_i18n     = {}        ;
let t_prop     = {}        ;

let t_store    = {}        ;
let t_fly      = {}        ;
let t_wording  = {}        ;
let t_select   = {}        ;
let t_slot     = {}        ;

let t_hide     = {}        ;
let t_view     = {}        ;
let t_sticky   = {}        ;
let t_seek     = {}        ;
let t_share    = {}        ;

let t_details  = {}        ;
let t_wot      = {}        ;
let t_sentence = {}        ;
let t_grid     = {}        ;
let t_gutter   = {}        ;

let t_ipc      = {}        ;



let t_tools_IMPORT  = function(log_this)
{


                                         t_data    = dom_data    ;

if(typeof dom_log     != "undefined")    t_log     = dom_log     ;
if(typeof dom_popup   != "undefined")    t_popup   = dom_popup   ;
if(typeof dom_util    != "undefined")    t_util    = dom_util    ;
if(typeof dom_i18n    != "undefined")    t_i18n    = dom_i18n    ;
if(typeof dom_prop    != "undefined")    t_prop    = dom_prop    ;

if(typeof dom_store   != "undefined")    t_store   = dom_store   ;
if(typeof dom_fly     != "undefined")    t_fly     = dom_fly     ;
if(typeof dom_wording != "undefined")    t_wording = dom_wording ;
if(typeof dom_select  != "undefined")    t_select  = dom_select  ;
if(typeof dom_slot    != "undefined")    t_slot    = dom_slot    ;

if(typeof dom_hide    != "undefined")    t_hide    = dom_hide    ;
if(typeof dom_view    != "undefined")    t_view    = dom_view    ;
if(typeof dom_sticky  != "undefined")    t_sticky  = dom_sticky  ;
if(typeof dom_seek    != "undefined")    t_seek    = dom_seek    ;
if(typeof dom_share   != "undefined")    t_share   = dom_share   ;

if(typeof dom_details != "undefined")    t_details = dom_details ;
if(typeof dom_wot     != "undefined")    t_wot     = dom_wot     ;
if(typeof dom_sentence!= "undefined")    t_sentence= dom_sentence;
if(typeof dom_grid    != "undefined")    t_grid    = dom_grid    ;
if(typeof dom_gutter  != "undefined")    t_gutter  = dom_gutter  ;

if(typeof dom_ipc     != "undefined")    t_ipc     = dom_ipc     ;



    tools_INTERN();

    DOM_TOOLS_LOG = DOM_TOOLS_LOG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_TOOLS_LOG"));
    DOM_TOOLS_TAG = DOM_TOOLS_TAG || ((typeof dom_store != "undefined") && dom_store.t_store_getBool("DOM_TOOLS_TAG"));


if(log_this) log("%c 22 tools", lbH+lf2);
};





let LF = String.fromCharCode(10);
let CSS_CC1, CSS_CC2, CSS_CC3, CSS_CC4, CSS_CC5, CSS_CC6, CSS_CC7, CSS_CC8, CSS_CC9, CSS_CC0;


let LOG_MAP;

let lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX;
let lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb          ;
let lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX;

let log, logBIG, logXXX, log_caller, log_json_one_liner, log_key_val, log_key_val_group;


let add_el_class;
let del_el_class;
let get_event_XY;
let get_id_or_tag;
let get_id_or_tag_and_className;
let get_n_lbl;
let has_el_class;
let set_el_class;
let set_el_class_on_off;
let set_el_class_removing;
let t_get_event_target;


let i18n_get;


let prop;


let   tools_INTERN = function()
{

    LF = t_data.LF;
    [ CSS_CC1, CSS_CC2, CSS_CC3, CSS_CC4, CSS_CC5, CSS_CC6, CSS_CC7, CSS_CC8, CSS_CC9, CSS_CC0 ] = t_data.CCX_CLASSLIST;



    LOG_MAP = t_log.LOG_MAP;

    ({ lb0, lb1, lb2, lb3, lb4, lb5, lb6, lb7, lb8, lb9, lbX } = t_log.LOG_BG_CSS);
    ({ lf0, lf1, lf2, lf3, lf4, lf5, lf6, lf7, lf8, lf9, lfX } = t_log.LOG_FG_CSS);
    ({ lbA, lbB, lbC, lbF, lbH, lbL, lbR, lbS, lbb           } = t_log.LOG_XX_CSS);

    log                 = t_log.log;
    logBIG              = t_log.logBIG;
    logXXX              = t_log.logXXX;
    log_caller          = t_log.log_caller;
    log_json_one_liner  = t_log.log_json_one_liner;
    log_key_val         = t_log.log_key_val;
    log_key_val_group   = t_log.log_key_val_group;


    prop = t_prop;



    add_el_class                = t_util.add_el_class;
    del_el_class                = t_util.del_el_class;
    get_event_XY                = t_util.get_event_XY;
    get_id_or_tag               = t_util.get_id_or_tag;
    get_id_or_tag_and_className = t_util.get_id_or_tag_and_className;
    get_n_lbl                   = t_util.get_n_lbl;
    has_el_class                = t_util.has_el_class;
    set_el_class                = t_util.set_el_class;
    set_el_class_on_off         = t_util.set_el_class_on_off;
    set_el_class_removing       = t_util.set_el_class_removing;
    t_get_event_target          = t_util.t_get_event_target;



    i18n_get            = t_i18n.i18n_get;


    tools_DEPEND();
};




let DIV_MAGNIFY;
let T_ONCLICK_DELAY;



let TOOL_SET;
let TOOL_SET1_WORD;
let TOOL_SET2_SEEK;
let TOOL_SET3_HIDE;
let TOOL_SET4_PLAY;
let TOOL_SET5_MORE;


let LONG_PRESS_ARM_DELAY;
let LONG_PRESS_DELAY;


let   tools_DEPEND = function()
{


    DIV_MAGNIFY     = "<em class='button_magnify' title='magnify'>"+ t_data.SYMBOL_MAGNIFY_LEFT +"</em>";
    T_ONCLICK_DELAY = t_data.CLICK_DURATION;

    WORDS_CLASSLIST
        = [ t_data.WORDS_EXACT
        ,   t_data.WORDS_SEGMENT
        ,   t_data.WORDS_HEAD_TAIL
    ];



    TOOL_SET1_WORD
    = [   { dom_load_id : "dom_find"   , panel_id : "headsup_w"     }


    ];

    TOOL_SET2_SEEK =
    [     { dom_load_id : ""           , panel_id : "seeker_CU"     }
        , { dom_load_id : ""           , panel_id : "seeker_CD"     }
        , { dom_load_id : ""           , panel_id : "seekspot_A"    }
        , { dom_load_id : ""           , panel_id : "seekspot_U"    }
        , { dom_load_id : ""           , panel_id : "seekspot_D"    }
        , { dom_load_id : ""           , panel_id : "seekzone"      }
    ];


    TOOL_SET3_HIDE
    = [   { dom_load_id : "dom_hide"   , panel_id : "headsup"       }
        , { dom_load_id : "dom_hide"   , panel_id : "headsup_ds"    }
        , { dom_load_id : "dom_hide"   , panel_id : "dev_log_map"   }
        , { dom_load_id : "dom_hide"   , panel_id : "dom_load_tags" }
        , { dom_load_id : "dom_hide"   , panel_id : "test_panel"    }

    ];

    TOOL_SET4_PLAY
    = [   { dom_load_id : "playground" , panel_id : "headsup"       }
        , { dom_load_id : "playground" , panel_id : "headsup_fs"    }
        , { dom_load_id : "playground" , panel_id : "headsup_bw"    }
        , { dom_load_id : "playground" , panel_id : "headsup_bz"    }
        , { dom_load_id : "playground" , panel_id : "headsup_ds"    }
        , { dom_load_id : "playground" , panel_id : "headsup_w"     }

        , { dom_load_id : "playground" , panel_id : "pat_bag"       }
        , { dom_load_id : "playground" , panel_id : "sel_bag"       }
        , { dom_load_id : "playground" , panel_id : "dom_traversal" }

        , { dom_load_id : "playground" , panel_id : "test_panel"    }
        , { dom_load_id : "playground" , panel_id : "dev_log_map"   }
        , { dom_load_id : "playground" , panel_id : "dom_load_tags" }

        , { dom_load_id : "playground" , panel_id : "transcript1"   }
        , { dom_load_id : "playground" , panel_id : "transcript2"   }

    ];

    TOOL_SET5_MORE
    = [   { dom_load_id : ""           , panel_id : "fly_div"       }
        , { dom_load_id : ""           , panel_id :  t_data.TOOLS_TRAP     }
    ];


    TOOL_SET =   TOOL_SET1_WORD
        .concat( TOOL_SET2_SEEK )
        .concat( TOOL_SET3_HIDE )
        .concat( TOOL_SET4_PLAY )

    ;

    t_set_tools_tiers();



    LONG_PRESS_ARM_DELAY = t_data.CLICK_DURATION;
    LONG_PRESS_DELAY     = t_data.CLICK_DURATION * 2;


};


let   load_IMPORT = function()
{
let log_this = localStorage.getItem("DOM_TOOLS_TAG");

let i =5;

    i+=1; if(typeof dom_log      != "undefined")    dom_log     .t_log_IMPORT     (log_this,i);
    i+=1;
    i+=1; if(typeof dom_util     != "undefined")    dom_util    .t_util_IMPORT    (log_this,i);
    i+=1; if(typeof dom_i18n     != "undefined")    dom_i18n    .t_i18n_IMPORT    (log_this,i);
    i+=1; if(typeof dom_prop     != "undefined")    dom_prop    .t_prop_IMPORT    (log_this,i);

    i+=1; if(typeof dom_store    != "undefined")    dom_store   .t_store_IMPORT   (log_this,i);
    i+=1; if(typeof dom_fly      != "undefined")    dom_fly     .t_fly_IMPORT     (log_this,i);
    i+=1; if(typeof dom_wording  != "undefined")    dom_wording .t_wording_IMPORT (log_this,i);
    i+=1; if(typeof dom_select   != "undefined")    dom_select  .t_select_IMPORT  (log_this,i);
    i+=1; if(typeof dom_slot     != "undefined")    dom_slot    .t_slot_IMPORT    (log_this,i);

    i+=1; if(typeof dom_hide     != "undefined")    dom_hide    .t_hide_IMPORT    (log_this,i);
    i+=1; if(typeof dom_view     != "undefined")    dom_view    .t_view_IMPORT    (log_this,i);
    i+=1; if(typeof dom_sticky   != "undefined")    dom_sticky  .t_sticky_IMPORT  (log_this,i);
    i+=1; if(typeof dom_seek     != "undefined")    dom_seek    .t_seek_IMPORT    (log_this,i);
    i+=1; if(typeof dom_share    != "undefined")    dom_share   .t_share_IMPORT   (log_this,i);

    i+=1; if(typeof dom_details  != "undefined")    dom_details .t_details_IMPORT (log_this,i);
    i+=1; if(typeof dom_wot      != "undefined")    dom_wot     .t_wot_IMPORT     (log_this,i);
    i+=1; if(typeof dom_sentence != "undefined")    dom_sentence.t_sentence_IMPORT(log_this,i);
    i+=1; if(typeof dom_grid     != "undefined")    dom_grid    .t_grid_IMPORT    (log_this,i);
    i+=1; if(typeof dom_gutter   != "undefined")    dom_gutter  .t_gutter_IMPORT  (log_this,i);

    i+=1; if(typeof dom_ipc      != "undefined")    dom_ipc     .t_ipc_IMPORT     (log_this,i);
    i+=1; t_tools_IMPORT   (log_this,i);


    if( DOM_TOOLS_GLOBALS )
    {
        logBIG("DOM_TOOLS_GLOBALS .. EXPORTING [window.t_tools = dom_tools] ", lf0);

        window.t_data    = t_data;
        window.t_log     = t_log;
        window.t_util    = t_util;
        window.t_prop    = t_prop; window.prop = t_prop;
        window.t_store   = t_store;
        window.t_fly     = t_fly;

        window.t_wording = t_wording;
        window.t_select  = t_select;
        window.t_sentence= t_sentence;
        window.t_slot    = t_slot;

        window.t_hide    = t_hide;
        window.t_view    = t_view;
        window.t_sticky  = t_sticky;
        window.t_seek    = t_seek;
        window.t_share   = t_share;

        window.t_grid    = t_grid;
        window.t_gutter  = t_gutter;

        window.t_ipc     = t_ipc;
        window.t_tools   = dom_tools;
    }



};



let   DOM_TOOLS_LOG         = false;
let   DOM_TOOLS_TAG         = false;
let   DOM_TOOLS_GLOBALS     = false;


const CSS_FG0                   = "fg0";
const CSS_FG1                   = "fg1";
const CSS_FG2                   = "fg2";
const CSS_FG3                   = "fg3";
const CSS_FG4                   = "fg4";
const CSS_FG5                   = "fg5";
const CSS_FG6                   = "fg6";
const CSS_FG7                   = "fg7";
const CSS_FG8                   = "fg8";
const CSS_FG9                   = "fg9";

const FGX_CLASSLIST = [
      CSS_FG0
    , CSS_FG1
    , CSS_FG2
    , CSS_FG3
    , CSS_FG4
    , CSS_FG5
    , CSS_FG6
    , CSS_FG7
    , CSS_FG8
    , CSS_FG9
];

let   WORDS_CLASSLIST;



const CSS_MOVING                = "moving";
const CSS_STACKING              = "stacking";
const CSS_PAUSE_ANIMATION       = "pause_animation";

const CSS_ON_COOLDOWN           = "on_cooldown";

const CSS_REMOVING              = "removing";



const CSS_COLLAPSED             = "collapsed";



const CSS_TRANSCRIPT            = "transcript";
const CSS_FLOATLOG              = "floatlog";




const CSS_STANDBY               = "standby";
const CSS_DISABLED              = "disabled";
const CSS_EMPTY                 = "empty";
const CSS_FADING                = "fading";
const CSS_FOCUSSED              = "focussed";
const CSS_GRAYED_OUT            = "grayed_out";
const CSS_FULLSCREEN            = "fullscreen";
const CSS_FULLSCREEN_LAST       = "fullscreen_last";
const CSS_FULLSCREEN_LEFT       = "fullscreen_left";
const CSS_FULLSCREEN_RIGHT      = "fullscreen_right";
const CSS_FULLSCREEN_PREV       = "fullscreen_prev";
const CSS_FULLSCREEN_NEXT       = "fullscreen_next";

const CSS_HIDING_TOOLS          = "hiding_tools";

const CSS_MAGNIFIED             = "magnified";
const CSS_MAGNIFIED_SCALE       = 2;

const MOUSE_OFFSET_FACTOR       = 0.5;
const TOUCH_OFFSET_FACTOR       = 1.5;



const CSS_TOOLBAG_BUTTON        = "toolbag_button";
const CSS_EMBEDDED_DOC_TOOL     = "embedded_doc_tool";

const CSS_GRID_BAG              = "grid_bag";
const CSS_HAS_MOVING_CHILD      = "has_moving_child";
const CSS_MOV_SRC               = "mov_src";

const CSS_TXT_LOG               = "txt_log";


const CSS_TALL_PANEL            = "tall_panel";
const CSS_WIDE_PANEL            = "wide_panel";
const CSS_TOO_LARGE             = "too_large";

const CSS_CLEARPIN              = "clearpin";
const CSS_CLOSEPIN              = "closepin";
const CSS_PUSH_PIN              = "push_pin";
const CSS_SCALEPIN              = "scalepin";

const CSS_PIN_ON_PANEL          = "pin_on_panel";
const CSS_TOOLTIP               = "tooltip";



const CSS_USER_SET              = "user_set";
const CSS_SORT_OFF              = "sort_off";
const CSS_ON                    = "on";



const CSS_OPEN_BAG              = "open_bag";
const CSS_CLOSING               = "closing";

const CSS_BACK                  = "back";



const CSS_CONTAINER_SELECTED    = "container_selected";
const CSS_BUTTONS_POD           = "buttons_pod";
const CSS_BUTTON_COPY           = "button_copy";
const CSS_BUTTON_MAGNIFY        = "button_magnify";
const CSS_BUTTON_MONO           = "button_mono";
const CSS_BUTTON_MONOSPACE      = "button_monospace";
const CSS_BUTTON_NEXT           = "button_next";
const CSS_BUTTON_PREV           = "button_prev";







let is_a_DOM_LOAD_panel = function(panel_id)
{

let   caller = "is_a_DOM_LOAD_panel";
let log_this = LOG_MAP.T1_DOM_LOAD;


    let dom_load_id                 = (typeof DOM_LOAD_ID != "undefined") ? DOM_LOAD_ID : "default";
    let panel_to_load               =  true;
    let dom_load_is_defined         = false;

if(log_this && !TOOL_SET.parsed_once) logBIG(caller, lf4);
    for(let index=0; index < TOOL_SET.length; ++index)
    {
        let entry = TOOL_SET[index];
if(log_this && !TOOL_SET.parsed_once) log("index %c"+index+" %c entry.panel_id %c"+entry.panel_id, lbH+lfX[(index % 10)], lbA, lbH+lf4);


        if(!dom_load_is_defined && (entry.dom_load_id == dom_load_id))
        {
            dom_load_is_defined     =  true;
            panel_to_load           = false;
        }


        if(entry.dom_load_id == dom_load_id)
        {

            if(entry.panel_id  == panel_id)
            {
                panel_to_load       = true;

                if(!log_this || TOOL_SET.parsed_once) break;
            }
        }

    }
TOOL_SET.parsed_once=true;

if(log_this) {
    let lfx = (panel_to_load ? lf4 : lf8);
    log("%c "+caller+"%c"+panel_to_load    +"%c "+dom_load_id+"%c "+(dom_load_is_defined ? "defined" : "")+"%c"+panel_id
        ,lbH+lfx     ,lbL+lfx               ,lbC+lf8          ,lbC+lf8                                     ,lbR+lfx     );
}

    return panel_to_load;
};




const FUNCTIONS_TO_IGNORE
    = [    { dom_load_id : "dom_hide" , id : "t_seekzone1_XYWH"            }
         , { dom_load_id : "dom_hide" , id : "t_seek.t_seekzone1_show_onDown_XY"}
         , { dom_load_id : "dom_hide" , id : "t_seek.t_seekzone2_show_misclick" }
         , { dom_load_id : "dom_hide" , id : "t_seek.t_seekzone3_show_dblclick" }
         , { dom_load_id : "dom_hide" , id : "onDown_7_SENTENCE"                }
         , { dom_load_id : "dom_hide" , id : "onDown_8_DOC_SELECT_OR_SEEK"      }
         , { dom_load_id : "dom_hide" , id : "onUp_7_DOC_CB_CLICK_WORD"         }
         , { dom_load_id : "dom_hide" , id : "onUp_2_SLOT_CONTAINER_CB"         }
         , { dom_load_id : "dom_hide" , id : "t_store_patterns_csv"             }

         , { dom_load_id : "dom_find" , id : "t_seekzone1_XYWH"                 }
         , { dom_load_id : "dom_find" , id : "t_seek.t_seekzone1_show_onDown_XY"}
         , { dom_load_id : "dom_find" , id : "t_seek.t_seekzone2_show_misclick" }
         , { dom_load_id : "dom_find" , id : "t_seek.t_seekzone3_show_dblclick" }
         , { dom_load_id : "dom_find" , id : "t_sticky.t_sticky_CHOOSE"         }
         , { dom_load_id : "dom_find" , id : "t_sticky.t_sticky_EDIT"           }
    ];

let cached_entry_selected_item_id = {};

let is_a_DOM_LOAD_featured_function = function(item_id)
{

let   caller = "is_a_DOM_LOAD_featured_function";
let log_this = LOG_MAP.T1_DOM_LOAD;



    let feature_to_ignore  = cached_entry_selected_item_id[item_id];
    if( feature_to_ignore != undefined) {

if( log_this) {
    let lfx = (feature_to_ignore ? lf2 : lf5);
    log("%c "+caller+"%c"+(feature_to_ignore ? "FALSE":"TRUE ")+"%c CACHED ANSWER %c"+item_id
        ,lbH+lf8     ,lbL+lfx                                   ,lbC+lf8         ,lbR+lfx    );
}

        return !feature_to_ignore;
    }

    let dom_load_id                 = (typeof DOM_LOAD_ID != "undefined") ? DOM_LOAD_ID : "default";
    feature_to_ignore               = false;
    let dom_load_is_defined         = false;

if(log_this && !FUNCTIONS_TO_IGNORE.parsed_once) logBIG(caller, lf5);

    for(let index=0; index < FUNCTIONS_TO_IGNORE.length; ++index) {
        let          entry = FUNCTIONS_TO_IGNORE[          index];
if(log_this && !FUNCTIONS_TO_IGNORE.parsed_once) log("index %c"+index+" %c entry.id %c"+entry.id, lbH+lfX[(index % 10)], lbA, lbH+lf5);


        if(!dom_load_is_defined && (entry.dom_load_id == dom_load_id))
        {
            dom_load_is_defined     =  true;
            feature_to_ignore       = false;
        }



        if(entry.dom_load_id == dom_load_id)
        {

            if(entry.id == item_id)
            {
                feature_to_ignore   = true;

                if(!log_this || FUNCTIONS_TO_IGNORE.parsed_once) break;
            }
        }

    }
FUNCTIONS_TO_IGNORE.parsed_once=true;

if(log_this) {
    let lfx = (feature_to_ignore ? lf2 : lf5);
    log("%c "+caller+"%c"+feature_to_ignore+"%c "+dom_load_id+"%c "+(dom_load_is_defined ? "defined" : "")+"%c"+item_id
        ,lbH+lf3     ,lbL+lfx               ,lbC+lf8          ,lbC+lf8                                     ,lbR+lfx    );
}

    cached_entry_selected_item_id[item_id] = feature_to_ignore;
    return !feature_to_ignore;
};



let t_set_tools_tiers = function()
{

    for(let index=0; index < TOOL_SET.length; ++index)
    {
        let    entry = TOOL_SET[index];

        if(    (entry.panel_id == "headsup"  )
           ||  (entry.panel_id == "headsup_w")
          )
            entry.tier = 1;

        else if(entry.panel_id == "pat_bag"  )
            entry.tier = 2;
    }
};


let t_is_a_tools_id_tier = function(id, tier)
{
    let    el  = t_get_tool        (id      );
    return el && is_a_tools_el_tier(el, tier);
};


let is_a_tools_el_tier =   function(el,tier)
{
    let result = false;

    for(let index=0; index < TOOL_SET.length; ++index)
    {
        let entry = TOOL_SET[index];
        if( entry.panel_id   == el.id) {
            result  = (entry.tier <= tier);
            break;
        }
    }


    return result;
};


let t_activate_tools_tier1 = function(_caller)
{
let log_this = LOG_MAP.T2_GRID;

if(log_this) log("t_activate_tools_tier1 .. CALLED BY "+ _caller);

    let some_panel_selected = false;
    for(let index=0; index < TOOL_SET.length; ++index)
    {
        let entry       = TOOL_SET[index];
        if( entry.tier == 1)
        {
            let panel = t_get_tool( entry.panel_id );
            if(!t_tools_panel_is_selected( panel ))
            {
                t_tools_panel_select(panel, true);
                some_panel_selected = true;
            }
        }
    }
    if(some_panel_selected)
    {
        t_tools_show(true);

        t_TOOL_SET_eval_wide_or_tall_panel();
    }
    return some_panel_selected;
};


let t_sync_tools_tier2 = function(_caller)
{

    let caller = "t_sync_tools_tier2";
let log_this = LOG_MAP.T2_GRID;

    let tools_tier2 = prop.get( t_data.TOOLS_TIER2 );

if(log_this) log("t_sync_tools_tier2: tools_tier2=["+tools_tier2+"] .. CALLED BY "+ _caller);


    for(let index=0; index < TOOL_SET.length; ++index)
    {
        let          entry = TOOL_SET[index];
        let             el = t_get_tool(entry.panel_id);
        let tools_selected = t_tools_panel_is_selected(el);
        let  tier_selected = tools_tier2 && (entry.tier <= 2);
        let     is_showing = tools_selected || tier_selected;

        set_el_class_on_off(el, t_data.CSS_HIDDEN, !is_showing);

    }

    t_sync_layout(caller);

    t_TOOL_SET_eval_wide_or_tall_panel();
};








const TOOLS3_NEED_RELAXED_CSP    = "TOOLS NEED RELAXED CSP"   ;
const TOOLS4_DEPLOYED            = "TOOLS DEPLOYED"           ;
const TOOLS5_UNLOADED            = "TOOLS UNLOADED"           ;






let t_TOOL_SET_select = function()
{

let   caller = "t_TOOL_SET_select";
let log_this = LOG_MAP.T2_GRID;

if( log_this) log(caller);


if( log_this) log("...pat_bag=["+get_n_lbl(pat_bag)+"]");
if( log_this) log("...TOOL_panels.includes(pat_bag)=["+TOOL_panels.includes(pat_bag)+"]");
    if(pat_bag && !off_bag) t_build_bag_tools();



    t_fly.t_fly_log_set_state( LOG_MAP.EV8_FLOATLOG );

    set_el_class_on_off(fly_log, t_data.CSS_CHECKED, LOG_MAP.EV8_FLOATLOG  );


    let some_panel_selected = false;

    for(const entry of TOOL_SET)
    {
        let panel = t_get_tool( entry.panel_id );
        if( t_tools_panel_is_selected(panel) ) {
            some_panel_selected = true;
            break;
        }
    }



    if(!some_panel_selected || has_el_class(pivot_PANEL, t_data.CSS_PINNED))
    {
        t_set_pivot_PANEL(null, "PINNED pivot_PANEL");
    }

    if(!pivot_PANEL && some_panel_selected)
    {
        let dom_load_id
            = (typeof DOM_LOAD_ID != "undefined")
            ?  DOM_LOAD_ID
            : "default";

        let panel;
        for(const entry of TOOL_SET)
        {
            if(     ( dom_load_id ==             entry.dom_load_id        )
                &&  (       panel =  t_get_tool( entry.panel_id          ))
                && !( has_el_class  (     panel, t_data.CSS_PINNED))
                &&  ( t_tools_panel_is_selected( panel                   ))
              ) {
                t_set_pivot_PANEL(panel, "FIRST SELECTED "+DOM_LOAD_ID+" TOOL_SET PANEL");
                break;
            }
        }
    }

    t_get_selected_count( caller );

    t_cache_armed_by(caller);
};


let t_TOOL_SET_set_class_state = function(className, state)
{

let   caller = "t_TOOL_SET_set_class_state("+className+", "+state+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

    for(const entry of TOOL_SET) {
        let   panel = t_get_tool( entry.panel_id );
        if(   panel ) set_el_class_on_off(panel, className, state);
    }
};



let            EVAL_WIDE_OR_TALL_DELAY    =  1000;

let t_TOOL_SET_eval_wide_or_tall_timer;

let t_TOOL_SET_eval_wide_or_tall_panel         = function(_caller)
{
    if(       t_TOOL_SET_eval_wide_or_tall_timer ) clearTimeout( t_TOOL_SET_eval_wide_or_tall_timer );
              t_TOOL_SET_eval_wide_or_tall_timer = null;

    let delay = t_just_loaded("FIRST TOOLS LAYOUT WIDE OR TALL", EVAL_WIDE_OR_TALL_DELAY)
        ? 3 * EVAL_WIDE_OR_TALL_DELAY
        :     EVAL_WIDE_OR_TALL_DELAY;

    t_TOOL_SET_eval_wide_or_tall_timer =   setTimeout( t_TOOL_SET_eval_wide_or_tall_panel_handler, delay);
};

let t_TOOL_SET_eval_wide_or_tall_panel_handler = function()
{



    t_TOOL_SET_eval_wide_or_tall_timer = null;

    for(const entry of TOOL_SET)
    {
        let panel = t_get_tool(  entry.panel_id );

        if( t_tools_panel_is_selected( panel) )
            t_eval_wide_or_tall_panel( panel );
    }
    set_pinned_panels_transform_origin();
};





let load_MS;


let t_load = function()
{
    load_IMPORT();

let caller     = "t_load";

    load_site_and_page_keys();
    t_log.logging_load_LOG_MAP();

let log_this = LOG_MAP.T1_DOM_LOAD;

if(log_this) log(caller, "info");



    if( t_store.t_store_getItem(t_data.DOM_FREEZE) ) t_util.t_REMOVE_EventListeners( document.body );


    dom_i18n.i18n_set_args({ lang: t_store.t_store_getItem(t_data.USER_LANG) , caller });

    load0_get_LOADER_ID();

    load_MS = new Date().getTime();

    let interrupted_on_id  = load1_SHADOW();
    if( interrupted_on_id != "") {
        log("%c*** TOOLS SHADOWING INCOMPLETE *** %c"+ caller +" INTERRUTED on %c id "+interrupted_on_id
            ,lbb+lbH+lf3                         ,lbb+lbL+lf8                 ,lbb+lbR+lf2              );
        return;
    }

    load3_PLAYGROUND_PANELS();

    load2_TOOLS();
    if(!hotspot) {
        log("%c*** TOOLS LOADING INCOMPLETE *** %c"+   caller +" INTERRUTED on !hotspot", lbb+lbH+lf3, lbb+lbH+lf2);
        return;
    }

    load4_HEADSUP();

    load5_STORAGE();

    load6_DOM_TAGS();

    if( prop.get( t_data.REMOVE_ADS ) )
    {
        t_util.t_REMOVE_ADS(t_data.REMOVE_ADS);
    }
    if( prop.get( t_data.SPLIT_WOT  ) )
    {
        t_wot.t_WOT_SPLIT();

    }


    t_details.details_onload();

    load7_GRID();

    load8_LOG_MAP();

    t_load_BEHAVIOR();

    load10_IPC_and_LISTENERS();

    load11_POST();
};


let t_just_loaded = function(action,delay,log_this)
{

let  caller = "t_just_loaded";


    let      this_MS = new Date().getTime();
    let since_t_load = this_MS - load_MS;
    let  just_loaded = (since_t_load < delay);


if(log_this)
    log(caller+": %c"+action+" .. %c   just_loaded "+just_loaded+"%c since_t_load "+since_t_load+"ms %c delay "+delay+"ms"
        ,         lb2            ,lbL+(just_loaded ? lf4 : lf8)  ,lbC+lf8                           ,lbR+lf9              );

    return just_loaded;
};


let t_unload = function()
{

let caller = "t_unload";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log(caller);


if( log_this) log("CLEAR SELECTED WORDS");
    t_select.t_clear_slot_all();

if( log_this) log("REMOVE EVENT LISTENERS");
    t_del_listeners();

if( log_this) log("MOVE TOOLS OFF GRID");
    if(!DOM_GRID_CSS_TAG)
        t_move_TOOLS_OFF_GRID(caller);

if( log_this) log("HIDE TOOLS");
    if(dom_tools_html)
        dom_tools_html.style.visibility = t_data.CSS_HIDDEN;

if( log_this) log("SET t_data.WORDING OFF");
    t_wording.dom_wording_cycle("OFF", false);

if( log_this) log("SEND IPC UNLOAD MESSAGE");
    let ipc = {    t_load : TOOLS5_UNLOADED
        ,          caller : DOM_TOOLS_JS_TAG
    };
    t_ipc.t_ipc_SEND( ipc );

};


let t_reload = function()
{

let  caller = "t_reload";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log(caller);
if( log_this) log_caller();

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly(caller);

    t_add_LISTENERS();

    load11_POST();
};




const PREVENT_RELOAD_DELAY = 5000;

let load_listener = function(event)
{

let   caller = "load_listener("+event.type+")";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) t_fly.t_log_event_status(caller, lbb+lf1);
if( log_this) t_log.console_dir("event", event);


    let this_MS = new Date().getTime();
    let since_t_load = this_MS - load_MS;

if( log_this) log("...since_t_load=["+since_t_load+"ms] .. PREVENT_RELOAD_DELAY=["+PREVENT_RELOAD_DELAY+"]");

    switch(event.type) {
    case "beforeunload":

    {


        t_sticky.t_sticky_STORE_NOW();

        if( t_save_update_timer )
            save4_layout(caller);



        let frame_had_a_user_gesture      = (onWork_EL_last_used != null);
        let requesting_tool_name =          (onWork_EL           != null) ? (onWork_EL          .id || onWork_EL          .title).toLowerCase()
        :                                   (onWork_EL_last_used != null) ? (onWork_EL_last_used.id || onWork_EL_last_used.title).toLowerCase()
        :                                                                   "";

        let all_csv = t_util.csv_cat(pat_csv, off_csv);
        all_csv     = t_util.csv_cat(all_csv, bak_csv);
        all_csv     = t_util.csv_cat(all_csv, alt_csv);

        let case1_is_a_reload_request     = (requesting_tool_name.includes("reload")                 )
        ||                                  (requesting_tool_name    == t_data.REMOVE_ADS            )
        ||                                  (requesting_tool_name    == t_data.SPLIT_WOT             )
        ||                                  (requesting_tool_name    == t_data.LINES_WOT             )  ;
        let case2_just_loaded             = t_just_loaded(event.type  , PREVENT_RELOAD_DELAY,log_this)  ;
        let case3_anchor_freezed          =                   prop.get( t_data.ANCHOR_FREEZE         )  ;
        let case4_has_some_csv            =                            (t_util.csv_count(all_csv) > 0)  ;
        let case5_user_is_wording         =                   prop.get( t_data.WORDING               )  ;
        let case6_export_tool_clicked     = (onDown_EL && (onDown_EL == t_get_tool("EXPORT"          )));
        let case7_remove_ads_tool_clicked = (onDown_EL && (onDown_EL == t_get_tool(t_data.REMOVE_ADS )));
        let case8_remove_ads_tool_set     =                              prop.get( t_data.REMOVE_ADS )  ;



        if( case1_is_a_reload_request)
            store_set_patterns_csv();

        let confirmation_required
        =   frame_had_a_user_gesture
        && !case1_is_a_reload_request
        && !case6_export_tool_clicked
        && !case7_remove_ads_tool_clicked
        &&  (     case2_just_loaded

           )
        ;
        if(case8_remove_ads_tool_set) confirmation_required = true;

        let reason_why_not
        =  confirmation_required         ? ""
        : !frame_had_a_user_gesture      ? "NO USER GESTURE YET"
        :  case1_is_a_reload_request     ? requesting_tool_name+" REQUEST"
        :  case6_export_tool_clicked     ? "EXPORT REQUEST"
        :  case7_remove_ads_tool_clicked ? "DOM CLEAN REQUEST"
        :                                  "NOT JUST LOADED and ANCHOR NOT FREEZED and NOT t_data.WORDING";


if(log_this) {
    t_fly.t_log_event_status(caller);
    let msg = log_key_val_group( caller
                       , {   confirmation_required
                           , reason_why_not
                           , requesting_tool_name
                           , case1_is_a_reload_request
                           , case2_just_loaded
                           , case3_anchor_freezed
                           , case4_has_some_csv
                           , case5_user_is_wording
                           , case6_export_tool_clicked
                           , case7_remove_ads_tool_clicked
                           , case8_remove_ads_tool_set

                           , onWork_EL
                           , onWork_EL_last_used
                           , frame_had_a_user_gesture
                       }
                       , lb0, false
                     );
    t_fly.t_fly(msg);
}



        if(confirmation_required) {
            event.returnValue = event.type +" USER CONFIRMATION";
        }
        else {
            let lfx
                = case7_remove_ads_tool_clicked ? lf7
                : case6_export_tool_clicked     ? lf6
                : case5_user_is_wording         ? lf5
                : case3_anchor_freezed          ? lf3
                : case2_just_loaded             ? lf2
                : case1_is_a_reload_request     ? lf1
                :                                 lf9;

if( log_this) log("%c UNLOAD CONFIRMATION NOT TRIGGERED %c"+reason_why_not, lbb+lbL+lf9, lbb+lbR+lfx);
        }
        event.preventDefault();

    }
    break;

    case "unload":

    {
if( log_this) log("%c"+caller+"%c"+event.type, lbb+lbL+lf2, lbb+lbR+lf3);

    }
    break;

    default:
    {
if( log_this) log("%c"+caller+"%c"+event.type, lbb+lbL+lf2, lbb+lbR+lf3);

    }

    }
};



let load0_get_LOADER_ID = function()
{

let   caller = "load0_get_LOADER_ID";
let log_this = LOG_MAP.T1_DOM_LOAD;

if(log_this) log(caller, "info");


    if( typeof DOM_LOAD_ID  == "undefined")
    {
if( log_this) logBIG("DOM_LOAD_ID IS NOT DEFINED");

    }
    else {
if( log_this) logBIG("DOM_LOAD_ID ["+ DOM_LOAD_ID +"] DEFINED BY SCRIPT", lf5);

    }


    let dom_load_id_template_literal = "${DOM_LOAD_ID}";
    if(!dom_load_id_template_literal.startsWith("$") )
    {
        window.DOM_LOAD_ID = dom_load_id_template_literal;

if( log_this) logBIG("DOM_LOAD_ID ["+DOM_LOAD_ID+"] FROM TEMPLATE LITERAL", lf6);
    }


    let dom_load_script = document.getElementById("dom_load");
    if( dom_load_script )
    {
        window.DOM_LOAD_ID = dom_load_script.title;

if( log_this) logBIG("DOM_LOAD_ID ["+ DOM_LOAD_ID +"] FROM [dom_load_script.title]", lf4);
    }



    if( typeof DOM_LOAD_TAG  == "undefined")
    {
if( log_this) logBIG("DOM_LOAD_TAG IS NOT DEFINED");

    }
    else {
if( log_this) logBIG("DOM_LOAD_TAG ["+ DOM_LOAD_TAG +"] DEFINED BY SCRIPT", lf5);

    }


    let dom_load_tag_template_literal = "${DOM_LOAD_TAG}";
    if(!dom_load_tag_template_literal.startsWith("$") )
    {
        window.DOM_LOAD_TAG = dom_load_tag_template_literal;

if( log_this) logBIG("DOM_LOAD_TAG ["+DOM_LOAD_TAG+"] FROM TEMPLATE LITERAL", lf6);
    }

};



let shadow_host;
let load1_SHADOW = function()
{

let   caller = "load1_SHADOW";
let log_this = DOM_TOOLS_LOG || LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD1+"%c "+caller, lbS+lf1, lbH+lf1);


    shadow_host                         = document.createElement("DIV");
    shadow_host.id                      = "shadow_host";
    shadow_host.style.fontSize          = "initial";
    document.documentElement.appendChild( shadow_host );

    if( shadow_host.attachShadow ) {
        shadow_host.style.zIndex        = t_data.ZINDEX_SHADOW_HOST;

if( log_this || DOM_TOOLS_TAG)    log("%c shadow_host.style.zIndex=["+shadow_host.style.zIndex+"]", lbH+lf1);
        shadow_host.style.fontSize      = t_data.FONT_SIZE_SHADOW_HOST;

        shadow_root =                     shadow_host.attachShadow({mode: "open"});
    }
    else {
        logBIG(caller+": shadow_host.attachShadow is missing");


        shadow_root    = shadow_host;
    }

    shadow_root.id     = "shadow_root";






    let  id;
    id = "dom_tools_html"; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_tools_css" ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_tools_js"  ; if( !load1_SHADOW_host(id) ) return id;

    id = "dom_hide_js"   ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_select_js" ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_wot_js"    ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_wording_js"; if( !load1_SHADOW_host(id) ) return id;

    id = "dom_data_js"   ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_log_js"    ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_popup_js"  ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_prop_js"   ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_store_js"  ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_share_js"  ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_util_js"   ; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_details_js"; if( !load1_SHADOW_host(id) ) return id;
    id = "dom_i18n_js"   ; if( !load1_SHADOW_host(id) ) return id;

    if( load1_SHADOW_host("dom_grid_html", true) )
    {
        load1_SHADOW_host("dom_grid_css" );
        load1_SHADOW_host("dom_grid_js"  );
    }


    return "";
};


let load1_SHADOW_host = function(id,optional)
{

let caller = "load1_SHADOW_host";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log(caller+"%c"+id, lbH+lf1);

    if( id.includes(" ") ) { log("%c"+caller+" %c"+id+"%c ID INCLUDES A SPACE", lbH+lf3, lbL+lf2, lbR+lf2); return false; }

    let el = document.querySelector("#"+id);
    if(!el ) {
        if(!optional) {
            log("%c"+caller+" %c"+id+"%c ELEMENT IS MISSING" , lbH+lf3, lbL+lf2, lbR+lf2);
            log_caller();
        }
        return false;
    }


    if(el.proxiedNode)
    {
if(log_this) log("load1_SHADOW_host: using proxiedNode ["+el.proxiedNode.type+"]:");
if(log_this) t_log.console_dir("el",el);
        el = el.proxiedNode;
    }


    el.style.display = "inline";

    shadow_root.appendChild( el );


    return true;
};




let dev_log_map;
let dom_load_tags;
let dom_tools_html;
let TOOL_panels = [];


let load2_TOOLS = function()
{

let caller = "load2_TOOLS";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD2+"%c "+caller, lbS+lf2, lbH+lf2);


    let id;
    let tool;

    id = "dom_tools_html"   ;      dom_tools_html = t_get_tool(id);






    id = "hotspot"          ;             hotspot = t_get_tool(id);
    TOOL_panels.push( hotspot );

    id =  "hotring"         ;             hotring = t_get_tool(id);
    id =  "hotspot_c"       ;           hotspot_c = t_get_tool(id);
    id =  "hotwave"         ;             hotwave = t_get_tool(id);




    id = "headsup"          ;             headsup = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( headsup );
    id = "thumb_p"          ;       toolbar_thumb = t_get_tool(id);

    id =  t_data.DOM_FREEZE        ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.USER_LANG         ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    {
        let el = prop.get_EL(t_data.USER_LANG);
        if( el ) {
            let     lang = dom_i18n.i18n_get_user_lang();
            el.title     = i18n_get(dom_i18n.USER_LANG, dom_i18n.USER_LANG);
            el.className = "flag bg_"+lang;
        }
    }
    id =  t_data.ANCHOR_FREEZE     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.THEME_DARK        ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.WORDING           ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    id =  t_data.CONTAINERS_HI     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    id =  t_data.OVERFLOW_VISI     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    id =  t_data.DETAILS_CLOSE     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.DETAILS_OPEN      ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.DETAILS_RADIO     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    id =  t_data.SCROLL_SMOOTH     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    id =  t_data.TOOLS_TIER2       ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    id =  t_data.SHOW_SEEKZONE     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.PIN_SEEKSPOT      ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.LOG_SEEKSPOT      ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    id =  t_data.REMOVE_ADS        ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.SPLIT_WOT         ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.LINES_WOT         ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    id =  t_data.DENY_OR_ALLOW     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.EDIT_OR_STAGE     ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.DOM_HIDE1_RESET   ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.DOM_HIDE1_UNDO    ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.MASK_OR_HIDE      ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.SITE_OR_PAGE      ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);



    id = "headsup_w"             ;           headsup_w = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( headsup_w );
    id = t_data.WORDS_FILTER     ;  words_filter_input = t_get_tool(id);

    id = t_data.WORDS_EXACT      ; if(            tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id = t_data.WORDS_SEGMENT    ; if(            tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id = t_data.WORDS_HEAD_TAIL  ; if(            tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id = t_data.WORDS_OPCYCLE    ; if(            tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id = t_data.WORDS_RECYCLE    ; if(            tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id = t_data.WORDS_BAG_ROT    ; if(            tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);

    for(const iD of get_words_drop_affix_array())
        if(                                       tool = t_get_tool(iD)) load2_TOOLS_prop_set_EL(iD, tool);



    id = "pat_bag"          ;             pat_bag = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( pat_bag );



    id = "sel_bag"          ;             sel_bag = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( sel_bag );




    id = "headsup_ds"       ;          headsup_ds = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( headsup_ds );

    id =  t_data.TOOLS_TRAP        ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);
    id =  t_data.TOOLS_SCROLL      ; if(           tool = t_get_tool(id)) load2_TOOLS_prop_set_EL(id, tool);


    id = "headsup_fs"       ;          headsup_fs = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( headsup_fs );



    id = "headsup_bw"       ;          headsup_bw = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) )  TOOL_panels.push( headsup_bw );



    id = "headsup_bz"       ;          headsup_bz = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( headsup_bz );




    id = "test_panel"    ;             test_panel = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( test_panel );



    id = "dom_traversal"    ;       dom_traversal = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( dom_traversal );



    id = "transcript1"      ;         transcript1 = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( transcript1 );

    id = "transcript2"      ;         transcript2 = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( transcript2 );

    t_log.log_TR_set_transcripts(transcript1, transcript2);



    id = "dom_load_tags"    ;       dom_load_tags = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( dom_load_tags );



    id = "dev_log_map"      ;         dev_log_map = t_get_tool(id); if( is_a_DOM_LOAD_panel(id) ) TOOL_panels.push( dev_log_map );





    id = "pivspot"          ;             pivspot = t_get_tool(id);
    id = "pivspot_c"        ;           pivspot_c = t_get_tool(id);

    t_seek.t_seeker_onLoad();



    id = "dom_grid_html"    ;       dom_grid_html = t_get_tool(id);



    if(dom_tools_html) dom_tools_html.style.visibility = t_data.CSS_HIDDEN;

    for(const el of TOOL_panels) if(el) add_el_class(el, t_data.CSS_HIDDEN);


if( log_this) prop.log_MAP(caller);
};


let load2_TOOLS_prop_set_EL = function(id,el)
{
    prop.set_EL(id, el);

    t_util.set_el_caption(el);

    if( playground_clones_panel ) t_clone_3_panel_id_bg_type_label(playground_clones_panel, id, "bg7", "input");
};



let load3_PLAYGROUND_PANELS = function()
{

let   caller = "load3_PLAYGROUND_PANELS";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD3+"%c "+caller, lbS+lf3, lbH+lf3);


    let panel;
    if( panel = document.getElementById("dom_hide_tools_panel"))
    {
        if(!panel.innerHTML) panel.innerHTML = "<em class='cc1'>HIDE TOOLS</em>";
        t_clone_1_DOC_SLIDER(panel, t_data.SITE_OR_PAGE   , "bg4");
        t_clone_1_DOC_SLIDER(panel, t_data.MASK_OR_HIDE   , "bg3");
        t_clone_1_DOC_SLIDER(panel, t_data.EDIT_OR_STAGE  , "bg2");
        t_clone_1_DOC_SLIDER(panel, t_data.DOM_HIDE1_RESET, "bg1");
        t_clone_1_DOC_SLIDER(panel, t_data.DOM_HIDE1_UNDO , "bg1");
        t_clone_1_DOC_SLIDER(panel, t_data.DENY_OR_ALLOW  , "bg0");
    }


    if(panel = document.getElementById("dom_hide_select_panel"))
    {
        let id, label, el;
        if(!panel.innerHTML) panel.innerHTML = "<em class='cc2'>HIDE SELECT</em>";
        id = "dom_hide1_collect_nodes_1"      ; label = "collect_nodes_1"      ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg2","input",label); if(el) prop.set_EL(id, el);
        id = "dom_hide1_collect_nodes_2"      ; label = "collect_nodes_2"      ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg3","input",label); if(el) prop.set_EL(id, el);
        id = "dom_hide1_collect_nodes_3"      ; label = "collect_nodes_3"      ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg4","input",label); if(el) prop.set_EL(id, el);
        id = "dom_hide1_collect_nodes_4"      ; label = "collect_nodes_4"      ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5","input",label); if(el) prop.set_EL(id, el);
        id = "dom_hide1_container_clicked"    ; label = "container_clicked"    ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1","input",label); if(el) prop.set_EL(id, el);
        id = "dom_hide4_scroll_to_last_hidden"; label = "scroll to last hidden"; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1","input",label); if(el) prop.set_EL(id, el);
    }


    if(panel = document.getElementById("dom_hide_store_panel"))
    {
        let id, label, el;
        if(!panel.innerHTML) panel.innerHTML = "<em class='cc3'>HIDE STORE</em>";
        id = "dom_hide2_store_save"   ;         label = "store_save"   ;         el = t_clone_3_panel_id_bg_type_label(panel,id,"bg2","input",label); if(el) prop.set_EL(id, el);
        id = "dom_hide1_reset"        ;         label = "store_reset"  ;         el = t_clone_3_panel_id_bg_type_label(panel,id,"bg3","input",label); if(el) prop.set_EL(id, el);
        id = "dom_hide2_store_reload" ;         label = "store_reload" ;         el = t_clone_3_panel_id_bg_type_label(panel,id,"bg4","input",label); if(el) prop.set_EL(id, el);
        id = "dom_hide5_history_start";         label = "start_history";         el = t_clone_3_panel_id_bg_type_label(panel,id,"bg6","input",label); if(el) prop.set_EL(id, el);
    }


    if(panel = document.getElementById("dom_sticky_panel"))
    {
        let id, label, el;
        if(!panel.innerHTML) panel.innerHTML = "<em class='cc3'>sticky</em>";

        id = "t_sticky_reorder"  ; label = "REORDER"      ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg2","input",label); if(el) prop.set_EL(id, el);
    }


    load3_PLAYGROUND_clones_panel();
};


let       playground_clones_panel = false;
let load3_PLAYGROUND_clones_panel = function()
{

let caller = "load3_PLAYGROUND_clones_panel";
let log_this = LOG_MAP.T1_DOM_LOAD;



    playground_clones_panel = document.getElementById("playground_clones_panel");
    if(!playground_clones_panel)
    {
if( log_this) log("FOUND NO DOC TOOL CLONES PANEL [playground_clones_panel]");

        return;
    }

if(log_this) t_log.console_dir(caller+": FOUND DOC TOOL CLONES PANEL", playground_clones_panel);


    let panel = playground_clones_panel;
    let id, el;
    id = "t_sticky_reorder"         ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1", "input"); if(el) prop.set_EL(id, el);
    id = "SEEK"                     ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1", "em"  );
    id = t_seek.CSS_SEEK2_ONSLOTEL  ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1", "input"); if(el) prop.set_EL(id, el);
    id = t_seek.CSS_SEEK1_ONRESUME  ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1", "input"); if(el) prop.set_EL(id, el);
    id = t_seek.CSS_SEEK4_ONJUMPEL  ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1", "input"); if(el) prop.set_EL(id, el);
    id = t_seek.CSS_SEEK5_ONSEEKER  ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1", "input"); if(el) prop.set_EL(id, el);
    id = t_seek.CSS_SEEK6_ONSTICKY  ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg1", "input"); if(el) prop.set_EL(id, el);

    id = "HIDE"                     ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg2", "em"   );
    id = "container_clicked"        ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg2", "input"); if(el) prop.set_EL(id, el);
    id = "reset"                    ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg2", "input"); if(el) prop.set_EL(id, el);
    id = "scroll_to_last_hidden"    ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg2", "input"); if(el) prop.set_EL(id, el);

    id = "COLLECT"                  ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg3", "em"   );
    id = "collect_nodes_1"          ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg3", "input"); if(el) prop.set_EL(id, el);
    id = "collect_nodes_2"          ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg3", "input"); if(el) prop.set_EL(id, el);
    id = "collect_nodes_3"          ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg3", "input"); if(el) prop.set_EL(id, el);
    id = "collect_nodes_4"          ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg2", "input"); if(el) prop.set_EL(id, el);

    id = "STORE"                    ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg4", "em"   );
    id = "store_reload"             ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg4", "input"); if(el) prop.set_EL(id, el);
    id = "store_save"               ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg4", "input"); if(el) prop.set_EL(id, el);
    id = "start_history"            ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg4", "input"); if(el) prop.set_EL(id, el);

    id = "MISC1"                    ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "em"   );
    id = "RELOAD"                   ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);
    id = "EXPORT"                   ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);
    id = "IMPORT"                   ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);

    id = "show_seekzone"            ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);
    id = "pin_seekspot"             ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);
    id = "log_seekspot"             ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);

    id = "remove_ads"               ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);
    id = "split_wot"                ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);
    id = "lines_wot"                ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg5", "input"); if(el) prop.set_EL(id, el);

    id = "MISC2"                    ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg6", "em"   );
    id = "theme_dark"               ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg6", "input"); if(el) prop.set_EL(id, el);
    id = "pat_sort"                 ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg6", "input"); if(el) prop.set_EL(id, el);
    id = "console_clear"            ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg6", "input"); if(el) prop.set_EL(id, el);

    id = "PROPERTIES"               ; el = t_clone_3_panel_id_bg_type_label(panel,id,"bg7", "em"   );


};



let load4_HEADSUP = function()
{

let caller = "load4_HEADSUP";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD4+"%c "+caller, lbS+lf4, lbH+lf4);


    let el;

    if( el = toolbar_thumb                        ) { el.style.position   = "absolute"; el.style.left = " 7%"; el.style.top    = "  2%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.DOM_FREEZE      )) { el.style.position   = "absolute"; el.style.left = "70%"; el.style.top    = " 40%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.USER_LANG       )) { el.style.position   = "absolute"; el.style.left = "45%"; el.style.top    = " 36%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.ANCHOR_FREEZE   )) { el.style.position   = "absolute"; el.style.left = " 0%"; el.style.top    = " 19%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.WORDING         )) { el.style.position   = "absolute"; el.style.left = " 0%"; el.style.top    = " 47%"; el.style.transform = ""; }

    if( el = prop.get_EL( t_data.CONTAINERS_HI   )) { el.style.position   = "absolute"; el.style.left = "28%"; el.style.top    = "  0%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.THEME_DARK      )) { el.style.position   = "absolute"; el.style.left = "42%"; el.style.top    = "  0%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.TOOLS_TIER2     )) { el.style.position   = "absolute"; el.style.left = "85%"; el.style.top    = " 65%"; el.style.transform = ""; }

    if( el = prop.get_EL( t_data.REMOVE_ADS      )) { el.style.position   = "absolute"; el.style.left = "52%"; el.style.bottom = "  0%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.SPLIT_WOT       )) { el.style.position   = "absolute"; el.style.left = "62%"; el.style.bottom = "  0%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.LINES_WOT       )) { el.style.position   = "absolute"; el.style.left = "73%"; el.style.bottom = "  0%"; el.style.transform = ""; }

    if( el = prop.get_EL( t_data.SCROLL_SMOOTH   )) { el.style.position   = "absolute"; el.style.left = "36%"; el.style.bottom = "  0%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.OVERFLOW_VISI   )) { el.style.position   = "absolute"; el.style.left = "18%"; el.style.bottom = "  0%"; el.style.transform = ""; }

    if( el = prop.get_EL( t_data.DETAILS_CLOSE   )) { el.style.position   = "absolute"; el.style.left = "60%"; el.style.top    = "  0%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.DETAILS_OPEN    )) { el.style.position   = "absolute"; el.style.left = "60%"; el.style.top    = " 23%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.DETAILS_RADIO   )) { el.style.position   = "absolute"; el.style.left = "74%"; el.style.top    = " 12%"; el.style.transform = ""; }

    if( el = prop.get_EL( t_data.PIN_SEEKSPOT    )) { el.style.position   = "absolute"; el.style.left = "70%"; el.style.top    = "  5%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.SHOW_SEEKZONE   )) { el.style.position   = "absolute"; el.style.left = "70%"; el.style.top    = " 30%"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.LOG_SEEKSPOT    )) { el.style.position   = "absolute"; el.style.left = "70%"; el.style.top    = " 50%"; el.style.transform = ""; }



    if( el = prop.get_EL( t_data.WORDS_EXACT     )) { el.style.position   = "absolute"; el.style.left =  "10px"; el.style.top = " 52px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.WORDS_SEGMENT   )) { el.style.position   = "absolute"; el.style.left =  "55px"; el.style.top = " 38px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.WORDS_HEAD_TAIL )) { el.style.position   = "absolute"; el.style.left = "100px"; el.style.top = " 52px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.WORDS_OPCYCLE   )) { el.style.position   = "absolute"; el.style.left =  "55px"; el.style.top = " 85px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.WORDS_RECYCLE   )) { el.style.position   = "absolute"; el.style.left = "100px"; el.style.top = "100px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.WORDS_BAG_ROT   )) { el.style.position   = "absolute"; el.style.left =  "10px"; el.style.top = "125px"; el.style.transform = ""; }

    let    top =  48;
    let   left = 155;


    for(const id of get_words_drop_affix_array())
    {
        if( el = prop.get_EL(id)) {
            el.style.position  = "absolute";
            el.style.left      =  left+"px";
            el.style.top       =   top+"px";
            el.style.transform =         "";
            top += 30;
        }
    }


    if( el = prop.get_EL( t_data.TOOLS_TRAP      )) { el.style.position   = "absolute"; el.style.left =  "10px"; el.style.top =   "5px"; }
    if( el = prop.get_EL( t_data.TOOLS_SCROLL    )) { el.style.position   = "absolute"; el.style.left =  "80px"; el.style.top =   "5px"; }

    if( el = prop.get_EL( t_data.SITE_OR_PAGE    )) { el.style.position   = "absolute"; el.style.left =   "5px"; el.style.top =  "50px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.MASK_OR_HIDE    )) { el.style.position   = "absolute"; el.style.left =  "43px"; el.style.top =  "73px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.EDIT_OR_STAGE   )) { el.style.position   = "absolute"; el.style.left =  "80px"; el.style.top =  "50px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.DOM_HIDE1_RESET )) { el.style.position   = "absolute"; el.style.left = "125px"; el.style.top =  "35px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.DOM_HIDE1_UNDO  )) { el.style.position   = "absolute"; el.style.left = "110px"; el.style.top =  "85px"; el.style.transform = ""; }
    if( el = prop.get_EL( t_data.DENY_OR_ALLOW   )) { el.style.position   = "absolute"; el.style.left = "135px"; el.style.top =  "80px"; el.style.transform = "scale(0.7)"    ; }


};




const ONLOAD_MOVE_HOTSPOT_DELAY = 2000;
let IN_WEBVIEW = "";
let USERAGENT  = "";


let load5_STORAGE = function()
{

let   caller = "load5_STORAGE";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log("%c"+t_data.SD5+"%c "+caller, lbS+lf5, lbH+lf5);
    let xy, x, y;



    let id, state, value;

    id = t_data.DOM_FREEZE           ; value =  t_store.t_store_getItem(id)           ; prop.set(id, value);
    id = t_data.USER_LANG            ; value =  t_store.t_store_getItem(id)           ; prop.set(id, value);
    id = t_data.ANCHOR_FREEZE        ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.CONTAINERS_HI        ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.FLY_DIV_MAGNIFIED    ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.LOG_SEEKSPOT         ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);

    id = t_data.REMOVE_ADS           ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state, t_REMOVE_ADS_changed);
    id = t_data.SPLIT_WOT            ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state, t_WOT_SPLIT_changed);
    id = t_data.LINES_WOT            ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state, t_LINES_WOT_changed);

    id = t_data.OVERFLOW_VISI        ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.DETAILS_RADIO        ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);

    id = t_data.PIN_SEEKSPOT         ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state, t_PIN_SEEKSPOT_changed);
    id = t_data.PIVOT_MAGNIFIED      ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.SCROLL_SMOOTH        ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.SHOW_SEEKZONE        ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state, t_SHOW_SEEKZONE_changed);
    id = t_data.THEME_DARK           ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.TOOLS_TIER2          ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.TOOLS_SCROLL         ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);
    id = t_data.TOOLS_TRAP           ; state = (t_store.t_store_getItem(id) == "true"); prop.set(id, state);




    t_store_get_patterns_csv();




    prop.init(  t_data.SITE_OR_PAGE   , false, t_SITE_OR_PAGE_changed   );
    prop.init(  t_data.MASK_OR_HIDE   , false, t_MASK_OR_HIDE_changed   );
    prop.init(  t_data.EDIT_OR_STAGE  , false, t_EDIT_OR_STAGE_changed  );
    prop.init(  t_data.DOM_HIDE1_RESET, false, t_DOM_HIDE1_RESET_changed);
    prop.init(  t_data.DOM_HIDE1_UNDO , false, t_DOM_HIDE1_UNDO_changed );



    prop.init(  t_data.WORDS_DROP_ING ,  true                           );
    prop.init(  t_data.WORDS_DROP_S   ,  true                           );





    if(!USERAGENT)
    {
        USERAGENT  = window.navigator.userAgent;
        IN_WEBVIEW = (USERAGENT.toLowerCase().indexOf("android") > 0);

    }


    xy = t_store.t_store_parseXY("pivotXY")
        || {  x : (window.innerWidth  / 2)
            , y : (window.innerHeight / 2) };

    xy.x = Math.max( -w_W , xy.x      );
    xy.y = Math.max( -w_H , xy.y      );
    xy.x = Math.min(        xy.x, w_W );
    xy.y = Math.min(        xy.y, w_H );

    t_set_pivotXY(xy.x, xy.y);


    id = t_store.t_store_getItem("pivot_PANEL");
    let panel = (id == null) ? null : t_get_tool(id);

    t_set_pivot_PANEL(panel, "STORED pivot_PANEL");


    if(transcript1)
    {
        panel     = transcript1;
        let key   = panel.id +"_pinned";
        let attr  = prop.set(key, t_store.t_store_getBool(key));
        if(!attr.value)
            panel.style.position = prop.get( t_data.TOOLS_SCROLL ) ? "absolute" : "fixed";
        else {
            if( xy = t_store.t_store_parseXY(panel.id +"_XY")) {
                xy = t_view.t_view5_move_panel_XY(panel, xy.x, xy.y);
                t_pin_panel_at_XY(panel, xy.x, xy.y, "fixed", t_data.ZINDEX_PINNED_PANEL_ZERO);
            }
        }
    }
    if(transcript2)
    {
        panel     = transcript2;
        let key   = panel.id +"_pinned";
        let attr  = prop.set(key, t_store.t_store_getBool(key));
        if(!attr.value)
            panel.style.position = prop.get( t_data.TOOLS_SCROLL ) ? "absolute" : "fixed";
        else {
            if( xy = t_store.t_store_parseXY(panel.id +"_XY")) {
                xy = t_view.t_view5_move_panel_XY(panel, xy.x, xy.y);
                t_pin_panel_at_XY(panel, xy.x, xy.y, "fixed", t_data.ZINDEX_PINNED_PANEL_ZERO);
            }
        }
    }



    for(let index=0; index < TOOL_panels.length; ++index) {
        panel              = TOOL_panels[          index];


        if(!panel                           ) continue;

        if(has_el_class(panel, CSS_OPEN_BAG)) continue;


        let panel_json = t_store.t_store_getItem(panel.id);
        if(!panel_json ) continue;

        value = JSON.parse( panel_json );
if( log_this) log_key_val(caller+" "+panel.id+" value", value, lf3);


        if( value.pinned) {
            if( value.xy ) {
                let vp_xy = t_view.t_view5_move_panel_XY(panel, value.xy.x, value.xy.y);
                t_pin_panel_at_XY(panel, vp_xy.x, vp_xy.y, "fixed", index+t_data.ZINDEX_PINNED_PANEL_ZERO);
            }
        }


        if(panel != hotspot)
            t_layout_panel_magnified(panel, value.magnified);


    }


    x =                      parseFloat(   t_store.t_store_getItem("spread_ratio_x") || 0.5);
    y =                      parseFloat(   t_store.t_store_getItem("spread_ratio_y") || 0.5);

    spread_ratio.x = x;
    spread_ratio.y = y;


    load5_STORAGE_hotspot();

    t_hide.dom_hide6_add_container_observer        ( t_seek_set_container_selected );
    t_hide.dom_hide6_add_t_store_set_value_observer( t_store.t_store_set_value             );
    t_hide.dom_hide6_add_info_observer             ( t_fly.t_fly                   );



    t_store.t_store_add_info_observer( t_pat_bag_status_set_innerText );
    t_store.t_store_add_info_observer( t_fly.t_fly_observerCB               );

    t_store.t_store_add_listener();


    let window_scrollY = t_store.t_store_getItem("window_scrollY"); window_scrollY = (window_scrollY == null) ? 0 : parseFloat(window_scrollY);
    let near_current_scroll = (Math.abs(window_scrollY - window.scrollY) < 2 * window.innerHeight);
    if(     window_scrollY
       && ((window.scrollY == 0) || near_current_scroll)
      ) {
        let scrollBehavior
            = near_current_scroll
            ?  "smooth"
            :  "instant";

        setTimeout( function() { dom_scroll.t_window_scrollTo(window.scrollX, window_scrollY, scrollBehavior); }, 2000);
    }



    prop.set_CB( prop_id_state_CB );



    load_wording();



if( log_this) load5_STORAGE_log();

};


let load5_STORAGE_hotspot = function()
{

let   caller = "load5_STORAGE_hotspot";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD5+"%c "+caller, lbS+lf5, lbH+lf5);
if( log_this) log_caller();


    let value = t_store.t_store_getItem("hotspotXY");
    if( value ) hotspotXY = JSON.parse( value );
    hotspotXY.x = hotspotXY.x || HOTSPOT_STANDBY_X;
    hotspotXY.y = hotspotXY.y || HOTSPOT_STANDBY_Y;



    let xy;
    xy   = { x : hotspotXY.x , y : hotspotXY.y };
    xy.x = Math.max( -w_W , xy.x      );
    xy.y = Math.max( -w_H , xy.y      );
    xy.x = Math.min(        xy.x, w_W );
    xy.y = Math.min(        xy.y, w_H );

    if(xy.x || xy.y) t_gutter.set_WINDOW_XY(xy.x, xy.y);
if(log_this) logBIG(caller+": hotspotXY IN-WINDOW ["+xy.x+" "+xy.y+"]");


    xy   = { x : hotspotXY.x_in_gutter , y : hotspotXY.y_in_gutter };
    xy.x = Math.max( -w_W , xy.x      );
    xy.y = Math.max( -w_H , xy.y      );
    xy.x = Math.min(        xy.x, w_W );
    xy.y = Math.min(        xy.y, w_H );

    if(xy.x || xy.y) t_gutter.set_GUTTER_XY(xy.x, xy.y);

if(log_this) logBIG("hotspotXY_in_gutter=["+xy.x+" "+xy.y+"]");


if(log_this) log_key_val_group("LOADING hotspotXY", hotspotXY, lf7, true);

    xy.x = hotspotXY.gutter_urdl ? hotspotXY.x_in_gutter : hotspotXY.x;
    xy.y = hotspotXY.gutter_urdl ? hotspotXY.y_in_gutter : hotspotXY.y;
if(log_this) logBIG("POSTING A MOVE TO ["+xy.x+" "+xy.y+"] .. "+(hotspotXY.gutter_urdl ? "[IN-GUTTER]" : "[IN-WINDOW]"));

    t_tools_set_hotspot_xy(hotspotXY.x, hotspotXY.y);
if(log_this) logBIG("STARTING FROM: .. hotspotXY["+hotspotXY.x+" "+hotspotXY.y+"] .. h_x.h_y ["+h_x+" "+h_y+"]");

    enter_CSS_SLOW_REGROUP("LOADING");

    setTimeout(
               function() {
                   enter_CSS_SLOW_REGROUP("SHOWING HOTSPOT at "+xy.x+"@"+xy.y);

                   t_tools_set_top_xy(xy.x, xy.y);
               }
               , ONLOAD_MOVE_HOTSPOT_DELAY);

};


let load5_STORAGE_log = function()
{
log("%c STORAGE SETTINGS:", lbF+lb8);

    prop.log_MAP("load5_STORAGE_log");

    t_hide.dom_hide_log_settings();

    TOOL_KEY_PAGE_SITE_TRANSIENT.forEach(
        function(each) {
            let value = t_store.t_store_getItem(    each.key       );
            if( value ) t_store.t_store_key_log("", each.key, value);
        }
    );

    let id;

    id = "USERAGENT"         ; log("o %c "+id+": %c "+ USERAGENT +"] IN_WEBVIEW=["+ IN_WEBVIEW  +" ", lbF+lb1, lbA);
    id = "sel_csv"           ; log("o %c "+id+": %c "+ sel_csv                                  +" ", lbF+lb5, lbA);
    id = "pat_csv"           ; log("o %c "+id+": %c "+ pat_csv                                  +" ", lbF+lb5, lbA);
    id = "off_csv"           ; log("o %c "+id+": %c "+ off_csv                                  +" ", lbF+lb5, lbA);
    id = "alt_csv"           ; log("o %c "+id+": %c "+ alt_csv                                  +" ", lbF+lb5, lbA);
    id = "bak_csv"           ; log("o %c "+id+": %c "+ bak_csv                                  +" ", lbF+lb5, lbA);
    id = "bin_csv"           ; log("o %c "+id+": %c "+ bin_csv                                  +" ", lbF+lb5, lbA);
    id = "pivot_PANEL"       ; log("o %c "+id+": %c "+ get_n_lbl(pivot_PANEL)                   +" ", lbF+lb8, lbA);
    id = "pivotXY"           ; log("o %c "+id+": %c "+ pivotXY.x      +" "+ pivotXY.y           +" ", lbF+lb8, lbA);
    id = "hotspotXY"         ; log("o %c "+id+": %c "+ hotspotXY.x    +" "+ hotspotXY.y         +" ", lbF+lb8, lbA);
    id = "spread_ratio"      ; log("o %c "+id+": %c "+ spread_ratio.x +" "+ spread_ratio.y      +" ", lbF+lb8, lbA);
};



let DOM_TOOLS_HTML_TAG;
let DOM_GRID_HTML_TAG;
let DOM_HOST_CSS_TAG;
let DOM_TOOLS_CSS_TAG;
let DOM_GRID_CSS_TAG;

let load6_DOM_TAGS = function()
{

    let caller = "load6_DOM_TAGS";
let log_this = DOM_TOOLS_TAG || LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD6+"%c "+caller+" COLOR-STAMPING MODULE TAGS", lbS+lf6, lbH+lf6);


    let dom_load_tags_el = t_get_tool("dom_load_tags");
    if(!dom_load_tags) {
logBIG(caller+" *** t_get_tool('dom_load_tags') failed");

        return;
    }


    let id, el;

    id = "dom_tools_html"; if(el = t_get_tool(id+"_tag")) DOM_TOOLS_HTML_TAG = el.innerHTML;
    id =  "dom_grid_html"; if(el = t_get_tool(id+"_tag")) DOM_GRID_HTML_TAG  = el.innerHTML;

    id =   "dom_host_css";                              DOM_HOST_CSS_TAG   = load6_DOC_CSS ( id );
    id =  "dom_tools_css";                              DOM_TOOLS_CSS_TAG  = load6_TOOL_CSS( id );
    id =   "dom_grid_css";                              DOM_GRID_CSS_TAG   = load6_TOOL_CSS( id );

    let m_class = "em_missing";
    dom_load_tags_el.innerHTML = ""

+ ("LOADER"+LF)
        + ((typeof DOM_LOAD_TAG       == "undefined") ? "<em class='"+m_class+"'>DOM_LOAD_TAG       *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_LOAD_TAG       ) +"'>"+ DOM_LOAD_TAG        +"</em>")

+ ("HTML TOOLS"+LF)
        + ((typeof DOM_TOOLS_HTML_TAG == "undefined") ? "<em class='"+m_class+"'>DOM_TOOLS_HTML_TAG  *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_TOOLS_HTML_TAG ) +"'>"+ DOM_TOOLS_HTML_TAG  +"</em>")
        + ((typeof DOM_GRID_HTML_TAG  == "undefined") ? "<em class='"+m_class+"'>DOM_GRID_HTML_TAG   *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_GRID_HTML_TAG  ) +"'>"+ DOM_GRID_HTML_TAG   +"</em>")

+ ("CSS STYLE"+LF)
        + ((typeof DOM_HOST_CSS_TAG   == "undefined") ? "<em class='"+m_class+"'>DOM_HOST_CSS_TAG    *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_HOST_CSS_TAG   ) +"'>"+ DOM_HOST_CSS_TAG    +"</em>")
        + ((typeof DOM_GRID_CSS_TAG   == "undefined") ? "<em class='"+m_class+"'>DOM_GRID_CSS_TAG    *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_GRID_CSS_TAG   ) +"'>"+ DOM_GRID_CSS_TAG    +"</em>")
        + ((typeof DOM_TOOLS_CSS_TAG  == "undefined") ? "<em class='"+m_class+"'>DOM_TOOLS_CSS_TAG   *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_TOOLS_CSS_TAG  ) +"'>"+ DOM_TOOLS_CSS_TAG   +"</em>")

+ ("JS MODULES 05"+LF)
        + ((typeof DOM_DATA_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_DATA_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_DATA_JS_TAG    ) +"'>"+ DOM_DATA_JS_TAG     +"</em>")

+ ("JS MODULES 06..10"+LF)
        + ((typeof DOM_LOG_JS_TAG     == "undefined") ? "<em class='"+m_class+"'>DOM_LOG_JS_TAG      *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_LOG_JS_TAG     ) +"'>"+ DOM_LOG_JS_TAG      +"</em>")
        + ((typeof DOM_POPUP_JS_TAG   == "undefined") ? "<em class='"+m_class+"'>DOM_POPUP_JS_TAG    *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_POPUP_JS_TAG   ) +"'>"+ DOM_POPUP_JS_TAG    +"</em>")
        + ((typeof DOM_UTIL_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_UTIL_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_UTIL_JS_TAG    ) +"'>"+ DOM_UTIL_JS_TAG     +"</em>")
        + ((typeof DOM_I18N_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_I18N_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_I18N_JS_TAG    ) +"'>"+ DOM_I18N_JS_TAG     +"</em>")
        + ((typeof DOM_PROP_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_PROP_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_PROP_JS_TAG    ) +"'>"+ DOM_PROP_JS_TAG     +"</em>")

+ ("JS MODULES 11..15"+LF)
        + ((typeof DOM_STORE_JS_TAG   == "undefined") ? "<em class='"+m_class+"'>DOM_STORE_JS_TAG    *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_STORE_JS_TAG   ) +"'>"+ DOM_STORE_JS_TAG    +"</em>")
        + ((typeof DOM_FLY_JS_TAG     == "undefined") ? "<em class='"+m_class+"'>DOM_FLY_JS_TAG      *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_FLY_JS_TAG     ) +"'>"+ DOM_FLY_JS_TAG      +"</em>")
        + ((typeof DOM_WORDING_JS_TAG == "undefined") ? "<em class='"+m_class+"'>DOM_WORDING_JS_TAG  *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_WORDING_JS_TAG ) +"'>"+ DOM_WORDING_JS_TAG  +"</em>")
        + ((typeof DOM_SELECT_JS_TAG  == "undefined") ? "<em class='"+m_class+"'>DOM_SELECT_JS_TAG   *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_SELECT_JS_TAG  ) +"'>"+ DOM_SELECT_JS_TAG   +"</em>")
        + ((typeof DOM_SLOT_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_SLOT_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_SLOT_JS_TAG    ) +"'>"+ DOM_SLOT_JS_TAG     +"</em>")


+ ("JS MODULES 16..20"+LF)
        + ((typeof DOM_HIDE_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_HIDE_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_HIDE_JS_TAG    ) +"'>"+ DOM_HIDE_JS_TAG     +"</em>")
        + ((typeof DOM_VIEW_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_VIEW_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_VIEW_JS_TAG    ) +"'>"+ DOM_VIEW_JS_TAG     +"</em>")
        + ((typeof DOM_STICKY_JS_TAG  == "undefined") ? "<em class='"+m_class+"'>DOM_STICKY_JS_TAG   *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_STICKY_JS_TAG  ) +"'>"+ DOM_STICKY_JS_TAG   +"</em>")
        + ((typeof DOM_SEEK_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_SEEK_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_SEEK_JS_TAG    ) +"'>"+ DOM_SEEK_JS_TAG     +"</em>")
        + ((typeof DOM_SHARE_JS_TAG   == "undefined") ? "<em class='"+m_class+"'>DOM_SHARE_JS_TAG    *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_SHARE_JS_TAG   ) +"'>"+ DOM_SHARE_JS_TAG    +"</em>")

+ ("JS MODULES 21..25"+LF)
        + ((typeof DOM_DETAILS_JS_TAG == "undefined") ? "<em class='"+m_class+"'>DOM_DETAILS_JS_TAG  *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_DETAILS_JS_TAG ) +"'>"+ DOM_DETAILS_JS_TAG  +"</em>")
        + ((typeof DOM_WOT_JS_TAG     == "undefined") ? "<em class='"+m_class+"'>DOM_WOT_JS_TAG      *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_WOT_JS_TAG     ) +"'>"+ DOM_WOT_JS_TAG      +"</em>")
        + ((typeof DOM_SENTENCE_JS_TAG== "undefined") ? "<em class='"+m_class+"'>DOM_SENTENCE_JS_TAG *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_SENTENCE_JS_TAG) +"'>"+ DOM_SENTENCE_JS_TAG +"</em>")
        + ((typeof DOM_GRID_JS_TAG    == "undefined") ? "<em class='"+m_class+"'>DOM_GRID_JS_TAG     *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_GRID_JS_TAG    ) +"'>"+ DOM_GRID_JS_TAG     +"</em>")
        + ((typeof DOM_GUTTER_JS_TAG  == "undefined") ? "<em class='"+m_class+"'>DOM_GUTTER_JS_TAG   *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_GUTTER_JS_TAG  ) +"'>"+ DOM_GUTTER_JS_TAG   +"</em>")

+ ("JS MODULES 26..27"+LF)
        + ((typeof DOM_IPC_JS_TAG     == "undefined") ? "<em class='"+m_class+"'>DOM_IPC_JS_TAG      *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_IPC_JS_TAG     ) +"'>"+ DOM_IPC_JS_TAG      +"</em>")
        + ((typeof DOM_TOOLS_JS_TAG   == "undefined") ? "<em class='"+m_class+"'>DOM_TOOLS_JS_TAG    *</em>" : "<em class='cc"+ t_util.get_tag_hour( DOM_TOOLS_JS_TAG   ) +"'>"+ DOM_TOOLS_JS_TAG    +"</em>")
    ;
if(LOG_MAP.T3_LAYOUT) log(t_util.strip_HTML(dom_load_tags_el.innerHTML));

};


let load6_DOC_CSS = function(id)
{

let   caller = "load6_DOC_CSS";
let log_this = DOM_TOOLS_TAG || LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+caller+"("+id+")", lbH+lf1);


    let tag = "";

    let el = document.getElementById(id);
    if( el ) {
        tag = load6_CSS_TAG_FROM_CSSRULES(el);

    }

if( log_this) log("%c...return: tag=["+tag+"]", lf1);
    return tag;
};


let load6_TOOL_CSS = function(id)
{

let   caller = "load6_TOOL_CSS";
let log_this = DOM_TOOLS_TAG || LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+caller+"("+id+")", lbH+lf3);


    let tag = "";
    let el  = t_get_tool(id)  ;
if( log_this) log("...el=["+t_util.get_node_id_or_tag(el)+"]");
    if( el ) {
        tag = load6_CSS_TAG_FROM_CSSRULES(el);

    }

if( log_this) log("%c...return: tag=["+tag+"]", lf3);
    return tag;
};


let load6_CSS_TAG_FROM_CSSRULES = function(el)
{

let   caller = "load6_CSS_TAG_FROM_CSSRULES";
let log_this = DOM_TOOLS_TAG || LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+caller+"("+t_util.get_id_or_tag_and_className(el)+")", lf6);

    let    tag = ""; let result = "";

    if(document.location.origin == "file://")
    {
        tag = el.id+" ("+document.location.origin+")";

    }
    else {
        try {
            if(     !el.sheet            ) result = "!el.sheet";
            else if(!el.sheet.cssRules   ) result = "!el.sheet.cssRules";
            else if(!el.sheet.cssRules[0]) result = "!el.sheet.cssRules[0]";
            else {
                let txt = el.sheet.cssRules[0].cssText;
                let x_1 = txt.indexOf    ('"');
                let x_2 = txt.lastIndexOf('"');
                txt     = txt.substring(x_1+1, x_2);
                tag     = txt.includes(el.id) ? txt : "";
            }
        }
        catch(ex) { result = ex; }
    }

if( log_this) log("%c...return: "+(tag || result), (tag ? lf5:lf2));
    return tag;
};



let load7_GRID = function()
{

let   caller = "load7_GRID";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD7+"%c "+caller, lbS+lf7, lbH+lf7);

    if(typeof t_grid.t_grid_MEASURE != "undefined")
        t_grid.t_grid_MEASURE();
};



let load8_LOG_MAP = function()
{

let   caller = "load8_LOG_MAP";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD8+"%c "+caller+": dev_log_map=["+get_n_lbl(dev_log_map)+"]", lbS+lf8, lbH+lf8);
if( log_this) t_log.console_dir("LOG_MAP",LOG_MAP);


    if( !dev_log_map ) return;

    let button_className = CSS_TOOLBAG_BUTTON;
    dev_log_map.innerHTML = ""

        + "<em class='"+button_className+" "+ (LOG_MAP.EV0_LISTEN     ? "cc9" : "cc8") +"'>"+ "EV0_LISTEN"      +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.EV1_DOWN       ? "cc1" : "cc8") +"'>"+ "EV1_DOWN"        +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.EV2_MOVE       ? "cc2" : "cc8") +"'>"+ "EV2_MOVE"        +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.EV3_UP         ? "cc3" : "cc8") +"'>"+ "EV3_UP"          +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.EV4_LONG_PRESS ? "cc4" : "cc8") +"'>"+ "EV4_LONG_PRESS"  +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.EV5_TOOL_CB    ? "cc5" : "cc8") +"'>"+ "EV5_TOOL_CB"     +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.EV6_CHANGED    ? "cc6" : "cc8") +"'>"+ "EV6_CHANGED"     +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.EV7_DISPATCH   ? "cc7" : "cc8") +"'>"+ "EV7_DISPATCH"    +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.EV8_FLOATLOG   ? "cc9" : "cc8") +"'>"+ "EV8_FLOATLOG"    +"</em>"

        + "<em class='"+button_className+" "+ (LOG_MAP.S0_PATTERN     ? "cc1" : "cc8") +"'>"+ "S0_PATTERN"      +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.S1_RANGE       ? "cc1" : "cc8") +"'>"+ "S1_RANGE"        +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.S2_SELECT      ? "cc2" : "cc8") +"'>"+ "S2_SELECT"       +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.S3_SLOT        ? "cc3" : "cc8") +"'>"+ "S3_SLOT"         +"</em>"

        + "<em class='"+button_className+" "+ (LOG_MAP.T0_STORE       ? "cc9" : "cc8") +"'>"+ "T0_STORE"        +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.T1_DOM_LOAD    ? "cc1" : "cc8") +"'>"+ "T1_DOM_LOAD"     +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.T2_GRID        ? "cc2" : "cc8") +"'>"+ "T2_GRID"         +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.T3_LAYOUT      ? "cc3" : "cc8") +"'>"+ "T3_LAYOUT"       +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.T4_PIVOT       ? "cc4" : "cc8") +"'>"+ "T4_PIVOT"        +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.T5_SPREAD      ? "cc5" : "cc8") +"'>"+ "T5_SPREAD"       +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.T6_SLOT        ? "cc6" : "cc8") +"'>"+ "T6_SLOT"         +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.T7_SHARE       ? "cc7" : "cc8") +"'>"+ "T7_SHARE"        +"</em>"
        + "<em class='"+button_className+" "+ (LOG_MAP.T8_TOOLBAR     ? "cc0" : "cc8") +"'>"+ "T8_TOOLBAR"      +"</em>"

        + "<em class='"+button_className+" "+ (LOG_MAP.IPC_LOG        ? "cc9" : "cc8") +"'>"+ "IPC_LOG"         +"</em>"


    ;

    if(!t_has_push_pin_on_panel( dev_log_map ) ) t_add_toolpins_on_panel  ( dev_log_map );
    else                                         t_eval_wide_or_tall_panel( dev_log_map );
};



let t_load_BEHAVIOR = function()
{

let   caller = "t_load_BEHAVIOR";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SD9+"%c "+caller, lbS+lf9, lbH+lf9);












    let appVersion = navigator.appVersion.toLowerCase();
    behavior_TOUCH_ELSE_DESKTOP
        =  !appVersion.includes("windows")
        && !appVersion.includes("hp"     )
        && !appVersion.includes("mac"    )
        && !appVersion.includes("sunos"  )
    ;


    let behavior_em
        = behavior_TOUCH_ELSE_DESKTOP
        ? "<em class='cc7 big'> MOBILE  TOUCH BEHAVIOR </em>"
        : "<em class='cc8 big'> DESKTOP MOUSE BEHAVIOR </em>"
    ;


    let e_yes = "<em class='cc5'>IS DEFINED</em>";
    let e_no  = "<em class='cc8'>IS NOT DEFINED</em>";

    let event_info
        = "<em>EVENTS</em>"+LF
        +"<ul>"+LF
        + "<li>ontouchstart "+ ((typeof document.documentElement.ontouchstart != "undefined") ? e_yes : e_no)+"</li>"+LF
        + "<li>s_log        "+ ((typeof s_log                                 != "undefined") ? e_yes : e_no)+"</li>"+LF
        + "<li>  log        "+ ((typeof   log                                 != "undefined") ? e_yes : e_no)+"</li>"+LF
        + (move_cooldown_reason ? "<li>"+move_cooldown_reason+"</li>"+LF : "")
        + "</ul>"
    ;



    let s_yes = "<em class='cc5'>YES</em>";
    let s_no  = "<em class='cc8'>NO</em>";

    let screen_info
        = "<em>MEDIA</em>"+LF
        +"<ul>"+LF
    ;
    let  q;
    q = "(orientation: landscape)"                 ; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "(orientation:  portrait)"                 ; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution :  20dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution :  80dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution :  90dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (max-resolution :  96dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution : 100dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution : 120dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution : 150dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution : 200dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution : 240dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution : 300dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    q = "only screen and (min-resolution : 640dpi)"; screen_info += "<li>"+ q + (window.matchMedia(q).matches ? s_yes : s_no)+"</li>"+LF;
    screen_info
        += "</ul>"
    ;



    let navigator_info
        = "<em>NAVIGATOR</em>"+LF
        + "<ul>"+LF
        +  "<li>Browser CodeName.....: <em>"+ navigator.appCodeName   +"</em></li>"+LF
        +  "<li>Browser Name.........: <em>"+ navigator.appName       +"</em></li>"+LF
        +  "<li>Browser Version......: <em>"+ navigator.appVersion    +"</em></li>"+LF
        +  "<li>Cookies Enabled......: <em>"+ navigator.cookieEnabled +"</em></li>"+LF
        +  "<li>Browser Language.....: <em>"+ navigator.language      +"</em></li>"+LF
        +  "<li>Browser Online.......: <em>"+ navigator.onLine        +"</em></li>"+LF
        +  "<li>Platform.............: <em>"+ navigator.platform      +"</em></li>"+LF
        +  "<li>User-agent header....: <em>"+ navigator.userAgent     +"</em></li>"+LF
        + "</ul>"
    ;


    if(    t_fly.t_doc_div_clear("doc_log_div")
        || t_tools_panel_is_selected(transcript2)
    )
        t_fly.t_log_transcript_info(
            "<em class='cc8'>"+DOM_TOOLS_JS_TAG+"</em> "+ behavior_em
            +"<pre>"
            + event_info+LF
            + screen_info+LF
            + navigator_info
            +"</pre>"
        );


};



let load10_IPC_and_LISTENERS = function()
{

let   caller = "load10_IPC_and_LISTENERS";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SDA+"%c "+caller, lbS+lf9, lbH+lf9);



    let script_loaded;

    if((typeof DOM_TOOLS_CSS_TAG == "undefined") || !DOM_TOOLS_CSS_TAG)
    {
log("%c *** "+caller+": %c TOOLS_CSS INLINING HAS BEEN REJECTED", lb3, lb2);


        for(const el of TOOL_panels) if(el) el.style.display = "none";

        let       el      = pivspot; if(el) el.style.display = "none";

        t_seek.t_seeker_hide();



        let ipc      = {  t_load : TOOLS3_NEED_RELAXED_CSP
            ,             caller : DOM_TOOLS_JS_TAG
            ,            details : caller
        };
        t_ipc.t_ipc_SEND( ipc );

        script_loaded = false;
    }


    else {
if(LOG_MAP.EV0_LISTEN) log(caller+": ADDING EVENT LISTENERS");

        t_add_LISTENERS();

        script_loaded = true;
    }

if( log_this) log("..."+caller+": return script_loaded=["+script_loaded+"]");
    return script_loaded;
};



let load11_POST = function()
{

let   caller = "load11_POST";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log("%c"+t_data.SDB+"%c "+caller, lbS+lf1, lbH+lf1);



    if((typeof DOM_TOOLS_CSS_TAG == "undefined") || !DOM_TOOLS_CSS_TAG)
    {
        log("%c *** "+caller+": %c TOOLS CSS NOT LOADED ", lb2, lbF);

            let ipc = {  t_load : TOOLS3_NEED_RELAXED_CSP
                ,        caller : DOM_TOOLS_JS_TAG
                ,       details : caller
            };
            t_ipc.t_ipc_SEND( ipc );

    }


    else {

        let ipc
            = { t_load : TOOLS4_DEPLOYED
            ,   caller : DOM_TOOLS_JS_TAG+"."+caller
        };
        t_ipc.t_ipc_SEND( ipc );

    }


    if(!t_ipc.t_ipc_listener_id) {
logBIG("adding (SLOWING DOWN !) MutationObserver");
        t_ipc.t_ipc_add_MutationObserver(DOM_TOOLS_JS_ID);


    }


    t_clr_has_moved(caller+": CLEARING ONLOAD SCROLL");

    t_sync_styles(caller);
    t_SITE_OR_PAGE_changed();

    if(typeof t_select.t_sync_containers_hi != "undefined") t_select.t_sync_containers_hi();




    t_sync_layout(caller);


    setTimeout(load11_POST_delayed_divs_shadow_root,   500);
    setTimeout(load11_POST_delayed_divs_document   ,  1000);


    cache_PINNED_panels();



    setTimeout(t_sync_wording                   ,  500);
    setTimeout(t_sticky.t_sticky_LOAD           , 2000);

    t_TOOL_SET_eval_wide_or_tall_panel(caller);

    wording_3_CB_WORDS_RECYCLE_SYNC();
};



const CSS_DISPLAY_DELAYED = "display_delayed";


let load11_POST_delayed_divs_shadow_root = function() { load11_POST_delayed_divs_handler(shadow_root  ); };
let load11_POST_delayed_divs_document    = function() { load11_POST_delayed_divs_handler(document.body); };
let load11_POST_delayed_divs_handler     = function(container)
{
    let caller = "load11_POST_delayed_divs_handler";
let log_this = LOG_MAP.T1_DOM_LOAD || LOG_MAP.EV7_DISPATCH;

if(log_this) log("%c"+caller+"%c"+get_n_lbl(container),lbL+lf1,lbR+lf3);

    for(const child of container.children)
    {
        if( child.classList && child.classList.contains( CSS_DISPLAY_DELAYED ) )
        {
if(log_this) log(".%c"+ get_n_lbl(child)+" ", lbH+lf3);
            child.classList.remove  ( CSS_DISPLAY_DELAYED );
        }

        for(const el of child.children)
        {
            if(el.classList && el.classList.contains( CSS_DISPLAY_DELAYED ) )
            {
if(log_this) log("..%c"+ get_n_lbl(el)+" ", lbH+lf4);
                el.classList.remove  ( CSS_DISPLAY_DELAYED );
            }
        }
    }

};











let       words_drop_affix_array;
let   get_words_drop_affix_array = function()
{
    if(!words_drop_affix_array) {
        words_drop_affix_array = [];
        for(const sfx of t_data.WORDS_SUFFIXES)
            words_drop_affix_array.push("words_drop_"+sfx);
    }

    return words_drop_affix_array;
};





const TOOL_KEY_PAGE_SITE_TRANSIENT = [

    {   key : "EV0_LISTEN"           , page : false , site :  true, transient :  true }
    , { key : "EV1_DOWN"             , page : false , site :  true, transient : false }
    , { key : "EV2_MOVE"             , page : false , site :  true, transient : false }
    , { key : "EV3_UP"               , page : false , site :  true, transient : false }
    , { key : "EV4_LONG_PRESS"       , page : false , site :  true, transient : false }
    , { key : "EV5_TOOL_CB"          , page : false , site :  true, transient : false }
    , { key : "EV6_CHANGED"          , page : false , site :  true, transient : false }
    , { key : "EV7_DISPATCH"         , page : false , site :  true, transient : false }
    , { key : "EV8_FLOATLOG"         , page : false , site :  true, transient : false }

    , { key : "S0_PATTERN"           , page : false , site :  true, transient : false }
    , { key : "S1_RANGE"             , page : false , site :  true, transient : false }
    , { key : "S2_SELECT"            , page : false , site :  true, transient : false }
    , { key : "S3_SLOT"              , page : false , site :  true, transient : false }

    , { key : "T0_STORE"             , page : false , site :  true, transient : false }
    , { key : "T1_DOM_LOAD"          , page : false , site :  true, transient : false }
    , { key : "T2_GRID"              , page : false , site :  true, transient : false }
    , { key : "T3_LAYOUT"            , page : false , site :  true, transient : false }
    , { key : "T4_PIVOT"             , page : false , site :  true, transient : false }
    , { key : "T5_SPREAD"            , page : false , site :  true, transient : false }
    , { key : "T6_SLOT"              , page : false , site :  true, transient : false }
    , { key : "T7_SHARE"             , page : false , site :  true, transient : false }
    , { key : "T8_TOOLBAR"           , page : false , site :  true, transient :  true }

    , { key : "IPC_LOG"              , page : false , site :  true, transient :  true }



    , { key : "pivotXY"                , page : false , site :  true, transient :  true }
    , { key : "pivot_PANEL"            , page : false , site :  true, transient : false }
    , { key :  t_data.PIVOT_MAGNIFIED         , page : false , site :  true, transient : false }

    , { key : "fly_div"                , page : false , site :  true, transient :  true }
    , { key : "fly_div_XY"             , page : false , site :  true, transient :  true }

    , { key : "spread_ratio_x"         , page : false , site :  true, transient :  true }
    , { key : "spread_ratio_y"         , page : false , site :  true, transient :  true }
    , { key : "hotspotXY"              , page : false , site :  true, transient :  true }

    , { key : "window_scrollY"         , page :  true , site : false, transient : false }

    , { key : "transcript1_pinned"     , page : false , site :  true, transient : false }
    , { key : "transcript2_pinned"     , page : false , site :  true, transient : false }


    , { key : "sel_arr"                , page :  true , site : false, transient : false }
    , { key : "pat_arr"                , page :  true , site : false, transient : false }
    , { key : "off_arr"                , page :  true , site : false, transient : false }
    , { key : "alt_arr"                , page :  true , site : false, transient : false }
    , { key : "bak_arr"                , page :  true , site : false, transient : false }
    , { key : "bin_arr"                , page :  true , site : false, transient : false }


    , { key : "page_node_to_hide_arr"  , page :  true , site : false, transient : false }
    , { key : "site_node_to_hide_arr"  , page : false , site :  true, transient : false }

];




let   load_site_and_page_keys = function()
{

let   caller = "load_site_and_page_keys";
let log_this = LOG_MAP.T1_DOM_LOAD;

if( log_this) log(caller);



    Object.keys(LOG_MAP).forEach(
        function(key) {
            t_store.t_store_add_site_key( key );
        }
    );


    TOOL_KEY_PAGE_SITE_TRANSIENT.forEach(
        function(each) {
            if(  each.page     ) t_store.t_store_add_page_key            ( each.key );
            if(  each.site     ) t_store.t_store_add_site_key            ( each.key );
            if(  each.transient) t_store.t_store_do_not_log_transient_key( each.key );
        }
    );

    for(const panel of TOOL_panels) t_store.t_store_add_site_key( panel.id   );

    for(let sticky_num = 1; sticky_num <= t_sticky.STICKY_MAX; ++sticky_num) t_store.t_store_add_page_key("sticky_"+sticky_num);

if( log_this) {
    t_log.console_dir(caller+" .store_isa_site_key_array", t_store.isa_site_key_array);
    t_log.console_dir(caller+" .store_isa_page_key_array", t_store.isa_page_key_array);
}
};




let t_tools_save_all_settings = function()
{
let   caller = "t_tools_save_all_settings";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log(caller);


    if(!has_el_class(hotring, CSS_PAGE_ITEMS_ALL_REMOVED) )
    {

        return;
    }
    save3_logging();
    save5_wording();
    save2_theme();
    save4_layout("WHILE SAVING ALL SETTINGS");
};


let   save2_theme = function()
{
let   caller = "save2_theme";
let log_this = LOG_MAP.T0_STORE;

    let key, value;
if( log_this) log(caller);



    key = t_data.DOM_FREEZE    ; value = prop.get( key )       ; t_store.t_store_set_value(key, value);
    key = t_data.USER_LANG     ; value = prop.get( key )       ; t_store.t_store_set_value(key, value);
    key = t_data.ANCHOR_FREEZE ; value = prop.get( key )       ; t_store.t_store_set_state(key, value);
    key = t_data.CONTAINERS_HI ; value = prop.get( key )       ; t_store.t_store_set_state(key, value);
    key = t_data.THEME_DARK    ; value = prop.get( key )       ; t_store.t_store_set_state(key, value);
    key = t_data.TOOLS_TRAP    ; value = prop.get( key )       ; t_store.t_store_set_state(key, value);
    key = t_data.TOOLS_TIER2   ; value = prop.get( key )       ; t_store.t_store_set_state(key, value);

};


let   save3_logging = function()
{
let   caller = "save3_logging";
let log_this = LOG_MAP.T0_STORE;

    let key, value;
if( log_this) log(caller);



    key = "EV0_LISTEN"         ; value = LOG_MAP.EV0_LISTEN    ; t_store.t_store_set_state(key, value);
    key = "EV1_DOWN"           ; value = LOG_MAP.EV1_DOWN      ; t_store.t_store_set_state(key, value);
    key = "EV2_MOVE"           ; value = LOG_MAP.EV2_MOVE      ; t_store.t_store_set_state(key, value);
    key = "EV3_UP"             ; value = LOG_MAP.EV3_UP        ; t_store.t_store_set_state(key, value);
    key = "EV4_LONG_PRESS"     ; value = LOG_MAP.EV4_LONG_PRESS; t_store.t_store_set_state(key, value);
    key = "EV5_TOOL_CB"        ; value = LOG_MAP.EV5_TOOL_CB   ; t_store.t_store_set_state(key, value);
    key = "EV6_CHANGED"        ; value = LOG_MAP.EV6_CHANGED   ; t_store.t_store_set_state(key, value);
    key = "EV7_DISPATCH"       ; value = LOG_MAP.EV7_DISPATCH  ; t_store.t_store_set_state(key, value);
    key = "EV8_FLOATLOG"       ; value = LOG_MAP.EV8_FLOATLOG  ; t_store.t_store_set_state(key, value);

    key = "S0_PATTERN"         ; value = LOG_MAP.S0_PATTERN    ; t_store.t_store_set_state(key, value);
    key = "S1_RANGE"           ; value = LOG_MAP.S1_RANGE      ; t_store.t_store_set_state(key, value);
    key = "S2_SELECT"          ; value = LOG_MAP.S2_SELECT     ; t_store.t_store_set_state(key, value);
    key = "S3_SLOT"            ; value = LOG_MAP.S3_SLOT       ; t_store.t_store_set_state(key, value);

    key = "T0_STORE"           ; value = LOG_MAP.T0_STORE      ; t_store.t_store_set_state(key, value);
    key = "T1_DOM_LOAD"        ; value = LOG_MAP.T1_DOM_LOAD   ; t_store.t_store_set_state(key, value);
    key = "T2_GRID"            ; value = LOG_MAP.T2_GRID       ; t_store.t_store_set_state(key, value);
    key = "T3_LAYOUT"          ; value = LOG_MAP.T3_LAYOUT     ; t_store.t_store_set_state(key, value);
    key = "T4_PIVOT"           ; value = LOG_MAP.T4_PIVOT      ; t_store.t_store_set_state(key, value);
    key = "T5_SPREAD"          ; value = LOG_MAP.T5_SPREAD     ; t_store.t_store_set_state(key, value);
    key = "T6_SLOT"            ; value = LOG_MAP.T6_SLOT       ; t_store.t_store_set_state(key, value);
    key = "T7_SHARE"           ; value = LOG_MAP.T7_SHARE      ; t_store.t_store_set_state(key, value);
    key = "T8_TOOLBAR"         ; value = LOG_MAP.T8_TOOLBAR    ; t_store.t_store_set_state(key, value);

    key = "IPC_LOG"            ; value = LOG_MAP.IPC_LOG       ; t_store.t_store_set_state(key, value);

    key =  t_data.FLY_DIV_MAGNIFIED   ; value = prop.get( t_data.FLY_DIV_MAGNIFIED ); t_store.t_store_set_state(key, value);

};



const STORE_CYCLE_CLASSLIST   = ["store_count1","store_count2","store_count3"];
const STORE_CYCLE_CLEAR_DELAY = 250;

let t_store4_save_site_layout_step = 0;

let   save4_layout = function(reason)
{

let   caller = "save4_layout("+reason+")";
let log_this = LOG_MAP.T0_STORE;

if( log_this) logBIG(caller);
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly(caller);


    if(!t_store_consider_page_items_worth_storing("TOOLS LAYOUT") )
    {
if( log_this) log("...NO PAGE DATA WORTH REMEMBERING");

        return;
    }


    let fly_div = t_fly.t_fly_div_get();
    let key, value, xy;
    if(hotspot) {

        let scroll_last_scrollY = dom_scroll.get_scroll_last_scrollY();
        key = "window_scrollY"          ; value = scroll_last_scrollY       ; t_store.t_store_set_value(key, value);




        h_x                      = hotspot.offsetLeft;
        h_y                      = hotspot.offsetTop;

        hotspotXY.gutter_urdl    = t_gutter.get_XY_URDL(h_x, h_y, caller);

        t_gutter.set_CSS_URDL(hotring, hotspotXY.gutter_urdl);



        if(hotspotXY.gutter_urdl) {
            hotspotXY.x_in_gutter = h_x;
            hotspotXY.y_in_gutter = h_y;

            t_gutter.set_GUTTER_XY(h_x, h_y);
        }


        else {
            hotspotXY.x           = h_x;
            hotspotXY.y           = h_y;

            t_gutter.set_WINDOW_XY(h_x, h_y);
        }

if(log_this) log_key_val_group("SAVING hotspotXY", hotspotXY, lf5, false);
        key = "hotspotXY"               ; value = JSON.stringify(hotspotXY) ; t_store.t_store_set_value(key, value);


        if( !hotspotXY.gutter_urdl )
        {
            key = "spread_ratio_x"      ; value = spread_ratio.x            ; t_store.t_store_set_value(key, value);
            key = "spread_ratio_y"      ; value = spread_ratio.y            ; t_store.t_store_set_value(key, value);
            if(pivot_PANEL) {
                key = "pivot_PANEL"     ; value = pivot_PANEL.id            ; t_store.t_store_set_value(key, value);
                key = "pivotXY"         ; value = JSON.stringify(pivotXY)   ; t_store.t_store_set_value(key, value);
                key =  t_data.PIVOT_MAGNIFIED  ; value = prop.get(key)             ; t_store.t_store_set_state(key, value);
            }
        }



        xy  = { x:fly_div.offsetLeft , y:fly_div.offsetTop };
        key = "fly_div_XY"              ; value = JSON.stringify(xy)        ; t_store.t_store_set_value(key, value);
        key =  t_data.FLY_DIV_MAGNIFIED        ; value = prop.get(key)             ; t_store.t_store_set_state(key, value);



        key =  t_data.PIN_SEEKSPOT             ; value = prop.get(key)             ; t_store.t_store_set_state(key, value);
        key =  t_data.SHOW_SEEKZONE            ; value = prop.get(key)             ; t_store.t_store_set_state(key, value);
        key =  t_data.LOG_SEEKSPOT             ; value = prop.get(key)             ; t_store.t_store_set_state(key, value);

        key =  t_data.REMOVE_ADS               ; value = prop.get(key)             ; t_store.t_store_set_state(key, value);
        key =  t_data.SPLIT_WOT                ; value = prop.get(key)             ; t_store.t_store_set_state(key, value);
        key =  t_data.LINES_WOT                ; value = prop.get(key)             ; t_store.t_store_set_state(key, value);

    }


    key =  t_data.SCROLL_SMOOTH                ; value = prop.get(key); t_store.t_store_set_state(key, value);
    key =  t_data.OVERFLOW_VISI                ; value = prop.get(key); t_store.t_store_set_state(key, value);
    key =  t_data.DETAILS_RADIO                ; value = prop.get(key); t_store.t_store_set_state(key, value);

    key =  t_data.TOOLS_SCROLL                 ; value = prop.get(key); t_store.t_store_set_state(key, value);


    let some_change  = "";
    some_change     += save4_tools_panel_layout(transcript1);
    some_change     += save4_tools_panel_layout(transcript2);
    some_change     += save4_tools_panel_layout(fly_div    );

    for(const panel of TOOL_panels)
        some_change += save4_tools_panel_layout( panel );



    if(some_change)
        t_TOOL_SET_eval_wide_or_tall_panel(caller);



    some_change     += t_sticky.t_sticky_STORE();


    if(some_change)
    {
if((log_this || DOM_TOOLS_TAG) && some_change) logBIG(caller+": some_change=["+some_change+"]", lf7);



        t_store4_save_site_layout_step += 1;
        let next_class = STORE_CYCLE_CLASSLIST[t_store4_save_site_layout_step % STORE_CYCLE_CLASSLIST.length];


        set_el_class_removing(hotspot, next_class, t_data.CCX_CLASSLIST);


        setTimeout(
                   function() {

                       del_el_class(hotspot, next_class);
                   }
                   , STORE_CYCLE_CLEAR_DELAY
                  );
    }
};


let   save4_tools_panel_layout = function(panel)
{

let   caller = "save4_tools_panel_layout";
let log_this = LOG_MAP.T0_STORE;


    if(!panel) return "";


    let some_change = "";
    let      key    = panel.id;
    let selected    = t_tools_panel_is_selected(panel);
    if(!selected) {

                       t_store.t_store_set_value(key, null);
        return some_change;
    }

    let pinned = selected && panel.classList.contains(t_data.CSS_PINNED);
    let     xy = t_util.get_el_xy_computed(panel, caller);
    let    map = t_tools_map_get( panel );

    let  value = {  selected : (map && map.selected)
        ,             pinned
        ,                 xy
        ,          magnified : has_el_class(panel,CSS_MAGNIFIED)
    };
if( log_this) log_key_val(key, value, lf3);

    some_change += t_store.t_store_set_value(key, JSON.stringify(value)) ? (" "+key) : "";

if((log_this || DOM_TOOLS_TAG) && some_change) logBIG(caller+": some_change=["+some_change+"]", lf4);
    return some_change;
};


let   save5_wording = function()
{
let   caller = "save5_wording";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log("%c"+caller, lbH+lf5);

    let key, value;


    t_hide.dom_hide2_store_save();

    key =  t_data.WORDING             ; value = prop.get(key)         ; t_store.t_store_set_state(key, value);
    key =  t_data.WORDS_EXACT         ; value = prop.get(key)         ; t_store.t_store_set_value(key, value);
    key =  t_data.WORDS_SEGMENT       ; value = prop.get(key)         ; t_store.t_store_set_value(key, value);
    key =  t_data.WORDS_HEAD_TAIL     ; value = prop.get(key)         ; t_store.t_store_set_value(key, value);
    key =  t_data.WORDS_OPCYCLE       ; value = prop.get(key)         ; t_store.t_store_set_state(key, value);

    for(const affix of get_words_drop_affix_array())
    {
        key     =           affix+"_unchecked";
        let val = !prop.get(affix);

if( log_this) log("%c SAVING  "+t_util.mPadStart(key,32)+"%c"+val, lbL+lf5, lbR+lfX[val ? 4 : 8]);
        t_store.t_store_set_state(key, val);
    }

};


let   load_wording = function()
{

let   caller = "t_load_wording";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log("%c"+caller, lbH+lf6);

    let key, state;

    key =  t_data.WORDING              ; state = (t_store.t_store_getItem(key) == "true"); prop.set(key, state);
    key =  t_data.WORDS_EXACT          ; state = (t_store.t_store_getItem(key) == "true"); prop.set(key, state, t_words_option_select);
    key =  t_data.WORDS_SEGMENT        ; state = (t_store.t_store_getItem(key) == "true"); prop.set(key, state, t_words_option_select);
    key =  t_data.WORDS_HEAD_TAIL      ; state = (t_store.t_store_getItem(key) == "true"); prop.set(key, state, t_words_option_select);
    key =  t_data.WORDS_OPCYCLE        ; state = (t_store.t_store_getItem(key) == "true"); prop.set(key, state, t_words_option_select);

    for(const affix of get_words_drop_affix_array())
    {
        key     = affix+"_unchecked";
        let val = (t_store.t_store_getItem(key) == "true");

if( log_this) log("%c LOADING "+t_util.mPadStart(key,32)+"%c"+val, lbL+lf6, lbR+lfX[val ? 4 : 8]);
        prop.set(affix, !val, t_words_option_select);
    }

    t_words_option_select("INIT");
};



let WORKING_LOCALSTORAGE_DELAY   =  250;
let PENDING_LOCALSTORAGE_DELAY   = 1000;
let FIRST_STORAGE_DELAY          = 5000;
let CSS_STORE_UPDATE_PENDING     = "store_update_pending";

let first_storage_delay_ellapsed = false;

let t_save_update_timer;
let t_save_update_callers = "";
let t_save_update_callers_count   =  0;

let t_save_update_post = function(_caller,delay=WORKING_LOCALSTORAGE_DELAY)
{

    let caller = "t_save_update_post";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log(caller+"("+_caller+")");

    wording_3_CB_WORDS_RECYCLE_SYNC();


    if(               t_save_update_timer ) {
        clearTimeout( t_save_update_timer );
 t_save_update_timer = null;
    }


    if( t_just_loaded("FIRST SESSION LOCAL STORAGE", FIRST_STORAGE_DELAY, log_this) )
        return;

    first_storage_delay_ellapsed = true;


    if(!t_save_update_callers) {
        t_save_update_callers_count   = 1;
        t_save_update_callers = "1 "+ _caller;
if(log_this) log("%c FIRST PENDING LOCAL STORAGE .. %c BY "+t_save_update_callers
                 ,lb3                              ,lb0                                        );
    }


    else {
        t_save_update_callers_count += 1;
if(log_this && !t_save_update_callers.includes(_caller)) t_save_update_callers += LF + t_save_update_callers_count +" "+ _caller;
    }


    t_save_update_timer = setTimeout(save_update_handler, delay);

    add_el_class(hotspot, CSS_STORE_UPDATE_PENDING);

};


let   save_update_handler = function()
{

let   caller = "save_update_handler";
let log_this = LOG_MAP.T0_STORE;



    if( onWork_EL ) {
if(log_this) log(caller+": %c PENDING LOCAL STORAGE POSTPONED BY %c "+get_n_lbl(onWork_EL)+" ", lb3,lb0);

        t_save_update_timer = setTimeout(save_update_handler, PENDING_LOCALSTORAGE_DELAY);
        return;
    }

    t_save_update_timer = null;

    del_el_class(hotspot, CSS_STORE_UPDATE_PENDING);

if(log_this) log(caller+": %c PENDING LOCAL STORAGE (x"+t_save_update_callers_count+") BY: %c"+LF+t_save_update_callers, lb3,lb0);

    save4_layout(t_save_update_callers);
    t_save_update_callers_count   = 0;
    t_save_update_callers = "";

};


let   save_update_is_pending = function()
{
    if(!first_storage_delay_ellapsed)
        return true;
    else
        return !!t_save_update_timer;
};






const SITE_LOCALSTORAGE    = "site_localstorage";


let t_SITE_OR_PAGE_changed = function(id, site_or_page_mode)
{

let   caller = "t_SITE_OR_PAGE_changed";
let log_this = LOG_MAP.T3_LAYOUT;

    site_or_page_mode = (typeof site_or_page_mode != "undefined") ? site_or_page_mode  : prop.get( t_data.SITE_OR_PAGE );

if( log_this)
    log(  "%c"    + caller
         +"%c to "+ site_or_page_mode
         +"%c on "+ (behavior_TOUCH_ELSE_DESKTOP ? "MOBILE" : "DESKTOP")
         , lbL+lf3
         , lbR+lf4
         , lbH+lbb+ (behavior_TOUCH_ELSE_DESKTOP ?      lf7 : lf9   )
       );

    t_store.t_site_or_page_logged_keys_clear(caller);

if(log_this || LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG))
     t_fly.t_fly("<em class='cc3'>"+caller+"</em> to <em class='cc4'>"+site_or_page_mode+"</em> on <em class='cc9'>"+(behavior_TOUCH_ELSE_DESKTOP ? "MOBILE" : "DESKTOP")+"</em>");

if(typeof dom_prop_notify != "undefined") dom_prop_notify(caller);




    let          lfw;
    let      context;
    let   transition;
    let  which_nodes;

    let in_page_mode = !site_or_page_mode;
    let       action =  prop.get(  t_data.MASK_OR_HIDE ) ? "MASKING" : "HIDING";
    let          lfa = (action == "MASKING"     ) ?       lf6 : lf2     ;

    if(!prop.get( t_data.EDIT_OR_STAGE ) )
    {
        context = "WHILE NOT EDITING";
        if( in_page_mode ) {
            transition  = "ENTERING PAGE MODE";
            which_nodes = "SITE AND PAGE NODES";     lfw = lf4;
            t_hide.dom_hide2_store_reload("both");
            del_el_class(hotspot, SITE_LOCALSTORAGE);
        }
        else {
            transition  = "LEAVING PAGE MODE";
            which_nodes = "SITE ONLY NODES";         lfw = lf6;
            t_hide.dom_hide2_store_reload("site");
            add_el_class(hotspot, SITE_LOCALSTORAGE);
        }
    }


    else {
        context = "WHILE EDITING";
        if( in_page_mode ) {
            transition  = "ENTERING PAGE MODE";
            which_nodes = "PAGE ONLY NODES";         lfw = lf5;
            t_hide.dom_hide2_store_reload("page");
            del_el_class(hotspot, SITE_LOCALSTORAGE);
        }
        else {
            transition  = "LEAVING PAGE MODE";
            which_nodes = "SITE ONLY NODES";         lfw = lf6;
            t_hide.dom_hide2_store_reload("site");
            add_el_class(hotspot, SITE_LOCALSTORAGE);
        }
    }

    t_hide.dom_hide3_set_MASK_OR_HIDE();

    if( t_cache_has_been_armed() )
        save4_layout(caller);

if( log_this)
    log("%c"+transition+"%c"+context+"%c"+action +"%c"+which_nodes
        ,lbb+lbL        ,lbb+lbR     ,lbb+lbL+lfa ,lbb+lbR+lfw    );


};


let t_DOM_HIDE1_RESET_changed = function(id, value)
{

let   caller = "t_DOM_HIDE1_RESET_changed("+id+", "+value+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbH+lf5);

    t_hide.dom_hide1_reset();


    setTimeout(function() { del_el_class(prop.get_EL(id), t_data.CSS_CHECKED); }, 1000);

};


let t_DOM_HIDE1_UNDO_changed = function(id, value)
{

let   caller = "t_DOM_HIDE1_UNDO_changed("+id+", "+value+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbH+lf5);

     t_hide .dom_hide_csv_stack_pop(id);

    t_SITE_OR_PAGE_changed(id, prop.get( t_data.SITE_OR_PAGE ));


    setTimeout(function() { del_el_class(prop.get_EL(id), t_data.CSS_CHECKED); }, 1000);

};


let t_EDIT_OR_STAGE_changed = function(id, value)
{

let   caller = "t_EDIT_OR_STAGE_changed("+id+", "+value+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbH+lf5);

    if( value ) t_dom_EDIT_OR_STAGE_start(id, value);
    else        t_dom_EDIT_OR_STAGE_end  (id, value);

};


let t_dom_EDIT_OR_STAGE_start = function()
{

let   caller = "t_dom_EDIT_OR_STAGE_start"; if(typeof dom_prop_notify != "undefined") dom_prop_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbH+lf5);


    t_start_DOM_EDITING();

    t_seek.t_seekzone8_show_gutter_xywh(0, 0, window.innerWidth, window.innerHeight);

    let xy = t_gutter.get_GUTTER_XY();
    if( xy ) t_tools_set_top_xy(xy.x, xy.y);


    set_el_class_removing(hotspot_c, "", t_sticky.CSS_ROTATE_XX);


    t_hide.dom_hide2_store_reload("page");


    prop.set(t_data.MASK_OR_HIDE,  true);
    t_hide.dom_hide3_set_MASK_OR_HIDE();


    t_sync_wording( caller );
};


let t_dom_EDIT_OR_STAGE_end = function ()
{

let   caller = "t_dom_EDIT_OR_STAGE_end"; if(typeof dom_prop_notify != "undefined") dom_prop_notify(caller);
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbH+lf5);


    prop.set(t_data.EDIT_OR_STAGE, false);
    t_stop_DOM_EDITING();

    t_dom_EDIT_drag_hotspot_off_gutter();
    let xy = t_gutter.get_WINDOW_XY();
    if( xy ) t_tools_set_top_xy(xy.x, xy.y);

    t_seek.t_seekzone5_hide("instant");


    prop.set(t_data.MASK_OR_HIDE, false);


    prop.set(t_data.SITE_OR_PAGE, false);


    t_hide.dom_hide2_store_reload("both");
    t_hide.dom_hide3_set_MASK_OR_HIDE(true);


    t_sync_wording( caller );
};


let t_dom_EDIT_drag_hotspot_off_gutter = function(x, y)
{

let   caller = "t_dom_EDIT_drag_hotspot_off_gutter";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"("+x+", "+y+")", lbH+lf5);


    t_seek.t_seekzone8_hide_gutter();

    t_sync_wording(caller);
    t_seek.t_seekzone5_hide("instant");
    t_store_consider_page_items_worth_storing("HOTSPOT OFF GUTTER");
};


let t_start_DOM_EDITING = function()
{
    add_el_class(hotspot, t_data.DOM_EDITING);

    if(    !has_el_class(headsup_ds, t_data.CSS_PINNED)) {
        t_set_CSS_PINNED(headsup_ds, true);

        headsup_ds.was_pinned = true;
    }
};


let t_stop_DOM_EDITING = function()
{
    del_el_class(hotspot, t_data.MARKED_TO_HIDE);

    del_el_class(hotspot, t_data.DOM_EDITING   );

    if(headsup_ds.was_pinned) {
        t_set_CSS_PINNED(headsup_ds, false);

        delete headsup_ds.was_pinned;
    }
};


let t_MASK_OR_HIDE_changed = function(id, value)
{

let   caller = "t_MASK_OR_HIDE_changed("+id+", "+value+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbH+lf5);



    t_hide.dom_hide3_set_MASK_OR_HIDE();

    if( prop.get( t_data.MASK_OR_HIDE ) )
        del_el_class(hotspot , t_data.MARKED_TO_HIDE);
    else
        add_el_class(hotspot , t_data.MARKED_TO_HIDE);

    t_seek.t_seekzone0_show_MASK_OR_HIDE();

    t_SITE_OR_PAGE_changed();
};




let t_PIN_SEEKSPOT_changed = function(id, state)
{

let   caller = "t_PIN_SEEKSPOT_changed";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"("+id+", "+state+")", lbH+lf5);


    if(!state)
    {
        t_fly.t_fly_tooltip_clear(t_data.CSS_EVENT_LOG);
    }
};


let t_SHOW_SEEKZONE_changed = function(id, state)
{

let   caller = "t_SHOW_SEEKZONE_changed";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"("+id+", "+state+")", lbH+lf5);


    if( !state )
    {
        t_seek.t_seekzone5_hide("instant");

        t_fly.t_fly_tooltip_clear(t_data.CSS_STICKY_LOG);
    }

    if(state) add_el_class(document.body, t_data.SHOW_SEEKZONE);
    else      del_el_class(document.body, t_data.SHOW_SEEKZONE);

    t_sticky.t_sticky_SET_DIMMED(!state, "["+id+" "+state+"]");

    t_sticky.t_sticky_SHOW_SEEKZONE_sync(state);


};


let t_WOT_SPLIT_changed = function(id, state)
{
    let by_user_or_from_storage = onWork_EL != null;
    if(!by_user_or_from_storage ) return;
    t_store.t_store_set_state(id, state);

    if(state && !t_wot.t_WOT_SPLIT_done())
    {
        t_wot.t_WOT_SPLIT();
        t_details.details_onload();
        t_sticky .t_sticky_LOAD_ANCHORS_CHANGED();
        if( pat_csv ) pat_bag3_reselect( pat_csv );
    }
    else if( t_wot.t_WOT_SPLIT_done() )
    {
        document.location.reload();
    }
};


let t_LINES_WOT_changed = function(id, state)
{
    let by_user_or_from_storage = onWork_EL != null;
    if(!by_user_or_from_storage ) return;
    t_store.t_store_set_state(id, state);

    if(state) {
        if(!prop.get(t_data.SPLIT_WOT))
            t_store.t_store_set_state(t_data.SPLIT_WOT, true);

        document.location.reload();
    }
    else {
        if( prop.get(t_data.SPLIT_WOT))
            document.location.reload();
    }
};


let t_REMOVE_ADS_changed = function(id, state)
{
    let by_user_or_from_storage = onWork_EL != null;

    if(!by_user_or_from_storage ) return;
    t_store.t_store_set_state(id);

    if(state)
    {
        t_util.t_REMOVE_ADS(id);

        t_sticky.t_sticky_LOAD_ANCHORS_CHANGED();

        if( pat_csv ) pat_bag3_reselect( pat_csv );
    }

};





let behavior_TOUCH_ELSE_DESKTOP;

let shadow_root;

let dom_grid_html;

let hotspot;
let  hotring;
let  hotwave;
let pivspot;

let pat_bag;
let sel_bag;
let headsup;
let headsup_bw;
let headsup_ds;
let headsup_bz;
let headsup_fs;
let headsup_w;

let dom_traversal;
let pivspot_c;
let hotspot_c;

let toolbar_thumb;
let words_filter_input;
let words_node_input;

let test_panel;

let transcript1;
let transcript2;



let  ToolPanel = function(panel, selected)
{

    this.init = function() {
        this.x        =        0;
        this.y        =        0;
        this.w        =        0;
        this.h        =        0;
        this.panel    =    panel;
        this.selected = selected;
        this.p        =       "";
    };


    this.log = function() {

        let   pinned =  this.panel.classList.contains(t_data.CSS_PINNED);

        let      lfx =  pinned                       ? lf2
            :           this.selected                ? lf4
            :                                          lf8;

        let      sym = !this.selected                ? t_data.SYMBOL_CLOSEPIN
            :           pinned                       ? t_data.SYMBOL_PUSH_PIN
            :                                          t_data.SYMBOL_CHECK_MARK;

        let      arr = " "+t_data.SYMBOL_RIGHT_LEFT_ARROW+" ";
        log( " %c "+sym+" " + this.panel.id
            +  " %c   POS=["+ this.p                + arr + this.panel.style.position                                +"]"
            +   " %c  X_Y=["+ this.x +" x "+ this.y + arr + this.panel.offsetLeft   +" x "+ this.panel.offsetTop     +"]"
            +    " %c W_H=["+ this.w +" x "+ this.h + arr + this.panel.offsetWidth  +" x "+ this.panel.offsetHeight  +"]"
            ,  lbH+lfx
            ,    lbH+lf5
            ,     lbH+lf6
            ,      lbH+lf7
           );
    };




    this.init();
};


let tools_map = [];

let t_tools_get_map = function()
{
    return tools_map;
};

let tools_map_set = function(map)
{
    tools_map.push( map );
};

let t_tools_map_get = function(panel)
{
    for(const entry of tools_map) {
        if(   entry.panel == panel)
            return entry;
    }
    return null;
};




let t_tools_loaded = false;
let tools_inlining_has_been_rejected_once;

let t_load_TOOLS_MAP = function(_caller)
{

    if(tools_inlining_has_been_rejected_once) return;

let   caller = "t_load_TOOLS_MAP("+_caller+")";
let log_this = LOG_MAP.T2_GRID || LOG_MAP.T1_DOM_LOAD;

if( log_this) logBIG(caller+": CALLED BY ["+ _caller+"]");

    if((typeof DOM_TOOLS_CSS_TAG == "undefined") || !DOM_TOOLS_CSS_TAG) {
log("%c *** "+caller+": %c TOOLS_CSS INLINING HAS BEEN REJECTED", lb4, lb2);
log_caller();
                        tools_inlining_has_been_rejected_once = true;

        return;
    }


    if( t_tools_loaded ) {

        return;
    }


    if(!shadow_root) shadow_root = document.getElementById("shadow_root");

    if(shadow_root) {
if(log_this) t_log.console_dir("shadow_root:", shadow_root);
    }


    t_tools_loaded = (typeof t_get_tool != "undefined");
if(log_this) log("...t_tools_loaded=["+t_tools_loaded+"]");



    let dom_grid_is_loaded = is_dom_grid_loaded();
    if(!dom_grid_is_loaded )
        log_dom_grid_js_not_loaded(caller+"("+ _caller+")");



    load_TOOLS_MAP_select();



    del_el_class(hotspot, t_data.CSS_HIDDEN);


};


let load_TOOLS_MAP_select = function()
{

let   caller = "load_TOOLS_MAP_select";
let log_this = LOG_MAP.T2_GRID || LOG_MAP.T1_DOM_LOAD;

let dom_load_id = (typeof DOM_LOAD_ID != "undefined") ? DOM_LOAD_ID : "default";
if( log_this) log(caller+": SELECTING TOOLS FOR DOM_LOAD_ID=["+dom_load_id+"] .. ("+TOOL_panels.length+" TOOL panels)");

    if( !t_tools_loaded ) return;

    let selected_count = 0;

    for(let index=0; index < TOOL_panels.length; ++index) {
        let          panel = TOOL_panels[          index];
        if(           !panel ) {
            log("%c *** "+caller+": panel #"+index+" IS MISSING ", lb2);

            continue;
        }
        if((panel == hotspot) || is_a_DOM_LOAD_panel(panel.id))
        {

            let panel_json = t_store.t_store_getItem(panel.id);
if( log_this) log("%c"+index+"%c"+get_n_lbl(panel)+"%c "+panel_json, lbH, lbL+lf1, lbR+lf5);

            let selected;
            if( panel_json ) {
                let value = JSON.parse( panel_json );
                selected  = value.selected;
            }
            else {
                selected = false;
            }


            if( !t_tools_map_get( panel ) )
            {

                tools_map_set(new ToolPanel(panel, selected));

                if(panel != hotspot)
                    t_add_toolpins_on_panel(panel);
            }


            if(panel == hotspot) set_el_class_on_off(panel,t_data.CSS_HIDDEN, false    );
            else                 set_el_class_on_off(panel,t_data.CSS_HIDDEN, !selected);

            selected_count += selected ? 1 : 0;

if(log_this && selected) t_tools_map_get(panel).log(caller+":");

        }
    }
if(log_this) logBIG("tools_map.length=["+tools_map.length+"] selected_count=["+selected_count+"]");
};


let   set_pinned_panels_transform_origin = function()
{

    for(let i=0; i<TOOL_panels.length; ++i)
    {
        let                            panel = TOOL_panels[i];
        if(!t_tools_panel_is_selected( panel            )) continue;
        if(!has_el_class(panel, t_data.CSS_PINNED)) continue;

        t_util.t_adjust_panel_transform_origin( panel );
    }
};


let t_get_selected_count = function(_caller)
{

let log_this = LOG_MAP.T2_GRID;

if( log_this) log("t_get_selected_count: CALLED BY ["+ _caller+"]");

    let selected_count = 0;

    for(let index=0; index < TOOL_panels.length; ++index) {
        let          panel = TOOL_panels[          index];
        if(!panel) {
            log("%c *** t_get_selected_count: panel #"+index+" IS MISSING ", lb2);
            continue;
        }
        let         key = panel.id+".selected";
        let    selected = t_store.t_store_getBool(key) ? true : false;

        selected_count += selected ? 1 : 0;
    }

if(log_this) log("t_get_selected_count: ...return "+selected_count);
    return selected_count;
};



let t_TOOLS_panels_reload = function(msg="")
{

let   caller = "t_TOOLS_panels_reload";
let log_this = LOG_MAP.T2_GRID || LOG_MAP.T1_DOM_LOAD;

if( log_this) log(caller+"("+msg+")");


    if(!t_tools_loaded) return;
    let selected_count = 0;

    for(const [index , panel] of TOOL_panels.entries())
    {
        if(!panel) continue;

        let panel_json = t_store.t_store_getItem(panel.id);




        let value = JSON.parse( panel_json ) || { selected:false } ;
        if( value.pinned && value.xy )
        {
            let vp_xy = t_view.t_view5_move_panel_XY(panel, value.xy.x, value.xy.y);

            t_pin_panel_at_XY(panel, vp_xy.x, vp_xy.y, "fixed", index+t_data.ZINDEX_PINNED_PANEL_ZERO);
        }

        if(panel == hotspot) continue;

        t_tools_panel_select(panel, value.selected);

        selected_count += value.selected ? 1 : 0;


        if(!t_has_push_pin_on_panel( panel ) ) t_add_toolpins_on_panel  (panel);
        else                                   t_eval_wide_or_tall_panel(panel);


    }




    load5_STORAGE_hotspot();

if( log_this || DOM_TOOLS_TAG) log("%c TOOL PANELS RELOAD %c"+tools_map.length+" RELOADED %c"+selected_count+" SELECTED", lbL, lbC, lbR+lf5);
};


let t_tools_panel_select = function(panel, state=true)
{

let caller = "t_tools_panel_select";
let log_this = LOG_MAP.T2_GRID;

if( log_this)          caller += "("+get_n_lbl(panel)+", "+state+")";
if( log_this) log("%c"+caller, lfX[state ? 5:8]);


    if( prop.get( t_data.TOOLS_TIER2 ) )
    {
        pulse_id( t_data.TOOLS_TIER2 );

        return;
    }

    let map = t_tools_map_get( panel );
    if(!map) return;
    if( map.selected != state)
    {
if(log_this || DOM_TOOLS_TAG) log((state ? "SHOWING" : "HIDING")+" "+get_n_lbl(panel));

        t_grid.t_grid_TOOLS_SELECT_panel(panel, state);

        set_el_class_on_off(panel,t_data.CSS_HIDDEN, !map.selected);

        t_sync_layout(caller);
    }


    t_sync_tools_tier2(caller);
};



let   set_tool_id_value = function(id, value)
{
    let el = t_get_tool(id);
    if( el ) el.value     = value;
    if( el ) el.value_set = value;
};


let t_get_tool_id_value = function(id)
{
    let el = t_get_tool(id);
    if( el ) return el.value;
    else     return       "";
};


let t_get_bag_id = function(el)
{

    for(let node  = el; node != null; node = node.parentNode)
        if( get_node_bag_id ( node ) )         return node.id;


    if( t_util.is_el_child_of_class(el, "prop_bag") ) return "prop_bag";


    else                                       return "";
};


let get_node_bag_id = function(node)
{
    if(node.id == "fly_div"            ) return node.id;

    if(t_seek.t_seeker_get_node_bag_id( node )) return node.id;

    if(node.id == "sel_bag"            ) return node.id;
    if(node.id == "pat_bag"            ) return node.id;
    if(node.id == "off_bag"            ) return node.id;
    if(node.id == "alt_bag"            ) return node.id;
    if(node.id == "bak_bag"            ) return node.id;

    if(node.id == "headsup"            ) return node.id;
    if(node.id == "headsup_w"          ) return node.id;
    if(node.id == "headsup_ds"         ) return node.id;
    if(node.id == "headsup_bw"         ) return node.id;
    if(node.id == "headsup_bz"         ) return node.id;
    if(node.id == "headsup_fs"         ) return node.id;

    if(node.id == "test_panel"         ) return node.id;
    if(node.id == "dev_log_map"        ) return node.id;
    if(node.id == "dom_load_tags"      ) return node.id;
    if(node.id == "dom_traversal"      ) return node.id;

    if(node.id == "transcript1"        ) return node.id;
    if(node.id == "transcript2"        ) return node.id;

    return "";
};


let t_get_tool = function(id)
{
    if( id.includes(" ") ) return null;
    let selector
        = (id.charAt(0) != ".") && (id.charAt(0) != "#")
        ?  "#"+id
        :      id;

    let el;
    try {
        if( shadow_root ) el = shadow_root.querySelector( selector );
        if(!el          ) el = document   .querySelector( selector );
    }
    catch(ex) { if(DOM_TOOLS_LOG) { console.log("selector=["+selector+"]"); console.warn(ex); } }


    return el;
};


let t_get_shadow_tool = function(id)
{
    if(!dom_tools_html)
        return false;

    let el = t_get_tool( id );
    if(!el)
        return null;

    return t_util.is_el_or_child_of_parent_el(el, dom_tools_html)
        ?   el
        :   null;
};


let is_a_seeker_target = function(el)
{
    let node_selected = t_select.t_is_node_selected(el);
    let        sticky = t_util.get_el_parent_with_class(el, t_data.CSS_STICKY_TOOL);


    return node_selected || sticky;
};




const T_UPDATE_TOOLS_MAP_GEOMETRY_DELAY = 1000;
let   t_update_TOOLS_MAP_GEOMETRY_timer;


let   t_update_TOOLS_MAP_GEOMETRY = function(_caller, delay=T_UPDATE_TOOLS_MAP_GEOMETRY_DELAY)
{

let   caller ="t_update_TOOLS_MAP_GEOMETRY()";
let log_this = LOG_MAP.T2_GRID;

if( log_this) log(caller+"("+ _caller+", delay=["+delay+"])");

    if(       t_update_TOOLS_MAP_GEOMETRY_timer ) clearTimeout( t_update_TOOLS_MAP_GEOMETRY_timer );
              t_update_TOOLS_MAP_GEOMETRY_timer = null;

    if(delay) t_update_TOOLS_MAP_GEOMETRY_timer =   setTimeout( t_update_TOOLS_MAP_GEOMETRY_handler, delay);
    else                                                        t_update_TOOLS_MAP_GEOMETRY_handler();
};


let t_update_TOOLS_MAP_GEOMETRY_handler = function()
{

let   caller ="t_update_TOOLS_MAP_GEOMETRY_handler";
let log_this = LOG_MAP.T2_GRID;



if( log_this) log("%c"+caller, lbH);

    t_update_TOOLS_MAP_GEOMETRY_timer = null;


    if(!t_tools_loaded) t_load_TOOLS_MAP(caller);
    let zIndexOffset = 0;

    for(const map of tools_map)
    {

        let panel =       map.panel;


        if( has_el_class(panel, t_data.CSS_ON_GRID))
        {
if(log_this) log("%c"+caller+" ["+panel.id+"] "+t_data.CSS_ON_GRID, lbb+lbH+lf7);

if(log_this) log_caller();
            return;
        }
        if( has_el_class(panel, t_data.CSS_HIDDEN )) continue;

        if(!t_tools_panel_is_selected(panel)) continue;



        if(!panel.style.position) {
            panel.style.position = prop.get( t_data.TOOLS_SCROLL ) ? "absolute" : "fixed";

        }



        map.p   = panel.style.position;
        map.w   = panel.offsetWidth;
        map.h   = panel.offsetHeight;
        map.x   = panel.offsetLeft;
        map.y   = panel.offsetTop;

if(log_this) map.log("...");



        let cap_to_viewport = panel.classList.contains(t_data.CSS_PINNED);

        if( cap_to_viewport )
        {


            let xy = t_view.t_view5_move_panel_XY(panel);

                let zIndex = ++zIndexOffset + t_data.ZINDEX_PINNED_PANEL_ZERO;
                t_pin_panel_at_XY(panel, xy.x, xy.y, "fixed", zIndex);
                map.x = xy.x;
                map.y = xy.y;
                t_save_update_post(caller);



        }

    }
if( log_this) log("%c"+caller+"%c done", lbH, lbH);
};


let t_update_panel_TOOLS_MAP_GEOMETRY = function(panel)
{
    let map = t_tools_map_get( panel );
    if(!map) return;


    map.x   = panel.offsetLeft;
    map.y   = panel.offsetTop;
    map.w   = panel.offsetWidth;
    map.h   = panel.offsetHeight;


};


let t_dom_tools_html_appendChild = function(child)
{
    if(dom_tools_html) dom_tools_html.appendChild( child );
    else               document.body .appendChild( child );
};


let t_dom_tools_html_set_el_class_on_off = function(css,state)
{
    if(dom_tools_html) set_el_class_on_off(dom_tools_html, css, state);
};


let t_set_id_class_on_off = function(id, className, on_off)
{

    let el = t_get_tool(id);
    if(!el) return;

    t_util.set_el_class_on_off(el, className, on_off);
};








let onDown_HSPOT_XY        = { x:0, y:0 };
let onDown_TOOL_XY         = { x:0, y:0 };
let onDown_PANEL_XY        = { x:0, y:0 };
let onDown_XY_sign         = { x:0, y:0 };
let onMove_pivotXY         = { x:0, y:0 };


let onDown_SCROLL_XY        = { x:0, y:0 };


let onWork_PANEL           = null;
let onWork_PANEL_was_magnified_onMove;
let pivot_PANEL            = null;
let onStandby_PANEL        = null;
let onWork_PANEL_magnified = null;
let onWork_MOVABLE_PANEL   = null;


let onDown_EL              = null;
let onWork_EL              = null;
let onWork_MOVABLE_CHILD   = null;
let onWork_EL_last_used    = null;


let onDown_SHIFT           = false;
let onDown_ALT             = false;
let onDown_CTRL            = false;


let onDownPMS              = 0;
let onDown_MS              = 0;
let onUp_MS                = 0;









let t_add_input_listener = function(el)
{
    add_listener_capture_active(el, "keydown", t_input_2_CB);
    add_listener_capture_active(el, "keyup"  , t_input_2_CB);
    add_listener_capture_active(el, "change" , t_input_2_CB);
};


let t_add_LISTENERS = function()
{

let   caller = "t_add_LISTENERS";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) log("%c"+caller, lbb+lbH+lf2);


    add_listener_capture_active(       window, "beforeunload"     , load_listener);
    add_listener_capture_active(       window,       "unload"     , load_listener);


    add_listener_capture_active(       window, "scroll"           , dom_scroll.t_scroll_listener);
    add_listener_capture_active(       window, "resize"           , t_resize_listener);
    add_listener_capture_active(       window, "orientationchange", t_orient_listener);


    if( ("ontouchstart" in document.documentElement)) {
        add_listener_capture_active(   window, "touchstart"       , t_pointerdown_listener);
        add_listener_capture_active(   window, "touchend"         , t_pointerup_listener);
    }

    else {
        add_listener_capture_active(   window, "mousedown"        , t_pointerdown_listener);
        add_listener_capture_active(   window, "mouseup"          , t_pointerup_listener);
    }

if( log_this) {
    log("%c"+load_listener          .name+"%c beforeunload unload %c window",lbL,lbF+lf1,lbR);
    log("%c"+dom_scroll.t_scroll_listener      .name+"%c scroll              %c window",lbL,lbF+lf3,lbR);
    log("%c"+t_resize_listener      .name+"%c resize              %c window",lbL,lbF+lf3,lbR);
    log("%c"+t_orient_listener      .name+"%c orientationchange   %c window",lbL,lbF+lf3,lbR);

    log("%c"+t_pointerdown_listener .name+"%c mousedown           %c window",lbL,lbF+lf4,lbR);
    log("%c"+t_pointerup_listener   .name+"%c mousedown           %c window",lbL,lbF+lf4,lbR);
    log("%c"+t_pointerdown_listener .name+"%c touchstart          %c window",lbL,lbF+lf5,lbR);
    log("%c"+t_pointerup_listener   .name+"%c touchend            %c window",lbL,lbF+lf5,lbR);

}



    let inputs = dom_tools_html.getElementsByTagName("INPUT");
    for(let i=0; i < inputs.length ; ++i) {
        if( inputs[i].id ) {
if( log_this) log("%c"+t_input_2_CB.name+"%c onkeyup onchange %c"+(inputs[i].id || ("INPUT #"+i)),lbL,lbF+lf2,lbR);
            add_listener_capture_active(inputs[i], "keydown"      , t_input_2_CB);
            add_listener_capture_active(inputs[i], "keyup"        , t_input_2_CB);
            add_listener_capture_active(inputs[i], "change"       , t_input_2_CB);
        }
    }

    add_listener_capture_active(document.body, "keydown", t_window_2_keyup_CB);
    add_listener_capture_active(document.body, "keyup"  , t_window_2_keyup_CB);


    document.onselectstart=null;


    let html = document.getElementsByTagName("HTML")[0];
    html.style.scrollBehavior = "initial";
};


let t_del_listeners = function()
{
let   caller = "t_del_listeners";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) log(caller, "info");


    remove_listener_capture_active    (window, "orientationchange", t_orient_listener);
    remove_listener_capture_active    (window, "resize"           , t_resize_listener);
    remove_listener_capture_active    (window, "scroll"           , dom_scroll.t_scroll_listener);


    if( ("ontouchstart" in document.documentElement)) {
        remove_listener_capture_active(window, "touchstart"       , t_pointerdown_listener);
        remove_listener_capture_active(window, "touchend"         , t_pointerup_listener);
    }

    else {
        remove_listener_capture_active(window, "mousedown"        , t_pointerdown_listener);
        remove_listener_capture_active(window, "mouseup"          , t_pointerup_listener);
    }


    del_page_and_tool_pointermove_listeners(caller);
};




let t_add_tool_pointermove_listener = function(_caller)
{

let  caller = "t_add_tool_pointermove_listener";
    let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) t_fly.t_log_event_status(caller+" .. CALLED BY "+ _caller, lf2);

    if("ontouchmove"  in document.documentElement)
        add_listener_capture_active(   window, "touchmove"     , t_TOOL_pointermove_drag);
    else
        add_listener_capture_active(   window, "mousemove"     , t_TOOL_pointermove_drag);
};


let add_page_pointermove_listener = function(_caller)
{

let   caller = "add_page_pointermove_listener";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) t_fly.t_log_event_status(caller+" .. CALLED BY "+ _caller, lf2);


    if("ontouchmove"  in document.documentElement)
        add_listener_capture_active(   window, "touchmove"     , t_PAGE_pointermove_drag);
    else
        add_listener_capture_active(   window, "mousemove"     , t_PAGE_pointermove_drag);
};


let del_page_and_tool_pointermove_listeners = function(_caller)
{
let   caller = "del_page_and_tool_pointermove_listeners";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) t_fly.t_log_event_status(caller+" .. CALLED BY "+ _caller, lf2);


    remove_listener_capture_active(    window, "mousemove"     , t_PAGE_pointermove_drag);
    remove_listener_capture_active(    window, "touchmove"     , t_PAGE_pointermove_drag);

    remove_listener_capture_active(    window, "mousemove"     , t_TOOL_pointermove_drag);
    remove_listener_capture_active(    window, "touchmove"     , t_TOOL_pointermove_drag);
};




let CAPTURE_TRUE_PASSIVE_FALSE  = { capture:true , passive:false };

let add_listener_capture_active = function(el, ev, fn)
{
    if(!el) return;
if(LOG_MAP.EV0_LISTEN) log("%c add_listener_capture_active("+get_n_lbl(el)+", "+ev+")", lbF+lb8);

    el.   addEventListener(ev, fn, CAPTURE_TRUE_PASSIVE_FALSE);
};


let remove_listener_capture_active = function(el, ev, fn, uc)
{
let log_this = LOG_MAP.EV0_LISTEN;

    if(!el) return;
if(log_this) log("%c remove_listener_capture_active("+get_n_lbl(el)+" "+ev+" "+fn.name+")", lbH+lf8);

    el.removeEventListener(ev, fn, CAPTURE_TRUE_PASSIVE_FALSE);
};




let t_acceptBubble = function(e, msg, log_this)
{
    log_this = log_this || DOM_TOOLS_TAG || DOM_TOOLS_LOG;
    if( log_this )
    {
        t_fly.t_log_transcript_event_top("<span style='color:yellow;'>"+ t_data.SYMBOL_BLACK_CIRCLE +"</span>"
            +                            " ACCEPT BUBBLE <em>"+          e.type                     +"</em>"
            +                            " <em>"+                        msg                        +"</em>"
        );
        log_caller();
    }

    t_select.t_slot_visibility_changed();
};



let t_preventDefault_caller;


let t_preventDefault = function(e, preventDefault_caller)
{

    if(t_preventDefault_caller) return;
    t_preventDefault_caller = preventDefault_caller;

let caller = "t_preventDefault";
let log_this = DOM_TOOLS_LOG && !onDown_SHIFT && LOG_MAP.EV7_DISPATCH;

if( log_this)
{
    caller += "("+e.type+" .. "+preventDefault_caller+")";
    t_fly.t_log_event_status(caller, lbF+lf3);

    log_key_val( "BUBBLE .. CANCEL .. PROPAGATION"
                 , {   bubbles                  : e.bubbles
                     , cancelable               : e.cancelable
                     , defaultPrevented         : e.defaultPrevented
                     , preventDefault           : e.preventDefault
                     , stopImmediatePropagation : e.stopImmediatePropagation
                     , stopPropagation          : e.stopPropagation
                     , cancelBubble             : e.cancelBubble
                     , returnValue              : e.returnValue
                 }
                 , lbH+lf8
               );
    t_log.console_dir(e.type, e);
}


    if(e.cancelable)
    {
        if( e.stopPropagation          ) e.stopPropagation         ();
        if( e.stopImmediatePropagation ) e.stopImmediatePropagation();
        if( e.preventDefault           ) e.preventDefault          ();
    }
};



let t_preventDefault_has_been_called = function()
{

    return  t_preventDefault_caller;
};


let t_restoreDefault = function(restoreDefault_caller)
{
let log_this = t_log.logging_something();

if(log_this && t_preventDefault_caller) {

    if(log_this)
        t_fly.t_log_transcript_event_bot( "<span style='color:green;'>"+ t_data.SYMBOL_BLACK_CIRCLE +"</span>"
            +                      " <span style='text-decoration:line-through;'>preventDefault</span>"
            +                      " <em>"+ restoreDefault_caller +"</em> was set by "+ t_preventDefault_caller
        );

}
    t_preventDefault_caller = "";
};




let t_event_consumed_cause = "";



let t_event_set_e_consumed_by = function(e, consume_cause)
{
    t_event_consumed_cause = consume_cause;
};


let t_event_add_e_consumed_by = function(e, consume_cause)
{
let log_this = DOM_TOOLS_LOG && !onDown_SHIFT && t_log.logging_something();
if( log_this) log("t_event_add_e_consumed_by: %c "+consume_cause, lb0);
if( log_this) log_caller();


    t_event_consumed_cause
        += t_event_consumed_cause ? LF+consume_cause
        :                              consume_cause;
};


let t_event_has_been_consumed = function()
{


    return   t_event_consumed_cause.includes(LF)
        ? LF+t_event_consumed_cause
        :    t_event_consumed_cause
    ;

};


let t_event_clr_consumed = function()
{

    t_event_consumed_cause   = "";
};


let t_is_an_embedded_doc_tool = function(e_target,log_this)
{
    let result
        =                 has_el_class(e_target, CSS_EMBEDDED_DOC_TOOL)
        || t_util.is_el_child_of_class(e_target, CSS_EMBEDDED_DOC_TOOL)
    ;

if( log_this )
    log_key_val_group("t_is_an_embedded_doc_tool("+get_id_or_tag(e_target)+")"
                      , { get_EL_slot                          : get_EL_slot                (e_target)
                        , has_el_class_CSS_DOC_HANDLER_IGNORED : has_el_class               (e_target, CSS_EMBEDDED_DOC_TOOL)
                        , child_of_CSS_DOC_HANDLER_IGNORED     : t_util.is_el_child_of_class(e_target, CSS_EMBEDDED_DOC_TOOL)
                        ,                               result
                        ,                              callers : t_log.get_callers()
                      }, lb5, false
                     );


    return (result == null) ? false : result;
};



const MOVED_ENOUGH = 16;
let has_moved      = "";



let t_clr_has_moved = function(_caller)
{

    has_moved     = "";
    dom_scroll.clr_has_been_scrolled_by_script();
};


let t_set_has_moved = function(_caller)
{

let log_this = LOG_MAP.EV0_LISTEN || LOG_MAP.EV1_DOWN || LOG_MAP.EV2_MOVE || LOG_MAP.EV4_LONG_PRESS ;

if( log_this && !has_moved) t_fly.t_log_event_status("t_set_has_moved "+ _caller, lf3);

    has_moved = _caller;


    if( is_long_press_pending() )
        del_long_press_listener(has_moved);
};

let   check_has_moved       = function(_caller) { return check_has_moved_dx_dy(_caller,   MOVED_ENOUGH); };
let   check_big_moved       = function(_caller) { return check_has_moved_dx_dy(_caller, 2*MOVED_ENOUGH); };
let   check_has_moved_dx_dy = function(_caller, d_min=MOVED_ENOUGH)
{
    if( has_moved && (d_min <= MOVED_ENOUGH)) return  true;
    if(!onWork_EL                           ) return false;
    if( onDown_7_STALL_is_pending()         ) return false;
    if(onDown_TOUCHES > 1                   ) return false;


    let    dx = onMoveDXY.x;
    let    dy = onMoveDXY.y;
    let dx_dy = Math.max(Math.abs(dx), Math.abs(dy));
    if( dx_dy < d_min) return false;


    t_set_has_moved("[has_moved "+dx_dy+"px] ["+_caller+"] ["+get_n_lbl(onWork_EL)+"]");

    if( has_moved )
        t_seek.t_seeker_onMove2_DXY(onMoveDXY);

let log_this = LOG_MAP.EV0_LISTEN;
    if(log_this)
    {
        t_log.console_warn(has_moved +": "+_caller+"("+dx_dy+")"



        );
        t_log.console_dir(_caller, onWork_EL);
        t_fly.t_log_event_status(_caller+"("+dx_dy+") .. CALLED BY "+ _caller, lf2);

    }
    return true;
};



const T_EVENT_DEBOUNCE_DELAY = 100;
let   t_last_handled_event_of_type_MS = {};


let t_is_bouncing_e_type = function(e_type, _caller, delay_min=T_EVENT_DEBOUNCE_DELAY)
{
let log_this = t_log.logging_something();

    let last_MS = t_last_handled_event_of_type_MS[e_type] || 0;

    let this_MS = new Date().getTime() % 86400000;
    let delay   = this_MS - last_MS;

    let bouncing = (delay < delay_min);

    t_last_handled_event_of_type_MS[e_type] = this_MS;

if(log_this && bouncing) log("t_is_bouncing_e_type(%c "+e_type+" %c) %c .. CALLED BY ["+_caller+"] %c .. DEBOUNCED: ["+Math.floor(delay)+"ms < "+delay_min+"] .. onWork_EL=["+get_n_lbl(onWork_EL)+"] onWork_PANEL=["+get_n_lbl(onWork_PANEL)+"]",lb5,lbA, lb6,lbA);
    return bouncing;
};


let t_log_clr_status = function()
{
    t_fly.t_fly_clr_status();

    t_event_clr_consumed();
    t_preventDefault_caller  = "";
};








let t_set_onWork_EL = function(el,_caller,e)
{

let   caller = "t_set_onWork_EL";
let log_this = LOG_MAP.EV0_LISTEN || LOG_MAP.EV1_DOWN || LOG_MAP.EV5_TOOL_CB;

if( log_this ) log("%c"+caller+"%c("+get_n_lbl(el)+") %c CALLED BY "+ _caller, lbL+lf1, lbC+lf9, lbR);


    clr_onWork_EL(caller);

    if(!el) return;




    let     sticky = e && t_sticky.t_sticky_set_onWork_STICKY(el,e);

    onDown_EL      = sticky ? sticky : el;
    onWork_EL      = onDown_EL;
    if(onDown_EL == hotspot) onDown_EL = hotring;

    if(!onWork_EL_last_used) set_onWork_EL_last_used( onWork_EL );

    onDown_TOOL_XY = t_util.get_el_xy(onWork_EL);



    if(onWork_EL.tagName == "INPUT")
        t_focus( onWork_EL );



    set_onWork_MOVABLE_CHILD(onWork_EL, _caller);



    set_onWork_PANEL();



    onDown_HSPOT_XY.x        = h_x;
    onDown_HSPOT_XY.y        = h_y;

    onDown_XY_sign.x         = (onDown_HSPOT_XY.x < pivotXY.x) ? 1 : -1;
    onDown_XY_sign.y         = (onDown_HSPOT_XY.y < pivotXY.y) ? 1 : -1;

    onMove_pivotXY.x         = pivotXY.x;
    onMove_pivotXY.y         = pivotXY.y;





if(typeof t_grid.t_grid_onWork_EL_changed != "undefined") t_grid.t_grid_onWork_EL_changed(_caller);



    if(onWork_PANEL_magnified) {
        let        scale = t_util.t_get_panel_scale(onWork_PANEL_magnified);
        onDown_TOOL_XY.x = onWork_PANEL_magnified.offsetLeft + Math.round(onWork_EL.offsetLeft * scale);
        onDown_TOOL_XY.y = onWork_PANEL_magnified.offsetTop  + Math.round(onWork_EL.offsetTop  * scale);
    }


};


let clr_onWork_EL = function(_caller)
{

let   caller = "clr_onWork_EL";
let log_this = LOG_MAP.EV0_LISTEN || LOG_MAP.EV1_DOWN || LOG_MAP.EV5_TOOL_CB;

if( log_this ) log("%c"+caller+" %c CALLED BY "+ _caller, lbL+lf8,lbR+lf8);


    onWork_MOVABLE_CHILD    = null;
    onWork_MOVABLE_PANEL    = null;
    onWork_PANEL_magnified  = null;

    set_onWork_EL_last_used( onWork_EL );

    if(onWork_EL) clr_onWork_EL_pressed();
    onWork_EL               = null;

    onWork_PANEL            = null;


};


let set_onWork_PANEL = function()
{

let caller = "set_onWork_PANEL";
let log_this = LOG_MAP.EV0_LISTEN || LOG_MAP.EV1_DOWN || LOG_MAP.EV5_TOOL_CB;



    onWork_PANEL = get_el_PANEL( onWork_EL );



    if(onWork_PANEL)
        onWork_PANEL.scale = t_util.t_get_panel_scale(onWork_PANEL);

    onWork_PANEL_magnified
        = has_el_class(onWork_PANEL, CSS_MAGNIFIED)
        ?              onWork_PANEL
        :              null;

    let  xy
        = onWork_PANEL
        ? t_util.get_el_xy(onWork_PANEL, caller)
        : { x:0 , y:0 };
    onDown_PANEL_XY.x   = xy.x;
    onDown_PANEL_XY.y   = xy.y;



    onWork_MOVABLE_PANEL
        = is_a_movable_panel(onWork_PANEL)
        ?                    onWork_PANEL
        :                    null;



    if( onWork_PANEL )
    {
        if(!t_tools_loaded  ) t_load_TOOLS_MAP(caller);

        let map             = t_tools_map_get(onWork_PANEL);
        if( map ) {
            map.x           = xy.x;
            map.y           = xy.y;
        }

    }


    if(onWork_PANEL)
    {
        for(let i=1; i< TOOL_panels.length; ++i)
        {
            let panel = TOOL_panels[i]; if(!panel) continue;
            let is_a_pinned_work_panel  = ( panel ==  onWork_PANEL                 )
                &&                          panel.classList.contains(t_data.CSS_PINNED    );

            let was_a_pinned_work_panel = !is_a_pinned_work_panel
                &&                          panel.classList.contains(t_data.CSS_WORK_PANEL);

            if(      is_a_pinned_work_panel ) { add_el_class( panel, t_data.CSS_WORK_PANEL); if(log_this) log(caller+"%c...SELECTING "+panel.id, lf4); }
            else if(was_a_pinned_work_panel ) { del_el_class( panel, t_data.CSS_WORK_PANEL); if(log_this) log(caller+"%c...RELEASING "+panel.id, lf8); }
        }
    }

if( log_this) log("%c"+caller+"%c onWork_PANEL=["+get_n_lbl(onWork_PANEL)+"] %c onWork_MOVABLE_PANEL=["+get_n_lbl(onWork_MOVABLE_PANEL)+"]"
                  ,lbL+lf1    ,lbC+lf3                                      ,lbR+lf4                                                       );
};


let set_onWork_MOVABLE_CHILD = function(el, _caller)
{
    let sticky = t_sticky.t_sticky_get_onWork_STICKY();
    if(el == sticky) onDown_TOOL_XY.y += sticky.offsetHeight/2;

    onWork_MOVABLE_CHILD = is_a_movable_TOOL_CHILD(el)
        ?                                          el
        :                                          null;
};



let set_onWork_EL_last_used = function(el)
{


    if(el) onWork_EL_last_used = el;



};


let set_onWork_EL_pressed = function()
{


    if(!onWork_EL                       ) return;
    if( onWork_EL == onWork_PANEL       ) return;
    if( onWork_EL == div_slot_containers) return;

    del_el_class(onWork_EL     , t_data.CSS_DIMMED);
    add_el_class(onWork_EL     , t_data.CSS_PRESSED);
    if( t_util.is_el_or_child_of_parent_el(onWork_EL, hotspot) )
        add_el_class(dom_tools_html, t_data.CSS_PRESSED);


    if(has_el_class(onWork_EL, t_data.CSS_STICKY_TOOL))
    {
        t_sticky.t_sticky_move_z_on_top(onWork_EL);
        t_sticky.t_sticky_SET_DIMMED(false, "ON PRESS");
    }


};


let clr_onWork_EL_pressed = function()
{

    if(!onWork_EL                       ) return;
    if( onWork_EL == onWork_PANEL       ) return;
    if( onWork_EL == div_slot_containers) return;
    del_el_class(onWork_EL     , t_data.CSS_PRESSED);
    del_el_class(dom_tools_html, t_data.CSS_PRESSED);




 del_el_class(onWork_EL       , t_data.CSS_PRESSED);
    t_seek.t_seekzone_clr_onWork_EL_pressed();
};



let get_el_PANEL = function(el)
{

    let fly_div = t_fly.t_fly_div_get();
    let tool_panel = null;
    if(      t_util.is_el_or_child_of_parent_el(el, hotspot  ) ) tool_panel =   hotspot;
    else if( t_util.is_el_or_child_of_parent_el(el, fly_div  ) ) tool_panel =   fly_div;
    else if( t_util.is_el_or_child_of_parent_el(el, dimm_mask) ) tool_panel = dimm_mask;
    else {
        for(let i=1; i< TOOL_panels.length; ++i) {
            let panel = TOOL_panels[i];
            if( t_util.is_el_or_child_of_parent_el(el, panel) )
            {
                tool_panel = panel;
                break;
            }
        }
    }


    if(!tool_panel) tool_panel = t_seek.t_seeker_get_tool_panel(el);




    return tool_panel;
};


let get_onWork_TOOL_label = function()
{
    return (onWork_PANEL ?       get_n_lbl(onWork_PANEL)      : "")
        +  (onWork_EL    ? " ("+ get_n_lbl(onWork_EL   ) +")" : "")
    ;
};






let onDown_SELECTION       = null;
let onDown_SEL_TEXT        =   "";


let get_onDown_SELECTION = function()
{
    onDown_SELECTION = window.getSelection();


    onDown_SEL_TEXT  = t_get_current_sel_text();

    return onDown_SEL_TEXT;
};


let t_get_current_sel_text = function()
{
    let selection = window.getSelection();
    return (selection)
        ?   selection.toString().trim()
        :   "";


};


let t_get_onDown_SEL_TEXT = function()
{
    if(!onDown_SEL_TEXT) return "";

    let sel_text = t_util.trim_space_lf( onDown_SEL_TEXT );



    onDown_SEL_TEXT = "";

    return sel_text;
};


let t_window_getSelection_removeAllRanges = function(_caller)
{
let  caller = "t_window_getSelection_removeAllRanges";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) t_fly.t_log_event_status(caller+": .. CALLED BY "+ _caller, lf2);

    let something_removed = t_util.clearSelection();
    if( something_removed ) t_sticky.t_sticky_set_SEL_PASTE_TARGET_STATE(false);
};




let     onDown_XY = { x:0, y:0 };
let set_onDown_XY = function(e, _caller)
{

    let      xy = get_event_XY(e);
    onDown_XY.x = xy.x;
    onDown_XY.y = xy.y;

};


let t_get_onDown_XY = function()
{
    return onDown_XY;
};


let     onMoveDXY = { x:0, y:0 };
let get_onMoveDXY = function(e)
{
    if(e) {
        let      xy = get_event_XY(e);
        onMoveDXY.x = xy.x - onDown_XY.x;
        onMoveDXY.y = xy.y - onDown_XY.y;
    }

    return onMoveDXY;
};


let zap_onMoveDXY = function()
{
    onDown_XY.x += onMoveDXY.x;
    onDown_XY.y += onMoveDXY.y;
    drag_cursor.show_drag_cursor();
    onMoveDXY.x  = 0;
    onMoveDXY.y  = 0;
};





const T_RAISE_PIVOT_PANEL_DELAY_LONG  = 2000;
const T_RAISE_PIVOT_PANEL_DELAY_SHORT =  500;

let   t_raise_pivot_PANEL_timer;
let   pivot_PANEL_changed_since_onDown;



let pivotXY = { x:512 , y:512 };


let t_set_pivot_PANEL = function(panel,_caller)
{

let   caller = "t_set_pivot_PANEL";
let log_this   = LOG_MAP.T4_PIVOT;

if(log_this) t_fly.t_log_event_status(caller+"("+get_n_lbl(panel)+") "+_caller, lf1);


    if((panel == pat_bag) && off_bag && (pivot_PANEL != pat_bag))
        t_pat_bag_open_or_close("SET PIVOT PANEL [pat_bag]");



    if(pivot_PANEL && (pivot_PANEL == panel))
    {
if(log_this) log("%c"+caller+": UNCHANGED", lbF+lb2);

        return;
    }


    if(pivot_PANEL) {
        if( t_is_panel_magnified( pivot_PANEL ) )
        {
            let pinned =  pivot_PANEL.classList.contains(t_data.CSS_PINNED);
            if(!pinned) t_toggle_panel_magnified(pivot_PANEL, false);
        }
    }


    pivot_PANEL_changed_since_onDown = "from ["+get_n_lbl(pivot_PANEL)+"] to ["+get_n_lbl(panel)+"]";
if( log_this) log("pivot_PANEL_changed_since_onDown=["+pivot_PANEL_changed_since_onDown+"]");

    if(pivot_PANEL) t_set_CSS_PIVOT_PANEL(pivot_PANEL, false);


    pivot_PANEL = panel;

    if( !pivot_PANEL ) {
        t_set_pivotXY(h_x, h_y);
        return;
    }

    if(panel != hotspot) {
        t_set_CSS_PIVOT_PANEL(pivot_PANEL,  true);
        t_layout_panel_magnified(panel , prop.get( t_data.PIVOT_MAGNIFIED ));
    }
    else {
if( log_this) log(caller+": (panel == hotspot)");
    }


    let map = t_tools_map_get(pivot_PANEL);
    if(!map) {
if( log_this) log("MOVE PIVOT POINT: pivot_PANEL NOT TRACKED YET");
        return;
    }
    map.x   = panel.offsetLeft;
    map.y   = panel.offsetTop;
    map.w   = panel.offsetWidth;
    map.h   = panel.offsetHeight;



    let   x = map.x;
    let   y = map.y;
    let   w = map.w;
    let   h = map.h;


    let x_sign = (x > h_x) ? 1 : -1;
    let y_sign = (y > h_y) ? 1 : -1;
    if( x_sign < 0) x += w;
    if( y_sign < 0) y += h;


    let piv_x  =  x + x_sign * w * spread_ratio.x;
    let piv_y  =  y + y_sign * h * spread_ratio.y;
    t_set_pivotXY(piv_x, piv_y);

    t_save_update_post(caller);

    onMove_pivotXY.x = piv_x;
    onMove_pivotXY.y = piv_y;

    t_set_has_moved( caller );


};


let t_set_pivotXY = function(x,y)
{
    if((pivotXY.x != x) || (pivotXY.y != y))
    {
        pivotXY.x = parseInt( x );
        pivotXY.y = parseInt( y );
    }

    if(pivspot) t_tools_set_panel_xy(pivspot, pivotXY.x, pivotXY.y);
};


let t_flash_unpinned_panels = function(_caller)
{

let   caller = "t_flash_unpinned_panels";
let log_this = LOG_MAP.T4_PIVOT;

if( log_this) log(caller+".. CALLED BY "+ _caller);


    let fly_div = t_fly.t_fly_div_get();
    for(let i=0; i< TOOL_panels.length; ++i) {
        let panel  = TOOL_panels[i];
        if( panel == hotspot    ) continue;
        if( panel == fly_div    ) continue;
 t_show_unpinned_panel( panel );
    }

        add_el_class(dom_tools_html, t_data.CSS_PRESSED);

    t_raise_pivot_PANEL_delayed(T_RAISE_PIVOT_PANEL_DELAY_LONG, caller);


};



let t_raise_pivot_PANEL         = function(_caller) { t_raise_pivot_PANEL_delayed(0, _caller); };
let t_raise_pivot_PANEL_delayed = function(delay=0, _caller="")
{

let   caller = "t_raise_pivot_PANEL_delayed";

let log_this = LOG_MAP.T4_PIVOT;

if(log_this) logBIG(caller+"("+delay+") .. CALLED BY "+_caller);



    if( t_raise_pivot_PANEL_timer == null)
        t_raise_pivot_PANEL_timer  = setTimeout(t_raise_pivot_PANEL_handler, delay);
};


let t_raise_pivot_PANEL_handler = function()
{

let log_this   = LOG_MAP.T4_PIVOT;
    let caller = "t_raise_pivot_PANEL_handler";

if(log_this) logBIG(caller);
if(log_this) t_fly.t_log_event_status(caller);


    if(t_raise_pivot_PANEL_timer == null) {
if(log_this) log(caller+"%c HAS BEEN CANCELED", lbb+lbH+lf2);

        return;
    }
    t_raise_pivot_PANEL_timer = null;


    if( call_t_grid_IS_ON_GRID(caller) ) {
if(log_this) log(caller+"%c TOOLS ON GRID", lbb+lbH+lf3);

        return;
    }


    if( div_slot_containers_displayed() ) {
if(log_this) log(caller+"%c SLOT CONTAINERS DISPLAYED", lbb+lbH+lf4);

        return;
    }


    if( onWork_PANEL) {
if(log_this) log(caller+"%c [onWork_PANEL] STILL IN HAND .. POSTPONED", lbb+lbH+lf3);

        t_raise_pivot_PANEL_timer = setTimeout(t_raise_pivot_PANEL_handler, T_RAISE_PIVOT_PANEL_DELAY_SHORT);
        return;
    }

    del_el_class(dom_tools_html, t_data.CSS_PRESSED);
    t_raise_pivot_PANEL_layout(caller);
};


let t_raise_pivot_PANEL_layout = function(_caller)
{

    let caller = "t_raise_pivot_PANEL_layout";
let log_this   = LOG_MAP.T4_PIVOT;

if(log_this) logBIG(caller+" CALLED BY "+_caller);


    let selected_tools = [];
    for(let i=1; i < TOOL_panels.length; ++i)
    {
        let panel = TOOL_panels[i];
        if(!panel) continue;
        if( panel.classList.contains(t_data.CSS_PINNED)) continue;

        let map = t_tools_map_get(panel);
        if(!map ) continue;

        if( t_tools_panel_is_selected(panel) ) selected_tools.push(panel);
    }

if(log_this) log(".....selected_tools.length=["+ selected_tools.length +"]");


    let pivot_idx  = selected_tools.indexOf( pivot_PANEL );
    let panel_rank = selected_tools.length;
if(log_this) log(".....pivot_idx...........................=["+ pivot_idx  +"]");
if(log_this) log(".....panel_rank..........................=["+ panel_rank +"]");

    for(let i=0; i < selected_tools.length; ++i) {

        let panel       = selected_tools[i];
        let tool_idx    = selected_tools.indexOf( panel );
        panel.tool_rank = panel_rank - Math.abs(pivot_idx - tool_idx);

        let s = "....................".substring(0, panel.tool_rank);
if(log_this) log("...["+s+"] ["+get_n_lbl(panel)+"] .. panel.tool_rank=["+panel.tool_rank+"]");



        if(panel == pivot_PANEL)
        {
            t_show_unpinned_panel (panel);

            panel.style.zIndex = t_data.ZINDEX_ABOVE_TOOLS-1;


        }


        else if( panel.classList.contains(t_data.CSS_PINNED) )
        {
            t_show_pinned_panel(panel, panel_rank);
        }


        else {
            t_set_CSS_PIVOT_PANEL(panel, false);
            if(!panel.classList.contains(t_data.CSS_PINNED))
            {
                if(t_show_or_dimm_unpinned_panels(caller)) t_show_unpinned_panel( panel );
                else                                       t_dimm_unpinned_panel( panel );
            }
            panel.style.zIndex    = t_data.ZINDEX_TOOL_PANEL_ZERO + panel.tool_rank;


        }

    }


    if(!onWork_PANEL)
    {
        t_update_TOOLS_MAP_GEOMETRY(caller);
    }
    else {

    }

};


let t_raise_pivot_PANEL_posted_since_onDown = function(_caller)
{

let log_this   = LOG_MAP.T4_PIVOT;
    let caller = "t_raise_pivot_PANEL_posted_since_onDown";

if(log_this) log(caller+"("+_caller+"): ...return "+(t_raise_pivot_PANEL_timer != null));

    return (t_raise_pivot_PANEL_timer != null);
};


let t_raise_pivot_PANEL_reset = function(_caller)
{

let log_this   = LOG_MAP.T4_PIVOT;
    let caller = "t_raise_pivot_PANEL_reset";

if(log_this) logBIG(caller+"("+_caller+")", lf8);

    if(t_raise_pivot_PANEL_timer)
    {
        clearTimeout( t_raise_pivot_PANEL_timer );

        t_raise_pivot_PANEL_timer = null;
    }
};





const CSS_FULLY_SPREAD = "fully_spread";
const CSS_DIMMED_PANEL = "dimmed_panel";
const CSS_PIVOT_PANEL  = "pivot_panel";




let t_show_or_dimm_unpinned_panels = function(_caller)
{

let   caller = "t_show_or_dimm_unpinned_panels";
let log_this = LOG_MAP.EV0_LISTEN || LOG_MAP.EV1_DOWN || LOG_MAP.T4_PIVOT || LOG_MAP.EV5_TOOL_CB;


    let fully_spread          = ((spread_ratio.x >= 0.9) || (spread_ratio.y >= 0.9));
    let moving_unpinned_panel = (onWork_PANEL && (onWork_PANEL != pivot_PANEL) && !has_el_class(onWork_PANEL, t_data.CSS_PINNED));
    let moving_hotspot        = (             onWork_PANEL        == hotspot    );
    let moving_hotring        = (             onWork_EL_last_used == hotring    );
    let drag_hotspot_request  = hotspot.drag_hotspot_request;
if(log_this) {
    log_key_val( caller
                 , {   moving_hotspot
                     , moving_hotring
                     , moving_unpinned_panel
                     , onWork_PANEL          : t_util.get_id_or_tag(onWork_PANEL)
                     , pivot_PANEL           : t_util.get_id_or_tag(pivot_PANEL)
                     , fully_spread
                     , drag_hotspot_request
                 }
                 , lb0
               );
    log_caller();
t_fly.t_log_event_status(caller,  lf6 );
}


    let show_or_dimm_unpinned_panels
        = moving_hotspot        ?               "hotspot"
        : moving_hotring        ?               "hotring"
        : fully_spread          ?          "fully_spread"
        : drag_hotspot_request  ?  "drag_hotspot_request"
        : moving_unpinned_panel ? "moving_unpinned_panel"
        :                                              ""
    ;

if(log_this) log("%c"+caller+" .. CALLED BY "+ _caller+"%c"+(show_or_dimm_unpinned_panels ? "SHOW "+show_or_dimm_unpinned_panels : "DIMM"), lbH, lbb+lbH+lf5);
    return show_or_dimm_unpinned_panels;
};


let t_show_unpinned_panel = function(panel)
{

    if( has_el_class(panel, CSS_DIMMED_PANEL) )
        del_el_class(panel, CSS_DIMMED_PANEL);



    if(!has_el_class(panel, CSS_PIVOT_PANEL))
    {
        let moving_a_pinned_panel   = has_el_class(onWork_PANEL, t_data.CSS_PINNED);
        let tool_panel_pinned       = has_el_class(panel  , t_data.CSS_PINNED);
        let panels_are_fully_spread = ((spread_ratio.x >= 0.9) || (spread_ratio.y >= 0.9));
        let fully_spread
            =  !tool_panel_pinned
            && !moving_a_pinned_panel
            &&  panels_are_fully_spread
        ;

        t_set_CSS_FULLY_SPREAD(panel, fully_spread);
    }

};


let t_dimm_unpinned_panel = function(panel)
{
    add_el_class(panel, CSS_DIMMED_PANEL);
};


let t_show_pinned_panel = function(panel, panel_rank)
{
    del_el_class          (panel, CSS_DIMMED_PANEL);
    t_set_CSS_FULLY_SPREAD(panel, false);
    t_set_CSS_PIVOT_PANEL (panel, false);

    panel.style.zIndex = t_data.ZINDEX_PINNED_PANEL_ZERO + panel_rank;

};





let T_POST_FOCUS_TO_DELAY = 500;
let t_post_focus_to_el;



let post_focus_to = function(el,delay=T_POST_FOCUS_TO_DELAY)
{

let   caller = "post_focus_to("+get_n_lbl(el)+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);



    if(t_post_focus_to_el) t_blur( t_post_focus_to_el );

    t_post_focus_to_el = el;

    setTimeout(post_focus_to_handler, delay);
};


let post_focus_to_handler = function(el)
{

let   caller = "post_focus_to_handler";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

    if(!t_post_focus_to_el) return;


    t_focus( t_post_focus_to_el );

    let panel = get_el_PANEL( t_post_focus_to_el );
    if( panel && (pivot_PANEL != panel) )
    {
        t_set_pivot_PANEL(panel, "FOCUSSED TO PANEL");
        t_raise_pivot_PANEL(caller+"("+get_n_lbl(el)+")");
        t_toggle_pivot_PANEL_magnified( prop.get( t_data.PIVOT_MAGNIFIED ) );
    }
};


let t_focus = function(el)
{



    el.focus();
    add_el_class(el, CSS_FOCUSSED);
    el.addEventListener("focusout"
                        , function() {

                            del_el_class(el, CSS_FOCUSSED);
                        });
};


let t_blur = function(el)
{

    el.blur();

    del_el_class(el, CSS_FOCUSSED);
};



let t_focus_clipboard_target = function(e_target, focus_in_msg, _caller)
{

let caller = "t_focus_clipboard_target("+get_n_lbl(e_target)+") .. CALLED BY ["+_caller+"]";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log( caller );
if( log_this) t_log.console_dir("e_target", e_target);


    t_fly.t_fly_clr_cancel();



    if(!e_target.blur_HTML) e_target.blur_HTML = e_target.innerHTML;



    e_target.innerHTML = focus_in_msg;



    t_util.selectNodeContents( e_target );



    if(!e_target.onblur) {
        e_target.onblur = function() {
            if     ( e_target.pasteHTML ) e_target.innerHTML = e_target.pasteHTML;
            else if( e_target.blur_HTML ) e_target.innerHTML = e_target.blur_HTML;
        };

    }


    t_focus( e_target );
};



let MAGNIFIED_BY_FONTSIZE = false;

let t_layout_panel_magnified = function(panel, magnified)
{

let   caller = "t_layout_panel_magnified";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"("+panel.id+", [magnified "+magnified+"])");

    t_update_panel_TOOLS_MAP_GEOMETRY( panel );

    if( magnified ) {
        add_el_class(panel,CSS_MAGNIFIED);
        let magnified_scale
            = ((panel == pat_bag) && has_el_class(panel, CSS_OPEN_BAG))
            ?  CSS_MAGNIFIED_SCALE
            :  CSS_MAGNIFIED_SCALE
        ;
        if(!t_could_be_magnified(panel, magnified_scale) )
            add_el_class(panel,CSS_TOO_LARGE);

    } else {
        if( has_el_class(panel,CSS_TOO_LARGE) ) {
            del_el_class(panel,CSS_TOO_LARGE);
        }
        del_el_class(panel,CSS_MAGNIFIED);

        if(panel.style.fontSize ) panel.style.fontSize  = "";
        if(panel.style.transform) panel.style.transform = "";
    }

    let scalepin = t_util.get_el_child_with_class(panel, CSS_SCALEPIN);
    if( scalepin ) {
        let scale  = t_util.t_get_panel_scale(panel);
        if( scale == 1) t_util.set_el_caption(scalepin);
        else            t_util.set_el_caption(scalepin, ".. Current scale .. x"+ scale);

    }
};



let t_could_be_magnified = function(panel, magnified_scale)
{

let   caller = "t_could_be_magnified";
let log_this = (LOG_MAP.T4_PIVOT || LOG_MAP.EV4_LONG_PRESS || LOG_MAP.T3_LAYOUT);


    if( t_seek.t_seeker_could_be_magnified( panel ) ) return true;



    let current_fontSize = parseInt(panel.style.fontSize) || 100;
    let current_scale    = (MAGNIFIED_BY_FONTSIZE) ? (current_fontSize / 100) : t_util.t_get_panel_scale(panel);
    let max_scale        = (current_scale > magnified_scale) ? current_scale : magnified_scale;

    let      p_w = Math.floor(panel.offsetWidth  / (current_fontSize  / 100));
    let      p_h = Math.floor(panel.offsetHeight / (current_fontSize  / 100));


    let      v_w = w_W - BOX_MARGIN * 2;
    let      v_h = w_H - BOX_MARGIN * 2;


    let too_wide = (p_w * max_scale) > v_w;
    let too_high = (p_h * max_scale) > v_h;



 let result_reason = "";
    if     ( too_wide ) result_reason = "("+p_w+" x "+magnified_scale+") > "+v_w+" .. "+ "["+get_n_lbl(panel)+ "] IS TOO WIDE";
    else if( too_high ) result_reason = "("+p_h+" x "+magnified_scale+") > "+v_h+" .. "+ "["+get_n_lbl(panel)+ "] IS TOO HIGH";



    let could_apply_magnified_scale = (result_reason == "");


    if(!could_apply_magnified_scale)
    {
        let scaleX_max = (v_w / p_w);
        let scaleY_max = (v_h / p_h);
        let capped_scale
            = (scaleX_max < scaleY_max)
            ?  scaleX_max : scaleY_max
        ;
        capped_scale = Math.max(1/magnified_scale, capped_scale);

        if(MAGNIFIED_BY_FONTSIZE) {
            panel.style.fontSize = Math.floor(100 * capped_scale)+"%";
            result_reason += " .. "+panel.style.fontSize;
        }
        else {
            panel.style.transform = "scale("+capped_scale+","+capped_scale+")";
            result_reason += " .. "+panel.style.transform;
        }
    }
    else {
        if(MAGNIFIED_BY_FONTSIZE) panel.style.fontSize  = Math.floor(      100 * max_scale)+"%";
        else                      panel.style.transform = "scale("+max_scale+","+max_scale+")";
    }

if(log_this) {
    let panel_transform = window.getComputedStyle(panel).transform;
    log_key_val_group( caller
                       , {   MAGNIFIED_BY_FONTSIZE
                           ,              PANEL_WH : p_w+" "+p_h
                           ,               VIEW_WH : v_w+" "+v_h
                           ,      current_fontSize
                           ,       magnified_scale
                           ,         current_scale
                           ,             max_scale
                           ,              too_wide
                           ,              too_high
                           ,       style_transform : panel.style.transform
                           ,        panel_fontSize : panel.style.fontSize
                           ,    computed_transform : panel_transform
                       }
                       , lb0, false
                     );
}

if(log_this) log(caller+"("+get_n_lbl(panel)+", "+magnified_scale+") %c "+(could_apply_magnified_scale ? "MAGNIFIED" : "CAPPED")+" %c "+result_reason
                 ,                                                   lbH +(could_apply_magnified_scale ? lbH+lf5     : lbH+lf2 )  ,lbH+lf9           );
    return could_apply_magnified_scale;
};


let t_is_panel_magnified = function(panel)
{
let log_this  = LOG_MAP.T4_PIVOT;

    let state
        = panel && panel.classList.contains("magnified")
    ;
if(log_this) log("%c t_is_panel_magnified(panel=["+get_n_lbl(panel)+"]) %c: ...return "+state, lbF+lb1, lb2);

    return state;
};



let t_toggle_onWork_PANEL_magnified = function(action)
{
    if(onWork_PANEL == pivot_PANEL) {
        t_toggle_pivot_PANEL_magnified();

        return "TOGGLED PIVOT PANEL "+action;
    }
    else if( !t_seek.t_seeker_PU_is_active() )
    {
        t_toggle_panel_magnified(onWork_PANEL , "toggle");

        if(onWork_PANEL == pat_bag) t_pat_bag_open_or_close_layout();

        return "TOGGLED "+get_n_lbl(onWork_PANEL)+" "+action;
    }
    else {
        return "";
    }
};


let t_toggle_panel_magnified = function(panel, new_state)
{

let   caller = "t_toggle_panel_magnified("+t_util.get_id_or_tag(panel)+", "+new_state+")";
let log_this = (LOG_MAP.T4_PIVOT || LOG_MAP.EV4_LONG_PRESS || LOG_MAP.T3_LAYOUT);

if( log_this) t_fly.t_log_event_status(caller, lf4);


    let old_state = panel.classList.contains("magnified");
    switch( new_state ) {
        case  true: break;
        case false: break;
        default:       new_state = !old_state;    break;
    }


    if(new_state != old_state)
    {
        t_save_update_post(get_n_lbl(panel)+" magnified "+new_state);

if( log_this) log(caller+": ...TOGGLED TO "+ new_state);
    }
    else {
if( log_this) log(caller+": ...NO CHANGE");
    }

    if(panel != hotspot)
        t_layout_panel_magnified(panel, new_state);

    return new_state;
};


let t_toggle_pivot_PANEL_magnified = function(new_state)
{

let   caller = "t_toggle_pivot_PANEL_magnified("+new_state+")";
let log_this = (LOG_MAP.T4_PIVOT || LOG_MAP.EV4_LONG_PRESS || LOG_MAP.T3_LAYOUT);



    if( !pivot_PANEL ) return false;

    let old_state = prop.get                ( t_data.PIVOT_MAGNIFIED );
    new_state     = t_toggle_panel_magnified( pivot_PANEL, new_state);



    if(new_state != old_state) {
        prop.set(t_data.PIVOT_MAGNIFIED , new_state);

        t_save_update_post("pivot_magnified "+new_state);

if(log_this) log(caller+": pivot_magnified: %c "+new_state+" ", (new_state ? lb2 : lb8));
    }

    return new_state;
};









let mousedown_consumed_by = "";


let t_pointerdown_listener = function(e)
{

let   caller = "t_pointerdown_listener";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV0_LISTEN;

let tag_this = DOM_TOOLS_TAG || log_this;
if( log_this) t_log.console_clear(caller);
if( log_this) log(caller+"("+ get_n_lbl(t_get_event_target(e))+")");
if( log_this) log("...was_a_click "+was_a_click()+" .. onDown_MS=["+onDown_MS+"]");
if(LOG_MAP.EV7_DISPATCH) t_fly.t_log_event_status(caller);


    t_log.log_CLR();
    onDownPMS = onDown_MS;
    onDown_MS = new Date().getTime();


    dom_scroll.clr_has_scrolled();

    onDown_SHIFT = e.shiftKey;
    onDown_CTRL  = e.ctrlKey ;
    onDown_ALT   = e.altKey  ;



    if(onDown_CTRL ) { log(); caller="onDown_CTRL"  ; t_preventDefault(e, caller); t_event_set_e_consumed_by(e, caller); return; }
    if(onDown_ALT  ) { log(); caller="onDown_ALT "  ; t_preventDefault(e, caller); t_event_set_e_consumed_by(e, caller); t_log.console_clear     (caller); t_fly.t_fly_init(caller); return; }
    if(onDown_SHIFT) { log(); caller="onDown_SHIFT "; t_preventDefault(e, caller); t_event_set_e_consumed_by(e, caller); t_log.console_clear_post(caller); t_fly.t_fly_init(caller); return; }


    let                consumed_by = "";                               let  consumed_by_css =  "";
    if(!consumed_by) { consumed_by = onDown_0_MULTITOUCH               (e); consumed_by_css = lf9; }
    if(!consumed_by) { consumed_by = onDown_1_INIT_CTRL_DEBOUNCE_INPUT (e); consumed_by_css = lf1; }
    if(!consumed_by) { consumed_by = onDown_2_slot_fullscreen_DRAG     (e); consumed_by_css = lf3; }
    if(!consumed_by) { consumed_by = onDown_3_TOOL_PRESS               (e); consumed_by_css = lf4; }
    if(!consumed_by) { consumed_by = onDown_4_STICKY_PICK              (e); consumed_by_css = lf2; }
    if(!consumed_by) { consumed_by = onDown_5_TOOL_PICK                (e); consumed_by_css = lf5; }
    if(!consumed_by) { consumed_by = onDown_6_TOOL_MOVE                (e); consumed_by_css = lf6; }
    if(!consumed_by) { consumed_by = onDown_7_SENTENCE                 (e); consumed_by_css = lf7; }
    if(!consumed_by) { consumed_by = onDown_8_DOC_SELECT_OR_SEEK       (e); consumed_by_css = lf8; }
    if(!consumed_by) { consumed_by = e.type+" BUBBLING"; onDown_9_STALL( ); consumed_by_css = lf9; }

if( tag_this && !mousedown_consumed_by) log("%c"+consumed_by, lbH+consumed_by_css);
    mousedown_consumed_by = consumed_by;


if( log_this) t_fly.t_log_event_status(t_data.SYMBOL_RIGHT_ARROW+" "+consumed_by, lbb+consumed_by_css);

    if( t_log.logging_something() )
        t_fly.t_log_transcript_event_top("<span class='big'>"+ t_data.SYMBOL_DOWN_ARROW +"</span>"
            +                            "<em>"+               consumed_by              +"</em>"  );



    if(prop.get(t_data.PIN_SEEKSPOT) && prop.get(t_data.FLOATLOG)) t_fly.t_event_LOG_TOOLTIP("MOUSEDOWN");
};




let onDown_TOUCHES;


let onDown_0_MULTITOUCH = function(e)
{
    onDown_TOUCHES     = e.touches ? e.touches.length : 1;

};


let onDown_1_INIT_CTRL_DEBOUNCE_INPUT = function(e)
{

let   caller = "onDown_1_INIT_CTRL_DEBOUNCE_INPUT";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV0_LISTEN;

if( log_this) log("%c"+caller, lbF+lb1);
    let consumed_by = "";


    t_log_clr_status();
    t_clr_has_moved(caller);
    t_raise_pivot_PANEL_reset(caller);

    dom_scroll.t_scrollIntoViewIfNeeded_cancel(caller);

    if(               t_tools_layout_on_mouseup_timer ) {
        clearTimeout( t_tools_layout_on_mouseup_timer );
 t_tools_layout_on_mouseup_timer = null;
    }

    if(t_preventDefault_caller) t_restoreDefault("ON DOWN INIT");

    onMove_selection_removed    = false;

    mousedown_consumed_by       = "";
    mouselong_press_consumed_by = "";
    mousemove_consumed_by       = "";
    mouseup_consumed_by         = "";

    move_cooldown_handler();



    fully_spread_since_onDown                      = false;
    pivot_PANEL_changed_since_onDown               = false;



    set_onDown_XY(e, caller);
    onMoveDXY.x = 0;
    onMoveDXY.y = 0;



    if(!dimm_mask_displayed() )
        onDown_SCROLL_XY
            = {   x : window.scrollX
                , y : window.scrollY
            };




    let e_target           = t_get_event_target(e);
    let sticky             = t_sticky.t_sticky_e_target_STICKY(e_target);
    let sticky_scrollable  = t_sticky.t_sticky_onDown_a_scrollable_STICKY(sticky, e_target);
    if( sticky_scrollable )
    {

        if(behavior_TOUCH_ELSE_DESKTOP)
        {
            consumed_by    = "DOWN A SCROLLABLE STICKY";
            onDown_EL      = sticky;

            t_sticky.t_sticky_scroll_STICKY_PAD_MSG( e_target );

            t_seek.t_seeker_PU_hide("instant");

if( log_this) log("%c"+consumed_by, lbH+lf8);
            return consumed_by;
        }
    }


    let event_on_scrollbar = t_util.is_event_on_scrollbar( e );
    if( event_on_scrollbar && behavior_TOUCH_ELSE_DESKTOP)
    {
        consumed_by = "DOWN ["+t_util.get_id_or_tag(e_target)+"] SCROLLBAR";
        onDown_EL   = e_target;

if( log_this) log("%c"+consumed_by, lbH+lf1);
        return consumed_by;
    }



    t_set_onWork_EL(e_target, caller, e);




    t_seek.t_seeker_onDown_1_INIT_CTRL_DEBOUNCE_INPUT(onWork_EL, onDown_XY);

    seek_next_slot_num_cancel();


    get_onDown_SELECTION();






    if(t_is_bouncing_e_type(e.type, "t_pointerdown_listener", T_EVENT_DEBOUNCE_DELAY))
    {
        consumed_by = "BOUNCING [EVENT <= "+T_EVENT_DEBOUNCE_DELAY+" ms]";

        t_clear( consumed_by );
    }

if( log_this && consumed_by) t_fly.t_log_event_status(caller+": "+consumed_by, lf1);
    return consumed_by;
};


let onDown_2_slot_fullscreen_DRAG = function(e)
{

let   caller = "onDown_2_slot_fullscreen_DRAG";
let log_this = LOG_MAP.EV1_DOWN ||LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbF+lb2);

    if(!div_slot_containers_displayed()         ) return "";
    if(!has_el_class(onWork_EL, CSS_FULLSCREEN )) return "";

    let consumed_by = "START CONTAINERS FULLSCREEN DRAG";

    t_add_tool_pointermove_listener(caller);

if( log_this && consumed_by) log("%c"+consumed_by, lf2);
    return consumed_by;
};


let onDown_3_TOOL_PRESS = function(e)
{

let   caller = "onDown_3_TOOL_PRESS";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV0_LISTEN;

if( log_this) log("%c"+caller, lbF+lb3);



    if( onDown_3_TOOL_PRESS_has_long_press_handler() )
    {
if( log_this) log("%c ADDING LONG-PRESS TIMER:", lbF+lf3);

        add_long_press_listener("ON DOWN TOOL PRESS "+ get_n_lbl(onWork_EL));
        if( has_el_class(onWork_EL, CSS_TOOLTIP) ) {
if( log_this) log("%c ADDING SCROLL LISTENER ON "+get_n_lbl(onWork_EL), lbH+lf3);

            add_listener_capture_active(onWork_EL, "scroll", onDown_3_TOOL_PRESS_scroll_listener);
        }
    }

    set_onWork_EL_pressed();
    return "";
};


let onDown_3_TOOL_PRESS_scroll_listener = function(e)
{

let   caller = "onDown_3_TOOL_PRESS_scroll_listener";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV3_UP;

if( log_this) log("%c"+caller, lbH+lb3);


    if( is_long_press_pending() )
        del_long_press_listener(caller+"("+t_util.get_id_or_tag(e.target)+")");

    remove_listener_capture_active(e.target, "scroll", onDown_3_TOOL_PRESS_scroll_listener);
};


let onDown_3_TOOL_PRESS_has_long_press_handler = function()
{

let caller = "onDown_3_TOOL_PRESS_has_long_press_handler";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV4_LONG_PRESS;
let tag_this = DOM_TOOLS_TAG || log_this;

if( log_this) log("%c"+caller, lbH+lb3);


    if(!onWork_EL) return false;

    let panel1_is_a_dimm_mask        = dimm_mask_is(                onWork_EL                    );
    let panel2_is_hotspot            = (                            onWork_PANEL   ==  hotspot   );
    let panel3_is_a_sel_bag_CHILD    = (            sel_bag ==      onWork_PANEL) && ( onWork_EL != sel_bag);
    let panel4_longpress_magnify     = (onWork_PANEL &&       (     onWork_PANEL   ==  onWork_EL ));



    let el0_on_a_sentence_container  = t_util.is_el_or_child_of_class(onWork_EL, t_sentence.CSS_SENTENCE_CONTAINER);
    let el0_is_a_scrolling_EL        =  has_el_class(onWork_EL, t_data.CSS_SCROLLING);
    let el0_onSlotEL                 = (t_get_onWork_EL_slot() > 0);
    let el1_is_a_tool                =  t_is_a_tool_el                    ( onWork_EL, caller               );
    let el2_is_a_dimm_mask_child     =  t_util.is_el_or_child_of_parent_el( onWork_EL, dimm_mask            );
    let el3_is_a_fly_div_child       =  t_util.is_el_or_child_of_parent_el( onWork_EL, t_fly.t_fly_div_get());
    let el4_is_a_scalepin            =  has_el_class(onWork_EL     , CSS_SCALEPIN);
    let el5_has_t_sticky_EDIT        =  is_a_DOM_LOAD_featured_function("t_sticky.t_sticky_EDIT");
    let el5_is_a_seek_sticky         =  t_seek.t_seeker_get_STICKY();
    let el5_pinned_sticky_count      =  el5_has_t_sticky_EDIT && t_sticky.t_sticky_GET_COUNT();
    let el6_is_import_clipboard      = (onWork_EL && (onWork_EL.id == t_data.CSS_FLY_CLIPBOARD));
    let el7_has_title                =  t_util.get_el_title(onWork_EL);



if( tag_this)
    log_key_val_group( caller
                 , {   onWork_PANEL                  : get_n_lbl(onWork_PANEL)
                     ,  panel1_is_a_dimm_mask
                     ,  panel2_is_hotspot
                     ,  panel3_is_a_sel_bag_CHILD
                     ,  panel4_longpress_magnify

                     , onWork_EL                     : get_n_lbl(onWork_EL)
                     ,  current_sel_text             : t_util.ellipsis(t_get_current_sel_text())
                     ,  el0_on_a_sentence_container
                     ,  el0_is_a_scrolling_EL
                     ,  el0_onSlotEL
                     ,  el1_is_a_tool
                     ,  el2_is_a_dimm_mask_child
                     ,  el3_is_a_fly_div_child
                     ,  el4_is_a_scalepin
                     ,  el5_has_t_sticky_EDIT
                     ,  el5_is_a_seek_sticky
                     ,  el5_pinned_sticky_count
                     ,  el6_is_import_clipboard
                     ,  el7_has_title
                     , onDown_SEL_TEXT               : t_util.ellipsis_short(onDown_SEL_TEXT)
                     ,                       callers : t_log.get_callers()
                 }
                 , lf3);




    let handled_by; let why_not;
    if( el0_is_a_scrolling_EL )
    {
        handled_by = "";
        why_not    = "ON A SCROLLING EL";
    }


    else if( el0_on_a_sentence_container )
    {
        handled_by = "";
        why_not    = "ON A SENTENCE CONTAINER";
    }


    else if( el1_is_a_tool ) {


        if     ( panel1_is_a_dimm_mask          ) handled_by =     onWork_EL.id          ;

        else if( panel3_is_a_sel_bag_CHILD      ) handled_by = "A [sel_bag] CHILD"      ;
        else if( panel4_longpress_magnify       ) handled_by = "A TOOL PANEL TO MAGNIFY";


        else if( el2_is_a_dimm_mask_child       ) handled_by = "A [dimm_mask] CHILD"    ;
        else if( el3_is_a_fly_div_child         ) handled_by = "A [fly_div] CHILD"      ;
        else if( el4_is_a_scalepin              ) handled_by = onWork_EL.id             ;
        else if( el5_is_a_seek_sticky           ) handled_by = "A [sticky] TO FEED FROM SEL_TEXT";
        else if( el6_is_import_clipboard        ) handled_by = "IMPORT CLIPBOARD PASTE TOOL";
        else if( el7_has_title                  ) handled_by = "ON LONG-PRESS FOR A TOOL WITH TITLE ["+el7_has_title+"]";


        else if((onWork_EL    == off_bag       )) handled_by = "A [pat_bag] DIV"        ;
        else if((onWork_EL    == alt_bag       )) handled_by = "A [pat_bag] DIV"        ;
        else if((onWork_EL    == bak_bag       )) handled_by = "A [pat_bag] DIV"        ;
        else if((onWork_EL    == bag_rot       )) handled_by = "A [pat_bag] TOOL"       ;
        else if((onWork_EL    == bot_div       )) handled_by = "A [pat_bag] DIV"        ;


        else if((onWork_EL    == transcript1   )) handled_by =    onWork_EL.id          ;
        else if((onWork_EL    == transcript2   )) handled_by =    onWork_EL.id          ;

    }


    else {
        if     (     el0_onSlotEL               ) why_not    = "ON A SLOT-NODE";
        else if(     onDown_SEL_TEXT            ) handled_by = "LONG-PRESS [NEW sticky]";
        else if(     el5_has_t_sticky_EDIT      ) {
            if     ( el5_pinned_sticky_count < 1) handled_by = "A [sticky] TO ADD FIRST STICKY";
            else if( el5_pinned_sticky_count > 0) handled_by = el5_pinned_sticky_count+" [sticky] TO CHOOSE FROM";
        }
    }

    let result = !!handled_by;
if(tag_this) log("%c"+caller+"%c return "+result    +"%c"+(handled_by || why_not)
                 ,lbL+lf3    ,lbC+(result ? lf9:lf8) ,lbR+lf3                    );
    return result;
};


let onDown_4_STICKY_PICK = function(e)
{

let   caller = "onDown_4_STICKY_PICK";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV0_LISTEN;

if( log_this) log("%c"+caller, lbF+lb4);
    if(!onWork_EL) return "";

    let consumed_by = t_sticky.t_sticky_onDown(e);

    set_onWork_EL_pressed();

    if(consumed_by) t_preventDefault(e, "PREVENTING PAGE SCROLL WHILE "+consumed_by);

if( log_this && consumed_by) log("%c"+consumed_by, lf4);
    return consumed_by;
};


let onDown_5_TOOL_PICK = function(e)
{

let   caller = "onDown_5_TOOL_PICK";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV0_LISTEN;

if( log_this) log("%c"+caller, lbF+lb5);
    if(!onWork_EL) return "";


    let e_target = t_get_event_target(e);

    let     consumed_by = "";


    if(t_fly.t_doc_evt_div_get())
    {
        if(    !t_util.is_el_or_child_of_parent_el(e_target, t_fly.t_doc_evt_div_get())
            && !t_util.is_el_or_child_of_parent_el(e_target, t_fly.t_doc_log_div_get())
        )
            t_fly.t_doc_div_clear("doc_evt_div");

    }



    if(e_target)
    {






    }


    let mouse_down_on_a_push_pin = onWork_EL.classList.contains( CSS_PUSH_PIN );

if( log_this && mouse_down_on_a_push_pin) log("%c...MOUSE DOWN ON %c"+onWork_EL.id+" PUSH PIN", lf5, lbH+lf1);


    if(    !consumed_by
        && !mouse_down_on_a_push_pin
        && (onWork_PANEL                                  )
        && (onWork_PANEL                  != dimm_mask    )
        && (onWork_PANEL                  != hotspot      )
        && (onWork_PANEL                  != t_fly.t_fly_div_get())
        && !onWork_PANEL.classList.contains( t_data.CSS_PINNED   )
        && !t_seek.t_seeker_get_tool_panel(onWork_PANEL)
    ) {
        if(onWork_EL == onWork_PANEL) t_seek.t_seeker_PU_hide("instant");


        if(      (onWork_PANEL != pivot_PANEL)

          ) {
if( log_this) log("%c...PIVOT PANEL SWITCH TO %c"+onWork_PANEL.id, lf5, lbH+lf5);
            let msg
                = caller+": EVENT CANCELED:"
                + LF+"SWITCHING PIVOT PANEL"
                +    " FROM ["+ get_n_lbl(pivot_PANEL ) +"]"
                +      " TO ["+ get_n_lbl(onWork_PANEL) +"]"
                + LF+"...onWork_EL=["+ get_n_lbl(onWork_EL) +"]"
            ;
            t_event_add_e_consumed_by(e, msg);

            onWork_MOVABLE_CHILD      = null;

            fully_spread_since_onDown = true;

            t_set_pivot_PANEL(onWork_PANEL, "CHANGING UNPINNED [pivot_PANEL]");
            let show_or_dimm_unpinned_panels = true;
            t_raise_pivot_PANEL_layout(show_or_dimm_unpinned_panels, caller);

            t_sync_layout(caller);
        }


        else {
if( log_this) log("%c...PIVOT PANEL %c CURRENT", lf5, lbH+lf6);
            if( t_show_or_dimm_unpinned_panels(caller) )
                t_raise_pivot_PANEL(caller);


            if(e_target && (e_target.tagName == "INPUT"))
                consumed_by = "INPUT CLICKED";

        }

    }


    if(onWork_PANEL == hotspot)
    {
        t_flash_unpinned_panels();
if( log_this) log("%c...PIVOT PANEL %c HOTSPOT", lf5, lbH+lf5);
    }


    let e_target_lbl = get_id_or_tag_and_className( e_target );
    if( t_util.is_el_or_child_of_class(e_target, CSS_BUTTONS_POD) )
    {

        t_seek.t_seeker_PU_hide("instant");

        consumed_by = CSS_BUTTONS_POD;
    }


    if(!consumed_by)
    {

        let    onWork_EL_lbl        = get_n_lbl                  ( onWork_EL    );
        let onWork_PANEL_lbl        = get_n_lbl                  ( onWork_PANEL );

        let has_handler             = (t_util.get_el_event_handler(onWork_EL, caller) != null);
        let is_a_tool               = t_is_a_tool_el(onWork_EL, caller);
        let is_a_tool_dimmed        = t_util.is_el_or_child_of_parent_el(onWork_EL, dimm_mask);
        let is_a_child_of_doc_tools = t_util.is_el_child_of_id(onWork_EL, t_data.DOC_TOOLS_ID);


if( log_this)
        log_key_val(  (onWork_PANEL ? "onWork_PANEL=["+ t_util.get_id_or_tag(onWork_PANEL)+"] .. ":"")
                    +                   " onWork_EL=["+ t_util.get_id_or_tag(onWork_EL   )+"] "
                    , { e_target_lbl
                      , e_target_is_a_tool       : t_is_a_tool_el(e_target, "e_target_is_a_tool")
                      , onWork_EL_lbl
                      , onWork_EL
                      , onWork_PANEL_lbl
                      , onWork_PANEL
                      , on_pivot_PANEL           : (onWork_PANEL == pivot_PANEL)
                      , onWork_MOVABLE_CHILD
                      , has_handler
                      , is_a_tool
                      , is_a_tool_dimmed
                      , is_a_child_of_doc_tools
                      , doc_handler_freezed      : t_get_doc_handler_freezed()
                      , seeker_has_TARGET        : t_seek.t_seeker_has_TARGET()
                    }, lf5);




        if     (!is_a_tool_dimmed && t_seek.t_seeker_has_TARGET()          ) t_preventDefault(e, "ON DOWN .. SEEK_TARGET   ["+ onWork_EL_lbl +"]");
        else if(    onWork_MOVABLE_CHILD                                   ) t_preventDefault(e, "ON DOWN .. MOVE_CHILD    ["+ onWork_EL_lbl +"]");
        else if(t_touching_a_scrollable_panel(e)                           ) {

            t_set_body_style_overflow_hidden(true);
        }
        else if(is_a_tool && !is_a_child_of_doc_tools && !is_a_tool_dimmed ) {
            if     ( has_el_class(e_target, t_data.CSS_MAILTO)             ) t_acceptBubble  (e, "ON DOWN .. MAILTO    ["+                  onWork_EL_lbl +"]");
            else if( e_target.id         == t_data.CSS_FLY_CLIPBOARD       ) t_acceptBubble  (e, "ON DOWN .. CLIPBOARD ["+                  onWork_EL_lbl +"]");
            else if( has_handler         && !t_get_doc_handler_freezed()   ) t_acceptBubble  (e, "ON DOWN .. TOOL WITH WORKING HANDLER  ["+ onWork_EL_lbl +"]");
            else if( has_handler                                           ) t_preventDefault(e, "ON DOWN .. TOOL WITH FREEZED HANDLER  ["+ onWork_EL_lbl +"]");
            else                                                             t_preventDefault(e, "ON DOWN .. TOOL WITH      NO HANDLER  ["+ onWork_EL_lbl +"]");

        }
        else if(!is_a_tool_dimmed && onWork_PANEL) {
            if(     has_handler                  ) t_preventDefault(e, "ON DOWN .. PANEL WITH    HANDLER ["+ onWork_PANEL_lbl +"]");
            else if(!behavior_TOUCH_ELSE_DESKTOP ) t_preventDefault(e, "ON DOWN .. PANEL WITH NO HANDLER ["+ onWork_PANEL_lbl +"]");
        }

        else if(log_this)                          t_acceptBubble  (e, "ON DOWN .. NOT A PANEL OR TOOL   ["+ onWork_EL_lbl +"]");

    }

if( log_this && consumed_by) log("%c"+consumed_by, lf5);
    return consumed_by;
};


let onDown_6_TOOL_MOVE = function(e)
{

let   caller = "onDown_6_TOOL_MOVE";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV0_LISTEN;

if( log_this) log("%c"+caller, lbF+lb6);
if( log_this) t_fly.t_log_event_status(caller, lf6);





    if(   !onWork_MOVABLE_CHILD
       && !onWork_MOVABLE_PANEL       ) return "";
    if( call_t_grid_IS_SIZED(caller)  ) return "";

    let consumed_by = "";


    if( t_seek.t_seeker_PU_is_active() )
    {
if(log_this) log("HIDE SEEK TOOL");

        t_seek.t_seeker_PU_hide("instant");
    }


    let mouse_down_on_a_push_pin = onWork_EL.classList.contains( CSS_PUSH_PIN );
if(log_this) log("...%c[mouse_down_on_a_push_pin: "+mouse_down_on_a_push_pin+"]%c .. %c[onWork_EL "   +get_n_lbl(onWork_EL   )+"]%c ...classList=["+onWork_EL.classList   +"]",lb6,lbA, lbF,lbA);

    if( mouse_down_on_a_push_pin )
    {
        consumed_by = "START TOOL_DRAG PUSH_PIN ["+get_n_lbl(onWork_PANEL)+"]";

        onDown_6_TOOL_DRAG_PUSH_PIN(e);
    }
    else {
        consumed_by = "START TOOL_DRAG PANEL ["+get_n_lbl(onWork_PANEL)+"]";

        t_flash_unpinned_panels();

    }




    if( hotspotXY.gutter_urdl )
    {


    }


    t_add_tool_pointermove_listener(caller);



if( log_this && consumed_by) log("%c"+consumed_by, lf6);
    return consumed_by;
};


let onDown_6_TOOL_DRAG_PUSH_PIN = function(e)
{

    let caller = "onDown_6_TOOL_DRAG_PUSH_PIN";
let log_this   = LOG_MAP.T4_PIVOT || LOG_MAP.EV1_DOWN;

if( log_this) log("%c"+caller, lbF+lb6);


    let pinned = onWork_PANEL.classList.contains(t_data.CSS_PINNED);

if( log_this) log("%c.............................pinned "+pinned                           , lbH+(pinned                           ? lf6 : lf8));
if( log_this) log("%c...pivot_PANEL_changed_since_onDown "+ pivot_PANEL_changed_since_onDown, lbH+(pivot_PANEL_changed_since_onDown ? lf6 : lf8));

    if(!pinned && pivot_PANEL_changed_since_onDown) return;




    pinned = !pinned;
    t_set_CSS_PINNED(onWork_PANEL, pinned);


    if(onWork_PANEL == transcript1) prop.set("transcript1_pinned", pinned);
    if(onWork_PANEL == transcript2) prop.set("transcript2_pinned", pinned);
    t_save_update_post(caller);


    t_flash_unpinned_panels(caller);


    onWork_PANEL.style.position = pinned ? "fixed" : prop.get( t_data.TOOLS_SCROLL ) ? "absolute": "fixed";



    if(pinned) {
if( log_this) log("%c UNGROUP JUST-PINNED TOOL", lf6);
        if( prop.get( t_data.TOOLS_SCROLL ) )
            t_util.t_set_position_fixed( onWork_PANEL );

        onWork_PANEL.style.zIndex = t_data.ZINDEX_PINNED_PANEL_ZERO + onWork_PANEL.tool_rank;

        t_set_onWork_EL(onWork_PANEL, caller, e);
        t_seek.t_seeker_set_TOOL(onWork_EL);

        t_tools_set_top_xy(h_x, h_y);


        if(onWork_PANEL == pivot_PANEL)
        {
            let last_panel_idx = t_get_TOOL_panel_idx_not_pinned_last();
            if( log_this) log("%c PINNING [pivot_PANEL] ["+onWork_PANEL.id+"] %c LAST UNPINNED ["+get_n_lbl(TOOL_panels[last_panel_idx])+"]", lf6, lbR+lfX[last_panel_idx % 0]);

            t_set_pivot_PANEL(               (last_panel_idx > 0)
                                             ? TOOL_panels[last_panel_idx]
                                             : null
                                             ,  "REPLACING JUST PINNED [pivot_PANEL]"
                             );
        }

    }


    else {
if( log_this) log("%c REGROUP UNPINNED TOOL", lf6);


        if( onWork_PANEL )
        {
            t_set_has_moved("REGROUP JUST-UNPINNED PANEL");

            enter_CSS_SLOW_REGROUP("REGROUP JUST-UNPINNED PANEL");

            let next_panel_idx = t_get_hotspot_dist_next_panel_idx( onWork_PANEL );
            let move_panel_idx = TOOL_panels.indexOf( onWork_PANEL );

if( log_this) log( "%c move_panel #"+move_panel_idx+" "+ TOOL_panels[move_panel_idx].id
                   +"%c next_panel #"+next_panel_idx+" "+ TOOL_panels[next_panel_idx].id
                   , lfX[move_panel_idx]
                   , lfX[next_panel_idx]
                 );

            if(next_panel_idx) {
                while(move_panel_idx > next_panel_idx) TOOL_panels[ move_panel_idx ] = TOOL_panels[ --move_panel_idx ];
                while(move_panel_idx < next_panel_idx) TOOL_panels[ move_panel_idx ] = TOOL_panels[ ++move_panel_idx ];
 TOOL_panels[ next_panel_idx ] = onWork_PANEL;

if( log_this) log("%c move_panel #"+move_panel_idx+" "+ TOOL_panels[move_panel_idx].id
                  , lfX[move_panel_idx]
                 );

            }

            t_set_pivot_PANEL(onWork_PANEL, "JUST UNPINED PANEL BECOMES [pivot_PANEL]");


            t_tools_set_top_xy(h_x, h_y);

            fully_spread_since_onDown = true;
        }
    }

};


let onDown_7_SENTENCE = function(e)
{

let   caller = "onDown_7_SENTENCE";
if(!is_a_DOM_LOAD_featured_function(caller)) return "";
let log_this = LOG_MAP.T4_PIVOT || LOG_MAP.EV1_DOWN;

if( log_this) log("%c"+caller, lbF+lb7);
if( log_this) t_fly.t_log_event_status(caller, lf7);
    let consumed_by = "";


    if( t_util.is_el_child_of_id(onWork_EL, t_data.DOC_TOOLS_ID) )
    {
if( log_this) log("NOT WHEN ON DOC TOOLS ["+t_util.get_n_lbl(onWork_EL)+"]");

        return "";
    }


    let sentence_el        = t_sentence.t_SENTENCE_GET_EL_SENTENCE_CONTAINER(onDown_EL);
    if( sentence_el )
    {
        consumed_by += " .. ON A SENTENCE ELEMENT";

        t_preventDefault(e, consumed_by);

        t_CURSOR_add_MOVE_LISTENER(caller);
    }

if( log_this && consumed_by) log("%c"+consumed_by, lf7);
    return consumed_by;
};


let onDown_8_DOC_SELECT_OR_SEEK = function(e)
{

let   caller = "onDown_8_DOC_SELECT_OR_SEEK";
if(!is_a_DOM_LOAD_featured_function(caller)) return "";
let log_this = LOG_MAP.T4_PIVOT || LOG_MAP.EV1_DOWN;

if( log_this) log("%c"+caller, lbF+lb8);
if( log_this) t_fly.t_log_event_status(caller, lf8);
    let consumed_by = "";



    if( t_util.is_el_child_of_id(onWork_EL, t_data.DOC_TOOLS_ID) )
    {
if( log_this) log("NOT WHEN ON DOC TOOLS ["+t_util.get_n_lbl(onWork_EL)+"]");

        return "";
    }



    if(!consumed_by && !t_preventDefault_has_been_called())
    {

        if( t_is_an_embedded_doc_tool(onWork_EL,log_this) )
        {
            consumed_by = "BUBBLE EVENT";
            let msg = consumed_by+" .. ["+get_id_or_tag(onWork_EL)+"]";

            t_acceptBubble(e, msg, log_this);
        }


        else if( t_get_doc_handler_freezed() )
        {
            if(onWork_EL.tagName == "A")
            {
                consumed_by += " .. (t_data.WORDING) or (ANCHOR FREEZED)";
                t_preventDefault(e, consumed_by);
            }
            else if(t_util.get_el_event_handler(onWork_EL, caller) != null)
            {
                consumed_by += ".. (EVENT HANDLER FREEZED)";
                t_preventDefault(e, consumed_by);
            }
        }

    }


    if(   !consumed_by
       && !has_el_class(onWork_EL, t_data.CSS_SCROLLING)
       &&  t_seek.t_seeker_has_TARGET()
      ) {
        consumed_by = "SEEK TOOL ["+t_seek.t_seeker_get_TOOL_label()+"] ON DOC";
        add_page_pointermove_listener( caller );
        add_long_press_listener("ON DOWN DOC TOOL");
    }

if( log_this && consumed_by) log("%c"+consumed_by, lf8);
    return consumed_by;
};



const MOVE_ON_STALL_DURATION = 500;
let   move_on_stall_timer    = null;


let onDown_9_STALL = function()
{

let   caller = "onDown_9_STALL";
let log_this = LOG_MAP.T4_PIVOT || LOG_MAP.EV1_DOWN;

if( log_this) log("%c"+caller, lb8);

    if(move_on_stall_timer) clearTimeout(move_on_stall_timer);
    move_on_stall_timer   =   setTimeout(onDown_7_STALL_handler, MOVE_ON_STALL_DURATION);
};
let onDown_7_STALL_handler = function()
{


    move_on_stall_timer = null;
    t_seek.t_seeker_set_TOOL(null);
};
let onDown_7_STALL_is_pending = function()
{

    return (move_on_stall_timer != null);
};
let onDown_7_STALL_cancel  = function()
{
    move_on_stall_timer = null;
};



let t_get_doc_handler_freezed = function()
{

let   caller = "t_get_doc_handler_freezed";
let log_this = DOM_TOOLS_TAG || LOG_MAP.EV1_DOWN;


    let doc_handler_freezed
        =  prop.get( t_data.ANCHOR_FREEZE )
        || prop.get( t_data.WORDING       )
    ;

    doc_handler_freezed
        = onDown_CTRL
        ? !doc_handler_freezed
        :  doc_handler_freezed;


if( log_this)
    log_key_val(   caller+": ...return "+ doc_handler_freezed
               ,{ ANCHOR_FREEZE         :  prop.get( t_data.ANCHOR_FREEZE )
                , WORDING               :  prop.get( t_data.WORDING       )
                , onDown_CTRL
                , callers               : t_log.get_callers()
               }, lbH+lfX[doc_handler_freezed ? 4:6]);

    return doc_handler_freezed;
};


let t_get_onDown_SCROLL_XY = function()
{
    return onDown_SCROLL_XY;
};


let t_touching_a_scrollable_panel = function(e)
{
    let result;
    if( !behavior_TOUCH_ELSE_DESKTOP                                     )  result = false;

    if((onWork_PANEL == transcript2) && (onWork_EL == transcript2)       )  result = true;

    if( has_el_class(onWork_EL, CSS_TOOLTIP) ) {
        let on_a_tooltip_scrollbar
            =  ((onDown_XY.x - onDown_TOOL_XY.x) > onWork_EL.clientWidth )
            || ((onDown_XY.y - onDown_TOOL_XY.y) > onWork_EL.clientHeight); result = on_a_tooltip_scrollbar;
    }

    return result;
};


let t_set_body_style_overflow_hidden = function(hidden)
{
    document.body.style.overflow = (hidden ? t_data.CSS_HIDDEN : "");

};




const DIR_GRAB            = "DIR_GRAB";
const DIR_NUM_NEXT        = "DIR_NUM_NEXT";
const DIR_NUM_PREV        = "DIR_NUM_PREV";
const DIR_SLOT_NEXT       = "DIR_SLOT_NEXT";
const DIR_SLOT_PREV       = "DIR_SLOT_PREV";

let mousemove_consumed_by = "";
let onMove_selection_removed;


let t_PAGE_pointermove_drag = function(e)
{
if(e.ctrlKey) { log("%c PAGE POINTER MOVE IGNORED .. f(e.ctrlKey)", lbH+lf2); del_page_and_tool_pointermove_listeners( "e.ctrlKey" ); return false; }

let   caller = "t_PAGE_pointermove_drag";
let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T6_SLOT;

let tag_this = DOM_TOOLS_TAG || log_this;
if(LOG_MAP.EV7_DISPATCH && !mousemove_consumed_by) t_fly.t_log_event_status(caller);

    if(!onWork_EL                             ) return false;
    if(!onWork_EL.id                          ) return false;


if(!log_this) log_this = onDown_CTRL;

    get_onMoveDXY(e, caller);



    let                consumed_by = "";                       let  log_css = lbF;
    if(!consumed_by) { consumed_by = onMove_0_MULTITOUCH       (e); log_css = lb9; }
    if(!consumed_by) { consumed_by = onMove_1_ON_COOLDOWN      (e); log_css = lb1; }
    if(!consumed_by) { consumed_by = onMove_4_MUST_MOVE_MORE   (e); log_css = lb2; }
    if(!consumed_by) { consumed_by = onMove_5_GRAB_SELECTION   (e); log_css = lb5; }
    if(!consumed_by) { consumed_by = onMove_6_GRAB_STICKY      (e); log_css = lb6; }


if( tag_this && (mousemove_consumed_by != consumed_by)) log("%c"+consumed_by, log_css);


    mousemove_consumed_by = consumed_by;

    if(prop.get(t_data.PIN_SEEKSPOT) && prop.get(t_data.FLOATLOG)) t_fly.t_event_LOG_TOOLTIP("PAGE POINTER MOVED");

    return (mousemove_consumed_by != "");
};


let t_TOOL_pointermove_drag = function(e)
{
if(e.ctrlKey) { log("%c TOOL POINTER MOVE IGNORED .. f(e.ctrlKey)", lbH+lf2); del_page_and_tool_pointermove_listeners( "e.ctrlKey" ); return; }

let   caller = "t_TOOL_pointermove_drag";
let log_this = LOG_MAP.EV2_MOVE;

if(LOG_MAP.EV7_DISPATCH && !mousemove_consumed_by) t_fly.t_log_event_status(caller);



    if( !onMove_selection_removed )
    {
        t_window_getSelection_removeAllRanges(caller);
        onMove_selection_removed = true;
    }


    if(!onWork_EL) return;


    get_onMoveDXY(e, caller);

    let x = onDown_XY.x + onMoveDXY.x;
    let y = onDown_XY.y + onMoveDXY.y;


    if(onWork_PANEL == hotspot)
    {
        x -= onDown_XY.x - onDown_PANEL_XY.x;
        y -= onDown_XY.y - onDown_PANEL_XY.y;
        if( hotspot.style.transform != "") {
            x -= onDown_XY.x - onDown_PANEL_XY.x;
            y -= onDown_XY.y - onDown_PANEL_XY.y;
        }
    }



    if(has_el_class(dom_tools_html, t_data.CSS_SLOW_REGROUP))
        leave_CSS_SLOW_REGROUP(caller);



    let                consumed_by = "";                                let log_css =  "";
    if(!consumed_by) { consumed_by = onMove_0_MULTITOUCH       (e        ); log_css = lb9; }
    if(!consumed_by) { consumed_by = onMove_1_STICKY_TOOL_SEEK (e        ); log_css = lb1; }
    if(!consumed_by) { consumed_by = onMove_2_STICKY_TOOL_MOVE (e        ); log_css = lb2; }
    if(!consumed_by) { consumed_by = onMove_3_DIV_MAGNIFY      (e        ); log_css = lb3; }
    if(!consumed_by) { consumed_by = onMove_4_MUST_MOVE_MORE   (e        ); log_css = lb4; }
    if(!consumed_by) { consumed_by = onMove_5_GRAB_SELECTION   (e        ); log_css = lb5; }
    if(!consumed_by) { consumed_by = onMove_6_GRAB_TOOL_PANEL  (e, x, y  ); log_css = lb6; }
    if(!consumed_by) { consumed_by = onMove_7_GRAB_TOOL_CHILD  (e, x, y  ); log_css = lb7; }
    if(!consumed_by) { consumed_by = "DRAGGING ["+get_n_lbl(onWork_EL)+"]"; log_css = lb8;

        if(onWork_PANEL && !t_raise_pivot_PANEL_posted_since_onDown(caller)
           &&               is_a_spread_drag()
          ) {
            t_flash_unpinned_panels(caller);

        }


        if(onWork_PANEL && (onWork_PANEL == hotspot))
        {
            t_tools_pointermove_drag_hotspot(x,y);

        }


        else if(onWork_PANEL) {
            t_set_pivotXY( onMove_pivotXY.x + onMoveDXY.x
                         , onMove_pivotXY.y + onMoveDXY.y);

            t_tools_set_top_xy(h_x, h_y);
        }

    }


if( log_this && (mousemove_consumed_by != consumed_by)) log("%c "+caller+": %c "+consumed_by, lb9, log_css);


    mousemove_consumed_by = consumed_by;

    if(prop.get(t_data.PIN_SEEKSPOT) && prop.get(t_data.FLOATLOG)) t_fly.t_event_LOG_TOOLTIP("TOOL POINTER MOVED");
};




let t_tools_pointermove_drag_hotspot = function(x,y)
{

let   caller = "t_tools_pointermove_drag_hotspot";
let log_this = LOG_MAP.EV2_MOVE;

if( log_this) log(caller);


    if( hotspotXY.gutter_urdl )
    {



        add_long_press_listener("ON MOVE [hotspot] IN GUTTER");
    }


    else if( t_seek.t_seekzone8_isOn_gutter() )
    {

if( log_this) log("%c OFF  GUTTER %c HIDE"
                  ,lbb+lbH+lf7 ,lbH       );

        t_seek.t_seekzone8_hide_gutter();

        t_store_consider_page_items_worth_storing("HOTSPOT OFF GUTTER");
        t_seek.t_seekzone5_hide("instant");
        t_TOOL_SET_eval_wide_or_tall_panel(caller);

        if(   has_moved && (onWork_PANEL == hotspot)
           && prop.get( t_data.EDIT_OR_STAGE ))
            prop.set(   t_data.EDIT_OR_STAGE, false);
    }


    let dragging_pivspot = prop.get( t_data.TOOLS_TRAP );
    if( dragging_pivspot )
    {
        let move_x = false;
        let move_y = false;

        let margin = h_W / 2;
        if     ((onDown_XY_sign.x >  0) && ((x+margin) >  pivotXY.x)) { onMove_pivotXY.x = x+margin; onMoveDXY.x = 0; move_x = true; }
        else if((onDown_XY_sign.x <= 0) && ((x-margin) <= pivotXY.x)) { onMove_pivotXY.x = x-margin; onMoveDXY.x = 0; move_x = true; }

        if     ((onDown_XY_sign.y >  0) && ((y+margin) >  pivotXY.y)) { onMove_pivotXY.y = y+margin; onMoveDXY.y = 0; move_y = true; }
        else if((onDown_XY_sign.y <= 0) && ((y-margin) <= pivotXY.y)) { onMove_pivotXY.y = y-margin; onMoveDXY.y = 0; move_y = true; }

        if(move_x || move_y)
            t_set_pivotXY( move_x ? onMove_pivotXY.x : pivotXY.x
                ,          move_y ? onMove_pivotXY.y : pivotXY.y);
    }

    t_tools_set_top_xy(x, y);

};



let onMove_0_MULTITOUCH = function(e)
{

    let    consumed_by = ((onDown_TOUCHES > 1) ? "MULTI-TOUCH x"+onDown_TOUCHES : "");
    return consumed_by;
};


let onMove_1_ON_COOLDOWN = function(e)
{
    let caller = "onMove_1_ON_COOLDOWN";

    let                                           consumed_by = "";
    if     ( dom_scroll.t_scroll_not_done_yet() ) consumed_by = "SCROLLING";
    else if( move_cooldown_is_pending()         ) consumed_by = "MOVE COOLDOWN "+move_cooldown_reason;

    if(consumed_by)
    {
        consumed_by += ".. (set_onDown_XY tracking)";

        set_onDown_XY(e, caller);
        onMoveDXY.x = 0;
        onMoveDXY.y = 0;
    }


    return consumed_by;
};



let onMove_1_STICKY_TOOL_SEEK = function(e)
{

let   caller = "onMove_1_STICKY_TOOL_SEEK";
let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T6_SLOT;

    log_this = log_this && !mousemove_consumed_by;
    let consumed_by = "";


    let sticky = t_sticky.t_sticky_get_SEEK_NEXT(log_this);
    if(!sticky ) {

if( log_this && !mousemove_consumed_by) log("%c"+caller+"%c NO STICKY SEEK TARGET", lbL+lf1, lbR+lb8);
        return consumed_by;
    }


    if( sticky != onDown_EL) {

if( log_this && !mousemove_consumed_by) log("%c"+caller+"%c NO GRABBED STICKY", lbL+lf1, lbR+lb8);
        return consumed_by;
    }


    consumed_by = caller+": SEEKER MOVE TO STICKY";
if( log_this) t_sticky.t_sticky_LOG(sticky, caller);

    t_seek.t_seeker_onMove2_ON_NEXT_STICKY(sticky, onDown_SCROLL_XY);

    if(!t_seek.t_seeker_PU_is_active())
        t_seek.t_seeker_PU_show();


if( log_this) log("%c"+caller+"%c "+consumed_by+" "+sticky.id, lbL+lf1, lbR+lf9);
    return consumed_by;
};


let onMove_2_STICKY_TOOL_MOVE = function(e)
{

let   caller = "onMove_2_STICKY_TOOL_MOVE";
let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T6_SLOT;

    if(!onWork_EL) return "";


    let sticky = t_sticky.t_sticky_get_onWork_STICKY(log_this && !mousemove_consumed_by);
    if(!sticky ) return "";

    check_has_moved( caller );



    if( t_seek.t_seeker_PU_is_active() )
    {
if(log_this) log("HIDE SEEK TOOL");

        t_seek.t_seeker_PU_hide("instant");
    }


    let consumed_by = "";
    if(!consumed_by && t_sticky.t_sticky_is_RESIZING  (   sticky))
        consumed_by = onMove_2_STICKY_TOOL_MOVE_RESIZE(e, sticky, log_this);

    if(!consumed_by && t_sticky.t_sticky_is_ORIENTING (   sticky))
        consumed_by = onMove_2_STICKY_TOOL_MOVE_DIR   (e, sticky, log_this);

    if(!consumed_by )
        consumed_by = onMove_2_STICKY_TOOL_MOVE_STICKY(e, sticky, log_this);


if( log_this) log("%c"+caller+"%c "+get_n_lbl(sticky)+" %c "+consumed_by, lbH+lf2, lbL+lf4, lbR+lf9);
    return consumed_by;
};


let onMove_2_STICKY_TOOL_MOVE_STICKY = function(e,sticky,log_this)
{

let   caller = "onMove_2_STICKY_TOOL_MOVE_STICKY";

log_this = log_this && !mousemove_consumed_by;

    let consumed_by = "MOVE";


    let  x = onDown_TOOL_XY.x + onMoveDXY.x;
    let  y = onDown_TOOL_XY.y + onMoveDXY.y;
    t_sticky.t_sticky_onMove(x,y);

if( log_this) log("%c"+caller+"%c "+get_n_lbl(sticky)+" %c "+consumed_by, lbH+lf2, lbL+lf4, lbR+lf3);
    return consumed_by;
};


let onMove_2_STICKY_TOOL_MOVE_RESIZE = function(e,sticky,log_this)
{

let   caller = "onMove_2_STICKY_TOOL_MOVE_RESIZE";

    let consumed_by = "";


    if( move_cooldown_is_pending() )
    {
log_this = log_this && !mousemove_consumed_by;

        consumed_by = "RESIZE ON COOLDOWN "+move_cooldown_reason;
    }


    else {
        if(!has_moved) {
            consumed_by     = "STICKY RESIZE STARTING";

            t_set_has_moved(consumed_by);

log_this = log_this && !mousemove_consumed_by;
        }
        else {
            if(!t_sticky.t_sticky_is_RESIZING() ) {
                consumed_by = "STICKY RESIZE LAUNCHING";

                t_sticky.t_sticky_RESIZE(sticky);
            }
            else {
                consumed_by = "STICKY RESIZE HANDLING";

log_this = log_this && !mousemove_consumed_by;
            }
        }
    }

if( log_this) log("%c"+caller+"%c "+get_n_lbl(sticky)+" %c "+consumed_by, lbH+lf2, lbL+lf4, lbR+lf4);
    return consumed_by;
};


let onMove_2_STICKY_TOOL_MOVE_DIR = function(e,sticky,log_this)
{

let   caller = "onMove_2_STICKY_TOOL_MOVE_DIR";

    let consumed_by = "";


    if( move_cooldown_is_pending() )
    {
log_this = log_this && !mousemove_consumed_by;

        consumed_by = "DIR ON COOLDOWN "+move_cooldown_reason;

        set_onDown_XY(e, caller);
    }


    if(!consumed_by) {
        if(!has_moved)
        {
log_this = log_this && !mousemove_consumed_by;

            consumed_by = "TRACK DIR JUST STARTED";
        }
        else {
            let dir
                = (Math.abs(onMoveDXY.x) > Math.abs(onMoveDXY.y))
                ? ((onMoveDXY.x > 0) ? "RIGHT" : "LEFT")
                : ((onMoveDXY.y > 0) ?  "DOWN" : "UP"  )
            ;
            consumed_by = "TRACK DIR "+sticky.touched+" "+dir;

            t_sticky.t_sticky_TRACK_DIR(sticky, dir);

            move_cooldown_start("STICKY .. TRACK DIR "+sticky.touched);
        }
    }

if( log_this) log("%c"+caller+"%c "+get_n_lbl(sticky)+" %c "+consumed_by, lbH+lf2, lbL+lf4, lbR+lf5);
    return consumed_by;
};


let onMove_3_DIV_MAGNIFY = function(e)
{

let   caller = "onMove_3_DIV_MAGNIFY";

    if( !div_slot_containers_displayed() ) return "";
    if( !fullscreen_slot_container       ) return "";
    if( !div_slot_containers             ) return "";

    let consumed_by = t_util.get_id_or_tag(onWork_EL);
    t_preventDefault(e, caller+" "+consumed_by);


    if(move_cooldown_is_pending() )
    {
        set_onDown_XY(e, caller);
    }


    else {
        check_has_moved(caller);
        if(has_moved) {

            let  dir = (Math.abs(onMoveDXY.x) > Math.abs(onMoveDXY.y)) ? ((onMoveDXY.x > 0) ?    "PREV" : "NEXT"    )
                :                                                        ((onMoveDXY.y > 0) ? "ZOOM_IN" : "ZOOM_OUT");


            if((dir == "PREV") || (dir == "NEXT"))
            {
                t_slot_container_set_fullscreen((dir == "PREV") ? button_PREV : button_NEXT);
            }


            else {
                let value = (dir == "ZOOM_IN") ? 1 : -1;
                if( value ) {
                    value += slot_container_magnified_0_to_9;
                    value  = Math.max(value, 0);
                    value  = Math.min(value, 9);
                    if( slot_container_magnified_0_to_9 != value) {
                        slot_container_magnified_0_to_9  = value;
                        t_slot_containers_magnify();
                    }
                }
            }

            move_cooldown_start("DIV_MAGNIFY .. "+dir);
        }
    }

    return consumed_by;
};




const HAS_NOT_MOVED_ENOUGH = "HAS NOT MOVED ENOUGH";
const HAS_MOVED_ENOUGH     = "";

let onMove_4_MUST_MOVE_MORE = function(e)
{

let caller = "onMove_4_MUST_MOVE_MORE";

    if(has_moved && is_long_press_pending())
        del_long_press_listener(caller);

    if(has_moved) return HAS_MOVED_ENOUGH;


let log_this = (LOG_MAP.EV0_LISTEN || LOG_MAP.EV2_MOVE);
if(!log_this) log_this = onDown_CTRL;
    log_this = log_this && !mousemove_consumed_by;

if( log_this) t_fly.t_log_event_status(caller, lf4);


    if(   (onWork_PANEL == hotspot)
       && (onWork_EL    == hotring)
    ) {
        if( !t_gutter.get_XY_URDL(onDown_HSPOT_XY.x, onDown_HSPOT_XY.y, "NO LAG DRAGGING [hotspot] IN-WINDOW") )
        {
            t_set_has_moved(caller+": no lag for [hotring] when not IN GUTTER");

            del_el_class(pivspot, t_data.CSS_HIDDEN);

            return HAS_MOVED_ENOUGH;
        }
    }


    let   sticky  = t_sticky.t_sticky_get_onWork_STICKY();
    if(onWork_EL ==       sticky)
    {
        let dxy  = Math.abs(onMoveDXY.x + onMoveDXY.y);
        if( dxy >= 3*MOVED_ENOUGH)
        {
            if(mousemove_consumed_by == HAS_NOT_MOVED_ENOUGH)
            mousemove_consumed_by = "";
            return HAS_MOVED_ENOUGH;
        }
        else {
            return HAS_NOT_MOVED_ENOUGH;
        }
    }


    if(onWork_PANEL == t_fly.t_fly_div_get())
    {


        return HAS_MOVED_ENOUGH;
    }


    if( onDown_7_STALL_is_pending() )
    {
        let has_not_moved  = "MOVE ON STALL WAKEUP DELAY";

        has_not_moved     += ".. (set_onDown_XY tracking)";
        set_onDown_XY(e, caller);
        onMoveDXY.x       = 0;
        onMoveDXY.y       = 0;

        return has_not_moved;
    }


    if(!has_moved)
    {
        check_has_moved("MOVE CHECK");
    }


    if( has_moved )
    {
        if( is_long_press_pending() )
            del_long_press_listener("HAS MOVED "+has_moved);

        if(onWork_MOVABLE_CHILD) onMove_4_GRAB_PANEL_CHILD();

        if(!onWork_PANEL_was_magnified_onMove && t_is_panel_magnified(onWork_PANEL))
        {

            onWork_PANEL_was_magnified_onMove = true;
            add_el_class(onWork_PANEL, "dragged");
        }


        return HAS_MOVED_ENOUGH;
    }

    return HAS_NOT_MOVED_ENOUGH;
};



let mov_src_div;
let mov_dst_div;

let onMove_4_GRAB_PANEL_CHILD = function()
{

    let     parent_div  = t_util.get_el_parent_with_tag(onWork_EL,"DIV");

    let parent_div_has_movable_child
        =  (parent_div == pat_bag)
        || (parent_div == off_bag)
        || (parent_div == alt_bag)
        || (parent_div == bak_bag)
    ;

    if(!parent_div_has_movable_child) return;


    if(onWork_EL) clr_onWork_EL_pressed();
    onWork_EL = pat_bag9_grab_child( parent_div );

    set_onWork_EL_pressed();
};



let onMove_5_GRAB_SELECTION = function(e)
{

let   caller = "onMove_5_GRAB_SELECTION";
let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T6_SLOT;

if( log_this) t_log.console_clear(caller);

if( log_this) t_fly.t_log_event_status(caller, lbH+lf5);



    let consumed_by = "";
    if( move_cooldown_is_pending() )
    {
        consumed_by = "SELECTION ON COOLDOWN";

if(log_this) logBIG(consumed_by +": "+ move_cooldown_reason);

        return consumed_by;
    }


    let slot  = t_get_onWork_EL_slot();
    if( slot <= 0) return consumed_by;
    if(!t_select.t_select_get_ccs_length() )
    {
if( log_this) log(caller+": SLOT #"+slot+" NOT CURRENLTY INITIALIZED");

        if(t_preventDefault_caller) t_restoreDefault("NOT CURRENLTY INITIALIZED");

        return consumed_by;
    }
    consumed_by = "SCROLL TO [SLOT NUM]";


    if( is_long_press_pending() )
        del_long_press_listener("PAGE DRAGGED");



    let grabbed = t_seek.t_seeker_onMove1_grabbed();
    if(!grabbed) {

    }



    let on_sticky = t_seek.t_seeker_is_onSticky();
    if( on_sticky ) {
if( log_this) log(caller+": on_sticky=["+on_sticky+"]");

        return onMove_1_STICKY_TOOL_SEEK(e);
    }


    let  dir = (!grabbed                                     ) ? (                    DIR_GRAB                     )
        :      (Math.abs(onMoveDXY.x) > Math.abs(onMoveDXY.y)) ? ((onMoveDXY.x > 0) ? DIR_NUM_NEXT  : DIR_NUM_PREV )
        :                                                        ((onMoveDXY.y > 0) ? DIR_SLOT_NEXT : DIR_SLOT_PREV)
    ;



    let quick_move
        = t_seek.t_seeker_is_seeker_PU_ONSEEKER()
        || prop.get(t_data.TOOLS_TIER2)
    ;

    t_seek.t_seeker_set_class(t_data.CSS_QUICK_MOVE, quick_move);


    let to_slot = slot;
    let     num = t_get_onWork_EL_num();
    let  to_num = num;
    let num_max = t_select.t_select_get_slot_nodes_length(slot);
    switch(dir) {

        default:
        case DIR_GRAB:      {
            t_seek.t_seeker_onMove1_grab("GRAB SELECTION");

            t_select.slot_visible_num_array_update( to_slot );
        } break;


        case DIR_NUM_NEXT:  {
            to_num = num + 1;
            to_num = 1 + (num_max + (to_num-1)) % num_max;
            if((to_num < num) && quick_move) {
                to_num = num;

            }
        }
        break;


        case DIR_NUM_PREV:  {
            to_num = num - 1;
            to_num = 1 + (num_max + (to_num-1)) % num_max;
            if((to_num  > num) && quick_move) {
                to_num = num;

            }
        }
        break;


        case DIR_SLOT_NEXT: {
            to_slot      = t_get_used_slot_dir(slot, +1);
            if((to_slot  < slot) && quick_move) {
                to_slot  = slot;

            }

            if( to_slot != slot) {
                to_num   = t_select.ccs[to_slot].num_selected;
                t_seek.t_seeker_from_to_slot_num(slot, num, to_slot, to_num);
            }
        }
        break;


        case DIR_SLOT_PREV: {
            to_slot      = t_get_used_slot_dir(slot, -1);
            if((to_slot  > slot) && quick_move)
            {
                to_slot  = slot;

            }

            if( to_slot != slot) {
                to_num   = t_select.ccs[to_slot].num_selected;
                t_seek.t_seeker_from_to_slot_num(slot, num, to_slot, to_num);
            }
        }
        break;

    }
    slot = to_slot;

    num  = to_num;



    if((slot >= 0) && (num > 0))
    {
        if(!t_seek.t_seeker_PU_is_active())
            t_seek.t_seeker_PU_show();

        t_seek.t_seeker_onMove3_ON_SLOT_NUM(slot, num);


        if( quick_move ) move_cooldown_short("SCROLL TO SLOT "+slot+" (quick)");
        else             move_cooldown_start("SCROLL TO SLOT "+slot           );
    }


    let to_slot_num_EL;
    if(      (slot >= 0) &&                   t_select.ccs[slot]
          && ( num >  0) &&                   t_select.ccs[slot].nodes)
    {
        to_slot_num_EL = t_select.ccs[slot].nodes[num-1];
        if(to_slot_num_EL != onWork_EL)
            t_set_onWork_EL(to_slot_num_EL, caller, e);
    }


if( log_this)
{
    let lfx
        = (dir == DIR_GRAB     ) ? lf8
        : (dir == DIR_NUM_PREV ) ? lf3
        : (dir == DIR_SLOT_NEXT) ? lf4
        : (dir == DIR_NUM_NEXT ) ? lf5
        : (dir == DIR_SLOT_PREV) ? lf6
        :                           lf8;

    log_key_val(  "FROM dir TO slot num"
                , {   from_onWork_EL : get_n_lbl( onWork_EL      )
                    ,      onMoveDXY : onMoveDXY.x+" "+onMoveDXY.y
                    ,            dir
                    , to_slot_num_EL : (to_slot_num_EL ? get_n_lbl(to_slot_num_EL) : "")
                    ,           slot
                    ,            num
                    , onWork_PANEL   : get_n_lbl( onWork_PANEL   )
                    ,     quick_move
                }
                , lbb+lfx
               );

}

if( log_this) log("%c"+caller+"%c"+consumed_by+"%c"+slot+" "+num+" %c"+(quick_move ? " [quick_move]" : "")
                  ,lbH+lf5    ,lbL+lf5         ,lbR+lf5           ,lbH+lf4                                );
    return consumed_by;
};





let t_CURSOR_add_MOVE_LISTENER = function(_caller)
{

let   caller = "t_CURSOR_add_MOVE_LISTENER";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) t_fly.t_log_event_status(caller+" .. CALLED BY "+ _caller, lf4);



    if("ontouchmove"  in document.documentElement) {
        add_listener_capture_active(   window, "touchmove", t_SENTENCE_drag_listener);
    }
    else {
        add_listener_capture_active(   window, "mousemove", t_SENTENCE_drag_listener);
        add_listener_capture_active(   window, "wheel"    , t_SENTENCE_drag_listener);
    }


};


let t_CURSOR_del_MOVE_LISTENER = function(_caller)
{

let   caller = "t_CURSOR_del_MOVE_LISTENER";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) t_fly.t_log_event_status(caller+" .. CALLED BY "+ _caller, lf6);


    t_del_NOT_MOVED_ENOUGH();
    t_del_MOVE_ON_COOLDOWN();


    if( drag_cursor.get_mouseUP_display_state() )
        return;




    if("ontouchmove"  in document.documentElement) {
        remove_listener_capture_active(window, "touchmove", t_SENTENCE_drag_listener);
    }
    else {
        remove_listener_capture_active(window, "mousemove", t_SENTENCE_drag_listener);
        remove_listener_capture_active(window, "wheel"    , t_SENTENCE_drag_listener);
    }

    drag_cursor.hide_drag_cursor();


};


let t_SENTENCE_drag_listener = function(event)
{
if(event.altKey ) return;
if(event.ctrlKey) return;

let   caller = "t_SENTENCE_drag_listener";
let log_this = LOG_MAP.EV2_MOVE;

if(log_this) log(caller);


    get_onMoveDXY(event, caller);

    if(onDown_XY && t_sentence.t_SENTENCE_drag_DXY( onMoveDXY ) )
    {


        drag_cursor.move_drag_cursor(event);
        event.preventDefault();
    }
    else if( drag_cursor.get_mouseUP_display_state() )
    {
        drag_cursor.move_drag_cursor(event);
    }
};




let onMove_5_TOOL_PANEL_PINNED = function(x,y)
{

let caller = "onMove_5_TOOL_PANEL_PINNED";
let log_this = LOG_MAP.EV2_MOVE;



    if( is_long_press_pending() )
    {
        if( check_big_moved(caller) )
            del_long_press_listener("MOVE PINNED");

    }


    let fly_div = t_fly.t_fly_div_get();
    if( t_util.is_el_or_child_of_parent_el(onWork_EL, fly_div) )
    {

        if(t_fly.t_fly_clr_is_pending())
            t_fly.t_fly_clr_cancel();


        t_add_closepin_on_panel( fly_div );
    }


    x -= onDown_XY.x - onDown_PANEL_XY.x;
    y -= onDown_XY.y - onDown_PANEL_XY.y;



    let x_min, x_max, y_min, y_max;
    let apply_pat_bag_min_max = false;
    if( apply_pat_bag_min_max )
    {
        x_min = 0;
        x_max = w_W                    - onWork_PANEL.offsetWidth  * onWork_PANEL.scale;
        y_min = 0;
        y_max = w_H                    - onWork_PANEL.offsetHeight * onWork_PANEL.scale;
    }


    else {
        x_min =       (  BOX_MARGIN  ) - onWork_PANEL.offsetWidth  * onWork_PANEL.scale;
        x_max = w_W - (2*BOX_MARGIN/2);
        y_min =       (  BOX_MARGIN  ) - onWork_PANEL.offsetHeight * onWork_PANEL.scale;
        y_max = w_H - (  BOX_MARGIN/2);
    }


    x = (x < x_min) ? x_min : (x > x_max) ? x_max : x;
    y = (y < y_min) ? y_min : (y > y_max) ? y_max : y;


if(log_this) log(caller+": moving "+onWork_PANEL.id+" TO ["+x+" "+y+"]");
    t_view.t_view3_move_panel_BORDERING(onWork_PANEL,x,y);



};


let onMove_6_GRAB_TOOL_PANEL = function(e,x,y)
{

let   caller = "onMove_6_GRAB_TOOL_PANEL";
let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T6_SLOT;
    log_this = log_this && !mousemove_consumed_by;

if( log_this) log("%c"+caller, lbH+lf6);


    if( onWork_MOVABLE_CHILD) return "";
    if(!onWork_PANEL        ) return "";

    let consumed_by = "";

    if(!consumed_by)
    {
if( t_util.is_el_or_child_of_class(onWork_EL, "zoomed")    )
        consumed_by = "zoomed onWork_EL=["+t_util.get_id_or_tag(onWork_EL)+"]";

    }

    if(!consumed_by && t_touching_a_scrollable_panel(e))
    {


        let panel_scrollbar_showing
            =  (onWork_PANEL.scrollHeight > onWork_PANEL.clientHeight)
            || (onWork_PANEL.scrollWidth  > onWork_PANEL.clientWidth )
        ;
if( log_this) log(caller+": panel_scrollbar_showing "+panel_scrollbar_showing);
        if( panel_scrollbar_showing )
            consumed_by = "SCROLLABLE PANEL ["+get_n_lbl(onWork_PANEL)+"]";
    }


    if(!consumed_by && onWork_PANEL.classList.contains(t_data.CSS_PINNED))
    {
        onMove_5_TOOL_PANEL_PINNED(x, y);
        consumed_by = "TOOL PINNED ["+get_n_lbl(onWork_PANEL)+"]";
    }


    if(!consumed_by && !onWork_PANEL.classList.contains(t_data.CSS_PINNED))
    {
        let moving_a_panel
            =                               onWork_PANEL
            &&                             !onWork_MOVABLE_CHILD
            && !t_util.is_el_or_child_of_parent_el(onWork_EL, t_fly.t_fly_div_get())
        ;

        if( moving_a_panel ) del_el_class(pivspot, t_data.CSS_HIDDEN);
    }

if(log_this) log("%c"+consumed_by, lbb+lbH+lf6);
    return consumed_by;
};


let onMove_6_GRAB_STICKY = function(e)
{

let   caller = "onMove_6_GRAB_STICKY";
let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T6_SLOT;

    log_this = log_this && !mousemove_consumed_by;


if( log_this ) t_fly.t_log_event_status_if_changed(caller,  lf6 );
    let consumed_by = "";



    let onWork_STICKY =  t_sticky.t_sticky_get_onWork_STICKY();
    let seeker_STICKY =  t_seek.t_seeker_get_STICKY();
    let sticky        =  onWork_STICKY || seeker_STICKY;

if( log_this) {
    let l_x
        = (sticky == onWork_STICKY) ? sticky.num
        : (sticky == seeker_STICKY) ? 0
        :                             2;

    log_key_val_group("STICKY GRABBED "+get_n_lbl(sticky)
                      , { t_sticky_get_onWork_STICKY : get_n_lbl( t_sticky.t_sticky_get_onWork_STICKY() )
                        , t_seeker_get_TOOL_label    : t_seek.t_seeker_get_TOOL_label()
                        , t_seeker_onMove1_grabbed   : t_seek.t_seeker_onMove1_grabbed()
                      }
                      , lfX[l_x], true);
}

    if(!sticky) return consumed_by;

    let onSeekXYL   = t_seek.t_seeker_get_onSeekXYL();
    consumed_by = onSeekXYL.label;


    if( is_long_press_pending() )
    {
        del_long_press_listener("SEEK STICKY");

    }


    if( has_el_class(sticky, t_data.CSS_STICKY_RING) )
    {
if( log_this) log("%c NO SEEK ON STICKY_RING", lf8);

        return consumed_by;
    }


    let quick_move
        =  t_seek.t_seeker_is_seeker_PU_ONSEEKER()
        || prop.get(t_data.TOOLS_TIER2)
    ;

    t_seek.t_seeker_set_class(t_data.CSS_QUICK_MOVE, quick_move);



    let  dir = (!t_seek.t_seeker_onMove1_grabbed()                  ) ? (                    DIR_GRAB                      )
        :      (Math.abs(onMoveDXY.x) > Math.abs(onMoveDXY.y)) ? ((onMoveDXY.x > 0) ? DIR_NUM_NEXT  : DIR_NUM_PREV )
        :                                                        ((onMoveDXY.y > 0) ? DIR_SLOT_NEXT : DIR_SLOT_PREV)
    ;

    if(!t_seek.t_seeker_PU_is_active())
        t_seek.t_seeker_PU_show();

    switch(dir)
    {
    default:
    case DIR_GRAB     : { sticky = t_sticky.t_sticky_set_SEEK_NEXT(sticky, onDown_SCROLL_XY,  0); t_seek.t_seeker_onMove1_grab("GRAB STICKY"); } break;
    case DIR_NUM_NEXT : { sticky = t_sticky.t_sticky_set_SEEK_NEXT(sticky, onDown_SCROLL_XY, +1);                                       } break;
    case DIR_NUM_PREV : { sticky = t_sticky.t_sticky_set_SEEK_NEXT(sticky, onDown_SCROLL_XY, -1);                                       } break;
    case DIR_SLOT_PREV: { sticky = t_sticky.t_sticky_set_SEEK_NEXT(sticky, onDown_SCROLL_XY, -1);                                       } break;
    case DIR_SLOT_NEXT: { sticky = t_sticky.t_sticky_set_SEEK_NEXT(sticky, onDown_SCROLL_XY, +1);                                       } break;
    }




    if(!sticky && t_seek.t_seeker_PU_is_active())
    {
        t_seek.t_seeker_PU_hide("instant");
    }



    t_set_has_moved(caller);
    if( quick_move ) move_cooldown_short("SCROLL TO STICKY "+ get_n_lbl(sticky) +" (quick)");
    else             move_cooldown_start("SCROLL TO STICKY "+ get_n_lbl(sticky)            );


if( log_this)
{
    consumed_by += " ["+get_n_lbl(sticky)+"]";

    log_key_val_group("STICKY NEXT "+get_n_lbl(sticky)
                      , {   onMoveDXY : onMoveDXY.x+" "+onMoveDXY.y
                        ,  quick_move
                        ,         dir
                        , consumed_by
                      }
                      , lfX[sticky ? sticky.num : 2], true);
}

    return consumed_by;
};



let onMove_7_GRAB_TOOL_CHILD = function(e,x,y)
{

let   caller = "onMove_7_GRAB_TOOL_CHILD";
let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T6_SLOT;
    log_this = log_this && !mousemove_consumed_by;

if( log_this) log("%c"+caller+"%c onWork_EL "+get_n_lbl(onWork_EL)+" %c onWork_MOVABLE_CHILD "+get_n_lbl(onWork_MOVABLE_CHILD), lbH+lf7, lbH+lf6, lbH+lf5);


if(!onWork_EL           ) return "";
if(!onWork_MOVABLE_CHILD) return "";


    let consumed_by = "MOVING onWork_EL=["+get_n_lbl(onWork_EL)+"] .. mov_src_div=["+get_n_lbl(mov_src_div)+"]";

    let ox = (onDown_XY.x - onDown_TOOL_XY.x);
    let oy = (onDown_XY.y - onDown_TOOL_XY.y);



    x     -= onWork_PANEL.offsetLeft;
    y     -= onWork_PANEL.offsetTop;



    if(onWork_PANEL_magnified) {
        x  /= onWork_PANEL_magnified.scale;
        y  /= onWork_PANEL_magnified.scale;
        ox /= onWork_PANEL_magnified.scale;
        oy /= onWork_PANEL_magnified.scale;

    }

    y     -= onWork_EL.offsetHeight * (behavior_TOUCH_ELSE_DESKTOP ? TOUCH_OFFSET_FACTOR : MOUSE_OFFSET_FACTOR);




    if( pat_bag9_grab_item_is_mov_div() )
    {
        let bag_at_xy = t_pat_bag9_get_bag_at_xy(e,x,y);
        consumed_by+= " .. bag_at_xy=["+bag_at_xy.id+"]";

        let   e_W = onWork_EL.offsetWidth ;
        let   e_H = onWork_EL.offsetHeight;

        let x_min = off_bag.offsetLeft;
        let y_min = bak_bag.offsetTop ;
        let x_max = bak_bag.offsetLeft + bak_bag.offsetWidth  - e_W;
        let y_max = bak_bag.offsetTop  + bak_bag.offsetHeight - e_H;

        x = (x < x_min) ? x_min : (x > x_max) ? x_max : x;
        y = (y < y_min) ? y_min : (y > y_max) ? y_max : y;

        let div_x = x - ox;
        let div_y = y - oy;
        pat_bag9_grab_item_mov_div_xy(e, div_x, div_y, bag_at_xy);
    }


    return consumed_by;
};





let mouseup_consumed_by = "";



const MOUSEUP_DBL_CLICK  = "DBL_CLICK";
const MOUSEUP_CLICK      = "CLICK";
const MOUSEUP_LONG_CLICK = "LONG_CLICK";
const MOUSEUP            = "MOUSE UP";


let t_pointerup_listener  = function(e)
{
if(e.button) return;
if(e.ctrlKey) {logXXX("UP   IGNORED .. f(e.ctrlKey)"); return; }

let   caller = "t_pointerup_listener";
let log_this = !onDown_SHIFT && !onDown_ALT && (LOG_MAP.EV0_LISTEN || LOG_MAP.EV3_UP);

let tag_this = DOM_TOOLS_TAG || log_this;

if( log_this) log("%c"+caller, lbH+lf8);
if(LOG_MAP.EV7_DISPATCH) t_fly.t_log_event_status(caller);


    del_page_and_tool_pointermove_listeners( caller );

    if( is_long_press_pending() )
        del_long_press_listener( MOUSEUP );








    if( t_is_bouncing_e_type(e.type, caller) ) return;


    if(onDown_CTRL ) { log(); return; }
    if(onDown_ALT  ) { log(); return; }
    if(onDown_SHIFT) { log(); return; }



    get_onMoveDXY(e, caller);


onDown_7_STALL_cancel();
    if(!has_moved) check_has_moved(MOUSEUP);


    let has_been_scrolled_by_script = dom_scroll.get_has_been_scrolled_by_script();
    if(!has_moved && behavior_TOUCH_ELSE_DESKTOP && has_been_scrolled_by_script)
        t_set_has_moved( has_been_scrolled_by_script );

    let clicked    = is_a_click(e) && !move_cooldown_is_pending();

    let dblclicked = is_a_dblclick(e, caller);




if( log_this) {
    let detail
        = has_moved  ? has_moved
        : dblclicked ? MOUSEUP_DBL_CLICK
        :    clicked ? MOUSEUP_CLICK
        :              MOUSEUP_LONG_CLICK
    ;
    caller += " "+detail;

    log_key_val( caller+": details"
                 , {   behavior_TOUCH_ELSE_DESKTOP
                     , t_preventDefault_caller
                     , t_event_consumed_cause
                     , clicked
                     , dblclicked
                     , fullscreen_slot_container   : t_util.get_id_or_tag(fullscreen_slot_container)
                     , EDIT_OR_STAGE               : prop.get( t_data.EDIT_OR_STAGE )
                 }
                 , lb0
               );

    t_fly.t_log_event_status(caller, lf8);
}


    let                consumed_by = "";                                            let consumed_by_css =  "";
    if(!consumed_by) { consumed_by = onUp_0_MULTITOUCH         (e                    ); consumed_by_css = lf9; }
    if(!consumed_by) { consumed_by = onUp_1_TOOL_GRID_TIER_CB  (e, clicked,dblclicked); consumed_by_css = lf1; }
    if(!consumed_by) { consumed_by = onUp_2_SLOT_CONTAINER_CB  (e, clicked           ); consumed_by_css = lf2; }
    if(!consumed_by) { consumed_by = onUp_3_STICKY_TOOL_CB     (e, clicked,dblclicked); consumed_by_css = lf3; }
    if(!consumed_by) { consumed_by = onUp_3_SEEKER_TOOL_CB     (e, clicked,dblclicked); consumed_by_css = lf3; }
    if(!consumed_by) { consumed_by = onUp_3_DOC_TOOL_CB        (e, clicked,dblclicked); consumed_by_css = lf3; }
    if(!consumed_by) { consumed_by = onUp_4_DOC_TOUCH_CB       (e, clicked,dblclicked); consumed_by_css = lf4; }
    if(!consumed_by) { consumed_by = onUp_5_TOOL_ONCLICK       (e, clicked,dblclicked); consumed_by_css = lf5; }
    if(!consumed_by) { consumed_by = onUp_7_DOC_SENTENCES      (e, clicked,dblclicked); consumed_by_css = lf7; }
    if(!consumed_by) { consumed_by = onUp_7_DOC_WORDING        (e, clicked,dblclicked); consumed_by_css = lf7; }
    if(!consumed_by) { consumed_by = onUp_8_ON_EVENT_CONSUMED  (e                    ); consumed_by_css = lf8; }
    if(!consumed_by) { consumed_by = e.type+" BUBBLING";                                consumed_by_css = lf9; }
if( tag_this && !mouseup_consumed_by) log("%c"+consumed_by, lbH+consumed_by_css);
    mouseup_consumed_by = consumed_by;
 onUp_9_ON_MOUSEUP_DONE    (e);





if( log_this) t_fly.t_log_event_status(caller+" "+t_data.SYMBOL_RIGHT_ARROW+" "+consumed_by, consumed_by_css);
    if(consumed_by && log_this)
        t_fly.t_log_transcript_event_bot("<span class='big'>"+ t_data.SYMBOL_UP_ARROW +"</span>"
            +                      "<em>"+               consumed_by     +"</em>");



    t_log.log_CLR();


};



let onUp_0_MULTITOUCH = function(e)
{
    onUp_MS = new Date().getTime();


};


let onUp_1_TOOL_GRID_TIER_CB = function(e, clicked, dblclicked)
{

let   caller = "onUp_1_TOOL_GRID_TIER_CB(clicked "+clicked+")";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) t_fly.t_log_event_status(caller, lf1);

    if(!clicked                          ) return "";

    if( prop.get( t_data.EDIT_OR_STAGE ) ) return "";

    let is_on_grid = call_t_grid_IS_ON_GRID(caller);

    let consumed_by = "";

    if(!is_on_grid && has_moved)
    {
        if(check_big_moved(caller) ) {
if( log_this) logBIG("BIG MOVE .. CLICK DENY", lf2);
            return consumed_by;
        }
        else {
if( log_this) logBIG("SMALL MOVE .. CLICK ALLOW", lf7);
        }
    }



    if(!consumed_by && dblclicked && !is_on_grid)
    {
        if(onWork_EL == hotring) {
            consumed_by     = "MOVING TOOLS ON GRID";

            t_move_TOOLS_ON_GRID("DOUBLE CLICK");
        }
    }


    if(   !consumed_by
       &&  is_on_grid
      ) {

        if((onWork_EL == hotring) || dimm_mask_is(onWork_EL))
        {
            if( !was_a_too_early_last_result() ) {
                consumed_by = " MOVING TOOLS OFF GRID";

                t_move_TOOLS_OFF_GRID("CLICK");

                t_sync_layout(caller);
            }
            else {
if(log_this) logBIG("TOO EARLY: NOT MOVING TOOLS OFF GRID");

            }
        }


        else {
            consumed_by = " SELECT TOOLS ON GRID ";

            t_grid.t_grid_TOOLS_SELECT(e);
        }

    }


    if(   !consumed_by
       && !is_on_grid
       && (onWork_EL == hotring)
      ) {
        prop.set(t_data.TOOLS_TIER2, false);
        if( t_activate_tools_tier1("CLICK") ) {
            consumed_by = "HOTSPOT CLICKED .. SELECT "+ t_data.TOOLS_TIER2;
        }
        else {
            consumed_by = "HOTSPOT CLICKED .. NO TOOL PANEL SELECTED";
            if( t_gutter.is_hotspot_IN(hotspot, "HOTSPOT CLICKED") ) {
                t_tools_show  ();
            }
            else {
                t_tools_hide();
            }
        }
    }

if(log_this) log(consumed_by);
    return consumed_by;
};


let onUp_2_SLOT_CONTAINER_CB = function(e, clicked)
{

let   caller = "onUp_2_SLOT_CONTAINER_CB";
if(!is_a_DOM_LOAD_featured_function(caller)) return "";
let log_this = !onDown_SHIFT && (LOG_MAP.EV3_UP || LOG_MAP.T1_DOM_LOAD);

if( log_this) caller += "(clicked "+clicked+")";
if( log_this) t_fly.t_log_event_status(caller, lf2);


    if(                                     !onWork_EL                        ) return "";
    if(   t_util.is_el_or_child_of_parent_el(onWork_EL, t_fly.t_fly_div_get())) return "";
    if(                                     (onWork_EL.tagName == "A"         )
       && t_util.is_el_or_child_of_parent_el(onWork_EL, dimm_mask)            ) return "";
    if(!clicked                                                               ) return "";
    if(!div_slot_containers_displayed()                                       ) return "";
    if( has_moved                                                             ) return "";
    if( was_a_too_early_last_result()                                         ) {
if(log_this) logBIG("TOO EARLY: FOR "+ caller);                                 return "";
    }



    let clicked_COPY_TO_CLIPBOARD = has_el_class(                 onWork_EL, CSS_BUTTON_COPY   ) ? "COPY TO CLIPBOARD" : "";
    let clicked_MAGNIFY_START     = has_el_class(                 onWork_EL, CSS_BUTTON_MAGNIFY) ?           "MAGNIFY" : "";
    let clicked_PREV              = has_el_class(                 onWork_EL, CSS_BUTTON_PREV   ) ?      "MAGNIFY PREV" : "";
    let clicked_NEXT              = has_el_class(                 onWork_EL, CSS_BUTTON_NEXT   ) ?      "MAGNIFY NEXT" : "";
    let clicked_MONO              = has_el_class(                 onWork_EL, CSS_BUTTON_MONO   ) ?         "MONOSPACE" : "";
    let clicked_MAGNIFY_STOP      = (fullscreen_slot_container == onWork_EL                    ) ?      "MAGNIFY_STOP" : "";


    let clicked_target
        = clicked_COPY_TO_CLIPBOARD ? onWork_EL.parentElement
        : clicked_MAGNIFY_START     ? onWork_EL
        : clicked_PREV              ? onWork_EL
        : clicked_NEXT              ? onWork_EL
        : clicked_MONO              ? onWork_EL
        : clicked_MAGNIFY_STOP      ? null
        :                             onWork_EL
    ;

    let consumed_by               =  "ON "+ t_util.get_id_or_tag( onWork_EL );

if(log_this) {
    log_key_val(   caller
               , { consumed_by
                 , clicked_COPY_TO_CLIPBOARD
                 , clicked_MAGNIFY_START
                 , clicked_PREV
                 , clicked_NEXT
                 , clicked_MONO
                 , clicked_MAGNIFY_STOP
                 , clicked_target            : get_n_lbl(clicked_target)
                 }
               , lf2);
}


    if(clicked_MAGNIFY_START) {
        if(!div_slot_containers.children[0].on_grid_top ) {

            for(let i=0; i < div_slot_containers.children.length; ++i)
            {
                let child = div_slot_containers.children[i];
                child.on_grid_top = parseInt(window.scrollY + child.getBoundingClientRect().top);

            }
        }
    }


    if     (clicked_MAGNIFY_START                      ) { consumed_by = clicked_MAGNIFY_START    +" .. "+consumed_by; t_slot_container_set_fullscreen( clicked_target ); }
    else if(clicked_PREV                               ) { consumed_by = clicked_PREV             +" .. "+consumed_by; t_slot_container_set_fullscreen( clicked_target ); }
    else if(clicked_NEXT                               ) { consumed_by = clicked_NEXT             +" .. "+consumed_by; t_slot_container_set_fullscreen( clicked_target ); }
    else if(clicked_MONO                               ) { consumed_by = clicked_MONO             +" .. "+consumed_by; t_slot_container_set_fullscreen( clicked_target ); }
    else if(clicked_MAGNIFY_STOP                       ) { consumed_by = clicked_MAGNIFY_STOP     +" .. "+consumed_by; t_slot_container_set_fullscreen( clicked_target ); }
    else if(clicked_COPY_TO_CLIPBOARD && clicked_target) { consumed_by = clicked_COPY_TO_CLIPBOARD+" .. "+consumed_by;
        let container_to_copy_from
            = (clicked_target.id == "button_COPY_ALL_parent_div")
            ?  clicked_target.parentElement
            :  clicked_target
        ;

        t_slot_containers_copy_to_clipboard_outerHTML( container_to_copy_from );


        for(let i=0; i < div_slot_containers.children.length; ++i)
            del_el_class(div_slot_containers.children[i], CSS_FOCUSSED);
        add_el_class(        clicked_target             , CSS_FOCUSSED);
    }


    else if( clicked_target )
    {
        consumed_by += " .. SCROLL TO "+t_onclick_target_handle_scroll_to_slot_num(clicked_target, caller);

        dimm_stop( caller );
    }


    else {
        consumed_by += " .. SCROLL BACK TO DIM START POINT";

        dom_scroll.t_window_scrollTo(0, onDown_SCROLL_XY.y);

        dimm_stop( caller );
    }

if(log_this)  log("%c"+caller+":%c"+LF+consumed_by, lf2, lbF+lf2);
    return consumed_by;
};


let onUp_3_STICKY_TOOL_CB = function(e,clicked,dblclicked)
{

let   caller = "onUp_3_STICKY_TOOL_CB";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) t_fly.t_log_event_status(caller, lf3);


    let consumed_by = "";
    let sticky      = t_sticky.t_sticky_get_onWork_STICKY();
    if( sticky && has_el_class(sticky, t_data.CSS_HAS_FOCUS))
    {
if( log_this) log("%c sticky.touched=["+sticky.touched+"]", lf3);

        if( t_sticky.t_sticky_is_EDITING( sticky ) )
            consumed_by = "IGNORING EDITED STICKY "+sticky.id;

        else if( t_sticky.t_sticky_EDIT_DONE() )
            consumed_by = "LEAVING  EDITED STICKY "+sticky.id;

if( log_this) log(caller+"%c consumed_by=["+consumed_by+"]", lbH+lf3);
        return consumed_by;
    }
    let sticky_is_EDITING   = t_sticky.t_sticky_is_EDITING( sticky );


    let onDown_sticky       = sticky && (onDown_EL == sticky) ;
    let seeker_PU_is_active = t_seek.t_seeker_PU_is_active();

if( log_this) {
    let onSeekXYL = t_seek.t_seeker_get_onSeekXYL();
    log_key_val(caller
                , {   seeker_PU_is_active
                    , onDown_sticky
                    , onSeekXYL
                    , sticky_is_EDITING
                    , sticky                : "["+ get_n_lbl( sticky       )       +"]"
                    , onDown_EL             : "["+ get_n_lbl( onDown_EL    )       +"]"
                    , onWork_EL             : "["+ get_n_lbl( onWork_EL    )       +"]"
                    , onWork_PANEL          : "["+ get_n_lbl( onWork_PANEL )       +"]"
                    , onWork_SEEK_TARGET    : "["+ t_seek.t_seeker_get_TOOL_label()+"]"
                    , clicked
                    , dblclicked
                    , has_moved
                    , onDown_SEL_TEXT       : "["+ onDown_SEL_TEXT                 +"]"
                }, lf3);
}
    let rejected_by = "";


    if(!consumed_by && onDown_sticky)
    {
        rejected_by
            = !clicked                          ?     "NO CLICK"
            :  dblclicked                       ? "DOUBLE CLICK"
            :  has_moved                        ? "HAS MOVED ["+has_moved+"]"
            :  prop.get(t_data.EDIT_OR_STAGE)   ? "HIDE EDIT MODE"
            :                                     "NO [sticky] TRANSITION";

        if(    clicked
           && !dblclicked
           && !has_moved
           && !prop.get(t_data.EDIT_OR_STAGE)
          )
            consumed_by = t_sticky.t_sticky_CLICK_CB(sticky);

    }


if(log_this) {
    if     (consumed_by) log("%c"+caller+":%c consumed_by %c STICKY "+consumed_by, lbb+lbH+lf3, lbL, lbb+lbH+lf4);
    else if(rejected_by) log("%c"+caller+":%c rejected_by %c PAGE "  +rejected_by, lbb+lbH+lf3, lbL, lbb+lbH+lf8);
    else                 log("%c"+caller+":%c NOT CONSUMED"                      , lbb+lbH+lf3,      lbb+lbH+lf8);
}

    return consumed_by;
};


let onUp_3_SEEKER_TOOL_CB = function(e,clicked,dblclicked)
{

let   caller = "onUp_3_SEEKER_TOOL_CB";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) t_fly.t_log_event_status(caller, lf3);


    let consumed_by = "";

    if( clicked ) consumed_by = t_seek.t_seeker_onClick();

if(log_this && consumed_by) log("%c"+caller+":%c consumed_by %c SEEKER: "+consumed_by, lbb+lbH+lf3, lbL, lbb+lbH+lf4);

    return consumed_by;
};


let onUp_3_DOC_TOOL_CB = function(e,clicked,dblclicked)
{

let   caller = "onUp_3_DOC_TOOL_CB";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) log("%c"+caller, lf3);

    if( !onWork_EL                  ) return "";
    if( dblclicked                  ) return "";
    if( t_event_has_been_consumed() ) return "";

    let consumed_by = "";


    if( clicked )
    {
        let doc_div = onWork_EL.id.startsWith("doc_evt_div") ? t_fly.t_doc_evt_div_get()
            :         onWork_EL.id.startsWith("doc_log_div") ? t_fly.t_doc_log_div_get()
            :         null;
        if(doc_div) {
            if(has_el_class(onWork_EL, CSS_CLOSEPIN)) {
                consumed_by     = "EMBEDDED TOOL: CLOSING "+doc_div.id;
                t_fly.t_doc_div_clear(doc_div.id);
            }
            else {
                consumed_by     = "EMBEDDED TOOL: CLICK IGNORED";
            }
        }
        else {
if(log_this) log("NO DOC EMBEDDED TOOL");
        }
    }




if(log_this) log(consumed_by);
    return consumed_by;
};


let onUp_4_DOC_TOUCH_CB = function(e,clicked,dblclicked)
{

let   caller = "onUp_4_DOC_TOUCH_CB";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) log("%c"+caller, lf4);


    let is_a_tool               = t_is_a_tool_el(onWork_EL, caller);
    let is_an_embedded_doc_tool = t_is_an_embedded_doc_tool(onWork_EL,log_this);

    let rejected_by
        = (!clicked                         ) ? "!clicked"
        : ( is_a_tool                       ) ? "is_a_tool"
        : ( is_an_embedded_doc_tool         ) ? "is_an_embedded_doc_tool"
        : ( prop.get( t_data.ANCHOR_FREEZE )) ? t_data.ANCHOR_FREEZE
        : ( prop.get( t_data.WORDING       )) ? t_data.WORDING
        : ( dblclicked                      ) ? "dblclicked"
        : ( t_event_has_been_consumed()     ) ? t_event_consumed_cause
        :                                        ""
    ;

    if(rejected_by) {
if( log_this) log("%c"+caller+"%c rejected_by %c"+rejected_by, lf4, lbA, lf9);
        return "";
    }


    let el_event_handler  = t_util.get_el_event_handler(onWork_EL, caller);
    rejected_by
        = (el_event_handler == null)
        ? "NO EVENT HANDLER"
        : "";
    if(rejected_by) {
if( log_this) log("%c"+caller+"%c rejected_by %c"+rejected_by, lf4, lbA, lf9);
        return "";
    }


if( log_this) log("...handler=["+el_event_handler.label+"]");
    let consumed_by = onUp_45_el_event_handler(e, el_event_handler);


if( log_this) log("%c"+caller+"%c consumed_by %c"+consumed_by, lbL, lbC, lbR+lf4);
    return consumed_by;
};


let onUp_5_TOOL_ONCLICK = function(e,clicked,dblclicked)
{

let   caller = "onUp_5_TOOL_ONCLICK";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) t_fly.t_log_event_status(caller+"(clicked "+clicked+")", lf5);

    let rejected_by
    = ( t_event_has_been_consumed()       ) ? t_event_consumed_cause
    : (!t_is_a_tool_el(onWork_EL, caller) ) ? "NOT A TOOL ["+get_n_lbl(onWork_EL)+"]"
    :                                          "";
if( log_this && rejected_by) log("%c"+caller+"%c rejected_by %c"+rejected_by, lf5, lbA, lf9);
    if(rejected_by) return "";
if( log_this) log("%c"+caller, lf5);

    let consumed_by = "ON TOOL .. ["+get_n_lbl(onWork_EL)+"]";


    let sticky = t_sticky.t_sticky_get_onWork_STICKY();
    if(has_moved && (onWork_PANEL || (onWork_EL == sticky)))
    {
        t_save_update_post(caller);
    }


    if(onWork_PANEL && clicked && has_moved)
    {
        if(check_big_moved(caller) )
        {
if(log_this) log("%c [CLICKED + BIG   MOVE] .. CANCEL CLICK ON ["+get_n_lbl(onWork_PANEL)+"]", lf5);
            clicked = false;
        }
        else {
if(log_this) log("%c [CLICKED + SMALL MOVE] .. CANCEL MOVE  ON ["+get_n_lbl(onWork_PANEL)+"]", lf6);
            t_clr_has_moved(caller);
        }
    }











    if(dblclicked) {
        if(      clear_DBLCLICK_for_panel( onWork_PANEL  ) ) { consumed_by += " DBLCLICK PANEL CLEAR"; t_clear(caller);                                  }
        else if( filter_STANDBY_for_panel( onWork_PANEL  ) ) { consumed_by += " DBLCLICK STANDBY"    ; t_onClick_1_onWork_EL(0, true); }
        else if( shake_ON_DBLCLICK_for   ( onWork_PANEL  ) ) { consumed_by += " DBLCLICK TOOL PANEL" ;


            if(onWork_EL == onWork_PANEL)
            {
                if( !t_has_push_pin_on_panel( onWork_PANEL ) ) t_add_toolpins_on_panel( onWork_PANEL );
                else                                           t_del_toolpins_on_panel( onWork_PANEL );
            }

            else if(!t_has_push_pin_on_panel( onWork_PANEL ) )
            {
                if(onWork_EL.blur) t_blur( onWork_EL );        t_add_toolpins_on_panel( onWork_PANEL );
            }

            clicked = false;
        }
    }


    if(   (hotspot == onWork_PANEL)
       &&  prop.get( t_data.EDIT_OR_STAGE )

      ) {
        if( clicked ) {
            prop.toggle( t_data.MASK_OR_HIDE );
            consumed_by += " CLICK .. NODE TO HIDE "+ (prop.get( t_data.MASK_OR_HIDE ) ? "MASKED" : "HIDDEN");
        }


    }



    if(clicked && is_a_seeker_target(onWork_EL)  && t_seek.t_seeker_has_TARGET())
    {
if( log_this) log("%c clicked ON %c SEEKER %c"+t_seek.t_seeker_get_TOOL_label()+"%c WHICH IS NOT A TOOL"
                  ,lbH+lf5      ,lbL+lf6  ,lbR+lf6                       ,lbH+lf5                );

        t_seek.t_seeker_PU_hide("instant");

        consumed_by = "";
    }


    else if( clicked && !has_moved) {
        if     ( sticky             == onWork_EL                 ) { consumed_by += " .. CLICK [sticky]"       ; t_onClick_1_onWork_EL(               ); }
        else if( dimm_mask          == onWork_EL                 ) { consumed_by += " .. CLICK [dimm_mask]"    ; t_onClick_1_onWork_EL(               ); }
        else if( filter_SEL_CLICK_for (onWork_EL               ) ) { consumed_by += " .. CLICK [DOC SEL CLICK]"; t_onClick_1_onWork_EL(0, false       ); }
        else if( has_el_class         (onWork_EL, CSS_PUSH_PIN ) ) { consumed_by += " .. CLICK [push_pin]"     ; t_onClick_1_onWork_EL(               ); }
        else if( has_el_class         (onWork_EL, CSS_CLOSEPIN ) ) { consumed_by += " .. CLICK [closepin]"     ; t_onClick_1_onWork_EL(               ); }
        else if( has_el_class         (onWork_EL, CSS_SCALEPIN ) ) { consumed_by += " .. CLICK [scalepin]"     ; t_onClick_1_onWork_EL(               ); }
        else if( has_el_class         (onWork_EL, CSS_CLEARPIN ) ) { consumed_by += " .. CLICK [clearpin]"     ; t_onClick_1_onWork_EL(               ); }
        else if( has_onclick_for      (onWork_EL               ) ) { consumed_by += " .. CLICK [onWork_EL]"    ; t_onClick_1_onWork_EL(               ); }
        else if( has_onclick_for      (onWork_PANEL            ) ) { consumed_by += " .. CLICK [onWork_PANEL]" ; t_onClick_1_onWork_EL(T_ONCLICK_DELAY); }
        else {
            let el_event_handler =  t_util.get_el_event_handler(onWork_EL, caller);
            if( el_event_handler )
                consumed_by += onUp_45_el_event_handler(e, el_event_handler);
        }
    }


    else if(has_moved) {

        if(    mov_dst_div && mov_src_div

          ) {
            if(mov_dst_div != mov_src_div)
                consumed_by += t_pat_bag9_move_pattern_from_src_to_dst_div();
            else
                consumed_by += " MOVING PATTERN IN "+get_n_lbl(mov_dst_div);
        }


        else if(onWork_PANEL) {
            consumed_by += " TOOL MOVED";


            let is_a_pinned_transcript
                =  (      (onWork_PANEL                 == transcript1)
                       || (onWork_PANEL                 == transcript2))
                && (       onWork_PANEL.classList.contains(t_data.CSS_PINNED ));


            let key =      onWork_PANEL.id+"_XY";
            if( is_a_pinned_transcript )
            {
                let  xy = t_util.get_el_xy(onWork_PANEL, caller);
                t_store.t_store_set_value(key, JSON.stringify(xy));
                consumed_by += " (a pinned transcript)";
            }
            else {
                t_store.t_store_set_value(key, null);
            }

        }

    }


    if(consumed_by) t_event_add_e_consumed_by(e, consumed_by);

if( log_this) log("...return %c"+consumed_by, lbH+lf5);
    return consumed_by;
};


let   shake_ON_DBLCLICK_for = function(el)
{
    if(     !el   ) return false;
    if(     !el.id) return false;

    return  has_el_class(el, CSS_TRANSCRIPT);

};


let   clear_DBLCLICK_for_panel = function(panel)
{
    if(     !panel   ) return false;
    if(     !panel.id) return false;

    let is_a_pinned_transcript
        =  (      (panel == transcript1)
               || (panel == transcript2)
           ) &&   (panel.classList.contains(t_data.CSS_PINNED))
    ;

    return  is_a_pinned_transcript;
};


let   has_onclick_for = function(el)
{

let   caller = "has_onclick_for";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

    if(!el   ) return false;
    if(!el.id) return false;



    let bag_id = t_get_bag_id(el);

    let result
        = (                         (bag_id != "")
           || is_a_toggle_option    ( el.id      )
           || get_n_lbl( prop.get_EL( el.id     ))
          );


if( log_this)
    log("%c "+caller+"("+get_n_lbl(el)+"): %c ...return "+result   +"%c el=["+get_n_lbl(el)+"]%c parent=["+get_n_lbl(t_util.get_el_parent_with_id(el))+"]%c bag=["+bag_id+"]"
        ,lbL                              ,lbR+(result ? lf5 : lf8) ,lbL                     ,lbR+lf7                                                   ,lbC+lf3             );

    return result;
};


let   is_a_toggle_option = function(id)
{

let   caller = "is_a_toggle_option";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;



    if(!id) return false;
    let result
        =  (id ==  t_data.DOM_FREEZE      )
        || (id ==  t_data.USER_LANG       )
        || (id ==  t_data.ANCHOR_FREEZE   )
        || (id ==  t_data.CONTAINERS_HI   )
        || (id ==  t_data.SCROLL_SMOOTH   )
        || (id ==  t_data.OVERFLOW_VISI   )
        || (id ==  t_data.DETAILS_RADIO   )

        || (id ==  t_data.SHOW_SEEKZONE   )
        || (id ==  t_data.PIN_SEEKSPOT    )
        || (id ==  t_data.LOG_SEEKSPOT    )
        || (id ==  t_data.REMOVE_ADS      )
        || (id ==  t_data.SPLIT_WOT       )
        || (id ==  t_data.LINES_WOT       )

        || (id ==  t_data.SITE_OR_PAGE    )
        || (id ==  t_data.MASK_OR_HIDE    )
        || (id ==  t_data.EDIT_OR_STAGE   )
        || (id ==  t_data.DOM_HIDE1_RESET )
        || (id ==  t_data.DOM_HIDE1_UNDO  )
        || (id ==  t_data.DENY_OR_ALLOW   )

        || (id ==  t_data.THEME_DARK      )
        || (id ==  t_data.TOOLS_TRAP      )
        || (id ==  t_data.TOOLS_TIER2     )
        || (id ==  t_data.TOOLS_SCROLL    )

        || (id ==  t_data.WORDING         )
        || (id ==  t_data.WORDS_EXACT     )
        || (id ==  t_data.WORDS_SEGMENT   )
        || (id ==  t_data.WORDS_HEAD_TAIL )
        || (id ==  t_data.WORDS_OPCYCLE   )

        || id.startsWith( t_data.SQUEEZE_CYCLE )

        || get_words_drop_affix_array().includes(id)
    ;


if( log_this)
    log("%c "+caller+"("+id+"): %c ...return "+result
        ,lbL                   ,lbR+(result ? lf5 : lf8));

    return result;
};


let   filter_STANDBY_for_panel = function(panel)
{
    if(    !panel   ) return false;
    if(    !panel.id) return false;
    return (onStandby_PANEL != null )
        && (onStandby_PANEL == panel)
    ;
};


let   filter_SEL_CLICK_for = function(el)
{
    if(    !el   ) return false;
    if(    !el.id) return false;
    return  el.id.startsWith("thumb_p_")
        ||  el.id.startsWith("thumb_s_")
    ;
};


let onUp_45_el_event_handler = function(e, el_event_handler)
{

let   caller = "onUp_45_el_event_handler";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) log("%c"+caller, lbb+lf7);

    let consumed_by = "";


if( log_this) log("behavior_TOUCH_ELSE_DESKTOP=["+behavior_TOUCH_ELSE_DESKTOP+"]");
if( log_this) log("t_preventDefault_caller=["+t_preventDefault_caller+"]");

    if(behavior_TOUCH_ELSE_DESKTOP && t_preventDefault_caller)
    {
        consumed_by = "MOBILE  CALLING EVENT HANDLER ["+ get_n_lbl(onWork_EL) +"] ["+el_event_handler.label+"] HANDLER";

        if(t_preventDefault_caller) t_restoreDefault("ON TOUCH UP");

        el_event_handler.handler(e);
        t_cache_armed_by( consumed_by );
    }


    else {
        consumed_by = "BUBBLING TO DOC EVENT HANDLER: ["+ el_event_handler.label +"]";

    }

if( log_this) log("%c"+caller+"%c consumed_by %c"+consumed_by, lbL, lbC, lbR+lf3);
    return consumed_by;
};



let onUp_7_DOC_SENTENCES = function(e, clicked, dblclicked)
{

let   caller = "onUp_7_DOC_SENTENCES";
let log_this = !onDown_SHIFT && (LOG_MAP.EV3_UP || LOG_MAP.T1_DOM_LOAD);

if( log_this) t_fly.t_log_event_status(caller, lf7);


if(!is_a_DOM_LOAD_featured_function(caller)) return "";

    let rejected_by
        = (!clicked                           ) ? "!clicked"
        : ( has_moved                         ) ? has_moved
        : (onDown_TOUCHES > 1                 ) ? ""
        : ( t_event_has_been_consumed()       ) ? t_event_consumed_cause
        : ( t_is_a_tool_el(onWork_EL, caller) ) ? "[onWork_EL] IS A TOOL"
        : ( t_seek.t_seeker_PU_is_active()    ) ? "[seeker_PU] IS ACTIVE"
        :                                          "";
if( log_this && rejected_by) log("%c"+caller+"%c rejected_by %c"+rejected_by, lf7, lbA, lf9);
    if(rejected_by) return "";

if( log_this) log("%c"+caller+"%c clicked "+clicked  +"%c dblclicked "+dblclicked+"%c was_a_click "+was_a_click()+"%c onDown_TOUCHES=["+onDown_TOUCHES+"]"
                   ,lf7        ,lbL+lfX[clicked ? 5:8] ,lbR+lfX[dblclicked ? 5:8]  ,lbH+lfX[dblclicked ? 5:8]       ,lbH+lf8                               );

    let consumed_by = "";


    let { container , cells } = dom_sentence.t_SENTENCE_GET_EL_CONTAINER( onDown_EL );
    if(   container )
    {

        if( cells )
        {
            for(let i=0; i < cells.length; ++i)
                consumed_by
                    =     t_sentence.t_SENTENCE_RESTORE_EL(cells[i], e)
                    ||    consumed_by
            ;
        }



        if(!consumed_by)
        {
            if(!t_util.is_el_child_of_id(onWork_EL, "log_popup_div") )
            {

                consumed_by = t_sentence.t_SENTENCE_RESTORE_EL(container, e);
            }
            else {
                if( t_util.is_el_child_of_class(onWork_EL, "xpath") )
                {
                    consumed_by = "CLOSING LOG POPUP";

                    t_popup.log_popup_hide();
                }
                else {
                    consumed_by = "RESTORING ALL CONTAINERS SENTENCES";

                    t_sentence.t_SENTENCE_RESTORE_ALL( e );
                }
            }
        }

        drag_cursor.set_mouseUP_display_state(false);
    }

    if( consumed_by )
        t_event_set_e_consumed_by(e, consumed_by);

if(log_this && consumed_by) log("%c"+consumed_by, lbb+lbH+lf7);
    return consumed_by;
};


let onUp_7_DOC_WORDING = function(e, clicked, dblclicked)
{

let   caller = "onUp_7_DOC_WORDING";
if(!is_a_DOM_LOAD_featured_function(caller)) return "";
let log_this = !onDown_SHIFT && (LOG_MAP.EV3_UP || LOG_MAP.T1_DOM_LOAD);

    let rejected_by
        = (!clicked                           ) ? "!clicked"
        : ( has_moved                         ) ? has_moved
        : (onDown_TOUCHES > 1                 ) ? ""
        : ( t_event_has_been_consumed()       ) ? t_event_consumed_cause
        : ( t_is_a_tool_el(onWork_EL, caller) ) ? "[onWork_EL] IS A TOOL"
        : ( t_seek.t_seeker_PU_is_active()    ) ? "[seeker_PU] IS ACTIVE"
        :                                          "";
if( log_this && rejected_by) log("%c"+caller+"%c rejected_by %c"+rejected_by, lf7, lbA, lf9);
    if(rejected_by) return "";

if( log_this) log("%c"+caller+"%c clicked "+clicked  +"%c dblclicked "+dblclicked+"%c was_a_click "+was_a_click()
                  ,lf7         ,lbL+lfX[clicked ? 5:8] ,lbR+lfX[dblclicked ? 5:8] ,lbH+lfX[dblclicked ? 5:8]     );

    let consumed_by = "";


    if(!consumed_by && !(dblclicked || (onDown_TOUCHES > 1)))
    {
        if( was_a_misclick() )
        {
if(log_this) logBIG("WAS A MISSCLICK", lf3);

            consumed_by = "DOC MISSCLICK";

        }
        else {

            if( t_seek.t_seeker_has_TARGET() )
            {
                let slot    = t_get_onWork_EL_slot();
                consumed_by = "DOC CLICK: CLEAR SLOT #"+slot;

                clear_clicked_slot( slot );
            }


            if(!consumed_by && prop.get( t_data.EDIT_OR_STAGE ))
            {
                consumed_by = t_tools_hide_onDown_XY();

            }


            else if(!consumed_by && onWork_EL)
            {

                let has_event_handler       = t_util.get_el_event_handler(onWork_EL,caller);
                let is_an_embedded_doc_tool =   t_is_an_embedded_doc_tool(onWork_EL,log_this);
                let                    cs   =            getComputedStyle(onWork_EL);
                let user_select_allowed     = (cs.userSelect != "none");

if( log_this) log_key_val(    "ON A DOC WORD"
                          , { onWork_EL
                            , has_event_handler
                            , is_an_embedded_doc_tool
                            , user_select_allowed : user_select_allowed+" .. ["+cs.userSelect+"]"
                          } , lbH+lf8
                         );

                if(user_select_allowed && (!has_event_handler || !is_an_embedded_doc_tool))
                {
                    consumed_by = "DOC CLICK .. NO HANDLER for ["+t_util.get_n_lbl(onWork_EL)+"]";



                    onUp_7_DOC_CB_CLICK_WORD(consumed_by);
                }


                else {
                    if(is_an_embedded_doc_tool)
                    {
if(log_this) log("DOC CLICK .. NOT CONSUMED .. EMBEDDED DOC TOOL "+get_id_or_tag(onWork_EL));

                        t_acceptBubble(e, caller+" EMBEDDED DOC TOOL", log_this);
                    }
                    else if(prop.get(t_data.ANCHOR_FREEZE) || prop.get(t_data.WORDING))
                    {
                        consumed_by = "DOC CLICK .. HANDLER FREEZED";

                        t_preventDefault(e, caller+" "+consumed_by);

                        onUp_7_DOC_CB_CLICK_WORD(consumed_by);
                    }
                    else {

                        consumed_by = "DOC CLICK .. NO FREEZED HANDLER .. NO EMBEDDED TOOL";

                        t_acceptBubble(e, caller+" "+consumed_by);
                    }
                }

            }

        }
    }

if(log_this && consumed_by) log("%c"+consumed_by, lbb+lbH+lf7);
    return consumed_by;
};


let onUp_7_DOC_CB_CLICK_WORD = function(doc_click_context)
{

let   caller = "onUp_7_DOC_CB_CLICK_WORD";
if(!is_a_DOM_LOAD_featured_function(caller)) return;
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) caller += "("+doc_click_context+")";



    call_touchedWord(onDown_XY.x, onDown_XY.y);




    if( !t_select.get_touchedWord_range_parent() )
    {
if( log_this) log("%c "+caller+" %c NO SELECTION RANGE",lbL+lf7  ,lbR+lf2);

        return;
    }


    let  touchedWord_slot = t_select.get_touchedWord_slot();
    if( !touchedWord_slot )
    {
if( log_this) log("%c "+caller+" %c NO TOUCHED WORD SLOT",lbL+lf7  ,lbR+lf2);

        return;
    }



    if( !t_select.ccs[touchedWord_slot].pattern )
    {
if( log_this) log("%c "+caller+" %c NO TOUCHED WORD PATTERN: RESELECTING",lbL+lf7  ,lbR+lf2);

        t_pat_bag3_reselect_all();

        return;
    }

if( log_this) log("%c"+caller+" %c touchedWord_slot %c "+touchedWord_slot, lbL+lf7, lbC, lbR+lfX[touchedWord_slot]);



    t_select.t_onPatternUpdate("DOCUMENT <em>"+ doc_click_context +"</em>", caller);

};



let onUp_8_ON_EVENT_CONSUMED = function(e)
{
let   caller = "onUp_8_ON_EVENT_CONSUMED";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) log("%c"+caller +" "+t_event_consumed_cause, lf8);

    return t_event_has_been_consumed();
};



const   TOOLS_LAYOUT_ON_MOUSEUP_HANDLER_DELAY = 500;

let   t_tools_layout_on_mouseup_timer;

let onUp_9_ON_MOUSEUP_DONE = function(e)
{

let   caller = "onUp_9_ON_MOUSEUP_DONE";
let log_this = !onDown_SHIFT && LOG_MAP.EV3_UP;

if( log_this) t_fly.t_log_event_status(caller, lf9);

    t_check_onModalMS(caller);


    add_el_class(pivspot, t_data.CSS_HIDDEN);

    move_cooldown_clear_pending();


    if(    has_moved && (onWork_PANEL == hotspot)
       &&  prop.get( t_data.EDIT_OR_STAGE )
       && !t_gutter.get_XY_URDL(h_x, h_y, "EDITING DONE .. dragging [hotspot] back IN-WINDOW")
      ) {
        t_dom_EDIT_drag_hotspot_off_gutter(h_x, h_y);
    }


    if( pat_bag9_grab_item_mov_div_is_showing() )
        pat_bag9_grab_item_mov_div_drop();



    get_onMoveDXY(e, caller);
    t_seek.t_seeker_onUp8_ON_MOUSEUP_DONE(e);

    if(prop.get(t_data.PIN_SEEKSPOT) && prop.get(t_data.FLOATLOG)) t_fly.t_event_LOG_TOOLTIP("MOUSE UP");



    t_set_body_style_overflow_hidden(false);



    let sticky = t_sticky.t_sticky_get_onWork_STICKY();
    if( sticky )
    {
        if( has_el_class(sticky, t_data.CSS_PRESSED))
            del_el_class(sticky, t_data.CSS_PRESSED);




if(log_this) {
    log_key_val(   caller
               , { was_a_misclick : was_a_misclick()
                 , was_a_click    : was_a_click   ()
                 , was_a_dblclick : was_a_dblclick()
                 ,      has_moved
                 ,       CONSUMED : t_event_consumed_cause
                 }, lf9);
}

    }


    if(onWork_PANEL && onWork_PANEL_was_magnified_onMove)
    {

        onWork_PANEL_was_magnified_onMove = false;
        del_el_class(onWork_PANEL, "dragged");
    }


    cache_PINNED_panels();



    if(sticky && has_el_class(sticky, t_data.CSS_SCROLLING))
    {
if( log_this) log("%c AFTER SCROLLING STICKY "+sticky.id+" %c REMOVING STICKY SCROLL CSS", lbb+lbL+lf9, lbb+lbR+lf5);

        del_el_class(sticky, t_data.CSS_SCROLLING);
    }


    if(sticky && has_el_class(sticky, t_data.CSS_HAS_FOCUS))
    {
if( log_this) log("%c WHILE EDITING STICKY "+sticky.id+" %c IGNORING STICKY PASTE TARGET INDICATORS", lbb+lbL+lf9, lbb+lbR+lf5);

    }
    else {
        if( t_get_current_sel_text() )
        {
if( log_this) log( "SHOWING STICKY PASTE TARGET INDICATORS");

            t_sticky.t_sticky_set_SEL_PASTE_TARGET_STATE(true);

            t_sticky.t_sticky_SET_DIMMED(false, "SHOWING PASTE TARGET INDICATORS");
        }
        else {
            let some_paste_indicator_changed = t_sticky.t_sticky_set_SEL_PASTE_TARGET_STATE(false);

if( log_this && some_paste_indicator_changed) log("%c NO CURRENT SELECTION %c HIDING STICKY PASTE TARGET INDICATORS", lbb+lbL+lf9, lbb+lbR+lf6);
        }
    }


    let import_clipboard = t_share.t_share_get_import_clipboard();
    if( import_clipboard && (import_clipboard.parentElement != null))
    {
if(log_this) log("%c SETTING FOCUS ON ["+import_clipboard.id+"]", lbb+lbH+lf9);

        let focus_in_msg = "PASTE EXPORTED MAIL MESSAGE HERE";
        t_focus_clipboard_target(import_clipboard, focus_in_msg, caller);
    }


    if(!onWork_MOVABLE_CHILD && onWork_PANEL)
    {
        if(has_moved || t_is_panel_magnified( onWork_PANEL ))
        {
            if( has_el_class(pat_bag, CSS_OPEN_BAG)) t_pat_bag_open_or_close_layout();
            else                                     t_view.t_view7_clr_panel_capped_from_xy(pat_bag);
        }
    }


    t_sticky.t_sticky_onUp(onWork_EL);



    if(has_moved || call_t_grid_IS_ON_GRID(caller) || cached_user_options_map.length) {
        t_tools_layout_on_mouseup_timer = setTimeout(onUp_9_TOOLS_LAYOUT_HANDLER, TOOLS_LAYOUT_ON_MOUSEUP_HANDLER_DELAY);
    }
    else {
        clr_onWork_EL(caller);
    }
    if( t_preventDefault_caller ) t_restoreDefault("ON UP DONE");

    onWork_MOVABLE_CHILD = null;


    if( t_sentence.t_SENTENCE_GET_SENTENCE_CONTAINERS() )
    {
        t_CURSOR_del_MOVE_LISTENER(caller);
    }


    clr_click_last_result();
    dom_scroll.set_onLong_press_scroll_freezed( false );
};


let onUp_9_TOOLS_LAYOUT_HANDLER = function()
{

let caller   = "onUp_9_TOOLS_LAYOUT_HANDLER";
let log_this = !onDown_SHIFT && (LOG_MAP.EV0_LISTEN || LOG_MAP.EV3_UP);

    if( call_t_grid_IS_ON_GRID(caller)      ) { clr_onWork_EL(caller); return; }
    if( has_el_class(pat_bag, CSS_OPEN_BAG) ) { clr_onWork_EL(caller); return; }



    if( t_cache_armed( caller) ) {
        t_cache_sync("Tools layout adjusted");

    }
    t_set_onWork_EL(null, caller);
    t_seek.t_seeker_set_TOOL(onWork_EL);
if( log_this) t_fly.t_log_event_status(caller, lbb+lf9);





    clr_SELECTION_PROGRESS("BY LAYOUT HANDLER", log_this);



    t_hide_hov();



    if( is_el_off_screen(t_fly.t_fly_div_get()) ) t_fly.t_fly_onlayout();

    t_reinstate_USER_OPTIONS( caller );


    clr_onWork_EL(caller);
};



let t_some_tool_clicked = function()
{
    return onWork_PANEL;
};


let t_dimm_should_postpone = function(dimming)
{

let   caller = "t_dimm_should_postpone";
let log_this = LOG_MAP.T3_LAYOUT || LOG_MAP.T7_SHARE;

if( log_this) caller += "(dimming "+dimming+")";


    let    onWork_STICKY = t_sticky.t_sticky_get_onWork_STICKY();
    let scrolling_STICKY = t_sticky.t_sticky_get_SCROLLING_STICKY();
    let seeker_is_active = t_seek.t_seeker_is_active();
    let should_postpone
        =      dimming
        && (   onWork_EL
            || onWork_STICKY
            || scrolling_STICKY
            || seeker_is_active
           )
    ;
    let reason_why
        = !dimming          ?  " .. INSTANT UNDIMM"
        :  onWork_EL        ? (" .. DIMMING POSTPONED .. onWork_EL "       +get_n_lbl(onWork_EL       ))
        :  onWork_STICKY    ? (" .. DIMMING POSTPONED .. onWork_STICKY "   +get_n_lbl(onWork_STICKY   ))
        :  scrolling_STICKY ? (" .. DIMMING POSTPONED .. scrolling_STICKY "+get_n_lbl(scrolling_STICKY))
        :  seeker_is_active ? (" .. DIMMING POSTPONED .. SEEKER IS ACTIVE"                             )
        :                      " .. NONE .. DIMMING NOW"
    ;


if( log_this) {
    let l_x
        = scrolling_STICKY ? 7
        : should_postpone  ? 3
        :                    8;

    log_key_val(caller+" .. return "+!!should_postpone+" .. "+reason_why
                , { dimming
                    , onWork_EL
                    , onWork_STICKY
                    , scrolling_STICKY
                    , seeker_is_active
                    , should_postpone
                    , reason_why
                }
                , lbR+lfX[l_x]
               );
}

    return (should_postpone ? reason_why : "");
};




const LONG_PRESS_ARM     = "long_press_arm";

let long_press_caller;
let long_press_timer;
let long_press_arm_timer;
let mouselong_press_consumed_by = "";



let add_long_press_listener = function(_caller="setTimeout")
{

let   caller = "add_long_press_listener";
let log_this = LOG_MAP.EV4_LONG_PRESS;

if( log_this) log("%c"+caller+" %c "+_caller, lbL+lf4, lbR+lf0);
if(LOG_MAP.EV7_DISPATCH) t_fly.t_log_event_status(caller);
if( log_this) log_caller();


    rearm_long_press_timer = null;


    long_press_caller = _caller;


    if(long_press_timer) clearTimeout(long_press_timer);
 long_press_timer = null;


    if(long_press_arm_timer) clearTimeout(long_press_arm_timer);
    long_press_arm_timer =     setTimeout(long_press_arm_handler, LONG_PRESS_ARM_DELAY);
};



const REARM_LONG_PRESS_DELAY = 500;
let   rearm_long_press_timer;


let rearm_long_press_listener_onScrollIntoView = function()
{

let   caller = "rearm_long_press_listener_onScrollIntoView";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) log(caller);
if(LOG_MAP.EV7_DISPATCH) t_fly.t_log_event_status(caller);


    if( rearm_long_press_timer ) clearTimeout( rearm_long_press_timer );
    rearm_long_press_timer =  setTimeout(add_long_press_listener, REARM_LONG_PRESS_DELAY);
};


let del_long_press_listener = function(_caller)
{

let   caller = "del_long_press_listener";
let log_this = !onDown_SHIFT && (LOG_MAP.EV4_LONG_PRESS || LOG_MAP.EV2_MOVE);

if( log_this) t_fly.t_log_event_status(caller+"("+_caller+")", lf4);
else if(LOG_MAP.EV7_DISPATCH) t_fly.t_log_event_status(caller);





    if(long_press_arm_timer)
    {
        clearTimeout( long_press_arm_timer );
 long_press_arm_timer = null;


        t_seek.t_seeker_PU_disarm();

        if(long_press_timer == null) {
            if(log_this)
                t_fly.t_log_transcript_event_bot( "<span style='color:white;'>x</span>"
                    +                      " <span style='text-decoration:line-through;'>long press</span> disarmed"
                    +                      " <em>"+ _caller +"</em>"
                );
if( log_this) log("%c...long press DISARMED by: "+ _caller, lf3);

            return;
        }
    }


    if(long_press_timer)
    {
        clearTimeout( long_press_timer );
 long_press_timer = null;

        if(log_this)
            t_fly.t_log_transcript_event_bot( "<span style='color:white;'>"+t_data.SYMBOL_HEAVY_BALLOT+"</span>"
                +                      " <span style='text-decoration:line-through;'>LONG-PRESS</span> CANCELED: "
                +                      " <em>"+ _caller +"</em>"
            );
if( log_this) log("%c...long press CANCELED by: "+_caller, lf2);

        if(onWork_PANEL == null) return;
    }

};


let is_long_press_pending = function()
{
    let result
            =  (long_press_arm_timer != null)
            || (long_press_timer     != null)
    ;


    return result;
};



let long_press_arm_handler = function()
{

let   caller = "long_press_arm_handler";
let log_this = LOG_MAP.EV4_LONG_PRESS;

if(LOG_MAP.EV7_DISPATCH) t_fly.t_log_event_status(caller);



    long_press_arm_timer = null;


    t_seek.t_seeker_PU_arm();


    if(long_press_timer) clearTimeout(long_press_timer);
    long_press_timer     = setTimeout(long_press_handler, LONG_PRESS_DELAY);


if( log_this) log("%c"+caller+": ADDING LONG-PRESS LISTENER ON %c"+get_onWork_TOOL_label(), lbH+lf4, lbH+lf3);

if( log_this)
    t_fly.t_log_transcript_event_top("<span style='color:yellow;'>"+ t_data.SYMBOL_BLACK_CIRCLE +"</span>"
        +                      caller+" .. CALLED BY <em>"+ long_press_caller +"</em>");

};


let long_press_handler  = function()
{

let   caller = "long_press_handler";
let log_this = DOM_TOOLS_LOG || LOG_MAP.EV4_LONG_PRESS;

let tag_this = DOM_TOOLS_TAG || log_this;
if(LOG_MAP.EV7_DISPATCH) t_fly.t_log_event_status(caller);


    long_press_timer = null;


    t_seek.t_seeker_PU_disarm();


    let                consumed_by = "";                               let consumed_by_css =  "";
    if(!consumed_by) { consumed_by = onLong_press1_HOTSPOT             (); consumed_by_css = lf1; }
    if(!consumed_by) { consumed_by = onLong_press2_TOOLS_ON_GRID       (); consumed_by_css = lf2; }
    if(!consumed_by) { consumed_by = onLong_press3_EDIT_OR_STAGE       (); consumed_by_css = lf3; }
    if(!consumed_by) { consumed_by = onLong_press4_SENTENCE            (); consumed_by_css = lf3; }
    if(!consumed_by) { consumed_by = onLong_press5_TOOL_EL             (); consumed_by_css = lf4; }
    if(!consumed_by) { consumed_by = onLong_press6_TOOL_TOOLTIP        (); consumed_by_css = lf6; }
    if(!consumed_by) { consumed_by = onLong_press7_TOOL_PANEL_MAGNIFY  (); consumed_by_css = lf7; }
    if(!consumed_by) { consumed_by = onLong_press8_HOTSPOT_PANEL_UNHIDE(); consumed_by_css = lf8; }
    if(!consumed_by) { consumed_by = onLong_press9_SLOTTED_WORD        (); consumed_by_css = lf9; }


    if(!consumed_by) {
        consumed_by = "NO LONG-PRESS ACTION FOR ["+get_n_lbl(onWork_EL)+"]";

if(tag_this) log("%c "+caller+" %c *** "+consumed_by+" ***", lbb+lbL+lf9, lbb+lbR+lf2);
if(tag_this) t_fly.t_log_event_status(caller+": "+consumed_by);
    }

if( tag_this && !mouselong_press_consumed_by) log("%c"+consumed_by, lbH+consumed_by_css);
    mouselong_press_consumed_by = consumed_by;

    if(log_this)
        t_fly.t_log_transcript_event_bot( "<span style='color:white;'>"+t_data.SYMBOL_CHECK_MARK+"</span>"
            +                      " long press <em>"+ consumed_by +"</em>"
        );


if( log_this) t_fly.t_log_event_status(caller+" "+t_data.SYMBOL_RIGHT_ARROW+" "+consumed_by, consumed_by_css);

    if(prop.get(t_data.PIN_SEEKSPOT) && prop.get(t_data.FLOATLOG)) t_fly.t_event_LOG_TOOLTIP("LONG-PRESS");
};


let t_get_mouselong_press_consumed_by = function()
{
    return mouselong_press_consumed_by;

};


let onLong_press1_HOTSPOT = function()
{

    let caller = "onLong_press1_HOTSPOT";

    if(  onWork_PANEL != hotspot ) return "";
    if(  onWork_EL    != hotring ) return "";
    let in_gutter      = t_gutter.is_hotspot_IN(hotspot, "LONG-PRESS IN GUTTER");
    let while_editing  =  prop.get( t_data.EDIT_OR_STAGE );
    let is_on_grid     = call_t_grid_IS_ON_GRID(caller);
    let consumed_by    = "";


    if(!consumed_by && in_gutter && while_editing) {

        prop.toggle( t_data.EDIT_OR_STAGE );

        consumed_by = t_data.EDIT_OR_STAGE +" done .. HOTSPOT LONG-PRESS IN GUTTER .. WHILE EDITING";
    }


    if(!consumed_by && !is_on_grid)
    {
        consumed_by = "HOTSPOT LONG-PRESS MOVING TOOLS ON GRID";

        t_move_TOOLS_ON_GRID("LONG-PRESS");
    }


    if(!consumed_by &&  is_on_grid)
    {
        prop.set(t_data.TOOLS_TIER2, false);
        t_activate_tools_tier1("LONG-PRESS");

        consumed_by = "HOTSPOT LONG-PRESS .. SELECT "+ t_data.TOOLS_TIER2;
    }

    return consumed_by;
};


let onLong_press2_TOOLS_ON_GRID = function()
{

let   caller = "onLong_press2_TOOLS_ON_GRID";

    let consumed_by = "";

    if( !dimm_mask_displayed() ) return "";

    if(!consumed_by && call_t_grid_IS_ON_GRID(caller))
    {
        t_move_TOOLS_OFF_GRID("LONG-PRESS");

        consumed_by = "MOVING TOOLS OFF GRID";
    }

    if(!consumed_by && has_el_class(pat_bag, CSS_OPEN_BAG))
    {
        t_pat_bag_close(caller,caller);

        dimm_stop(caller);

        consumed_by = "CLOSING [pat_bag]";
    }

    return consumed_by;
};


let onLong_press3_EDIT_OR_STAGE = function()
{

let   caller = "onLong_press3_EDIT_OR_STAGE";
let log_this = !onDown_SHIFT && (LOG_MAP.EV4_LONG_PRESS || LOG_MAP.T3_LAYOUT);

if( log_this) t_fly.t_log_event_status(caller, lf3);


    if(!prop.get( t_data.EDIT_OR_STAGE )) return "";

    return t_tools_hide_onDown_XY_parent();
};


let onLong_press4_SENTENCE = function(e)
{

let   caller = "onLong_press4_SENTENCE";
let log_this = !onDown_SHIFT && LOG_MAP.EV4_LONG_PRESS;

if( log_this) t_fly.t_log_event_status(caller, lf4);
    let rejected_by = "";
    let consumed_by = "";


    if( t_is_a_tool_el          (onWork_EL, caller         )) rejected_by = "t_is_a_tool_el";

    if( t_util.is_el_child_of_id(onWork_EL, "log_popup_div")) rejected_by = "is_el_child_of_id";


    if( t_get_current_sel_text() ) rejected_by = "t_get_current_sel_text";



    check_has_moved(caller);

    if(  has_moved )               rejected_by = "has_moved=["+has_moved+"]";

    if(rejected_by)
    {
if( log_this && rejected_by) log("%c"+rejected_by, lb4);

        return "";
    }

    let { container , cells } = dom_sentence.t_SENTENCE_GET_EL_CONTAINER( onDown_EL );
    if(   container )
    {

        if( cells )
        {
            consumed_by += "SPLITTING TABLE "+cells.length+" CELLS SENTENCES";

            for(let i=0; i < cells.length; ++i)
            {
                t_sentence.t_SENTENCE_SPLIT( cells[i] );
            }
        }


        if(!consumed_by)
        {
            consumed_by += "SPLITTING ["+container.nodeName+"] SENTENCES";

            t_sentence.t_SENTENCE_SPLIT( container );
        }
    }


if( log_this && consumed_by) log("%c"+consumed_by, lf4);
    return consumed_by;
};


let onLong_press5_TOOL_EL = function()
{

let   caller = "onLong_press5_TOOL_EL";
let log_this = LOG_MAP.EV4_LONG_PRESS;


if( log_this) t_fly.t_log_event_status(caller, lf5);
    let consumed_by = "";


    if( behavior_TOUCH_ELSE_DESKTOP )
    {
if( log_this) log("%c behavior_TOUCH_ELSE_DESKTOP=["+behavior_TOUCH_ELSE_DESKTOP+"]", lb5);

        dom_scroll.set_onLong_press_scroll_freezed( true );
    }


    let el_slot = t_get_onWork_EL_slot();
    if( el_slot > 0) {
if(log_this) logBIG(caller+": SLOT #"+el_slot+" PRESSED .. NOT CONSUMED", lf8);

        return consumed_by;
    }


    if(!consumed_by) {
        let sticky  = t_sticky.t_sticky_get_onWork_STICKY();
        if( sticky && has_el_class(sticky, t_data.CSS_HAS_FOCUS))
        {
            consumed_by = "IGNORING EDITED STICKY "+sticky.id;

if( log_this) t_log.logSD1("%c"+caller+"%c"+consumed_by, lbH+lf8);
        }
        else {
            consumed_by = onLong_press5_TOOL_STICKY(log_this);

        }
    }


    if(!consumed_by
       &&      onWork_EL
       && (   (onWork_EL.id == t_data.bag_rot      )
           || (onWork_EL.id == t_data.WORDS_BAG_ROT))
      ) {
        consumed_by = "HANDLING LONG-PRESS ON "+bag_rot.id;
if( log_this) t_log.logSD2("%c"+caller+"%c"+consumed_by, lbH+lf5);

        t_fly.t_fly_tooltip_update(bag_rot.title, bag_rot.id);
    }


    let div_slot_containers_child_pressed = t_util.is_el_or_child_of_parent_el(onWork_EL, div_slot_containers);
    if(!consumed_by && div_slot_containers_child_pressed)
    {
        consumed_by = "START CONTAINERS CHILD DRAG";
if( log_this) t_log.logSD3("%c"+caller+"%c"+consumed_by, lbH+lf5);

        t_slot_container_set_fullscreen( onWork_EL );
        t_add_tool_pointermove_listener(caller);
    }




if(log_this && !consumed_by) log("%c"+caller+"%c NOT CONSUMED", lbL+lf5, lbR+lf8);
    return consumed_by;
};


let onLong_press5_TOOL_STICKY = function(log_this)
{

let   caller = "onLong_press5_TOOL_STICKY";



    let current_sel_text    = t_get_current_sel_text();
    let pinned_sticky_count = t_sticky.t_sticky_GET_COUNT();
    let              sticky = t_sticky.t_sticky_get_onWork_STICKY();


if( log_this) {
    log_key_val_group( caller
                 , {                    current_sel_text : t_util.ellipsis_short(current_sel_text)
                     ,                   onDown_SEL_TEXT : t_util.ellipsis_short(onDown_SEL_TEXT )
                     ,               pinned_sticky_count
                     ,                    sticky_touched : (sticky ? sticky.touched : "")
                     ,                           callers : t_log.get_callers()
                 }, lf4);
}


    let consumed_by         = "";





    if(!consumed_by && (current_sel_text || onDown_SEL_TEXT))
    {
        if(!onDown_SEL_TEXT && !current_sel_text)
            clr_SELECTION_PROGRESS("NEW STICKY FROM PAGE-SELECTION", log_this);

        if(pinned_sticky_count < t_sticky.STICKY_MAX) {
            consumed_by = onLong_press5_TOOL_STICKY_SEL_TEXT(log_this);
if( log_this) t_log.logSD4("%c"+caller+"%c"+consumed_by, lbL+lf4,lbR+lf1);
        }
        else {
            logBIG("(pinned_sticky_count >= t_sticky.STICKY_MAX) .. ("+pinned_sticky_count+" >= "+t_sticky.STICKY_MAX+")");
        }
    }


    if(!consumed_by && t_sticky.t_sticky_onDown_a_STICKY_PAD(sticky))
    {
        consumed_by         = "LONG-PRESS ON STICKY PAD "+sticky.id+".. FORMAT MSG";
if( log_this) t_log.logSD4("%c"+caller+"%c"+consumed_by, lbL+lf4,lbR+lf2);

        t_sticky.t_sticky_format_pad(sticky);
    }


    if(!consumed_by && (!sticky && t_is_a_tool_el(onWork_EL, caller)))
    {
        consumed_by         = "LONG-PRESS ON TOOL "+onWork_EL.id+".. SHOW TOOLTIP";
if( log_this) t_log.logSD4("%c"+caller+"%c"+consumed_by, lbL+lf4,lbR+lf3);

        return "";
    }







    return consumed_by;
};



let onLong_press4_TOOL_STICKY_SEL_TEXT_timer;


let onLong_press5_TOOL_STICKY_SEL_TEXT = function(log_this=true)
{

let   caller = "onLong_press5_TOOL_STICKY_SEL_TEXT";

    let      consumed_by = "";



    if(onUp_MS > onDown_MS)
    {
        consumed_by     = "LONG-PRESS RELEASED .. SELECTION DROPPED";
if( log_this) t_log.log(    "%c"+caller+": "+ consumed_by
                    ,        lbH+lf8                     );

        clr_SELECTION_PROGRESS(consumed_by, log_this);
        return consumed_by;
    }


    let last_sel_text = get_last_sel_text() || onDown_SEL_TEXT;

    let current_sel_text  = t_get_current_sel_text();
    if( current_sel_text != last_sel_text)
    {
        tic_SELECTION_PROGRESS();

        consumed_by     = "LONG-PRESS .. SELECTION CHANGED";
if( log_this) t_log.log( "%c"+caller+": "+ consumed_by
                        +"%c"+LF+"FROM %c"+ t_util.ellipsis_short(t_util.strip_CR_LF( last_sel_text))
                        +"%c"+LF+"TO.. %c"+ t_util.ellipsis_short(t_util.strip_CR_LF(current_sel_text))
                        ,lbH+lf4
                        ,    lf8             ,lb8
                        ,    lf9             ,lb9);


        set_last_sel_text( current_sel_text );

        if(!onLong_press4_TOOL_STICKY_SEL_TEXT_timer)
            onLong_press4_TOOL_STICKY_SEL_TEXT_timer = setInterval(function() { onLong_press5_TOOL_STICKY_SEL_TEXT(log_this); }, SEL_TEXT_TIC_TOC_INTERVAL);

    }


    else
    {
        let unchanged_countdown = toc_SELECTION_PROGRESS();

        if( unchanged_countdown )
        {
            consumed_by     = "LONG-PRESS .. SELECTION STEADY";
if( log_this) t_log.log("%c"+caller+": "+ consumed_by+"%c unchanged x"+unchanged_countdown
                        ,lbH+lf4                      ,lbb+lbH+lfX[    unchanged_countdown]);

            let next_interval = SEL_TEXT_TIC_TOC_INTERVAL / 3;

            clearInterval( onLong_press4_TOOL_STICKY_SEL_TEXT_timer );
            onLong_press4_TOOL_STICKY_SEL_TEXT_timer = setInterval(function() { onLong_press5_TOOL_STICKY_SEL_TEXT(log_this); }, next_interval);
        }


        else if(last_sel_text)
        {
            consumed_by = "LONG-PRESS .. SELECTION ADD STICKY";
if(log_this) t_log.logSD4( "%c"+caller+": "+consumed_by+"=["+consumed_by+"]"
                    +"%c"+LF+t_util.ellipsis_short(t_util.strip_CR_LF(current_sel_text))
                    ,lbH+lf4
                    ,lbb+lb9);

            clr_SELECTION_PROGRESS(consumed_by, log_this);

            onLong_press5_STICKY_ADD_NEW(current_sel_text, log_this);
        }


        else {
            consumed_by = "LONG-PRESS .. SELECTION IS EMPTY";
if(log_this) t_log.logSD4("%c"+caller+": "+consumed_by
                    ,lbH+lf4                    );

            clr_SELECTION_PROGRESS(consumed_by, log_this);
        }

    }

    return consumed_by;
};


let onLong_press5_STICKY_ADD_NEW = function(current_sel_text, log_this)
{

let   caller = "onLong_press5_STICKY_ADD_NEW";

if(log_this) log(caller+"%c"+t_util.ellipsis_short(t_util.strip_CR_LF(current_sel_text)), lbH+lf5);


    let new_sticky = t_sticky.t_sticky_NEW_XY_SEL_TEXT(onDown_XY.x, onDown_XY.y, current_sel_text || onDown_SEL_TEXT);

    t_set_onWork_EL(new_sticky, caller);
    t_seek.t_seeker_set_TOOL(onWork_EL);



    t_window_getSelection_removeAllRanges(caller);
    onDown_SEL_TEXT = "";


    t_sticky.t_sticky_set_MOVING( new_sticky );

    t_add_tool_pointermove_listener(caller);
};


let onLong_press6_TOOL_TOOLTIP = function()
{

let   caller = "onLong_press6_TOOL_TOOLTIP";
let log_this = LOG_MAP.EV4_LONG_PRESS;

    let onWork_EL_is_a_tool = t_is_a_tool_el     (onWork_EL, caller);
    let onWork_EL_has_title = t_util.get_el_title(onWork_EL);
if( log_this)
    log_key_val_group(      caller
                , {   t_fly_div_get       : t_fly.t_fly_div_get()

                    , onWork_PANEL
                    , onWork_EL
                    , onWork_EL_is_a_tool
                    , onWork_EL_has_title
                }, lf6);
if( log_this) t_fly.t_log_event_status(caller, lf6);

    let consumed_by = "";


    if(onWork_PANEL == t_fly.t_fly_div_get()     ) return "";
    if(onWork_PANEL == onWork_EL                 ) return "";

    let title
        =           has_el_class(onWork_EL, t_data.CSS_STICKY_TOOL)
        ? t_sticky.t_sticky_get_tooltip(onWork_EL)
        :           t_util.get_el_title(onWork_EL)
    ;

    if( title ) {
        consumed_by = "SHOWING TOOLTIP ["+t_util.ellipsis_short(t_util.strip_CR_LF(title))+"]";

        t_fly.t_fly_tooltip( title );
    }
if( log_this) t_log.logSD5("%c"+caller+"%c"+consumed_by, lbL+lf6,lbR+lf6);
    return consumed_by;
};


let onLong_press7_TOOL_PANEL_MAGNIFY = function()
{

let   caller = "onLong_press7_TOOL_PANEL_MAGNIFY";



    if( t_util.is_el_or_child_of_parent_el(onWork_EL, t_fly.t_fly_div_get()) )
    {
        let el6_is_import_clipboard = (onWork_EL && (onWork_EL.id == t_data.CSS_FLY_CLIPBOARD));
        if( el6_is_import_clipboard )
            return "LONG-PRESS ON A CLIPBOARD CUT-PASTE TOOL";


        t_fly.t_fly_div_magnified_toggle();

        return "FLOAT LOG MAGNIFICATION";
    }


    if( !onWork_PANEL ) return "";



    if( is_a_spread_drag() )
    {
        if(onWork_PANEL == pivot_PANEL) {
            t_toggle_pivot_PANEL_magnified( prop.get( t_data.PIVOT_MAGNIFIED ) );
            return "SETTING DRAGGED PIVOT PANEL RE-MAGNIFICATION";
        }
    }


    else if(onWork_PANEL != hotspot)
    {
        return t_toggle_onWork_PANEL_magnified(caller);
    }

    return "";
};


let onLong_press8_HOTSPOT_PANEL_UNHIDE = function()
{

let   caller = "onLong_press8_HOTSPOT_PANEL_UNHIDE";




    t_clr_has_moved();
    check_has_moved(caller);

    if(  onWork_PANEL != hotspot ) return "";
    if(  onWork_EL    != hotring ) return "";
    if(  has_moved               ) return "";

    if(!t_raise_pivot_PANEL_posted_since_onDown(caller))
        t_flash_unpinned_panels(caller);

    return "UNHIDING PANELS";
};


let onLong_press9_SLOTTED_WORD = function()
{

let   caller = "onLong_press9_SLOTTED_WORD";
let log_this = !onDown_SHIFT && (LOG_MAP.EV4_LONG_PRESS || LOG_MAP.EV2_MOVE);

if( log_this) t_fly.t_log_event_status(caller, lf9);


    let      slot = t_get_onWork_EL_slot();
    if(     !slot           ) return "";
    if(!t_select.ccs[ slot] ) return "";


    t_select.ccs[slot].num_selected = t_get_onWork_EL_num();


    if( t_select.ccs[slot] )
        t_slot_containers_display(slot);

    return "SHOWING SLOT ["+slot+"] CONTAINERS";
};




let   t_onclick_e_target;
let   t_onclick_timer;



let is_a_spread_drag = function(e)
{

let   caller = "is_a_spread_drag";
let log_this = LOG_MAP.EV0_LISTEN;



    let this_MS      = new Date().getTime();
    let delayMS      = onDown_MS ? (this_MS - onDown_MS) : 0;
    let in_hand      = (delayMS > t_data.DRAG_MIN_MS);
    let fully_spread = ((spread_ratio.x >= 0.9) || (spread_ratio.y >= 0.9));

    let cause        = "";

    if(in_hand && has_moved && fully_spread)
        cause = "MOVED FULLY SPREAD AFTER "+ (this_MS-onDown_MS)+" ms .. "+has_moved;







    let result  = (cause != "");

if(log_this && result) log(caller+": ...return "+result+" .. %c"+cause, lb7);

    return result;
};


let is_a_drag = function(e)
{

let   caller = "is_a_drag";
let log_this = LOG_MAP.EV0_LISTEN;


    let dragged = (Math.abs(onMoveDXY.x) > MOVED_ENOUGH) || (Math.abs(onMoveDXY.y) > MOVED_ENOUGH);

if(log_this && dragged) log(caller+": ...return "+dragged);
    return dragged;
};


let is_a_click = function(e)
{

let   caller = "is_a_click";
let log_this = LOG_MAP.EV0_LISTEN;


    let reason    = "";
    let this_MS   = new Date().getTime();
    let delayMS   = onDown_MS ? (this_MS - onDown_MS) : 0;

    if(delayMS   <=  t_data.CLICK_DURATION) reason = "pressed during "+delayMS+" ms";

    let clicked   = (reason != "");

if(!clicked && (delayMS > t_data.LONG_PRESS_DURATION)) t_seek.t_seekzone4_show_longpress();

    is_a_click_last_result = clicked;

if(log_this && clicked) log(caller+": ...return "+clicked+" .. %c"+reason, lb7);
    return clicked;
};


let is_a_dblclick = function(e, _caller)
{

let   caller = "is_a_dblclick";
let log_this = !onDown_SHIFT && t_log.logging_something();



    let this_MS      = new Date().getTime();
    let clicks_MS    =             onDown_MS - onDownPMS;
    let pressMS      = (this_MS -  onDown_MS);
    let downs_MS     =             onDown_MS ? pressMS : 0;
    let quick_enough = (downs_MS < t_data.DBLCLICK_DELAY);
    let multi_click  = e.detail ? (e.detail > 1) : (clicks_MS < t_data.DBLCLICK_DELAY);
    let misclick     = is_a_misclick(e, multi_click, pressMS);
    let dblclick     = !misclick  &&    multi_click && quick_enough;

if(log_this) {
    console.dir(e);

    let                                 cause  = "";
    if     ( misclick                 ) cause += "misclick ";
    if     ( e.type == "mouseup"      ) cause += "click count "+ e.detail+" ";
    else if(!dblclick && !multi_click ) cause += "not multi_click  ";
    else if(!dblclick && !quick_enough) cause += "not quick_enough ";

    let lfx = (dblclick ? lf4 : lf8);

    let multi = "";
    if( multi_click )
        multi +=  "multi_click"
            +(       (e.detail > 1)
                   ? (   " e.detail=["+ e.detail                                     +"]")
                   : (  " clicks_MS=["+ clicks_MS        +" < "+t_data.DBLCLICK_DELAY+"]")
             );

    log("%c"+caller+": ...%c return "+dblclick +" %c "+ multi +" %c"+cause +"%c e.type ["+e.type+"] %c downs_MS ["+ downs_MS +"] %c clicks_MS ["+clicks_MS+"] %c onWork_PANEL ["+t_util.get_id_or_tag(onWork_PANEL)+"]"
        ,lbL+lf3         ,lbC+lfx                ,lbR+lfx       ,lbH+lfx    ,lb0                   ,lf6                         ,lf7                         ,lf3                                                      );
}


    if( dblclick ) t_seek.t_seekzone3_show_dblclick(pressMS);

    is_a_dblclick_last_result = dblclick;

    return dblclick;
};


let is_a_misclick = function(e, multi_click, pressMS)
{

let log_this = !onDown_SHIFT && t_log.logging_something();



    let some_window_selection
        = String(window.getSelection());




    let misclick_MS
        = behavior_TOUCH_ELSE_DESKTOP
        ?  t_data.MISCLICK_TOUCH_MS
        :  t_data.MISCLICK_MOUSE_MS;

    let too_quick
        =  (pressMS < misclick_MS)
        && !multi_click
        && !onWork_PANEL
        && !some_window_selection;

    is_a_too_quick_last_result = too_quick;



    let displayed_MS
        =  onModalMS
        ? (new Date().getTime() - onModalMS) : 0;

    let modal_click_early_ms
        = behavior_TOUCH_ELSE_DESKTOP
        ? 2 * t_data.MODAL_CLICK_EARLY_MS
        :     t_data.MODAL_CLICK_EARLY_MS;

    let too_early
        =  t_which_onModal_EL()
        && (onModalMS    > 0)
        && (displayed_MS < modal_click_early_ms);

    is_a_too_early_last_result = too_early;


if( log_this) {
    let s         = parseInt(displayed_MS   / 1000);
    let f         = (displayed_MS - s*1000) / 1000;
    let t         = parseInt(10 * f + 0.5);

    if( too_quick ) log("%c TOO QUICK "+               (pressMS +"ms  < "+ misclick_MS          +"ms") +" .. "+ too_quick, lbH+lf3);
    if( too_early ) log("%c MODAL CLOSING TOO EARLY "+ (s+"."+t +"sec < "+ modal_click_early_ms +"ms") +" .. "+ too_early, lbH+lf3);
}

    if(    too_quick || too_early ) t_seek.t_seekzone2_show_misclick(pressMS, misclick_MS);
    return too_quick || too_early;
};


let is_a_click_last_result;
let is_a_dblclick_last_result;
let is_a_too_early_last_result;
let is_a_too_quick_last_result;

let was_a_click                 = function() { return is_a_click_last_result;     };
let was_a_dblclick              = function() { return is_a_dblclick_last_result;  };
let was_a_misclick              = function() { return is_a_too_quick_last_result || is_a_too_early_last_result; };
let was_a_too_early_last_result = function() { return is_a_too_early_last_result; };
let was_a_too_quick_last_result = function() { return is_a_too_quick_last_result; };

let clr_click_last_result = function()
{
    is_a_click_last_result     = false;
    is_a_dblclick_last_result  = false;
    is_a_too_quick_last_result = false;
    is_a_too_early_last_result = false;
};


let t_is_a_quick_drag = function()
{
    let this_MS      = new Date().getTime();
    let elapsed      =  this_MS - onDown_MS;
    let quick_enough = (elapsed < t_data.CLICK_DURATION);
    let result       = !!(quick_enough && has_moved);


    return result;
};


let t_onClick_1_onWork_EL = function(delay=0, dblclicked=false)
{

let   caller = "t_onClick_1_onWork_EL("+get_n_lbl(onWork_EL)+", delay=["+delay+"], dblclicked=["+dblclicked+"])";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) t_fly.t_log_event_status(caller, lf5);


    if( t_event_has_been_consumed() )
    {
if(log_this) t_log.console_warn("*** "+caller+": ALREADY CONSUMED BY:"+LF+t_event_consumed_cause);

        return;
    }


    if(t_onclick_timer) clearTimeout(t_onclick_timer);
 t_onclick_timer = null;

    t_onclick_e_target   = onWork_EL;

    if( delay ) t_onclick_timer = setTimeout(onClick_1_onWork_EL_handler, delay);
    else                                     onClick_1_onWork_EL_handler();

};


let   onClick_1_onWork_EL_handler = function()
{

let   caller = "onClick_1_onWork_EL_handler";
let log_this = LOG_MAP.EV5_TOOL_CB;



    let e_target = t_onclick_e_target;
    if( e_target.nodeType == Node.TEXT_NODE)
        e_target = e_target.parentElement;

    if(!e_target.id && t_is_a_tool_el(onWork_EL, caller))
        e_target = t_util.t_get_e_target_proxy( e_target );

    if(!e_target) {
if(log_this) log("...!e_target for t_onclick_e_target=["+get_n_lbl(t_onclick_e_target)+"]");
        return;
    }


    if(    !e_target.id ) {
        if( e_target.textContent && (e_target.textContent.length <= 64)) {
            e_target.id       = e_target.textContent.trim();
            e_target.id_faked = true;
        }
    }


    let bag_id = t_get_bag_id(e_target);



if(log_this) {
    let s = log_key_val(   caller
                       , { e_target          : get_n_lbl( e_target )
                         , e_target_id       : e_target.id
                         , e_target_id_faked : e_target.id_faked
                         ,      bag_id
                         ,     standby       : get_n_lbl( onStandby_PANEL )
                         }
                       , lf1);



    if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly( s );
}

    t_onClick_1_e_target_bag_id(e_target, bag_id);
};


let t_onClick_1_e_target_bag_id = function(e_target, bag_id)
{

let   caller = "t_onClick_1_e_target_bag_id";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this)
    log("%c"+caller+"%c"+get_n_lbl(e_target)+"%c bag_id=["+bag_id+"]"
       ,lbL         ,lbC+lf3                 ,lbR+lf4                );

if( log_this) pattern_log_bag_csv(caller);

    let consumed_by = "";


    let                 e_target_name  = e_target.id.toLowerCase();
    if(!consumed_by && (e_target_name == "behavior"       ))             { consumed_by = e_target.id;       t_fly.t_log_behavior();               }
    if(!consumed_by && (e_target_name == "highlight"      ))             { consumed_by = e_target.id;       t_outline_viewport_top_containers();  }
    if(!consumed_by && (e_target_name == "regex"          ))             { consumed_by = e_target.id;       t_fly.t_log_regex();                  }
    if(!consumed_by && (e_target_name == "clear"          ))             { consumed_by = e_target.id;       t_clear(caller);                      }
    if(!consumed_by && (e_target_name == "import"         ))             { consumed_by = e_target.id;       t_share.t_share3_IMPORT_UI(e_target); }
    if(!consumed_by && (e_target_name == "reload"         ))             { consumed_by = e_target.id;       document.location.reload();           }

    if(!consumed_by && (e_target_name == t_data.CSS_FLY_CLIPBOARD))      { consumed_by = t_data.CSS_FLY_CLIPBOARD;                                }

    if(!consumed_by && (e_target_name == "export"         ))             { consumed_by = e_target.id;       t_share.t_share1_EXPORT   (e_target);
 t_share.t_share2_MAILTO_UI(e_target); }
    if(!consumed_by && has_el_class(e_target, t_data.CSS_MAILTO))        { consumed_by = t_data.CSS_MAILTO; t_share.t_share2_MAILTO_UI(e_target); }



    if(!consumed_by && onWork_PANEL && bag_id) {
        if(!consumed_by && has_el_class(e_target, CSS_PUSH_PIN)) { t_click_panel_pin_CB(onWork_PANEL, e_target); consumed_by = bag_id+"."+CSS_PUSH_PIN; }
        if(!consumed_by && has_el_class(e_target, CSS_CLOSEPIN)) { t_click_panel_pin_CB(onWork_PANEL, e_target); consumed_by = bag_id+"."+CSS_CLOSEPIN; }
        if(!consumed_by && has_el_class(e_target, CSS_SCALEPIN)) { t_click_panel_pin_CB(onWork_PANEL, e_target); consumed_by = bag_id+"."+CSS_SCALEPIN; }
        if(!consumed_by && has_el_class(e_target, CSS_CLEARPIN)) { t_click_panel_pin_CB(onWork_PANEL, e_target); consumed_by = bag_id+"."+CSS_CLEARPIN; }
    }


    if(!consumed_by && t_seek.t_seeker_get_node_bag_id( e_target ))
    {
        t_seek.t_seeker_onClick(); consumed_by = "SEEKER "+bag_id;

    }


    if(!consumed_by && bag_id)
    {

        switch( bag_id )
        {
        case "sel_bag"      : t_onClick_1_sel(e_target, bag_id ); consumed_by = bag_id; break;

        case "pat_bag"      :
        case "off_bag"      :
        case "alt_bag"      :
        case "bak_bag"      : t_handle_1_pat_bag    (e_target         ); consumed_by = bag_id; break;


        case "headsup_bw"   : t_body_layout_CB      (e_target         ); consumed_by = bag_id; break;
        case "headsup_bz"   : t_body_zoom_CB        (e_target         ); consumed_by = bag_id; break;
        case "headsup_fs"   : t_body_font_size_CB   (e_target         ); consumed_by = bag_id; break;

        case "dom_traversal": if(t_dom_traversal_CB (e_target, "click")) consumed_by = bag_id; break;

        case "dev_log_map"  :
        case "prop_bag"     : if(      prop_tools_CB(e_target)        )  consumed_by = bag_id; break;

        case "fly_div"      : t_fly.t_fly_clr         (e_target         ); consumed_by = bag_id; break;

        default:
if(log_this) log("%c"+caller+"%c ["+bag_id+"] has no delegation from ["+get_n_lbl(e_target)+"]"
                 ,lbL        ,lbH+lf8                                                          );
        break;
        }
    }


    if(!consumed_by)
    {
        if( t_onClick_1_e_target(e_target) )
            consumed_by = "["+e_target.id+"] HANDLER";

    }


    if(!consumed_by)
    {
        switch(e_target.id)
        {
        case "pat_sort"            : t_handle_1_pat_bag_sort_cycle(); consumed_by = e_target.id; break;

        case "t_log.console_clear" : t_log.console_clear   (caller); consumed_by = e_target.id; break;

        case "dimm_mask"           : {
            if( !was_a_too_early_last_result() ) {
                dimm_stop(caller);
                if(has_el_class(dimm_mask, "dimm_sticky"))
                    t_sticky.t_sticky_RING_stop("dimm_start");
            }
        }
        consumed_by = e_target.id;
        break;

        case t_data.WORDS_RECYCLE  : t_wording_3_CB    (e_target, "click"); consumed_by = e_target.id; break;
        case t_data.WORDS_BAG_ROT  : t_handle_1_pat_bag(e_target         ); consumed_by = e_target.id; break;
        case t_data.WORDS_FILTER   : t_wording_3_CB    (e_target, "click"); consumed_by = e_target.id; break;

        default:
if(log_this) log("%c"+caller+"%c NO EXTRA HANDLER FOR %c e_target=["+get_n_lbl(e_target)+"]"
            ,     lbL        ,lbR+lf2                ,lbH+lf4                               );
        break;
        }
    }


    if(!consumed_by && e_target.id)
    {
        consumed_by = prop_id_state_CB(e_target.id, "toggle");
    }

if( log_this) log("%c"+caller+"%c consumed_by "+consumed_by, lbL, lbR+lf3);
};


let t_onClick_1_e_target = function(e_target)
{

let   caller = "t_onClick_1_e_target("+get_n_lbl(e_target)+")";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) t_fly.t_log_event_status(caller, lf5);


    if( e_target.id == "hotring"                           ) { t_move_TOOLS_TOGGLE_GRID(caller); return true; }



    if( is_a_toggle_option(e_target.id)                  ) { prop_id_toggle( e_target.id   );   return true; }



    if( has_el_class(e_target, CSS_PUSH_PIN)               ) { t_click_panel_pin_CB(onWork_PANEL, e_target); return true; }
    if( has_el_class(e_target, CSS_CLOSEPIN)               ) { t_click_panel_pin_CB(onWork_PANEL, e_target); return true; }
    if( has_el_class(e_target, CSS_SCALEPIN)               ) { t_click_panel_pin_CB(onWork_PANEL, e_target); return true; }
    if( has_el_class(e_target, CSS_CLEARPIN)               ) { t_click_panel_pin_CB(onWork_PANEL, e_target); return true; }


    if( e_target.id == "transcript1_clearpin"              ) {                                      t_clear_panel_pined_innerHTML(transcript1); return true; }
    if( e_target.id == "transcript2_clearpin"              ) {                                      t_clear_panel_pined_innerHTML(transcript2); return true; }
    if( t_util.is_el_or_child_of_parent_el(e_target, transcript1) ) { if(is_a_dblclick_last_result) t_clear_panel_pined_innerHTML(transcript1); return true; }
    if( t_util.is_el_or_child_of_parent_el(e_target, transcript2) ) { if(is_a_dblclick_last_result) t_clear_panel_pined_innerHTML(transcript2); return true; }



    if( e_target.id == "dom_hide1_reset"                 ) { t_hide.dom_hide1_reset                ( ); return true; }
    if( e_target.id == "dom_hide2_store_reload"          ) { t_hide.dom_hide2_store_reload         ( ); return true; }
    if( e_target.id == "dom_hide2_store_save"            ) { t_hide.dom_hide2_store_save           ( ); return true; }
    if( e_target.id == "dom_hide4_scroll_to_last_hidden" ) { t_hide.dom_hide4_scroll_to_last_hidden( ); return true; }
    if( e_target.id == "dom_hide5_history_start"         ) { t_hide.dom_hide5_history_start        ( ); return true; }

    if( e_target.id == "dom_hide1_collect_nodes_1"       ) { t_hide.dom_hide1_collect_nodes        (1); return true; }
    if( e_target.id == "dom_hide1_collect_nodes_2"       ) { t_hide.dom_hide1_collect_nodes        (2); return true; }
    if( e_target.id == "dom_hide1_collect_nodes_3"       ) { t_hide.dom_hide1_collect_nodes        (3); return true; }
    if( e_target.id == "dom_hide1_collect_nodes_4"       ) { t_hide.dom_hide1_collect_nodes        (4); return true; }
    if( e_target.id == "dom_hide1_container_clicked"     ) { t_hide.dom_hide1_container_clicked    ( ); return true; }



    if( e_target.id == "dom_grid_playground"             ) { e_target.firstElementChild .style.display = "initial"; t_grid.t_grid_logging_toggle( true); return true; }
    if( e_target.id == "dom_grid_close_em"               ) { e_target.parentElement     .style.display =    "none"; t_grid.t_grid_logging_toggle(false); return true; }


    if( e_target.id == "details_open"                    ) { t_details.details_open_closed (); return true; }
    if( e_target.id == "details_close"                   ) { t_details.details_close_opened(); return true; }

    return false;
};


let t_onClick_1_sel = function(e_target, bag_id)
{

let   caller = "t_onClick_1_sel";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) t_fly.t_log_event_status(caller, lf5);


    let bag_id_is_on_standby
        =   onStandby_PANEL
        && (onStandby_PANEL.id == bag_id) ;

    let action
        =      ( is_a_thumb_el(e_target)) ? "sel_clicked"
        :      ( bag_id_is_on_standby   ) ? "standby_release"
        :                                   "standby"
    ;

if( log_this) log("%c "+caller+": %c bag_id ["+bag_id+"] %c e_target ["+get_n_lbl(e_target)+"] %c action ["+action+"]"
                  , lb1          ,lb2                   ,lb3                                  ,lb4                    );
if( log_this && (LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG))) t_fly.t_log_stage_msg(t_fly.STAGE_2_ACTION, " <em class='cc9'>"+action+"</em>");

    switch(action) {
        case "sel_clicked":
        {

if(log_this) t_log.log_TR_EVENT_add(".switch <em class='cc1'>"+action+"</em>");

            t_onclick_target_handle_scroll_to_slot_num(e_target, caller);

        }
        break;

        case "standby":
        {

if(log_this) t_log.log_TR_EVENT_add(".switch <em class='cc1'>"+action+" bag_id ["+bag_id+"]</em>");

            t_standby_bag_id( bag_id );

        }
        break;

        case "standby_release":
        {

if(log_this) t_log.log_TR_EVENT_add(".switch <em class='cc1'>"+action+" bag_id ["+bag_id+"]</em>");

            if(onStandby_PANEL) t_standby3_release(caller);

        }
        break;


        default:
        {
logBIG(caller+": default: action=["+action+"] .. bag_id=["+bag_id+"]");
        }

    }
};


let  is_a_thumb_el = function(node)
{
    let caller = "is_a_thumb_el("+get_n_lbl(node)+")";

    let result
        =  node.id.startsWith("thumb_p_")
        || node.id.startsWith("thumb_s_")
        ;

if(result && LOG_MAP.EV0_LISTEN) log(caller+": ...return "+result);
    return result;
};




let onModalMS = 0;



let t_check_onModalMS = function(_caller)
{

let log_this = !onDown_SHIFT && t_log.logging_something();



    let in_progress = (onModalMS > 0);
    if(!in_progress )
    {
        onModalMS
            =  t_which_onModal_EL()
            && dimm_mask_displayed()
            ?  new Date().getTime()
            :  0;

    }
    else if( !t_which_onModal_EL() )
    {
        onModalMS = 0;
        in_progress = "interrupted by "+ get_n_lbl(onWork_EL);
    }


if( log_this) {

    if(     in_progress ) log("%c "+t_data.SYMBOL_CHECK_MARK+" MODAL DIALOG IN PROGRESS FOR "+ (parseInt((new Date().getTime() - onModalMS) / 100) / 10)+"s", lbH+lf7);
    else if(  onModalMS ) log("%c "+t_data.SYMBOL_CHECK_MARK+" MODAL DIALOG OPENED BY %c "+ _caller                                                         , lbH+lf7, lbH+lf7);
    else                  log("%c "+t_data.SYMBOL_CHECK_MARK+" MODAL DIALOG NOT OPENED BY %c "+_caller                                                      , lbH+lf8, lbH+lf8);
}

};


let t_clear_onModalMS = function(_caller)
{

let   caller = "t_clear_onModalMS";
let log_this = !onDown_SHIFT && t_log.logging_something();


if( log_this) log(caller+":%c "+t_data.SYMBOL_CHECK_MARK+" MODAL TIMER CLEARED BY "+_caller, lbH+lf5);

    onModalMS = 0;
};


let t_which_onModal_EL = function()
{
    return                                     onWork_EL
        && (     t_seek.t_seeker_is_seeker_PU( onWork_EL)
            || ( hotring                    == onWork_EL)
            || ( dimm_mask                  == onWork_EL)
            || ( div_slot_containers        == onWork_EL)
           )
        ?   onWork_EL.id
        :   false
    ;
};




let t_window_2_keyup_CB = function(e)
{
    t_input_2_CB(e, "window");
};


let t_input_2_CB = function(e, listener_tag="input")
{

let e_target = t_get_event_target(e);
let   caller = "t_input_2_CB";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) log(caller+"("+e.type+", "+listener_tag+"): on "+get_n_lbl(e_target));
if( log_this) t_log.console_dir(e.type+t_data.SYMBOL_RIGHT_ARROW+"target", e.target);


    switch(e.type)
    {
    case "keydown" : t_input_2_handle(e, e_target, listener_tag); break;
    case "keyup"   : t_input_2_handle(e, e_target, listener_tag); break;
    case "change"  : {
        if     ( t_util.is_el_or_child_of_parent_el(e_target, headsup_w    ) ) t_wording_3_CB    (e_target, e.type);
        else if( t_util.is_el_or_child_of_parent_el(e_target, dom_traversal) ) t_dom_traversal_CB(e_target, e.type);
    }
    break;
    default:
    }

};




const CHAR_CODE_F         = 70;

const CHAR_CODE_ESC       = 27;
const CHAR_CODE_RETURN    = 13;

const CHAR_CODE_BACKSPACE =  8;
const CHAR_CODE_SHIFT     = 16;
const CHAR_CODE_CONTROL   = 17;
const CHAR_CODE_ALT       = 18;
const CHAR_CODE_LEFT      = 37;
const CHAR_CODE_UP        = 38;
const CHAR_CODE_RIGHT     = 39;
const CHAR_CODE_DOWN      = 40;
const CHAR_CODE_DELETE    = 46;

let modifiers = {};

let t_input_2_handle = function(e, e_target, listener_tag)
{

let   caller = "t_input_2_handle";
let log_this = LOG_MAP.EV0_LISTEN;

let charCode = (e.keyCode) ? e.keyCode : e.which;





    t_clr_has_moved(caller);



    if(e.type == "keydown")
    {
        switch(charCode) {
        case CHAR_CODE_SHIFT     : if(log_this && !modifiers.shift  ) log("%c   SHIFT DOWN",lbH+lf6); modifiers.shift   = true; break;
        case CHAR_CODE_CONTROL   : if(log_this && !modifiers.control) log("%c CONTROL DOWN",lbH+lf2); modifiers.control = true; break;
        case CHAR_CODE_ALT       : if(log_this && !modifiers.alt    ) log("%c     ALT DOWN",lbH+lf4); modifiers.alt     = true; break;
        }
    }
    if(e.type == "keyup")
    {
        switch(charCode) {
        case CHAR_CODE_SHIFT     : if(log_this &&  modifiers.shift  ) log("%c   SHIFT UP"  ,lbH+lf6); modifiers.shift   = false; return;
        case CHAR_CODE_CONTROL   : if(log_this &&  modifiers.control) log("%c CONTROL UP"  ,lbH+lf2); modifiers.control = false; return;
        case CHAR_CODE_ALT       : if(log_this &&  modifiers.alt    ) log("%c     ALT UP"  ,lbH+lf4); modifiers.alt     = false; return;
        }
    }


    if(e.type != "keyup")
    {
        return;

    }


t_preventDefault(e, caller);


    if(         shadow_root.activeElement && (document.activeElement && (document.activeElement != shadow_host))) {

        t_blur(    document.activeElement );
    }

    if(         shadow_root.activeElement ) {

        t_focus(shadow_root.activeElement );
    }


    switch(charCode) {

    case CHAR_CODE_BACKSPACE : if(log_this                      ) log("%c BACKSPACE %c IGNORED",lbL,lbR+lf2); break;
    case CHAR_CODE_LEFT      : if(log_this                      ) log("%c LEFT      %c IGNORED",lbL,lbR+lf2); break;
    case CHAR_CODE_RIGHT     : if(log_this                      ) log("%c RIGHT     %c IGNORED",lbL,lbR+lf2); break;
    case CHAR_CODE_DELETE    : if(log_this                      ) log("%c DELETE    %c IGNORED",lbL,lbR+lf2); break;



    case CHAR_CODE_F:
if( log_this) log("%c type=["+e.type+"] e_target=["+e_target+"] modifiers "+t_log.log_json(modifiers), lbH+lf3);
    if(modifiers.control && modifiers.shift && words_filter_input)
    {
if( log_this) log("%c CTRL F %c FIND IN PAGE",lbL,lbR+lf2);

        let map = t_tools_map_get(headsup_w);
        if( map ) {
            if(!map.selected)
            {
if( log_this) log("%c SELECTING [headsup_w]", lbH+lf4);

                t_grid.t_grid_TOOLS_SELECT_panel(headsup_w, true);
                t_set_CSS_PINNED(headsup_w, true);
                t_grid_TOOLS_MAP_changed();

                let xy = t_gutter.get_GUTTER_XY();
                if( xy ) t_tools_set_top_xy(xy.x, xy.y);

                set_onWork_EL_last_used(words_filter_input);

                let sel_text = t_get_current_sel_text() || onDown_SEL_TEXT;
                if( sel_text ) words_filter_input.value = sel_text;

                t_focus(       words_filter_input);

                t_preventDefault(e, caller);
            }
            else if( headsup_w.classList.contains(t_data.CSS_PINNED) )
            {
if( log_this) log("%c DESELECTING [headsup_w]", lbH+lf8);

                t_tools_panel_select(headsup_w, false);
                t_grid_TOOLS_MAP_changed();

                t_preventDefault(e, caller);
            }
        }
    }
    break;


    case CHAR_CODE_ESC:
    if(listener_tag == "input") {
if( log_this) log("%c ESCAPE %c ESCAPE CURRENT STATE",lbL,lbR+lf2);

        e_target.value = e_target.value_set ? e_target.value_set : "";

        if( t_ESCAPE_2_CURRENT_STATE() )
            t_preventDefault(e, caller);
    }
    break;


    case CHAR_CODE_RETURN:
    if(listener_tag == "input") {
if( log_this) log("%c RETURN %c SUBMIT",lbb+lbL,lbb+lbR+lf2);

        if(log_this)
            t_fly.t_log_transcript_event_top("<em class='cc8'>"+caller+"</em>"
                +                      " e_target "+e_target.id+" <em class='cc9'>"+e_target.value+"</em>");

        t_wording_3_CB(e_target, "submit");

        t_focus( e_target );
        if(      e_target.value ) {
            e_target.selectionStart = e_target.value.length-1;
            e_target.selectionEnd   = e_target.value.length;
        }

        t_preventDefault(e, caller);
    }
    break;


    }

    if(modifiers.control && !modifiers.shift)
    {
        if(listener_tag == "input")
        {
            switch( charCode ) {
            case CHAR_CODE_UP   : set_tools_filter_from_all_csv_dir(-1); break;
            case CHAR_CODE_DOWN : set_tools_filter_from_all_csv_dir(+1); break;
            }
            t_preventDefault(e, caller);
        }
    }


    if( !e_target.innerHTML ) {
        e_target.innerHTML = "&nbsp;";
if( log_this) log("%c...keep some content to focus into", lf7);
    }

};


let t_input_2_focus_words_filter_input = function()
{

let   caller = "t_input_2_focus_words_filter_input";
let log_this = LOG_MAP.EV0_LISTEN;

if(log_this) log(caller);

    let map = t_tools_map_get(headsup_w);
    if( map && map.selected) {

        t_focus( words_filter_input );
    }
    else {
if(log_this) log("[words_filter_input] OFF SCREEN");
    }
};


let                         all_csv_idx = 0;
let   set_tools_filter_from_all_csv_dir = function(dir)
{
let   caller = "set_2_tools_filter_from_all_csv_dir("+dir+")";
let log_this = LOG_MAP.EV0_LISTEN;

    let all_csv = t_util.csv_cat(pat_csv, off_csv);
    all_csv     = t_util.csv_cat(all_csv, bak_csv);
    all_csv     = t_util.csv_cat(all_csv, alt_csv);
    all_csv     = t_util.csv_cat(all_csv, bin_csv);

    let count   = t_util.csv_count(all_csv);
    if(!count) return;

    all_csv_idx = (all_csv_idx + dir + count) % count;
    let pattern = t_util.csv_get(all_csv, 1+all_csv_idx);

if(log_this)
    log_key_val_group( caller
                       , {         count
                           , all_csv_idx
                           ,     pattern
                       }
                       , lf3, false
                     );
if(log_this && t_util.csv_pos(bin_csv,pattern)) log("...from bin_csv: ["+pattern+"]");

    set_tool_id_value(t_data.WORDS_FILTER, t_pattern_del_words_option_sfx( pattern ));
};


let t_ESCAPE_2_CURRENT_STATE = function()
{

let   caller = "t_ESCAPE_2_CURRENT_STATE";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) log(caller);
    let consumed_by = "";


    if( call_t_grid_IS_ON_GRID() )
    {
        consumed_by ="ESCAPE FROM TOOLS ON GRID";

        t_move_TOOLS_OFF_GRID("ESCAPE");
    }


    if(!consumed_by && div_slot_containers_displayed())
    {

        if( has_el_class(div_slot_containers, CSS_FULLSCREEN))
        {
            consumed_by = "ESCAPE SLOT CONTAINERS FULLSCREEN";

            t_slot_container_set_fullscreen();
        }
        else {
            consumed_by = "ESCAPE SLOT CONTAINERS DISPLAYED";

            dom_scroll.t_window_scrollTo(0, onDown_SCROLL_XY.y);
            dimm_stop( caller );
        }
    }


    if(!consumed_by && t_sticky.t_sticky_EDIT_DONE())
    {
        consumed_by ="ESCAPE STICKY RELEASED FOCUS";

    }


    if(!consumed_by) {


if( log_this) t_fly.t_log_event_status(caller, lf4);

        if(onWork_EL_last_used == words_filter_input)
        {
            let xy = t_gutter.get_GUTTER_XY();
            if( xy ) t_tools_set_top_xy(xy.x, xy.y);
        }
    }

if( log_this) log("%c"+caller+": %c"+consumed_by, lbH+lf4, lbH+lf4);
    return consumed_by;
};





const T_WORDING_3_CB_DELAY =  100;

let t_wording_3_CB_timout;

let t_wording_3_CB         = function(e_target, action)
{
    if(t_wording_3_CB_timout) clearTimeout(t_wording_3_CB_timout);
    t_wording_3_CB_timout
        = setTimeout( function() { t_wording_3_CB_handler(e_target, action); }
                    , T_WORDING_3_CB_DELAY);

};


let t_wording_3_CB_handler = function(e_target, action)
{

let   caller = "t_wording_3_CB_handler";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) log_key_val_group(caller+" .. "+get_n_lbl(e_target)+" .. "+action
                          , { e_target
                            , action
                            , has_moved
                            , t_event_consumed_cause
                          }, lf3, true);

    t_wording_3_CB_timout = null;
    if( has_moved ) return;


    if(e_target) del_el_class(e_target, CSS_FOCUSSED);



    if(e_target && (e_target.tagName == "INPUT"))
    {
if(log_this) log("...words_filter_input.value=["+words_filter_input.value+"]");

        switch(action)
        {

        case "submit":
        {
if(log_this) log("...%c case ACTION "+action+":", lf3);

            let slot = t_slot.get_slot_matching_pattern( words_filter_input.value );
            if(      prop.get( t_data.WORDS_OPCYCLE ) )
            {

                if( slot ) {
if(log_this) log("%c WORDS OPTIONS CYCLE SLOT ["+slot+"]",lb6);
                    t_slot.t_clear_slot(slot);
                    t_select.t_onPatternUpdate("CLEARING SLOT <em>"+ slot +"</em>", caller);
                    words_option_cycle();
                    t_call_dom_traversal();
                    return;
                }


                else {
if(log_this) log("%c WORDS OPTIONS CYCLE FRESH-SELECT",lb7);
                    t_call_dom_traversal();
                    return;
                }

            }
            else if(slot)
            {
if(log_this) log("%c CLEAR SELECTION SLOT ["+slot+"]",lb3);

                clear_clicked_slot( slot );
                return;
            }

            else {
if(log_this) log("%c WORDS NEW-SELECT",lb4);

                t_call_dom_traversal();
                return;
            }

        }
        break;


        case "click":
        {
if(log_this) log("...%c case ACTION "+action+":", lf3);

            words_filter_input.selectionEnd   = words_filter_input.value.length;
            words_filter_input.selectionStart = 0;
            t_focus( words_filter_input );
            return;
        }
        break;

        }
    }


    let    keyword;
    if(   !keyword) try { keyword =                       e_target.id;                   } catch(ex) {}
    if(   !keyword) try { keyword = t_util.get_first_word(e_target.textContent, caller); } catch(ex) {}
    if(   !keyword)       keyword = action;


    switch(keyword) {

        case t_data.WORDS_FILTER:
        {
if(log_this) log("...%c case "+keyword+":", lf3);

            if( e_target.id != t_data.WORDS_FILTER) {
                let pattern  = t_pattern_del_words_option_sfx( e_target.value );
                set_tool_id_value(t_data.WORDS_FILTER, pattern);
            }

            if(e_target) del_el_class(e_target, CSS_FOCUSSED);


        }
        break;


        case t_data.WORDS_RECYCLE:
        {
            wording_3_CB_WORDS_RECYCLE(log_this);

        }
        break;


        case t_data.WORDS_EXACT     :
        case t_data.WORDS_SEGMENT   :
        case t_data.WORDS_HEAD_TAIL :
        case t_data.WORDS_DROP_CASE :
        case t_data.WORDS_DROP_ING  :
        case t_data.WORDS_DROP_S    :
        {
if(log_this) log("...%c case "+keyword+":", lf3);
            let slot = t_slot.get_slot_matching_pattern( words_filter_input.value );
            if( slot ) {
if(log_this) log("...%c SLOT ["+slot+"]",lb6);
                t_slot.t_clear_slot(   slot );
                t_select.t_onPatternUpdate("CLEARING SLOT <em>"+ slot +"</em>", caller);
            }
            t_call_dom_traversal();
        }
        break;


        case "no_keyword"  :
        default:
        {
if(log_this) log("...default: %c keyword=["+keyword+"]", lf3);

        }

    }

    t_cache_armed_by(caller);
};


let   wording_3_CB_WORDS_RECYCLE_next_action = function(log_this)
{

let caller = "wording_3_CB_WORDS_RECYCLE_next_action";



    let all_csv = t_util.csv_cat(pat_csv, off_csv);
    all_csv     = t_util.csv_cat(all_csv, alt_csv);
    all_csv     = t_util.csv_cat(all_csv, bak_csv);



    let    sel_count = t_util.csv_count(sel_csv);
    let    all_count = t_util.csv_count(all_csv);
    let sticky_count = t_sticky.t_sticky_GET_COUNT();


    let action1_hide_sel        = (   sel_count > 0);
    let action2_dump_all_csv    = (   all_count > 0) && !action1_hide_sel;
    let action3_dump_all_sticky = (sticky_count > 0) && !action1_hide_sel && !action2_dump_all_csv;

    let   action0_tooltip
        = action1_hide_sel        ? "Click to hide "   + sel_count+" of "+all_count +" word"+((sel_count   >1) ? "s":"")
        : action2_dump_all_csv    ? "Click to remove "+                   all_count +" word"+((all_count   >1) ? "s":"")
        : action3_dump_all_sticky ? "Click to unpin "  +               sticky_count +" note"+((sticky_count>1) ? "s":"")
        :                           ""
    ;

    let   action0_result
        = action1_hide_sel        ? sel_count+" of "+all_count +" word"+((all_count   >1) ? "s":"")+" hidden"
        : action2_dump_all_csv    ?                  all_count +" word"+((all_count   >1) ? "s":"")+" removed"
        : action3_dump_all_sticky ?               sticky_count +" note"+((sticky_count>1) ? "s":"")+" unpinned"
        :                           ""
    ;


if( log_this) {
    let lfx
        =   action3_dump_all_sticky ? lf3
        :   action2_dump_all_csv    ? lf2
        :   action1_hide_sel        ? lf1
        :                             lf8
    ;

    log_key_val_group(caller+" "+(action0_tooltip || "NOTHING TO DO")
                         , {      action0_tooltip
                             ,    action1_hide_sel
                             ,    action2_dump_all_csv
                             ,    action3_dump_all_sticky
                             ,    action0_result
                         }
                         , lbb+lfx, true);
}


    return { action0_tooltip
        ,    action1_hide_sel
        ,    action2_dump_all_csv
        ,    action3_dump_all_sticky
        ,    action0_result
    };

};


let   wording_3_CB_WORDS_RECYCLE = function(log_this)
{
    let action = wording_3_CB_WORDS_RECYCLE_next_action(log_this);


    if( action.action1_hide_sel        ) pat_bag5_hide_sel();
    if( action.action3_dump_sel        ) wording_3_CB_WORDS_RECYCLE_SYNC_NOW("DUMP SEL");

    if( action.action2_dump_all_csv    ) t_pat_bag3_dump_all_csv();
    if( action.action3_dump_all_csv    ) wording_3_CB_WORDS_RECYCLE_SYNC_NOW("DUMP ALL");

    if( action.action3_dump_all_sticky ) t_sticky.t_sticky_unpin_all();
    if( action.action3_dump_all_sticky ) wording_3_CB_WORDS_RECYCLE_SYNC_NOW("DUMP STICKY");


    if( words_filter_input )
    {
        let pattern = t_pattern_del_words_option_sfx( action.action0_result );
        set_tool_id_value(t_data.WORDS_FILTER, pattern);

        if( action.action0_tooltip )
        {
            words_filter_input.selectionStart = 0;
            words_filter_input.selectionEnd   = words_filter_input.value.length;
            t_focus( words_filter_input );
        }
    }

};



const WORDING_3_CB_WORDS_RECYCLE_SYNC_DELAY = 2000;

let   wording_3_CB_WORDS_RECYCLE_SYNC_timer;

let   wording_3_CB_WORDS_RECYCLE_SYNC_NOW = function(_caller)
{


    wording_3_CB_WORDS_RECYCLE_SYNC(0);
};
let   wording_3_CB_WORDS_RECYCLE_SYNC = function(delay=WORDING_3_CB_WORDS_RECYCLE_SYNC_DELAY)
{
    if(!delay &&     wording_3_CB_WORDS_RECYCLE_SYNC_timer)
        clearTimeout(wording_3_CB_WORDS_RECYCLE_SYNC_timer);

    wording_3_CB_WORDS_RECYCLE_SYNC_timer
        = setTimeout(wording_3_CB_WORDS_RECYCLE_SYNC_handler, delay);
};


let   wording_3_CB_WORDS_RECYCLE_SYNC_handler = function()
{

let caller = "wording_3_CB_WORDS_RECYCLE_SYNC_handler";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) t_fly.t_log_event_status(caller, lbb+lf3);

    wording_3_CB_WORDS_RECYCLE_SYNC_timer = null;


    let action = wording_3_CB_WORDS_RECYCLE_next_action(log_this);


    let words_recycle = prop.get_EL(t_data.WORDS_RECYCLE);
    if(!words_recycle ) return;

    t_util.set_el_caption(words_recycle , action.action0_tooltip);

    words_recycle.innerText             = action.action3_dump_all_sticky ? t_data.SYMBOL_STICKY_PEN
        :                                 action.action2_dump_all_csv    ? t_data.SYMBOL_HEAVY_BALLOT
        :                                 action.action1_hide_sel        ? t_data.SYMBOL_CLEAR_SCREEN
        :                                                                  t_data.SYMBOL_ELLIPSIS;

    set_el_class_removing(words_recycle , action.action3_dump_all_sticky ? "cc3"
                          :               action.action2_dump_all_csv    ? "cc2"
                          :               action.action1_hide_sel        ? "cc1"
                          :                                                "cc8"
                          ,                                                t_data.CCX_CLASSLIST);


};




const SEL_TEXT_TIC_TOC_INTERVAL =  250;
const SEL_TEXT_UNCHANGED_COUNT  =   20;

let          sel_text_unchanged_count;
let     last_sel_text;
let get_last_sel_text = function(    ) { return last_sel_text;        };
let set_last_sel_text = function(text) { return last_sel_text = text; };


let   tic_SELECTION_PROGRESS = function()
{


    sel_text_unchanged_count                      = SEL_TEXT_UNCHANGED_COUNT;
    t_util.flip_el_class(        document.documentElement,  t_data.CSS_SELECTION_PROGRESS );
    del_el_class (        document.documentElement,  t_data.CSS_SELECTION_ENDING   );
};


let   toc_SELECTION_PROGRESS = function()
{

    if(sel_text_unchanged_count == 0)
    {
        tic_SELECTION_PROGRESS();
        return sel_text_unchanged_count;
    }

    sel_text_unchanged_count          -= 1;


    if(sel_text_unchanged_count > 6)
    {
        t_util.flip_el_class(    document.documentElement,  t_data.CSS_SELECTION_PROGRESS );
    }
    else {
        del_el_class (    document.documentElement,  t_data.CSS_SELECTION_PROGRESS );
        t_util.flip_el_class(    document.documentElement,  t_data.CSS_SELECTION_ENDING   );
    }


    return sel_text_unchanged_count;
};


let   clr_SELECTION_PROGRESS = function(_caller, log_this=false)
{
if(log_this) t_log.logSD9("%c clr_SELECTION_PROGRESS %c"+_caller, lbb+lbL+lf0,lbb+lbR+lf0);


    del_el_class(         document.documentElement,   t_data.CSS_SELECTION_PROGRESS  );
    del_el_class(         document.documentElement,   t_data.CSS_SELECTION_ENDING    );


    sel_text_unchanged_count           = 0;
    if( onLong_press4_TOOL_STICKY_SEL_TEXT_timer ) clearInterval( onLong_press4_TOOL_STICKY_SEL_TEXT_timer );
        onLong_press4_TOOL_STICKY_SEL_TEXT_timer = null;
};


let   get_SELECTION_PROGRESS = function()
{
    return (sel_text_unchanged_count / SEL_TEXT_UNCHANGED_COUNT);
};





let t_body_width_show = function()
{
    let panel = t_get_tool("headsup_bw_value"); if(!panel) return;
    let     m = parseInt( document.body.style.marginLeft );
    let     w = parseInt( document.body.clientWidth      )
        -                 document.body.clientLeft
        ;
    if( isNaN(m) ) m = 0;
    if( isNaN(w) ) w = 0;

    panel.innerHTML = "BODY "
        +" <em class='cc1' title='Body   style.marginLeft'      >"+ t_data.SYMBOL_LEFT_HALF_BLACK     +" "+ m   +"</em>"
        +" <em class='cc2' title='Body   clientWidth clientLeft'>"+ t_data.SYMBOL_BLACK_SMALL_SQUARE  +" "+ w   +"</em>"
        +" <em class='cc3' title='Window innerWidth'            >"+ t_data.SYMBOL_BLACK_MEDIUM_SQUARE +" "+ w_W +"</em>"
    ;
    t_eval_wide_or_tall_panel( panel );
};


let t_body_layout_CB = function(e_target)
{

let   caller = "t_body_layout_CB("+get_n_lbl(e_target)+")";
let log_this = LOG_MAP.EV0_LISTEN || LOG_MAP.EV5_TOOL_CB;

if( log_this) t_fly.t_log_event_status(caller, lf7);

    if( has_moved                                ) return;
    if( e_target.tagName != "EM"                 ) return;


    let body_width = parseInt( e_target.innerText.trim() );
if( log_this) log("...body_width=["+body_width+"]");

    if(!isNaN(body_width) ) {
        body_width -= 2 * document.body.clientLeft;

        document.body.style.width       = body_width+"px";
    }
    else {
        document.body.style.width       = "";
    }

    t_layout_changed();
};




let   body_zoom_percent = 100;


let t_body_zoom_CB = function(e_target)
{

    let caller   = "t_body_zoom_CB("+get_n_lbl(e_target)+")";
let log_this = LOG_MAP.EV0_LISTEN || LOG_MAP.EV5_TOOL_CB;

if( log_this) t_fly.t_log_event_status(caller, lf7);

    if(has_moved                                 ) return;
    if(e_target.tagName != "EM"                  ) return;


    let old_page_height = t_util.getPageHeight();


    body_zoom_percent = parseInt( e_target.innerText.trim() );
if( log_this) log("...body_zoom_percent=["+body_zoom_percent+"]");

    if( !isNaN(body_zoom_percent) )
    {
        let className = "zoom_"+body_zoom_percent;
        set_el_class(document.body , className);
    }
    else {
        body_zoom_percent          = 100 ;
        set_el_class(document.body ,  "");
        set_el_class(dom_tools_html,  "");
    }


    let new_page_height = t_util.getPageHeight();

    let    s_X = Math.floor(window.scrollX);
    let    s_Y = Math.floor(window.scrollY * new_page_height / old_page_height);

if( log_this) {
    log_key_val_group( caller
                       , {            WINDOW : window.innerHeight +" "+ window.innerWidth
                           ,          SCROLL : window.scrollX     +" "+ window.scrollY
                           ,         s_X_s_Y :                s_X +" "+ s_Y
                           , old_page_height
                           , new_page_height
                       }, lf1, false
                     );

}

    s_X /= (body_zoom_percent  / 100);
    s_Y /= (body_zoom_percent  / 100);
    dom_scroll.t_window_scrollTo(s_X, s_Y, "instant");

    t_layout_changed();


};


let t_body_zoom_show = function()
{
    let panel = t_get_tool("headsup_bz_value"); if(!panel) return;

    let zoom_class = document.body.className  ? "cc2" : "cc8";

    let zoom_label
        =  document.body.className.includes("zoom")
        ?  document.body.className
        : (document.body.style.zoom || "default");

    panel.innerHTML = "BODY zoom factor <em class='"+zoom_class+"'>"+zoom_label+"</em>";

    t_eval_wide_or_tall_panel( panel );
};




let   body_font_size_percent = 100;


let t_body_font_size_CB = function(e_target)
{

    let caller   = "t_body_font_size_CB("+get_n_lbl(e_target)+")";
let log_this = LOG_MAP.EV0_LISTEN || LOG_MAP.EV5_TOOL_CB;

if( log_this) t_fly.t_log_event_status(caller, lf7);

    if(has_moved                                 ) return;
    if(e_target.tagName != "EM"                  ) return;



    body_font_size_percent = parseInt( e_target.innerText.trim() );
if( log_this) log("...body_font_size_percent=["+body_font_size_percent+"]");

    if( !isNaN(body_font_size_percent) )
    {

        let className = "font_size_"+body_font_size_percent;
        set_el_class(document.body , className);

    }
    else {
        body_font_size_percent          = 100 ;

        set_el_class(document.body ,  "");
        set_el_class(dom_tools_html,  "");

    }

    t_body_font_size_show();
    t_layout_changed();
};


let t_body_font_size_show = function()
{
    let panel = t_get_tool("headsup_fs_value"); if(!panel) return;

    let font_size_class = document.body.className  ? "cc2" : "cc8";

    let font_size_label
        =  document.body.className.includes("font_size")
        ?  document.body.className
        : (document.body.style.fontSize || "default");

    panel.innerHTML = "BODY font-size <em class='"+font_size_class+"'>"+font_size_label+"</em>";
};



let prop_tools_CB = function(e_target)
{

let   caller = "prop_tools_CB(e_target=["+get_n_lbl(e_target)+"]";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller, lbb+lbH+lf7);
    let consumed_by = "";


    let keyword = ""; try { keyword = e_target.id                ; } catch(ex) {}
    if(!keyword)      try { keyword = e_target.title      .trim(); } catch(ex) {}
    if(!keyword)      try { keyword = e_target.textContent.trim(); } catch(ex) {}



    if( has_moved                          ) return consumed_by;




    if(t_log.logging_toggle( keyword ))
    {
log("%c "+caller+": %c TOGGLED keyword=["+ keyword +"]",lb9, lbF);

        load8_LOG_MAP();


        if(keyword == "EV8_FLOATLOG")
            t_fly.t_fly_log_set_state( LOG_MAP.EV8_FLOATLOG );

        t_sync_layout(caller);

        t_save_update_post("DOC LOGGING CB");

        consumed_by = "t_log.logging_toggle("+keyword+")";
    }


    t_sync_tool_clones_state( caller );


    t_layout_changed();

    return consumed_by;
};



let call_touchedWord        = function( x,   y) { t_select.touchedWord            ( x ,   y    ); };
let call_check_NodeIterator = function(id, fil, wo) { t_select.check_NodeIterator (id , fil, wo); };
let call_check_TreeWalker   = function(id, fil, wo) { t_select.check_TreeWalker   (id , fil, wo); };
let call_check_childNodes   = function(id, fil, wo) { t_select.check_childNodes   (id , fil, wo); };
let call_check_tagNodes     = function(id, fil, wo) { t_select.check_tagNodes     (id , fil, wo); };





let t_dom_traversal_CB = function(e_target, e_type)
{


    let caller   = "t_dom_traversal_CB("+get_n_lbl(e_target)+", e_type=["+e_type+"])";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) t_fly.t_log_event_status(caller, lf5);


    if( has_moved                   ) return false;
    if(e_target.tagName == "INPUT"  ) return false;




if(e_target) del_el_class(e_target, CSS_FOCUSSED);



    let keyword;
    if(!keyword) try { keyword =                e_target.id;                   } catch(ex) {}
    if(!keyword) try { keyword = t_util.get_first_word(e_target.textContent, caller); } catch(ex) {}
    if(!keyword)       keyword =                e_type;


    switch(keyword) {

        case "NodeIterator":
        case "TreeWalker"  :
        case "childNodes"  :
        case "tagNodes"    :
        {
            current_traversal = keyword;

if(log_this) log("%c SETTING current_traversal to %c"+current_traversal, lbL, lbR);
        }
        break;


        case "node":
        {
if(log_this) t_log.log_TR_SELECT_set("<em class='big'>CLEAR: tools_node</em>");


            set_tool_id_value("tools_node", "");


            if(words_node_input) words_node_input.value = "";
        }
        break;


        case "tools_node"  :
        {
            if(e_target.id != "tools_node") set_tool_id_value("tools_node", keyword);

if(e_target && log_this) t_log.log_TR_SELECT_set("<em class='big'>CHANGE: tools_node ["+ keyword +"]</em>");
        }
        break;


        case "html":
        case "head":
        case "body":
        {

            set_tool_id_value("tools_node", keyword);

if(log_this) t_log.log_TR_SELECT_set("<em class='big'>SET</em> : <em>tools_node "+ keyword +"</em>");
        }
        break;


        default: {
            if(log_this) log("...default: keyword=["+keyword+"]");
            return false;
        }

    }

    t_call_dom_traversal();

t_cache_armed_by(caller+": keyword=["+keyword+"]");
    return true;
};


let current_traversal = "TreeWalker";

let t_call_dom_traversal = function()
{

let   caller = "t_call_dom_traversal";
let log_this = LOG_MAP.T3_LAYOUT;



    let user_pattern   = t_get_tool_id_value(t_data.WORDS_FILTER);
    if(!user_pattern) {
logBIG(caller+": "+current_traversal+" ➔ NO user_pattern", 2);
        return;
    }

    let pattern        = prop.get(t_data.WORDS_SEGMENT) ? user_pattern
        :                         t_select.t_escapeREGEX( user_pattern );



    let current_words_option   = get_current_words_option();

    let pat_with_sfx   = pattern_fallback_to_current_words_option_sfx(pattern, current_words_option);


    let tools_node     = t_get_tool_id_value("tools_node"  );

if( log_this) log_key_val(   caller+": .. pattern=["+pattern+"]"
                         , { current_traversal
                           , tools_node
                           , pattern
                           , pat_with_sfx
                           , current_words_option
                         } , lf4);

    switch( current_traversal )
    {
        case "NodeIterator": call_check_NodeIterator(tools_node, pat_with_sfx, current_words_option); break;
        case "TreeWalker"  : call_check_TreeWalker  (tools_node, pat_with_sfx, current_words_option); break;
        case "childNodes"  : call_check_childNodes  (tools_node, pat_with_sfx, current_words_option); break;
        case "tagNodes"    : call_check_tagNodes    (tools_node, pat_with_sfx, current_words_option); break;
    }

    t_select.t_onPatternUpdate("CALLING DOM TRAVERSAL <em class='cc9'>"+ t_util.ellipsis_short(pat_with_sfx) +"</em>", caller);


    t_sync_layout(caller);

    if( words_filter_input ) t_focus( words_filter_input );

};


let t_log_option_changes = function(changes)
{

    let options
        = prop.get( t_data.WORDS_EXACT   ) ? t_data.WORDS_EXACT
        : prop.get( t_data.WORDS_SEGMENT ) ? t_data.WORDS_SEGMENT
        :                             t_data.WORDS_HEAD_TAIL
    ;
    let s = "<em>"+changes+"</em>" +"<br>"+LF
        +"<table>"+LF
        +"<tr><th>OPTIONS:</th></tr>"+LF
        +"<tr>"
        +" <td>"+ get_log_option_state( t_data.TOOLS_SCROLL       , prop.get( t_data.TOOLS_SCROLL      ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.DOM_FREEZE         , prop.get( t_data.DOM_FREEZE        ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.USER_LANG          , prop.get( t_data.USER_LANG         ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.ANCHOR_FREEZE      , prop.get( t_data.ANCHOR_FREEZE     ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.CONTAINERS_HI      , prop.get( t_data.CONTAINERS_HI     ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.SCROLL_SMOOTH      , prop.get( t_data.SCROLL_SMOOTH     ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.OVERFLOW_VISI      , prop.get( t_data.OVERFLOW_VISI     ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.DETAILS_RADIO      , prop.get( t_data.DETAILS_RADIO     ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.TOOLS_TIER2        , prop.get( t_data.TOOLS_TIER2       ) ) +"</td>"
        +"</tr>"+LF
        +"<tr>"
        +" <td>"+ get_log_option_value("WORDS OPTIONS"     , words_options_symbol(options) )
        +" <td>"+ get_log_option_state( t_data.WORDS_EXACT        , prop.get( t_data.WORDS_EXACT       ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.WORDS_SEGMENT      , prop.get( t_data.WORDS_SEGMENT     ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.WORDS_HEAD_TAIL    , prop.get( t_data.WORDS_HEAD_TAIL   ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.WORDS_OPCYCLE      , prop.get( t_data.WORDS_OPCYCLE     ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.WORDING            , prop.get( t_data.WORDING           ) ) +"</td>"
        +" <td>"+ get_log_option_state( t_data.THEME_DARK         , prop.get( t_data.THEME_DARK        ) ) +"</td>"
        +"</tr>"+LF
        +"<tr>"




        +"</tr>"+LF
        +"<tr>"
        +" <td>"+ get_log_option_state(LOG_MAP.T8_TOOLBAR  , LOG_MAP.T8_TOOLBAR                      ) +"</td>"
        +"</tr>"+LF
        +"<tr><th>CSS:</th></tr>"+LF
        +"<tr>"
        + "<td><em class='em_match'  >em_match  </em></td>"
        + "<td><em class='em_missing'>em_missing</em></td>"
        +"</tr>"+LF
        +"</table>"+LF
    ;

    t_log.log_TR_LAYOUT_set("<div id='log_tags_div'>"+ s +"</div>");
};

let get_log_option_state = function(option, state)
{
    let     mark = state ? t_data.SYMBOL_CHECK_MARK : t_data.SYMBOL_NOT_CHECKED;
    let em_class = state ?             "cc2" : "cc8";
    return option +" <em class='"+em_class+"'>"+ mark     +"</em>    ";
};

let get_log_option_value = function(option, value_em)
{
    return option +" "+ value_em;
};




let t_override_USER_OPTION = function(key, val)
{

let   caller = "t_override_USER_OPTION("+key+", "+val+")";
let log_this = t_log.logging_something();

if( log_this) log(caller);

    if(!cached_user_options_map_get(key) ) {
        cached_user_options_map_set(key, prop.get(key));
if(log_this) log(caller+": ...caching USER OPTION %c"+key+"%c"+val, lbL+lf3, lbR+lf3);
    }
if(log_this) log(caller+": ...overriding "+key+" option from %c "+cached_user_options_map_get(key)+" %c to %c "+val, lb1,lbA ,lb2);
    prop.set(key, val);
};


let t_reinstate_USER_OPTIONS = function(_caller)
{

let   caller = "t_reinstate_USER_OPTIONS("+_caller+")";
let log_this = LOG_MAP.EV1_DOWN || LOG_MAP.EV0_LISTEN;

if( log_this) log(caller);

    for(let i=0; i< cached_user_options_map.length; ++i)
    {
        let    key =   cached_user_options_map[i].key;
        let cached =   cached_user_options_map[i].val;
        let option =                prop.get(key);
        if( option != cached) {
if(log_this)
        log(caller+": ...restoring %c"+key+"%c option from %c"+option+"%c to %c"+cached+"]"
            ,                      lb1     ,lbA           ,lb4       ,lbA   ,lb3           );
            prop.set(key, cached);
        }
        else {
if(log_this)
        log(caller+": ............ %c"+key+"%c option ==== %c"+cached+"%c (as cached)"
            ,                      lb1     ,lbA           ,lb3       ,lbA             );
        }
    }
    cached_user_options_map = [];

    clr_onWork_EL(caller);
};



let t_onclick_target_handle_scroll_to_slot_num = function(e_target, _caller)
{

let caller = "t_onclick_target_handle_scroll_to_slot_num";
let log_this = LOG_MAP.EV5_TOOL_CB || LOG_MAP.T2_GRID || LOG_MAP.T6_SLOT;

if(log_this) log(caller+"(e_target=["+get_n_lbl(e_target)+"]) ..%c CALLED BY "+ _caller, lb0);

    let result;


    let slot  = get_slot_from_id_or_className(e_target);


    if( slot > 0) {
        if(!t_select.ccs[slot].thumbs) t_select.ccs[slot].thumbs = [];


        let num = get_num_from_id_or_className_slot(e_target, slot);
if(log_this) t_log.log_TR_SELECT_add(".slot=<em>"+slot+"</em> num=<em>"+num+"</em>");
if(log_this) log(              ".slot="    +slot     +" num="    +num        );


        if(!num) {
            num = t_select.t_get_last_highligted_slot_num(slot, prop.get( t_data.SEL_BACK ));
if(log_this) log(".slot_num_for_thumb_p=["+ num +"]");


            let num_max = t_select.t_select_get_slot_nodes_length(slot);
            let first = 1;
            let  last = num_max;

            if(prop.get( t_data.SEL_BACK )) num = (num > first) ? num-1 : last;
            else                     num = (num < last ) ? num+1 : first;

if(log_this) t_log.log_TR_SELECT_add(".NEXT num=<em>"+num+"</em>");
        }
        t_seek.t_seeker_onMove3_ON_SLOT_NUM(slot, num);

        result = "TO THUMB slot=["+slot+"] num=["+num+"]";
    }
    else {
        result = "NO SLOT FOR "+get_n_lbl(e_target);
    }

if(log_this) t_log.log_TR_SELECT_add("<em class='cc4'>"+result+"</em>");
    return result;
};




let cached_user_options_map = [];

let cached_user_options_map_set = function(key,val)
{
    cached_user_options_map.push({key , val});
};

let cached_user_options_map_get = function(key)
{
    for(let i=0; i< cached_user_options_map.length; ++i) {
        if(key   == cached_user_options_map[i].key) {
            return  cached_user_options_map[i].val;
        }
    }
    return null;
};





let t_standby1_timer = null;


let t_standby_bag_id = function(bag_id)
{


    let caller = "t_standby_bag_id("+bag_id+")";
let log_this = LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c "+caller, lbF+lb0);
if( log_this) t_log.log_TR_EVENT_add("<em class='cc1'>STANDBY</em> <em class='cc9'>"+bag_id+"</em>");
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_2_ACTION, " <em class='cc9'>standby ["+bag_id+"]</em>");



    if(onStandby_PANEL) t_standby3_release("t_standby_bag_id");


    if(bag_id) onStandby_PANEL = t_get_tool(bag_id);
    else       onStandby_PANEL = null;

    if(onStandby_PANEL) add_el_class(onStandby_PANEL, CSS_STANDBY);

if(onStandby_PANEL) if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_3_RESULT, " Setting "+bag_id+" on STANDBY");


    if(t_standby1_timer) clearTimeout(t_standby1_timer);
    t_standby1_timer =     setTimeout(t_standby1_handle, t_data.T_STANDBY1_DELAY);
};


let t_standby1_handle = function()
{

    if(!onStandby_PANEL) return;

    let caller = "t_standby1_handle";
let log_this = LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c "+caller+": ["+onStandby_PANEL.id+"]", lbF+lb1);

    switch( onStandby_PANEL.id )
    {
        case "pat_bag":
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_1_INPUT, " STANDBY HANDLE <em class='cc9'>"+onStandby_PANEL.id+"</em>");
        t_pat_bag_stage_target( pat_bag );
        break;

        case "sel_bag":
        prop.toggle( t_data.SEL_BACK );
if(log_this) t_log.log_TR_EVENT_add("_<em class='cc3'>SELBAG SELECT <em class='cc9'>"+(prop.get( t_data.SEL_BACK ) ? "BACKWARD" : "FORWARD")+"</em></em>");
        t_seek.t_seeker_sync_SEL_BACK(caller);
        break;
    }

    if( t_standby2_is_done(onStandby_PANEL.id, caller) )
        t_standby3_release(caller);
};


let t_standby2_is_done = function(id,_caller)
{

let log_this = LOG_MAP.S2_SELECT;


    let target_handled = true;

if( log_this) log("%c t_standby2_is_done("+id+"): ...return ["+target_handled+"] %c .. CALLED BY "+ _caller, lbF+lb2, lb0);
    return target_handled;
};


let t_standby3_release = function(_caller="TIMER")
{

let log_this = LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;
if( log_this) log("%c t_standby3_release: ["+get_n_lbl(onStandby_PANEL)+"] .. CALLED BY "+ _caller, lbF+lb3);

    if(!onStandby_PANEL) return;

    if(t_standby1_timer) clearTimeout( t_standby1_timer );
 t_standby1_timer = null;

    del_el_class(onStandby_PANEL, CSS_STANDBY);

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_3_RESULT, " STANDBY CLEAR <em class='cc9'>"+onStandby_PANEL.id+"</em>");

    onStandby_PANEL  = null;
};





let T_CLEAR_INTERVAL_MIN = 500;
let t_clear_timeStamp    = 0;

let t_clear = function(_caller)
{

    let caller = "t_clear .. CALLED BY ["+_caller+"]";
let log_this = t_log.logging_something();

if( log_this) log(caller);
if( log_this) log("...t_preventDefault_caller=["+t_preventDefault_caller+"]");



    let          this_MS = new Date().getTime();
    let t_clear_interval = this_MS - t_clear_timeStamp;
    if( t_clear_interval < T_CLEAR_INTERVAL_MIN)
    {
if(log_this) log(caller+": BOUNCING: "+t_clear_interval+" < (T_CLEAR_INTERVAL_MIN "+T_CLEAR_INTERVAL_MIN+")");
        return;
    }
    t_clear_timeStamp = this_MS;


    log();


    t_window_getSelection_removeAllRanges(caller);



    let target
        = _caller.includes("pat_bag" ) ? "pat_bag"
        : _caller.includes("EM"      ) ?      "em"
        : _caller.includes("INPUT"   ) ?   "input"
        : _caller.includes("cycle"   ) ?   "cycle"
        :                               "default"
        ;

    let action
        = _caller.includes("dblclick") ? "dblclick"
        : was_a_dblclick()             ? "dblclick"
        : _caller.includes("onclick" ) ? "onclick"
        :                                "default"
    ;

    let target_action = target+"."+action;

if(log_this) log(".target_action=["+target_action+"]");

    switch(target_action) {

        case    "em.onclick": case    "em.dblclick":
        case "input.onclick": case "input.dblclick":
        case "cycle.default":

        break;


        case "default.dblclick":
if(log_this) log("XXX fall through case default...");



        default:



        log();
if( LOG_MAP.EV3_UP) log("%c t_clear("+caller+") console logs preserved for %c LOG_MAP.EV3_UP", lb4, lbF+lb3);


        t_clear_panel_pined_innerHTML(transcript1);
        t_clear_panel_pined_innerHTML(transcript2);


        if( transcript1.classList.contains(t_data.CSS_PINNED) ) t_clear_move_panel_within_window(transcript1);
        if( transcript2.classList.contains(t_data.CSS_PINNED) ) t_clear_move_panel_within_window(transcript2);


        t_fly.t_doc_div_clear("doc_evt_div");
        t_fly.t_doc_div_clear("doc_log_div");


    }
    t_outline_clear();

    t_cache_armed_by(caller);


    t_fly.t_fly_init(caller);
};


let t_clear_move_panel_within_window = function(panel)
{
    let caller = "t_clear_move_panel_within_window("+get_n_lbl(panel)+")";
let log_this = t_log.logging_something();

    let xy = t_util.get_el_xy(panel, caller);

    let margin      = hotring.clientWidth;

    let x_max = w_W - margin;
    let y_max = w_H - margin;
    let x_min =       0;
    let y_min =       0;

    let                                               panel_moved = false;
    if(xy.x > x_max) { panel.style.left = x_max+"px"; panel_moved =  true; }
    if(xy.x < x_min) { panel.style.left = x_min+"px"; panel_moved =  true; }
    if(xy.y > y_max) { panel.style.top  = y_max+"px"; panel_moved =  true; }
    if(xy.y < y_min) { panel.style.top  = y_min+"px"; panel_moved =  true; }

if(log_this && panel_moved) log(caller+": .. moved from XY=["+xy.x+" "+xy.y+"] .. within ["+ x_max+" "+ y_max+"]");
};






let prop_id_state_CB = function(id, checked)
{

let caller = "prop_id_state_CB("+id+" , checked=["+checked+"])";
let log_this = LOG_MAP.T3_LAYOUT || LOG_MAP.EV5_TOOL_CB;

if( log_this) t_fly.t_log_event_status(caller, lf5);


    let tool_el       = t_get_tool         (id); if(log_this && tool_el    ) t_log.console_dir("...tool_el"      , tool_el      );
    let tool_clone    = get_tool_clone   (id); if(log_this && tool_clone   ) t_log.console_dir("...tool_clone"   , tool_clone   );
    let tool_embedded = get_tool_embedded(id); if(log_this && tool_embedded) t_log.console_dir("...tool_embedded", tool_embedded);

    if( tool_clone    ) tool_clone   .checked = checked;
    if( tool_el       ) tool_el      .checked = checked;
    if( tool_embedded ) tool_embedded.checked = checked;



    t_sync_styles(caller);



    t_clone_2_id_state_CB(id, checked);



    if(typeof playground_prop_CB != "undefined") playground_prop_CB(id, checked);



    switch(id)
    {
    case "t_sticky.t_sticky_reorder":
if(log_this) log("%c calling [funcion "+id+"]", lbb+lbH+lf7);

        t_sticky.t_sticky_reorder();
    break;
    }

    let state
        = tool_el
        ? tool_el.checked
        : checked
    ;
if( log_this) log("...return %c"+state, lbX[state ? 4 : 6]);
    return state;
};



const TOGGLE_RELOAD_DELAY = 2000;

let   location_reload_timeout;

let   prop_id_toggle = function(keyword)
{

let   caller = "prop_id_toggle("+keyword+")";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller);



    if( log_this) log("...................keyword %c["+ keyword                 +"]", lb0);
    if( log_this) log(".................has_moved %c "+ has_moved               +" ", lb2);
    if( log_this) log("....t_event_consumed_cause %c "+ t_event_consumed_cause  +" ", lb2);
    if( log_this) log("...t_preventDefault_caller %c "+ t_preventDefault_caller +" ", lb2);

    let                                    rejected_by = "";
    if     ( has_moved                   ) rejected_by = "has_moved";
    else if( t_event_has_been_consumed() ) rejected_by = t_event_consumed_cause;


if(log_this && rejected_by) log(caller+": %c rejected_by ["+ rejected_by+"]", lb2);
    if(rejected_by) {
if(log_this) console.trace();
        return;
    }


    if( keyword.startsWith(t_data.SQUEEZE_CYCLE) )
        keyword = t_data.SQUEEZE_CYCLE;



    let changes = "";
    switch(keyword)
    {
    case  t_data.USER_LANG       : changes += keyword;
    {
        let  user_lang = dom_i18n.i18n_get_user_lang();
        let       lang = user_lang;

        let      array = dom_i18n.i18n_get_LANGUAGES();
        for(let i=0; i<array.length; ++i)
        {
            if(array[i] == user_lang)
            {
                lang =    ((i+1) < array.length)
                    ? array[i+1] : array[ 0 ];
                break;
            }
        }



        dom_i18n.i18n_set_args({ lang , caller });


        let el = prop.get_EL(t_data.USER_LANG);
        if( el ) {
            el.title     = i18n_get(dom_i18n.USER_LANG, dom_i18n.USER_LANG);
            el.className = "flag bg_"+lang;
        }


        prop.set(t_data.USER_LANG, lang);
        t_store.t_store_set_value(t_data.USER_LANG, lang);


        let lang_applied  = dom_i18n.i18n_get_user_lang_applied();
        if( lang_applied != lang)
        {
logBIG("RELOADING: changing from "+lang_applied+" to "+lang, 7);
            if( el ) t_util.add_el_class(el, "reloading");

            if( location_reload_timeout ) clearTimeout( location_reload_timeout );
            location_reload_timeout     =   setTimeout(function() { document.location.reload(); }, TOGGLE_RELOAD_DELAY);
        }
        else {
            if( el ) t_util.del_el_class(el, "reloading");

            if( location_reload_timeout ) clearTimeout( location_reload_timeout );
logBIG("RELOAD CANCELED ..back to: "+lang, 8);
        }

if( log_this)
    log_key_val_group(caller
                      , { user_lang
                        , array
                        , lang
                        , TOGGLE_RELOAD_DELAY
                      } , lf5, false);

    }
    break;

    case  t_data.DOM_FREEZE      : changes += keyword; prop.toggle( keyword          );
    {


        let state = prop.get(     t_data.DOM_FREEZE);
        t_store.t_store_set_value(t_data.DOM_FREEZE, state);


        if( state )
            t_util.t_REMOVE_EventListeners();


        if(!state)
        {
            if( location_reload_timeout ) clearTimeout( location_reload_timeout );
            location_reload_timeout     =   setTimeout(function() { document.location.reload(); }, 0);
        }
    }
    break;

    case t_data.ANCHOR_FREEZE:
    if(!prop.get(t_data.WORDING) ) changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.TOOLS_TRAP      : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.THEME_DARK      : changes += keyword; prop.toggle( keyword          ); break;
    case "theme_LIGHT"    : changes += keyword; prop.set   ( t_data.THEME_DARK, false); break;
    case "theme_DARK"     : changes += keyword; prop.set   ( t_data.THEME_DARK,  true); break;

    case  t_data.WORDING         : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.CONTAINERS_HI   : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.SCROLL_SMOOTH   : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.OVERFLOW_VISI   : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.DETAILS_RADIO   : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.SHOW_SEEKZONE   : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.PIN_SEEKSPOT    : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.LOG_SEEKSPOT    : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.REMOVE_ADS      : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.SPLIT_WOT       : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.LINES_WOT       : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.MASK_OR_HIDE    : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.SITE_OR_PAGE    : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.EDIT_OR_STAGE   : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.DOM_HIDE1_RESET : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.DOM_HIDE1_UNDO  : changes += keyword; prop.toggle( keyword          ); break;
    case  t_data.DENY_OR_ALLOW   : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.TOOLS_TIER2     : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.WORDS_EXACT     : changes += keyword; prop.set   ( keyword   ,  true); break;
    case  t_data.WORDS_SEGMENT   : changes += keyword; prop.set   ( keyword   ,  true); break;
    case  t_data.WORDS_HEAD_TAIL : changes += keyword; prop.set   ( keyword   ,  true); break;
    case  t_data.WORDS_OPCYCLE   : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.TOOLS_SCROLL    : changes += keyword; prop.toggle( keyword          ); break;

    case  t_data.SQUEEZE_CYCLE   : changes += keyword; cycle_parent_classList(onWork_EL, t_data.SQUEEZE_CYCLE_CLASSLIST); break;

    default               :

    {
        let keyword_array = get_words_drop_affix_array();
        for(let i=0; i < keyword_array.length; ++i)
        {
            let id        = keyword_array[i];
            if( id       == keyword) {
                changes  += keyword;
                prop.toggle(keyword);
                break;
            }
        }
    }

    if(!changes) log("%c "+caller+" %c "+keyword+" %c *** not handled ***", lbH+lf4, lbb+lbL+lf2, lbb+lbR+lf2);
    }

    if(changes) {
if(log_this) t_log_option_changes(changes);
        t_fly.t_log_transcript_info("<em class='cc8'>"+caller+"</em> changes:<br><em class='cc9'> "+changes+" </em>");
    }
    else {
        t_fly.t_log_transcript_info("<em class='cc8'>"+caller+"</em> changes <em class='cc0'>none</em>");
    }



    if(         changes.includes( t_data.OVERFLOW_VISI  )
            ||  changes.includes( t_data.DETAILS_RADIO  )
            ||  changes.includes( t_data.SCROLL_SMOOTH  )
            ||  changes.includes( t_data.PIN_SEEKSPOT   )
      ) {
        t_tools_save_all_settings();
    }
    else {

        if(     changes.includes( t_data.ANCHOR_FREEZE  )
            ||  changes.includes( t_data.CONTAINERS_HI  )
            ||  changes.includes( t_data.THEME_DARK     )
            ||  changes.includes( t_data.TOOLS_TRAP     )
            ||  changes.includes( t_data.TOOLS_TIER2    )
          ) {
            save2_theme();
        }

        if(     changes.includes( t_data.WORDING        )
            ||  changes.includes( t_data.WORDS_EXACT    )
            ||  changes.includes( t_data.WORDS_SEGMENT  )
            ||  changes.includes( t_data.WORDS_HEAD_TAIL)
            ||  changes.includes( t_data.WORDS_OPCYCLE  )
            ||  get_words_drop_affix_array().includes(changes)
          ) {
            save5_wording();
        }
    }


    if( prop.get( t_data.SHOW_SEEKZONE ))
    {
        if(     changes.includes( t_data.LOG_SEEKSPOT   )
            ||  changes.includes( t_data.SITE_OR_PAGE   )
            ||  changes.includes( t_data.PIN_SEEKSPOT   )
            ||  changes.includes( t_data.SHOW_SEEKZONE  )
          ) {
            t_seek.t_seeker_show(caller);
            t_seek.t_seeker_sync_SEL_BACK(caller);
        }
    }


    if(         changes.includes( t_data.CONTAINERS_HI  )
           ||   changes.includes( t_data.THEME_DARK     )
           ||   changes.includes("theme_DARK"           )
           ||   changes.includes("theme_LIGHT"          )
      ) {
        t_select.t_sync_containers_hi();
        t_sentence.t_SENTENCE_restore_text_containers_outlined();

    }


    if(         changes.includes( t_data.ANCHOR_FREEZE  )
           ||   changes.includes( t_data.THEME_DARK     )
           ||   changes.includes( t_data.WORDING        )
           ||   changes.includes( t_data.CONTAINERS_HI  )
           ||   changes.includes("theme_DARK"           )
           ||   changes.includes("theme_LIGHT"          )
      )
        t_sync_wording(caller);

    if(words_filter_input && words_filter_input.value)
    {
        if     (changes.includes( t_data.WORDS_EXACT    ) ) t_wording_3_CB(null, t_data.WORDS_EXACT    );
        else if(changes.includes( t_data.WORDS_HEAD_TAIL) ) t_wording_3_CB(null, t_data.WORDS_HEAD_TAIL);
        else if(changes.includes( t_data.WORDS_SEGMENT  ) ) t_wording_3_CB(null, t_data.WORDS_SEGMENT  );
        else if(changes.includes( t_data.WORDS_DROP_CASE) ) t_wording_3_CB(null, t_data.WORDS_DROP_CASE);
        else if(changes.includes( t_data.WORDS_DROP_ING ) ) t_wording_3_CB(null, t_data.WORDS_DROP_ING );
        else if(changes.includes( t_data.WORDS_DROP_S   ) ) t_wording_3_CB(null, t_data.WORDS_DROP_S   );
    }
    else if( log_this) logBIG("NO PATTERN TO RE-SELECT");


    if(         changes.includes( t_data.TOOLS_SCROLL   ) ) t_sync_TOOLS_SCROLL();
    if(         changes.includes( t_data.TOOLS_SCROLL   )) save4_layout(t_data.TOOLS_SCROLL);



    if(         changes.includes( t_data.TOOLS_TIER2    ) ) t_sync_tools_tier2 (caller);



    t_tools_sync_top_xy();



    t_sync_styles( caller );



    t_sync_tool_clones_state( caller );



    t_save_update_post("PROP TOGGLED ["+keyword+"]");
};


let   cycle_parent_classList = function(el, classList)
{
    let el_parent;
    for(let i=0; i < classList.length ; ++i)
    {
        if(el_parent = t_util.get_el_parent_with_class(el, classList[i]))
        {
            t_util.cycle_el_classList(el_parent, classList);
            return;
        }
    }
};




let t_orient_listener = function(e)
{
    if(!hotspot) return;

    t_layout_changed();

};


let t_resize_listener = function(e)
{
    if(!hotspot) return;

    t_layout_changed();

    dom_scroll.scroll_listener_scroll_changed(e);
};



let LAYOUT_CHANGED_DELAY = 200;
let layout_changed_timer;


let t_layout_changed = function(delay=LAYOUT_CHANGED_DELAY)
{
    let caller = "t_layout_changed";

if(LOG_MAP.EV7_DISPATCH && !layout_changed_timer) t_fly.t_log_event_status(caller);

    if(!dom_tools_html || (dom_tools_html.style.visibility == t_data.CSS_HIDDEN))
    {

        return;
    }


    if(layout_changed_timer )   clearTimeout(layout_changed_timer);
    layout_changed_timer    =   null;

    if(!delay)                               layout_changed_handler(        window.event);
    else layout_changed_timer = setTimeout  (layout_changed_handler, delay, window.event);
};


let layout_changed_handler = function(e)
{

let   caller = "layout_changed_handler";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+ caller, lbH+lf3);

    layout_changed_timer = null;

    t_cache_wph_WH();



    if( has_el_class(tools_map[0], t_data.CSS_ON_GRID) )
    {
if(log_this) log("%c"+caller+" ["+get_n_lbl(tools_map[0])+"] "+t_data.CSS_ON_GRID, lbb+lbH+lf7);

if(log_this) log_caller();
        return;
    }


    if(window.matchMedia("only screen and (min-resolution : 128dpi)").matches != behavior_TOUCH_ELSE_DESKTOP)
        document.location.reload();




    t_outline_clear();

    t_update_TOOLS_MAP_GEOMETRY(caller,0);

    t_cache_armed_by(caller);

    t_cache_sync("Layout changed");


    if(     call_t_grid_IS_SIZED() )
    {
        if(has_el_class(dimm_mask, "dimm_sticky"))
            t_sticky.t_sticky_RING_stop(caller);

        dimm_start_grid(caller);
    }


    else if(div_slot_containers_displayed())
    {
        div_slot_containers.style.minHeight = window.innerHeight+"px";

        dom_scroll.t_scrollIntoView_EL_reset();

        dom_scroll.t_scroll_div_slot_containers_in_viewport();
    }


    else if(dimm_mask_displayed() && has_el_class(dimm_mask, "dimm_sticky"))
    {
        t_sticky.t_sticky_RING_layout();

    }


    if( dimm_mask_displayed() ) dimm_start();



    t_sync_layout(caller);

    t_fly.t_fly_onlayout(caller);

    t_body_width_show();
    t_body_zoom_show();
    t_body_font_size_show();

    t_tools_set_top_xy(h_x, h_y);

    if(!call_t_grid_IS_ON_GRID(caller) )
        t_TOOL_SET_eval_wide_or_tall_panel(caller);



    t_sticky.t_sticky_SET_DIMMED(false, "LAYOUT");

    t_sticky.t_sticky_onLayout();


    t_sentence.t_SENTENCE_onresize(e);
};




let t_get_consumed_by_table = function()
{
    return "<table>"
        + "<tr><td class='cc1'>"+t_data.SYMBOL_BULB+ " DOWN  </td><td>"+ t_util.ellipsis(mousedown_consumed_by      , 56)+"</td></tr>"
        + "<tr><td class='cc2'>"+t_data.SYMBOL_BULB+ " MOVE  </td><td>"+ t_util.ellipsis(mousemove_consumed_by      , 56)+"</td></tr>"
        + "<tr><td class='cc3'>"+t_data.SYMBOL_BULB+ " PRESS </td><td>"+ t_util.ellipsis(mouselong_press_consumed_by, 56)+"</td></tr>"
        + "<tr><td class='cc4'>"+t_data.SYMBOL_BULB+ " UP    </td><td>"+ t_util.ellipsis(mouseup_consumed_by        , 56)+"</td></tr>"
        + "</table>"
    ;
};












let log_dom_grid_js_not_loaded = function (_caller)
{
logXXX("%c *** dom_grid.js NOT LOADED *** .. CALLED BY "+ _caller, lbH+lf3);
console.trace();
};


let t_log_TOOL_panels = function(_caller, lfx=lf8)
{
log("%c"+_caller+":", lbb+lbH+lfx);
    let s = "";
    for(let i=0; i < TOOL_panels.length; ++i)
        s += LF+i+"."+t_util.get_id_or_tag(TOOL_panels[i]);
log(s);
};


let t_log_panel_style_zIndex = function(panel, _caller)
{

if(!t_log_panel_style_zIndex.logged_once)
{
    log("%c t_data.ZINDEX_ON_GRID............%c"+ t_data.ZINDEX_ON_GRID          , lbH+lf8, lbb+lf4);
    log("%c t_data.ZINDEX_ABOVE_TOOLS........%c"+ t_data.ZINDEX_ABOVE_TOOLS      , lbH+lf8, lbb+lf4);
    log("%c t_data.ZINDEX_BELOW_TOOLS........%c"+ t_data.ZINDEX_BELOW_TOOLS      , lbH+lf8, lbb+lf3);
    log("%c t_data.ZINDEX_TOOL_PANEL_ZERO....%c"+ t_data.ZINDEX_TOOL_PANEL_ZERO  , lbH+lf8, lbb+lf3);
    log("%c t_data.ZINDEX_PINNED_PANEL_ZERO..%c"+ t_data.ZINDEX_PINNED_PANEL_ZERO, lbH+lf8, lbb+lf2);
    log("%c t_data.ZINDEX_STICKY_TOOL_ZERO...%c"+ t_data.ZINDEX_STICKY_TOOL_ZERO , lbH+lf8, lbb+lf1);

    t_log_panel_style_zIndex.logged_once = true;
}


 let label  = " TOOL";      let lfx = lf3;

    if( panel == pivot_PANEL                        ) { label += " [pivot_PANEL]"   ; lfx = lf7; }
    if( panel.classList.contains( CSS_PIVOT_PANEL ) ) { label += " "+CSS_PIVOT_PANEL; lfx = lf7; }
    if( panel.classList.contains( t_data.CSS_PINNED      ) ) { label += " "+t_data.CSS_PINNED     ; lfx = lf2; }
    if( panel.classList.contains( t_data.CSS_ON_GRID     ) ) { label += " "+t_data.CSS_ON_GRID    ; lfx = lf5; }

log("%c"+_caller+"%c "+label+"%c "+panel.id+".style.zIndex %c"+panel.style.zIndex
    ,lbH         ,lbL+lf8    ,lbR+lfx                     ,lbH+lfx               );
};




let t_sync_TOOLS_SCROLL = function()
{
let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T2_GRID;

    let caller = "t_sync_TOOLS_SCROLL";

    let position =  prop.get( t_data.TOOLS_SCROLL )  ? "absolute" : "fixed";
if(log_this) log(caller+"...t_data.TOOLS_SCROLL=[%c "+prop.get( t_data.TOOLS_SCROLL )+" %c]", lb6,lbA);
if(log_this) log(caller+"...position....=[%c "+position    +" %c]", lb5,lbA);

    let position_has_changed = (hotspot.style.position != position);
    if( position_has_changed)
    {
        t_cache_armed_by(caller);
        t_cache_sync("t_data.TOOLS_SCROLL "+prop.get( t_data.TOOLS_SCROLL ));

        t_sync_tools_position(caller, position_has_changed);

        t_sync_layout(caller);
    }
};


let t_sync_tools_position = function(_caller)
{

    let log_this = LOG_MAP.EV2_MOVE || LOG_MAP.T2_GRID;
if(log_this) log("t_sync_tools_position .. CALLED BY "+ _caller);

    let position =  prop.get( t_data.TOOLS_SCROLL ) ? "absolute" : "fixed";
if(log_this) log("...FROM position=["+hotspot.style.position+"]");
if(log_this) log(".....TO position=["+              position+"]");



    let x  = h_x;
    let y  = h_y;

    if(position == "fixed") {
        x -= window.scrollX;
        y -= window.scrollY;
    }
    else {
        x += window.scrollX;
        y += window.scrollY;
    }


    t_tools_set_top_xy(x, y, position);
};



const START_WITH_FIRST = 0;
const START_WITH_LAST  = 1;


let t_get_TOOL_panel_idx_not_pinned_first= function() { return t_get_TOOL_panel_idx_not_pinned(START_WITH_FIRST); };
let t_get_TOOL_panel_idx_not_pinned_last = function() { return t_get_TOOL_panel_idx_not_pinned(START_WITH_LAST ); };

let t_get_TOOL_panel_idx_not_pinned      = function(first_or_last)
{

let caller   = (first_or_last == START_WITH_FIRST) ? "t_get_TOOL_panel_idx_not_pinned_first" : "t_get_TOOL_panel_idx_not_pinned_last";
let log_this = LOG_MAP.T5_SPREAD;


    let panel_idx = 0;

    let from = (first_or_last == START_WITH_FIRST) ? 1 : (TOOL_panels.length-1);
    let to   = (first_or_last != START_WITH_FIRST) ? 0 : (TOOL_panels.length  );
    let step = (first_or_last == START_WITH_FIRST) ? 1 :                    -1 ;
if( log_this) log("%c"+caller+"%c from "+from+" %c to "+to+" %c step "+step, lbH, lbL+lf5, lbR+lf6, lbH+lf8);
    for(let i = from; i != to; i += step)
    {
        let                    panel = TOOL_panels[i];      if(!panel                ) { if( log_this) log("%c...#"+i+" "+          "!panel"        , lfX[i % 0]); continue; }
        if( panel.classList.contains ( t_data.CSS_PINNED )                           ) { if( log_this) log("%c...#"+i+" "+ panel.id+" pinned"       , lfX[i % 0]); continue; }

        if(!t_tools_panel_is_selected( panel                                        )) { if( log_this) log("%c...#"+i+" "+ panel.id+" NOT SELECTED" , lfX[i % 0]); continue; }
        if(!panel_idx) panel_idx = i;                                                    if(!log_this) break;
    }
if( log_this) log("%c...return panel_idx #"+ panel_idx+" ["+ t_util.get_id_or_tag(  TOOL_panels[panel_idx] ) +"]", lbH+lfX[panel_idx % 10]);
    return panel_idx;
};


let t_get_hotspot_dist_next_panel_idx = function(moving_panel)
{

let caller   = "t_get_hotspot_dist_next_panel_idx";
let log_this = LOG_MAP.T5_SPREAD;


    let mov_idx   = 0;
    let next_idx  = 0;
    let mov_dist  = t_get_dist_from_panel_to_panel(TOOL_panels[0], moving_panel);
if( log_this) log("%c"+caller+"%c"+moving_panel.id+"%c"+mov_dist, lbH,lbH,lbH);

    let from = 1;
    let to   = TOOL_panels.length;
    let step = 1;

    let far_dist = 0;
    let far_idx  = 0;
    for(let i = from; i != to; i += step)
    {
        let next_panel  = TOOL_panels[i];     if(!next_panel                           )                continue;
        if( next_panel == moving_panel                                                 ) { mov_idx = i; continue; }
        if( next_panel.classList.contains(t_data.CSS_PINNED)                           )                continue;

        if(!t_tools_panel_is_selected(            next_panel)                          )                continue;


        let            dist_to_hotspot = t_get_dist_from_panel_to_panel(TOOL_panels[0], next_panel);
        if( far_dist < dist_to_hotspot) {
            far_dist = dist_to_hotspot;
            far_idx = i;
        }


        if( mov_dist < dist_to_hotspot) {
            next_idx
                = (mov_idx == 0)
                ?  i
                :  i-1
            ;
            break;
        }
    }
    if(!next_idx)
        next_idx = far_idx + 1;
if( log_this)
    log_key_val_group( caller
                       , {   mov_panel : "#"+mov_idx+" "+        moving_panel.id+" dist "+ mov_dist
                           , far_panel : "#"+far_idx+" "+TOOL_panels[far_idx].id+" dist "+ far_dist
                           ,  next_idx
                       }, lf5, false);

if( log_this)
    log("%c"+caller+"%c...return next_idx #"+ next_idx+"%c"+ TOOL_panels[next_idx].id, lbH, lbH, lbH);
    return next_idx;
};


let t_get_dist_from_panel_to_panel = function(from_panel, to_panel)
{
    let from_x = from_panel.offsetLeft + from_panel.offsetWidth  / 2;
    let from_y = from_panel.offsetTop  + from_panel.offsetHeight / 2;

    let   to_x =   to_panel.offsetLeft +   to_panel.offsetWidth  / 2;
    let   to_y =   to_panel.offsetTop  +   to_panel.offsetHeight / 2;

    let     dx =                from_x - to_x;
    let     dy =                from_y - to_y;

    let   dist = Math.round( Math.sqrt(dx*dx + dy*dy) );


    return dist;
};





let t_eval_wide_or_tall_panel = function(tool_panel)
{

    if(!tool_panel.offsetWidth || !tool_panel.offsetHeight) return;


    if(   !t_util.get_el_child_with_class(tool_panel, CSS_PUSH_PIN  )
       && !t_util.get_el_child_with_class(tool_panel, CSS_CLOSEPIN  )
       && !t_util.get_el_child_with_class(tool_panel, CSS_SCALEPIN  )
       && !t_util.get_el_child_with_class(tool_panel, CSS_CLEARPIN  )
      ) {
        del_el_class(tool_panel,                      CSS_WIDE_PANEL);
        del_el_class(tool_panel,                      CSS_TALL_PANEL);
    }

    else {


        if(tool_panel.offsetWidth   > tool_panel.offsetHeight) {
            if(!has_el_class(         tool_panel,     CSS_WIDE_PANEL)) {
                set_el_class_removing(tool_panel,     CSS_WIDE_PANEL, [CSS_TALL_PANEL]);
            }
        }

        else {
            if(!has_el_class(         tool_panel,     CSS_TALL_PANEL)) {
                set_el_class_removing(tool_panel,     CSS_TALL_PANEL, [CSS_WIDE_PANEL]);
            }
        }
    }

    if(tool_panel == pat_bag) t_pat_bag_open_or_close_layout();
};


let t_add_toolpins_on_panel = function(panel)
{
    t_add_push_pin_on_panel( panel );
    t_add_closepin_on_panel( panel );
    t_add_scalepin_on_panel( panel );
    if(      (panel.id == "transcript1")
          || (panel.id == "transcript2")

      )
        t_add_clearpin_on_panel(panel);

    t_eval_wide_or_tall_panel(panel);
};


let t_add_push_pin_on_panel = function(tool_panel)
{

    let push_pin = t_util.get_el_child_with_class(tool_panel, CSS_PUSH_PIN);
    if( push_pin ) return;



    push_pin           = document.createElement("em");
    push_pin.className = "push_pin cc8";
    push_pin.id        = tool_panel.id +"_push_pin";
    push_pin.innerHTML = t_data.SYMBOL_PUSH_PIN;

    t_util.set_el_caption(push_pin);


    tool_panel.insertBefore(push_pin, tool_panel.firstElementChild);

    add_el_class(tool_panel, CSS_PIN_ON_PANEL);

};


let t_add_closepin_on_panel = function(tool_panel)
{

    t_fly.t_fly_cancel_fading();



    let closepin = t_util.get_el_child_with_class(tool_panel, CSS_CLOSEPIN);
    if( closepin ) return;



    closepin           = document.createElement("em");
    closepin.className = "closepin";
    closepin.id        = tool_panel.id +"_closepin";
    closepin.innerHTML = t_data.SYMBOL_CLOSEPIN;

    t_util.set_el_caption(closepin);


    let     prevpin;
    if(     prevpin = t_util.get_el_child_with_class(tool_panel, CSS_PUSH_PIN)) tool_panel.insertBefore(closepin, prevpin.nextElementSibling);
    else {  prevpin = tool_panel.firstElementChild;                      tool_panel.insertBefore(closepin, prevpin                   ); }

    add_el_class(tool_panel, CSS_PIN_ON_PANEL);

};


let t_add_scalepin_on_panel = function(tool_panel)
{

    let scalepin = t_util.get_el_child_with_class(tool_panel, CSS_SCALEPIN);
    if( scalepin ) return;



    scalepin             = document.createElement("em");
    scalepin.className   = CSS_SCALEPIN;
    scalepin.id          = tool_panel.id +"_scalepin";

    t_util.set_el_caption(scalepin);


    let     prevpin;
    if     (prevpin = t_util.get_el_child_with_class(tool_panel, CSS_CLOSEPIN)) tool_panel.insertBefore(scalepin, prevpin.nextElementSibling);
    else if(prevpin = t_util.get_el_child_with_class(tool_panel, CSS_PUSH_PIN)) tool_panel.insertBefore(scalepin, prevpin.nextElementSibling);
    else {  prevpin = tool_panel.firstElementChild;                             tool_panel.insertBefore(scalepin, prevpin                   ); }

    add_el_class(tool_panel, CSS_PIN_ON_PANEL);

};


let t_add_clearpin_on_panel = function(tool_panel)
{

    let clearpin = t_util.get_el_child_with_class(tool_panel, CSS_CLEARPIN);
    if( clearpin ) return;



    clearpin           = document.createElement("em");
    clearpin.className = "clearpin";
    clearpin.id        = tool_panel.id +"_clearpin";

    clearpin.innerHTML = t_data.SYMBOL_RECYCLE;

    t_util.set_el_caption(clearpin);
    tool_panel.insertBefore(clearpin, tool_panel.firstElementChild);


    let     prevpin;
    if     (prevpin = t_util.get_el_child_with_class(tool_panel, CSS_SCALEPIN)) tool_panel.insertBefore(clearpin, prevpin.nextElementSibling);
    else if(prevpin = t_util.get_el_child_with_class(tool_panel, CSS_CLOSEPIN)) tool_panel.insertBefore(clearpin, prevpin.nextElementSibling);
    else if(prevpin = t_util.get_el_child_with_class(tool_panel, CSS_PUSH_PIN)) tool_panel.insertBefore(clearpin, prevpin.nextElementSibling);
    else {  prevpin = tool_panel.firstElementChild;                             tool_panel.insertBefore(clearpin, prevpin                   ); }

    add_el_class(tool_panel, CSS_PIN_ON_PANEL);

};


let t_has_push_pin_on_panel = function(tool_panel) { return t_has_pinclass_on_panel(tool_panel, CSS_PUSH_PIN); };
let t_has_closepin_on_panel = function(tool_panel) { return t_has_pinclass_on_panel(tool_panel, CSS_CLOSEPIN); };
let t_has_scalepin_on_panel = function(tool_panel) { return t_has_pinclass_on_panel(tool_panel, CSS_SCALEPIN); };
let t_has_clearpin_on_panel = function(tool_panel) { return t_has_pinclass_on_panel(tool_panel, CSS_CLEARPIN); };
let t_has_pinclass_on_panel = function(tool_panel, pin_class)
{
    return (t_util.get_el_child_with_class(tool_panel, pin_class) != null);
};



let t_del_push_pin_on_panel = function(tool_panel) { t_del_pin_css_on_panel(tool_panel, CSS_PUSH_PIN); };
let t_del_closepin_on_panel = function(tool_panel) { t_del_pin_css_on_panel(tool_panel, CSS_CLOSEPIN); };
let t_del_scalepin_on_panel = function(tool_panel) { t_del_pin_css_on_panel(tool_panel, CSS_SCALEPIN); };
let t_del_clearpin_on_panel = function(tool_panel) { t_del_pin_css_on_panel(tool_panel, CSS_CLEARPIN); };
let t_del_toolpins_on_panel = function(tool_panel) { t_del_pin_css_on_panel(tool_panel, CSS_PUSH_PIN);
                                                     t_del_pin_css_on_panel(tool_panel, CSS_CLOSEPIN);
                                                     t_del_pin_css_on_panel(tool_panel, CSS_SCALEPIN);
                                                     t_del_pin_css_on_panel(tool_panel, CSS_CLEARPIN); };

let t_del_pin_css_on_panel = function(tool_panel, pin_class)
{
    let el = t_util.get_el_child_with_class(tool_panel, pin_class);
    if(!el )   return;

    tool_panel.removeChild( el );

    del_el_class(tool_panel, CSS_PIN_ON_PANEL);
    del_el_class(tool_panel, CSS_WIDE_PANEL  );
    del_el_class(tool_panel, CSS_TALL_PANEL  );
};


let t_click_panel_pin_CB = function(panel, pin)
{

    let caller = "t_click_panel_pin_CB";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c"+caller+"%c"+get_n_lbl(panel)+"%c"+get_n_lbl(pin)+"])"
        ,          lbL+lf5    ,lbC+lf3              ,lbR+lf4                );

 let action;
    if     ( panel.id == "fly_div"            ) { action = "FLY CLOSE PIN"   ; t_fly.t_fly_init    ( action      ); }
    else if( has_el_class(pin , CSS_CLOSEPIN) ) { action = "PANEL UNSELECTED"; t_tools_panel_select( panel, false); }
    else if( has_el_class(pin , CSS_CLEARPIN) ) { action = "PANEL CLEARED"   ; t_clear             ( action      ); }
    else if( has_el_class(pin , CSS_PUSH_PIN) ) { action = "PANEL "+(has_el_class(onWork_PANEL, t_data.CSS_PINNED) ?    "PINNED" : "UNPINNED" );                                          }
    else if( has_el_class(pin , CSS_SCALEPIN) ) { action = "PANEL "+(has_el_class(onWork_PANEL, CSS_MAGNIFIED    ) ? "MAGNIFIED" : "SCALE 1:1"); t_toggle_onWork_PANEL_magnified(action); }

if(log_this && action) log("t_click_panel_pin_CB %c"+action, lbH+lf5);
};


let t_clear_panel_pined_innerHTML = function(panel)
{


    let push_pin = t_util.get_el_child_with_class(panel, CSS_PUSH_PIN); if( push_pin ) panel.removeChild(push_pin);
    let closepin = t_util.get_el_child_with_class(panel, CSS_CLOSEPIN); if( closepin ) panel.removeChild(closepin);
    let scalepin = t_util.get_el_child_with_class(panel, CSS_SCALEPIN); if( scalepin ) panel.removeChild(scalepin);
    let clearpin = t_util.get_el_child_with_class(panel, CSS_CLEARPIN); if( clearpin ) panel.removeChild(clearpin);

    panel.innerHTML = "";

    if( clearpin ) panel.insertBefore(clearpin, panel.firstElementChild);
    if( scalepin ) panel.insertBefore(scalepin, panel.firstElementChild);
    if( closepin ) panel.insertBefore(closepin, panel.firstElementChild);
    if( push_pin ) panel.insertBefore(push_pin, panel.firstElementChild);
};


let t_isa_panel_pin = function(pin)
{
    return has_el_class(pin , CSS_CLOSEPIN)
        || has_el_class(pin , CSS_CLEARPIN)
        || has_el_class(pin , CSS_PUSH_PIN)
        || has_el_class(pin , CSS_SCALEPIN)
    ;
};




let t_cycle_pivot_panel = function()
{

let caller   = "t_cycle_pivot_panel";
let log_this = LOG_MAP.T5_SPREAD;

if( log_this ) log(caller);


if( log_this) log("...pivot_PANEL=["+ t_util.get_id_or_tag(pivot_PANEL) +"]");
    if( !pivot_PANEL) return;



    let next_visible_panel; let  next_visible_panel_idx;
 let         pivot_PANEL_idx;
    for(let i=1; i < TOOL_panels.length; ++i)
    {

        let panel = TOOL_panels[i];
        if(!panel                               ) continue;
        if( panel.classList.contains(t_data.CSS_PINNED)) continue;



        if(!t_tools_panel_is_selected(panel)) continue;

        if(!next_visible_panel && pivot_PANEL_idx) {  next_visible_panel_idx = i;  next_visible_panel    = panel; }
        if(              panel == pivot_PANEL    ) {         pivot_PANEL_idx = i;                                 }

        if(  next_visible_panel ) break;
    }
if( log_this) log("..........pivot_PANEL #"+        pivot_PANEL_idx+" ["+ t_util.get_id_or_tag( pivot_PANEL         ) +"]");
if( log_this) log("...next_visible_panel #"+ next_visible_panel_idx+" ["+ t_util.get_id_or_tag(  next_visible_panel ) +"]");

    if( !next_visible_panel ) return;









if( log_this) t_log_TOOL_panels(caller);

        TOOL_panels[        pivot_PANEL_idx ] =  next_visible_panel;
        TOOL_panels[ next_visible_panel_idx ] =         pivot_PANEL;

if( log_this) t_log_TOOL_panels(caller, lf4);
};




const CACHE_NEVER_ARMED = "CACHE_NEVER_ARMED";
let w_W = 1280, w_H = 1024;
let p_W = 1280, p_H = 1024;
let h_W =   32, h_H =   32;
let hsR = { top:0 , left:0 , right:0 , bottom:0 };

let t_cache_armed_callers = CACHE_NEVER_ARMED;


let t_cache_wph_WH = function()
{
    w_H = Math.min(window.innerHeight, document.body.parentElement.clientHeight);
    w_W = Math.min(window.innerWidth , document.body.parentElement.clientWidth );

    p_H = document.body.parentElement.scrollHeight;
    p_W = document.body.parentElement.scrollWidth;

    let w_H_or_p_H
        = (!hotspot || (hotspot.style.position == "fixed"))
        ?  w_H
        :  p_H;

    hsR.top    = 0;
    hsR.left   = 0;
    hsR.right  = w_W        - t_data.SCROLLBAR_WIDTH;
    hsR.bottom = w_H_or_p_H - t_data.SCROLLBAR_WIDTH;

        t_gutter.layout_has_CHANGED(hsR, BOX_MARGIN);


    return { w_W , w_H
        ,    p_W , p_H
        ,    h_W , h_H
        ,    hsR
    };



};


let t_cache_armed_by = function(_caller)
{
    let log_this = LOG_MAP.EV5_TOOL_CB;

    t_cache_armed_callers
        = (t_cache_armed_callers)
        ?  t_cache_armed_callers+LF+ _caller
        :                              _caller
    ;

if(log_this) log("%c CACHE INIT BY "+ _caller, lbF+lb7);

};


let t_cache_has_been_armed = function(_caller)
{
    let log_this = LOG_MAP.EV5_TOOL_CB;

if(log_this) log("t_cache_has_been_armed: t_cache_armed_callers = %c "+t_cache_armed_callers+" %c", lbF+lb7,lbA);

    return (t_cache_armed_callers != CACHE_NEVER_ARMED);
};


let t_cache_armed = function(_caller)
{
    let log_this = LOG_MAP.EV5_TOOL_CB;

if(log_this) log("t_cache_armed: %c CALLED BY "+ _caller    , lbF+lb7);
if(log_this) log("%c t_cache_armed_callers:%c"+LF+t_cache_armed_callers, lb7, lf7);

    return (t_cache_armed_callers != "");
};


let t_cache_sync = function(_caller)
{

let log_this = LOG_MAP.EV5_TOOL_CB;


if(log_this) log("%c t_cache_sync .. CALLED BY "+ _caller,lbF+lb5);
if(log_this) log("%c t_cache_armed_callers:%c"+LF+t_cache_armed_callers, lb5, lf5);


    if(hotring) {
        h_W = hotring.offsetWidth ;
        h_H = hotring.offsetHeight;

if(log_this) log("...HOTSPOT %c "+ h_W+" x "+h_H +" ", lb7);
    }


    t_update_TOOLS_MAP_GEOMETRY("t_cache_sync .. CALLED BY "+ _caller);



    t_cache_armed_callers = "";
};


let   is_el_off_screen = function(el)
{
    let caller = "is_el_off_screen(el=["+get_n_lbl(el)+"])";
    if(LOG_MAP.T3_LAYOUT) log(caller);


    let   xy = t_util.get_el_xy(el, caller);
    let el_T = xy.y - window.scrollY;
    let el_L = xy.x - window.scrollX;
    let el_W = el.offsetWidth;
    let el_H = el.offsetHeight;


    let el_B = el_T + el_H;
    let el_R = el_L + el_W;


    let reject_reason = "";

    if(                  (el_T < 0   )) reject_reason = "["+get_n_lbl(el)+"] IS OFF TOP"   ;
    if(!reject_reason && (el_L < 0   )) reject_reason = "["+get_n_lbl(el)+"] IS OFF LEFT"  ;
    if(!reject_reason && (el_B > w_H )) reject_reason = "["+get_n_lbl(el)+"] IS OFF BOTTOM";
    if(!reject_reason && (el_R > w_W )) reject_reason = "["+get_n_lbl(el)+"] IS OFF RIGHT" ;

    let result = (reject_reason != "");

if(LOG_MAP.EV0_LISTEN) log(caller+": ...return "+result+" %c "+reject_reason,lb2);
    return result;
};




let t_tools_sync_top_xy = function()
{
    t_tools_set_top_xy(h_x, h_y);
};



const BOX_MARGIN   =  24;
let   hotspotXY    = { x:0 , y:0 , gutter_urdl:undefined};

let t_tools_set_top_xy = function(x, y, p)
{

    let caller = "t_tools_set_top_xy";
let log_this = LOG_MAP.T5_SPREAD;

if( log_this) t_fly.t_log_event_status(caller+"("+x+" "+y+ ((p) ? (" p=["+p+"]") : "") +")", lf2);

    if(!hotspot) return;


    if( call_t_grid_IS_ON_GRID(caller) )
    {
if(log_this) log(caller+"("+x+" , "+y+"): IS ON GRID");

        return;
    }

    t_tools_set_hotspot_xy(x, y);

    let regrouping_a_pinned_panel
        = onDown_EL && onDown_EL.classList .contains( CSS_PUSH_PIN )
    ;
    let hiding_tools
        =   !regrouping_a_pinned_panel
        && (!!hotspotXY.gutter_urdl || prop.get(t_data.EDIT_OR_STAGE))
    ;

if(log_this) {
    t_log.log_label_URDL(".................hotspotXY.gutter_urdl"  ,                    hotspotXY.gutter_urdl              );
    log(".........................................hiding_tools=["+                      hiding_tools                   +"]");
    log(".......................prop.get(t_data.EDIT_OR_STAGE)=["+ prop.get(     t_data.EDIT_OR_STAGE                ) +"]");
    log("...has_el_class(headsup_ds, t_data.CSS_PINNED)=["+ has_el_class( headsup_ds, t_data.CSS_PINNED) +"]");
}


    if(p && (p != hotspot.style.position))
    {
        hotspot              .style.position = p;

        headsup              .style.position = p;
        headsup_w            .style.position = p;
        headsup_ds           .style.position = p;
        headsup_bw           .style.position = p;
        headsup_bz           .style.position = p;
        headsup_fs           .style.position = p;

        pat_bag              .style.position = p;
        sel_bag              .style.position = p;
        dom_traversal        .style.position = p;

        test_panel           .style.position = p;
        dev_log_map          .style.position = p;
        dom_load_tags        .style.position = p;


        if(!transcript1.classList.contains(t_data.CSS_PINNED) ) transcript1.style.position = p;
        if(!transcript2.classList.contains(t_data.CSS_PINNED) ) transcript2.style.position = p;


        if(p != "fixed") {
            t_set_CSS_PINNED(hotspot      , true);

            t_set_CSS_PINNED(headsup      , true);
            t_set_CSS_PINNED(headsup_w    , true);
            t_set_CSS_PINNED(headsup_ds   , true);
            t_set_CSS_PINNED(headsup_bw   , true);
            t_set_CSS_PINNED(headsup_bz   , true);
            t_set_CSS_PINNED(headsup_fs   , true);

            t_set_CSS_PINNED(pat_bag      , true);
            t_set_CSS_PINNED(sel_bag      , true);

            t_set_CSS_PINNED(dom_traversal, true);
            t_set_CSS_PINNED(test_panel   , true);
            t_set_CSS_PINNED(dev_log_map  , true);
            t_set_CSS_PINNED(dom_load_tags, true);
        }


    }


    if( !hiding_tools ) {
        t_tools_spread_xy(x, y);

    }

    t_tools_set_top_xy_p_hiding_tools(x, y, p, hiding_tools, log_this);
};


let t_tools_hide = function()
{
let   caller = "t_tools_hide";
let log_this = LOG_MAP.T5_SPREAD;

    let xy = t_gutter.get_GUTTER_XY();
if( log_this) log(caller+": t_gutter.get_GUTTER_XY() .. xy=["+xy.x+" "+xy.y+"]");

    if(!xy.x && !xy.y) { xy.x = 0; xy.y = 0; }

    enter_CSS_SLOW_REGROUP("HIDING HOTSPOT");

    t_tools_set_top_xy(xy.x, xy.y);
};


let t_tools_show = function(centered)
{
let   caller = "t_tools_show";
let log_this = LOG_MAP.T5_SPREAD;

    let xy = t_gutter.get_WINDOW_XY();
if( log_this) log(caller+": t_gutter.get_WINDOW_XY() .. xy=["+xy.x+" "+xy.y+"]");

    if(centered || (!xy.x && !xy.y)) { xy.x = window.innerWidth  / 2; xy.y = window.innerHeight / 2; }

    enter_CSS_SLOW_REGROUP("SHOWING HOTSPOT");

    t_tools_set_top_xy(xy.x, xy.y);
};


let t_tools_set_top_xy_p_hiding_tools = function(x,y,p,hiding_tools,log_this)
{

let caller = "t_tools_set_top_xy_p_hiding_tools";

if( log_this) log(caller+"("+x+" "+y+" p "+hiding_tools+")");


    let x_sign = (x < pivotXY.x) ? 1 : -1;
    let y_sign = (y < pivotXY.y) ? 1 : -1;
    if( hiding_tools ) { x_sign *= -1; y_sign *= -1; }



    if(!t_tools_loaded) t_load_TOOLS_MAP(caller);

    let panels_on_stage = [];
    if(hiding_tools && prop.get( t_data.EDIT_OR_STAGE ) && has_el_class(headsup_ds, t_data.CSS_PINNED))
        panels_on_stage.push( headsup_ds );

if( log_this) log("...panels_on_stage=["+ get_n_lbl(panels_on_stage) +"]");


    for(let i=1; i < TOOL_panels.length; ++i)
    {

        let panel  = TOOL_panels[i];
        if(!panel) continue;

        let panel_is_pinned   = panel.classList.contains( t_data.CSS_PINNED );
        let panel_is_on_stage = panels_on_stage.includes( panel             );

        let      map = t_tools_map_get(panel);
        let selected = (map && map.selected) || t_tools_panel_is_selected(panel);



        if(hiding_tools && !panel_is_on_stage)
        {
            add_el_class(panel, t_data.CSS_HIDDEN);
        }


        else if( panel_is_pinned )
        {
            if(    selected ) del_el_class(panel, t_data.CSS_HIDDEN);
            else              add_el_class(panel, t_data.CSS_HIDDEN);
        }


        else {
            if(map) {

                if( p ) {
                    map.p = p;
                }


                if(!selected) {
                    add_el_class(panel, t_data.CSS_HIDDEN);
                }


                else {
                    del_el_class(panel, t_data.CSS_HIDDEN);

                    let w = map.w;
                    let h = map.h;
                    t_tools_set_panel_xy_wh(panel, map.x, map.y, w, h, x_sign, y_sign);

                    panel.style.zIndex
                        = (panel == pivot_PANEL)
                        ?  t_data.ZINDEX_ABOVE_TOOLS     - 1
                        :  t_data.ZINDEX_TOOL_PANEL_ZERO + i;
                }

            }
        }

    }


    let is_hiding_tools  = has_el_class(hotspot, CSS_HIDING_TOOLS);
    if( is_hiding_tools != hiding_tools)
    {

        set_el_class_on_off(hotspot, CSS_HIDING_TOOLS, hiding_tools);
    }



    t_trapped_dir_show(x, y);


};


let t_tools_set_panel_xy = function(panel, x, y)
{
    t_tools_set_panel_xy_wh(panel, x, y, panel.offsetWidth, panel.offsetHeight);
};






let t_tools_set_panel_xy_wh = function(panel, x, y, w, h, x_sign=1, y_sign=1)
{

let caller = "t_tools_set_panel_xy_wh("+get_n_lbl(panel)+", xy=["+x+" , "+y+"], w=["+w+" "+h+"])";
let log_this = LOG_MAP.T5_SPREAD;



    if(x_sign < 0) x -= w;
    if(y_sign < 0) y -= h;

    panel.style.left      = x+"px"  ;
    panel.style.top       = y+"px"  ;

    if(   (panel != hotspot)
       && (panel != pat_bag)
       && !panel.classList.contains( t_data.CSS_PINNED )
      ) {
        let t_x = (x_sign > 0) ? 0 : 100;
        let t_y = (y_sign > 0) ? 0 : 100;
        panel.style.transformOrigin = t_x+"% "+t_y+"% 0";
    }



    let touched_idx  = spreaded_tools.indexOf( onWork_PANEL );
    let this_el_idx  = spreaded_tools.indexOf( panel        );
    let this_el_rank = this_el_idx - touched_idx;



if(log_this) log(caller+": ...this_el_rank=["+this_el_rank+"] / "+spreaded_tools.length+" onWork_PANEL=["+ get_n_lbl(onWork_PANEL) +"]");

};




let h_x;
let h_y;


let t_tools_set_hotspot_xy = function(x,y)
{

let caller = "t_tools_set_hotspot_xy";
let log_this = LOG_MAP.T5_SPREAD;




    t_cache_wph_WH();

    x = Math.max(x , hsR.left   + BOX_MARGIN);
    x = Math.min(x , hsR.right  - BOX_MARGIN);
    y = Math.max(y , hsR.top    + BOX_MARGIN);
    y = Math.min(y , hsR.bottom - BOX_MARGIN);

    let hot_spot_has_moved
        =  (x != h_x)
        || (y != h_y);

    if(!hot_spot_has_moved) {
if(log_this) log(caller+"("+x+" "+y+"): UNCHANGED");

        return;
    }

if(log_this)
        log(caller+"("+x+" "+y+"):"+LF
           +"...hotspotXY FROM XY=["+ h_x  +" "+ h_y     +"]"+LF
           +"...............TO XY=["+   x  +" "+   y     +"]"   );



    h_x                = x;
    h_y                = y;
    hotspot.style.left = x +"px";
    hotspot.style.top  = y +"px";

    hotspotXY.gutter_urdl = t_gutter.get_XY_URDL(x, y, "MOVING HOTSPOT");
    t_gutter.set_CSS_URDL(hotring, hotspotXY.gutter_urdl);



    if(    !save_update_is_pending()
        && !prop.get( t_data.EDIT_OR_STAGE   )
      ) {
if(log_this) log_key_val_group("MOVING hotspotXY", hotspotXY, lf4, true);

        t_save_update_post(caller, PENDING_LOCALSTORAGE_DELAY);
    }

};




const HOTSPOT_HIDE_SHOW_DELAY = 1000;


let t_hide_hotspot = function(delay)
{
    if(delay === undefined) delay = HOTSPOT_HIDE_SHOW_DELAY;

    let x = HOTSPOT_STANDBY_X;
    let y = HOTSPOT_STANDBY_Y;


    if(delay) t_drag_hotspot_xy_delay(x, y, delay);
    else      t_tools_set_top_xy(x,y);


    add_el_class(dom_tools_html, t_data.CSS_PRESSED);
    t_raise_pivot_PANEL_layout("t_hide_hotspot");


    hotspotXY.x           = 0;
    hotspotXY.y           = 0;
    hotspotXY.gutter_urdl = null;
    t_store.t_store_set_value("hotspotXY", JSON.stringify(hotspotXY));
};


let t_show_hotspot = function(delay=HOTSPOT_HIDE_SHOW_DELAY)
{

    t_drag_hotspot_xy_delay(hotspotXY.x, hotspotXY.y, delay);


    add_el_class(dom_tools_html, t_data.CSS_PRESSED);
    t_raise_pivot_PANEL_layout("t_show_hotspot");
};


let t_drag_hotspot_xy_delay = function(x,y,delay)
{

let   caller = "t_drag_hotspot_xy_delay";
let log_this = DOM_TOOLS_LOG;

let tag_this = DOM_TOOLS_TAG || log_this;
if( log_this) log("%c "+caller+"("+x+" , "+y+")", lf1);


    if( hotspot.drag_hotspot_request ) drag_HOTSPOT_cancel();

    let requestID = requestAnimationFrame( drag_HOTSPOT_AnimationFrame );
    let time_from = new Date().getTime();
    let    x_from = hotspot.offsetLeft;
    let    y_from = hotspot.offsetTop;

    hotspot.drag_hotspot_request
        = {   x_to      : x
            , y_to      : y
            , delay
            , x_from
            , y_from
            , time_from
            , requestID
        };
if( log_this) log(hotspot.drag_hotspot_request);

if( tag_this) log_key_val(caller, hotspot.drag_hotspot_request, lb1);
};


let   drag_HOTSPOT_cancel = function()
{
    if(!hotspot.drag_hotspot_request) return;

    if(hotspot.drag_hotspot_request.requestID)
        cancelAnimationFrame( hotspot.drag_hotspot_request.requestID );

    delete hotspot.drag_hotspot_request;
};


let   drag_HOTSPOT_AnimationFrame = function(timestamp)
{

    if(!hotspot.drag_hotspot_request)
        return;


    if( drag_HOTSPOT_XY() ) hotspot.drag_hotspot_request.requestID = requestAnimationFrame( drag_HOTSPOT_AnimationFrame );
    else             delete hotspot.drag_hotspot_request;

};


let   drag_HOTSPOT_XY = function()
{

let   caller = "drag_HOTSPOT_XY";
let log_this = DOM_TOOLS_LOG;



    let drag_req = hotspot.drag_hotspot_request;
    let       dx = drag_req.x_to - drag_req.x_from;
    let       dy = drag_req.y_to - drag_req.y_from;


    let time_now = new Date().getTime();
    let       dt = time_now - drag_req.time_from;
    let    ratio = Math.min(1, dt / ((drag_req.delay > dt) ? drag_req.delay : 1));


    if(ratio <= 1)
    {
        let x    = drag_req.x_from + dx * ratio;
        let y    = drag_req.y_from + dy * ratio;

        t_tools_set_top_xy(x,y);
    }

if(log_this)
    log_key_val(caller
                , {   X         : dx+" ← "+ (dx * ratio)
                    , Y         : dy+" ← "+ (dy * ratio)
                    , T         : dt+" ← "+ (dt * ratio)+" ms"
                    , ratio     : ratio.toFixed(1)
                }, lf2, true);

    return (ratio < 1);
};





let fully_spread_since_onDown;



let t_tools_spread_xy = function(x, y)
{

let   caller = "t_tools_spread_xy";
let log_this = LOG_MAP.T5_SPREAD;

if( log_this) t_fly.t_log_event_status(caller+"("+x.toFixed(0)+" "+y.toFixed(0)+")", lf2);

    if(!hotspot) return;


    let x_sign = (x < pivotXY.x) ? 1 : -1;
    let y_sign = (y < pivotXY.y) ? 1 : -1;

    if( !!hotspotXY.gutter_urdl ) { x_sign *= -1; y_sign *= -1; }

    x += x_sign * h_W / 2;
    y += y_sign * h_H / 2;



    if(!t_tools_loaded) t_load_TOOLS_MAP(caller);
if(!pivot_PANEL) t_set_pivot_PANEL(onWork_PANEL, "PICKING OUT A MISSING [pivot_PANEL]");

    if(!pivot_PANEL) {

        return;
    }
    let xy_ratio = t_set_spread_ratio_at_xy_in_panel(x, y, pivot_PANEL);




    if(has_moved && !fully_spread_since_onDown && (onWork_PANEL == pivot_PANEL))
    {
        let fully_spread = ((spread_ratio.x >= 0.99) || (spread_ratio.y >= 0.99));
if( log_this) log("%c"+(fully_spread ? "@@@ fully_spread" : "not fully_spread"), lbH+(fully_spread ? lf4 : lf8));

        if( fully_spread ) {
if( log_this) t_fly.t_log_event_status(caller, lf2);

            fully_spread_since_onDown = true;
            t_cycle_pivot_panel();
        }
    }


    let xy = {x , y};

    for(let i=1; i < TOOL_panels.length; ++i)
    {

        let panel = TOOL_panels[i];
        if(!panel                                            ) continue;
        if( panel.classList.contains(t_data.CSS_PINNED)      ) continue;


        let map = t_tools_map_get(panel);
        if(!map                                              ) continue;
        if(!map.selected && !t_tools_panel_is_selected(panel)) continue;


        if( has_el_class(panel, t_data.CSS_HIDDEN) ||!panel.offsetWidth) {

        del_el_class(panel, t_data.CSS_HIDDEN);

        if(!panel.offsetWidth)
            logBIG(get_id_or_tag_and_className(panel)+".offsetWidth=["+panel.offsetWidth+"]", lf3);
        }


        map.x =  xy.x;
        map.y =  xy.y;



        xy    = t_tools_spread_panel_xy(panel, map, xy_ratio, x_sign, y_sign);

    }

};



let spread_ratio = { x:0 , y:0 };


let t_set_spread_ratio_at_xy_in_panel = function(x, y, moving_panel)
{

let caller = "t_set_spread_ratio_at_xy_in_panel";


    let unchanged
        =   spread_ratio.x
        && !has_moved
        && !hotspot.drag_hotspot_request;

    if( unchanged ) {

        return spread_ratio;
    }


    let up_to_panel_WH = t_spread_get_leading_panels_wh_up_to_panel( moving_panel );
    if( up_to_panel_WH ) {


        let x_ratio = Math.abs(x - pivotXY.x) / up_to_panel_WH.w;
        let y_ratio = Math.abs(y - pivotXY.y) / up_to_panel_WH.h;

        x_ratio     = Math.min(x_ratio , 1);
        y_ratio     = Math.min(y_ratio , 1);
        x_ratio     = Math.max(x_ratio , 0);
        y_ratio     = Math.max(y_ratio , 0);

        spread_ratio.x = x_ratio;
        spread_ratio.y = y_ratio;

        if(!save_update_is_pending()) t_save_update_post(caller, PENDING_LOCALSTORAGE_DELAY);
    }




    return spread_ratio;
};


let t_set_spread_ratio_up_to_panel = function(panel)
{

    let up_to_panel_WH = t_spread_get_leading_panels_wh_up_to_panel( panel );


    if(up_to_panel_WH) {

        let      x = panel.offsetLeft;
        let      y = panel.offsetTop ;
        let x_sign = (x > h_x) ? 1 : -1;
        let y_sign = (y > h_y) ? 1 : -1;
        if( x_sign < 0) x += onWork_PANEL.offsetWidth;
        if( y_sign < 0) y += onWork_PANEL.offsetHeight;

        x += x_sign * h_W / 2;
        y += y_sign * h_H / 2;

        spread_ratio.x = Math.abs(x - h_x) / up_to_panel_WH.w;
        spread_ratio.y = Math.abs(y - h_y) / up_to_panel_WH.h;
    }
};


let t_spread_log = function(moving_panel)
{
    set_tool_id_value(t_data.WORDS_FILTER
                        , moving_panel.id+" "
                        + parseInt(100 * spread_ratio.x)+"*"+parseInt(100 * spread_ratio.y)
                       );

    let msg
        = "<pre>"
        +  moving_panel.offsetLeft +"@"+ moving_panel.offsetTop+"          "+ moving_panel.id+LF
        +             h_x          +"@"+            h_y        +"          "+ "hotspot"      +LF
        +       pivotXY.x          +"@"+      pivotXY.y        +"          "+ "pivot"
        + "</pre>"
    ;

    if(onWork_PANEL) t_words_option_tooltip(msg);
};


let              my_up_to_panel_WH = {};
let t_spread_get_leading_panels_wh_up_to_panel = function( moving_panel )
{
    if(!t_tools_loaded) t_load_TOOLS_MAP("t_spread_get_leading_panels_wh_up_to_panel");


    my_up_to_panel_WH.w = 0;
    my_up_to_panel_WH.h = 0;
    let selected_count = 0;
    for(let i=1; i < TOOL_panels.length; ++i)
    {

        let panel = TOOL_panels[i];
        if(!panel) continue;
        if( panel.classList.contains( t_data.CSS_PINNED )) continue;


        let map = t_tools_map_get(panel);
        if(!map.selected && !t_tools_panel_is_selected(panel)) continue;

        selected_count += 1;

        my_up_to_panel_WH.w += map.w;
        my_up_to_panel_WH.h += map.h;

        if(panel == moving_panel) break;
    }


    return (selected_count > 0) ? my_up_to_panel_WH : null;
};


let t_tools_spread_panel_xy = function(panel, map, xy_ratio, x_sign, y_sign)
{


    map.w  = panel.offsetWidth;
    map.h  = panel.offsetHeight;

    let    x  = map.x;
    let    y  = map.y;
    let    w  = map.w;
    let    h  = map.h;

    if(panel == pivot_PANEL)
    {
        if((spread_ratio.x == 1) || (spread_ratio.y == 1))
        {
            let piv_x = (spread_ratio.x == 1) ? (x + x_sign * w) : pivotXY.x;
            let piv_y = (spread_ratio.y == 1) ? (y + y_sign * h) : pivotXY.y;
            t_set_pivotXY(piv_x, piv_y);
        }
    }


    let dx = xy_ratio.x * map.w;
    let dy = xy_ratio.y * map.h;

    x += x_sign * Math.min(w, Math.abs(dx));
    y += y_sign * Math.min(h, Math.abs(dy));

    return {x , y};

};




const OUTLINE_SCAN_STEP_MAX = 3;
const OUTLINE_SCAN_SIGN_MAX = [
    { x: 1 , y: 1 }
  , { x: 1 , y:-1 }
  , { x:-1 , y: 1 }
  , { x:-1 , y:-1 }
];

const COLORX
    = [   "#964B00"
        , "#FF0000"
        , "#FFA500"
        , "#FFFF00"
        , "#9ACD32"
        , "#6495ED"
        , "#EE82EE"
        , "#A0A0A0"
        , "#FFFFFF"
        , "#000000"
    ];

let outlined_divs = [];
let outlined_dots = [];
let outlined_dots_used_since_t_outline_clear;


let t_outline_viewport_top_containers = function()
{

let caller = "t_outline_viewport_top_containers";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

if( log_this) console.time(caller);

    t_outline_clear();



    let v_W = window.innerWidth ;
    let v_H = window.innerHeight;
    let w_2 = v_W / 2;
    let h_2 = v_H / 2;



    let          step_Y  = v_H / 2 /  OUTLINE_SCAN_STEP_MAX        ;
    let          step_X  = v_W / 2 /  OUTLINE_SCAN_STEP_MAX        ;
    let             num  = 0;
    for(        let col  = 0; (col <= OUTLINE_SCAN_STEP_MAX       ); ++col) { let d_x = col * step_X;
        for(    let row  = 0; (row <= OUTLINE_SCAN_STEP_MAX       ); ++row) { let d_y = row * step_Y;
            for(let dir  = 0; (dir <  OUTLINE_SCAN_SIGN_MAX.length); ++dir)
            {
                if((col == 0)     && (OUTLINE_SCAN_SIGN_MAX[dir].x != 1)) continue;
                if((row == 0)     && (OUTLINE_SCAN_SIGN_MAX[dir].y != 1)) continue;

                let left = w_2 + d_x *  OUTLINE_SCAN_SIGN_MAX[dir].x ;
                let top  = h_2 + d_y *  OUTLINE_SCAN_SIGN_MAX[dir].y ;

if( log_this)   t_outline_dot(num, left, top);

                let range;
                if( range = t_select.get_range_from_caret (left, top))
                    num   = t_outline_range(range, left, top, num);
                if((col  == 0) && (row == 0)) break;
            }
        }
    }


if( log_this) console.timeEnd(caller);
};


let t_outline_range = function(range, left, top, num)
{

let caller = "t_outline_range";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) t_util.log_range(range, caller);


    let el = range.startContainer;
    if( el.nodeType == Node.TEXT_NODE) el = el.parentElement;



    if(has_el_class(el, "outlined")               ) return num;
    add_el_class   (el, "outlined");



    let tl   = t_util.get_el_xy(el, caller);
    if( tl.x < (window.scrollX                   )) return num;
    if( tl.y < (window.scrollY                   )) return num;
    if( tl.x > (window.scrollX+window.innerWidth )) return num;
    if( tl.y > (window.scrollY+window.innerHeight)) return num;



    let br   = t_util.get_el_xy(el, caller);
    br.x += el.offsetWidth;
    br.y += el.offsetHeight;
    if( br.x < (window.scrollX                   )) return num;
    if( br.y < (window.scrollY                   )) return num;
    if( br.x > (window.scrollX+window.innerWidth )) return num;
    if( br.y > (window.scrollY+window.innerHeight)) return num;



    let div = outlined_divs[num];
    if(!div) {
        div = document.createElement("DIV");
        add_el_class(div, "outlined_divs");
        document.documentElement.appendChild(div);
        outlined_divs[num] = div;
    }


    div.style.top             = (tl.y           -     div.style.borderWidth) +"px";
    div.style.left            = (tl.x           -     div.style.borderWidth) +"px";
    div.style.width           = (el.offsetWidth + 2 * div.style.borderWidth) +"px";
    div.style.height          = (el.offsetHeight+ 2 * div.style.borderWidth) +"px";

    div.style.zIndex          = el.style.zIndex + 1;
    div.style.borderColor     = COLORX[num % 10];
    div.style.display         = "block";


    return num + 1;
};


let t_outline_dot = function(num,left,top)
{

    let div = outlined_dots[outlined_dots_used_since_t_outline_clear];
    if(!div) {
        div = document.createElement("DIV");
        add_el_class(div, "outlined_dots");
        document.documentElement.appendChild(div);
        outlined_dots[outlined_dots_used_since_t_outline_clear] = div;
    }

    outlined_dots_used_since_t_outline_clear += 1;


    div.style.top             = (window.scrollY + top )+"px";
    div.style.left            = (window.scrollX + left)+"px";

    div.style.backgroundColor = COLORX[num % 10];
    div.style.display         = "block";

    div.innerHTML             = outlined_dots_used_since_t_outline_clear;


};


let t_outline_clear = function()
{

    let className = "outlined";
    let node_list = document.querySelectorAll("."+className);
    for(let i=0; i < node_list.length; ++i)
        del_el_class(node_list[i], className);



    for(let i=0; i < outlined_divs.length; ++i)
        outlined_divs[i].style.display = "none";



    for(let i=0; i < outlined_dots.length; ++i)
        outlined_dots[i].style.display = "none";


    outlined_dots_used_since_t_outline_clear = 0;
};




let t_sync_wording = function(_caller)
{

    let caller = "t_sync_wording";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller+": wording=["+ prop.get( t_data.WORDING ) +"] %c CALLED BY "+_caller, lbH+lf5);


    if(typeof dom_wording == "undefined") {
        prop.set(t_data.ANCHOR_FREEZE, false);
        return;
    }

    let cycle_step
        = !prop.get( t_data.WORDING        ) ? "OFF"
        : (prop.get( t_data.THEME_DARK     ) ? "DARK" : "LIGHT")
    ;

    let anchor_freeze_by_wording_or_user
        =  prop.get( t_data.WORDING       )
        || prop.get( t_data.ANCHOR_FREEZE )
        || prop.get( t_data.EDIT_OR_STAGE )
    ;
if( log_this) log(caller+": anchor_freeze_by_wording_or_user=["+anchor_freeze_by_wording_or_user+"]");
    t_wording.t_wording_cycle(cycle_step, anchor_freeze_by_wording_or_user);
};


let are_p1_p2_in_same_quadrant_and_p2_in_corner = function(p1, p2)
{
let log_this = LOG_MAP.T5_SPREAD;

    let c_x = w_W / 2;
    let c_y = w_H / 2;
if(log_this) {
    log("____________________");
    log("..............p1 ["+ p1.x +" , "+ p1.y +"]");
    log("..............p2 ["+ p2.x +" , "+ p2.y +"]");
    log("..........center ["+  c_x +" , "+  c_y +"]");
}


    let same_quadrant
        =  ((p1.x >= c_x) && (p2.x >= c_x) || (p1.x <  c_x) && (p2.x <  c_x))
        && ((p1.y >= c_y) && (p2.y >= c_y) || (p1.y <  c_y) && (p2.y <  c_y))
    ;

if(log_this) log("...same_quadrant=["+ same_quadrant +"]");
    if(!same_quadrant) return false;


    let p2_in_corner
        =  Math.abs(p2.x - c_x) >= Math.abs(p1.x - c_x)
        && Math.abs(p2.y - c_y) >= Math.abs(p1.y - c_y)
    ;

if(log_this) log("...p2_in_corner=["+ p2_in_corner +"]");
    if(!same_quadrant) return false;

    return true;
};


let is_pannel_in_hotspot_quadrant = function(pannel)
{
let log_this = LOG_MAP.T5_SPREAD;

    let px = pannel .offsetLeft + pannel.offsetWidth  / 2;
    let py = pannel .offsetTop  + pannel.offsetHeight / 2;
    let hx = hotspot.offsetLeft      + h_W            / 2;
    let hy = hotspot.offsetTop       + h_H            / 2;

    let same_quadrant
        =  ((px >= pivotXY.x) && (hx >= pivotXY.x) || (px <  pivotXY.x) && (hx <  pivotXY.x))
        && ((py >= pivotXY.y) && (hy >= pivotXY.y) || (py <  pivotXY.y) && (hy <  pivotXY.y))
    ;

if(log_this) {
    log("____________________");
    log("...pivotXY=["+ pivotXY.x +" , "+ pivotXY.y +"]");
    log(".....px py=["+        px +" , "+        py +"]");
    log(".....hx hy=["+        hx +" , "+        hy +"]");
    log("...same_quadrant=["+ same_quadrant         +"]");
}

    return same_quadrant;
};








const T_SYNC_STYLES_DELAY = 50;
let   t_sync_styles_timer;
let   t_sync_styles_caller_csv;


let t_sync_styles = function(_caller)
{
    t_sync_styles_caller_csv = t_util.csv_add(t_sync_styles_caller_csv, _caller);

    if(t_sync_styles_timer) clearTimeout(t_sync_styles_timer);
    t_sync_styles_timer   =   setTimeout(t_sync_styles_handler, T_SYNC_STYLES_DELAY);
};


let t_sync_styles_handler = function()
{

let   caller = "t_sync_styles_handler";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);

    t_sync_styles_timer      = null;
    t_sync_styles_caller_csv = "";

    prop.get_MAP().forEach( function(p,index,array)
                            {
                                if(p.id) t_set_id_class_on_off(p.id, t_data.CSS_CHECKED,  p.value);
                            });



    let state, id, el;
    state = prop.get( t_data.THEME_DARK );

    t_TOOL_SET_set_class_state      (                        t_data.CSS_DARK   , state);
    t_set_tool_class_theme_state    (t_data.CSS_STICKY_TOOL, t_data.CSS_DARK   , state);
    t_set_tool_class_theme_state    (CSS_TRANSCRIPT        , t_data.CSS_DARK   , state);
    t_set_doc_tool_class_theme_state(CSS_TRANSCRIPT        , t_data.CSS_DARK   , state);


    state = prop.get( t_data.TOOLS_SCROLL );

    t_TOOL_SET_set_class_state      (                        t_data.TOOLS_SCROLL, state);
    t_set_tool_class_theme_state    (t_data.CSS_STICKY_TOOL, t_data.TOOLS_SCROLL, state);
    t_set_doc_tool_class_theme_state(CSS_TRANSCRIPT        , t_data.TOOLS_SCROLL, state);


    state = prop.get( t_data.TOOLS_TRAP );

    if(el = hotspot_c )                                   set_el_class_on_off(el, t_data.CSS_TRAPPED, state);
    if(el = pivspot_c )                                   set_el_class_on_off(el, t_data.CSS_TRAPPED, state);
    id    = t_data.TOOLS_TRAP; if(el = prop.get_EL(id)) t_set_id_class_on_off(id, t_data.CSS_TRAPPED, state);





    el = document.getElementsByTagName("HTML")[0]; set_el_class_on_off(el,  t_data.OVERFLOW_VISI, prop.get( t_data.OVERFLOW_VISI ));
    el = document.getElementsByTagName("HTML")[0]; set_el_class_on_off(el,  t_data.DETAILS_RADIO, prop.get( t_data.DETAILS_RADIO ));
    el = document.getElementsByTagName("HTML")[0]; set_el_class_on_off(el,  t_data.SCROLL_SMOOTH, prop.get( t_data.SCROLL_SMOOTH ));

    t_seek.t_seeker_set_class(t_data.SCROLL_SMOOTH, prop.get( t_data.SCROLL_SMOOTH ));


    if(el = prop.get_EL( t_data.THEME_DARK   )) el.innerHTML = (prop.get( t_data.THEME_DARK   )) ? t_data.SYMBOL_THEME_DARK_IS_ON  : t_data.SYMBOL_THEME_DARK_IS_OFF;
    if(el = prop.get_EL( t_data.TOOLS_SCROLL )) el.innerHTML = (prop.get( t_data.TOOLS_SCROLL )) ? t_data.SYMBOL_UP_AND_DOWN_ARROW : t_data.SYMBOL_ANCHOR           ;
    if(el = prop.get_EL( t_data.WORDING      )) el.innerHTML = (prop.get( t_data.WORDING      )) ? t_data.SYMBOL_WORDING_IS_ON     : t_data.SYMBOL_WORDING_IS_OFF   ;
    if(el = prop.get_EL( t_data.TOOLS_TIER2  )) el.innerHTML = (prop.get( t_data.TOOLS_TIER2  )) ? t_data.SYMBOL_TOOLS_TIER2_ON    : t_data.SYMBOL_TOOLS_TIER2_OFF  ;

    id    = t_data.ANCHOR_FREEZE;
    if(el = prop.get_EL(id)) {
        state = (prop.get( t_data.WORDING ) || prop.get( t_data.ANCHOR_FREEZE ))
            &&  (typeof dom_wording != "undefined")
        ;
        t_set_id_class_on_off(id,  t_data.CSS_CHECKED,  state);
        el.innerHTML
            = state
            ? t_data.SYMBOL_NO_ENTRY
            : t_data.SYMBOL_SAILBOAT
        ;
    }

    words_option_sync();
};


let t_set_doc_tool_class_theme_state = function(className, theme, state)
{


    let                     node_list = document.querySelectorAll("."+className);
    for(let i=0;        i < node_list.length; ++i)
    {

        set_el_class_on_off(node_list[i], theme, state);
    }
};


let t_set_tool_class_theme_state = function(className, theme, state)
{


    let                     node_list = shadow_root.querySelectorAll("."+className);
    for(let i=0;        i < node_list.length; ++i)
    {

        set_el_class_on_off(node_list[i], theme, state);
    }
};




let is_dom_grid_loaded = function()
{
    return (typeof t_grid.t_grid_ON_OFF_CB != "undefined");
};


let t_move_TOOLS_ON_GRID = function(_caller)
{

    call_t_grid_ON_OFF_CB(true);
};


let t_move_TOOLS_OFF_GRID = function(_caller)
{

    call_t_grid_ON_OFF_CB(false);


};


let t_move_TOOLS_TOGGLE_GRID = function(_caller)
{


    if( !was_a_too_early_last_result() )
    {
        call_t_grid_ON_OFF_CB(false);
        dimm_stop(_caller);
    }
    else {

    }
};


let call_t_grid_ON_OFF_CB = function(new_state="toggle")
{
    let caller = "call_t_grid_ON_OFF_CB("+new_state+")";
let log_this = LOG_MAP.EV5_TOOL_CB;

    if(new_state == "toggle") new_state = !call_t_grid_IS_ON_GRID(caller);
if( log_this) log("%c "+caller+": new_state=["+new_state+"]",lb2+lbF);

    if(!new_state                                           ) t_raise_pivot_PANEL_delayed(T_RAISE_PIVOT_PANEL_DELAY_SHORT, caller);
    else if(!t_raise_pivot_PANEL_posted_since_onDown(caller)) t_flash_unpinned_panels    (caller);

    if(typeof t_grid.t_grid_ON_OFF_CB == "undefined") log_dom_grid_js_not_loaded(caller);
    else      t_grid.t_grid_ON_OFF_CB(new_state);

    t_fly.t_fly_init(caller);
};


let call_t_grid_IS_SIZED = function(_caller)
{
    if(typeof t_grid.t_grid_IS_SIZED == "undefined") {
        return false;
    }
    else {
        return t_grid.t_grid_IS_SIZED("call_t_grid_IS_SIZED .. CALLED BY "+ _caller);
    }
};


let call_t_grid_IS_ON_GRID = function(_caller)
{
    if(typeof t_grid.t_grid_IS_ON_GRID == "undefined")
        return false;
    else
        return t_grid.t_grid_IS_ON_GRID("call_t_grid_IS_ON_GRID .. CALLED BY "+ _caller);
};



let call_t_grid_add_observer = function()
{
    if(typeof t_grid.t_grid_add_observer_callback != "undefined")
    {
        t_grid.t_grid_add_observer_callback( t_IS_ON_GRID_observerCB );
    }
    else {
        log_dom_grid_js_not_loaded("call_t_grid_add_observer");
    }
};



const OFF_GRID_MARGIN_X = 64;
const OFF_GRID_MARGIN_Y = 64;


let t_IS_ON_GRID_observerCB = function(on_grid)
{

    let caller = "t_IS_ON_GRID_observerCB("+on_grid+")";
let log_this = LOG_MAP.T2_GRID;

if( log_this) log(caller);


    if( on_grid )
    {
        t_sticky.t_sticky_RING_stop(caller);
        dimm_start_grid(caller);

        if(!t_raise_pivot_PANEL_posted_since_onDown(caller))
            t_flash_unpinned_panels(caller);
    }


    else {


        let          xy    = t_gutter.get_WINDOW_XY();
        if((Math.abs(xy.x) < OFF_GRID_MARGIN_X)) xy.x = OFF_GRID_MARGIN_X;
        if((Math.abs(xy.y) < OFF_GRID_MARGIN_Y)) xy.y = OFF_GRID_MARGIN_Y;


        t_tools_set_top_xy(xy.x, xy.y);

        t_grid_TOOLS_MAP_changed();
        t_TOOL_SET_eval_wide_or_tall_panel(caller);
    }

};


let t_grid_TOOLS_MAP_changed = function()
{

let caller = "t_grid_TOOLS_MAP_changed";
let log_this = LOG_MAP.T2_GRID;

if( log_this) log(caller);

    t_TOOL_panels_SLOT_SELECTED();

    t_update_TOOLS_MAP_GEOMETRY(caller, 0);

    t_tools_set_top_xy(h_x, h_y);
};


let t_TOOL_panels_SLOT_SELECTED = function()
{

let   caller = "t_TOOL_panels_SLOT_SELECTED";
let log_this = LOG_MAP.T5_SPREAD;

if( log_this) log(caller);

if( log_this) t_log_TOOL_panels(caller);

if( log_this) log("%c REORDERING ", lbb+lbH+lf7);
    let free_slots = [];
    let map;
    for(let i=1; i < TOOL_panels.length; ++i)
    {

        let                   panel = TOOL_panels[i];
        if(                  !panel
           ||                 panel.classList.contains(t_data.CSS_PINNED)


           || !(!(map = t_tools_map_get( panel )) || !map.selected)
          ) {
            free_slots.push(i);
        }

        else {
            let free_slot = free_slots.shift();
            if( free_slot ) {
if( log_this) log("...free_slot=["+free_slot+" "+t_data.SYMBOL_LEFT_CHEVRON+" "+i+"] .. ["+t_util.get_id_or_tag(TOOL_panels[free_slot])+" "+t_data.SYMBOL_LEFT_CHEVRON+" "+t_util.get_id_or_tag(TOOL_panels[i])+"]");
                let removed = TOOL_panels[free_slot];
 TOOL_panels[free_slot] = TOOL_panels[i];
 TOOL_panels[i] = removed;
            }

        }

    }

if( log_this) t_log_TOOL_panels(caller, lf5);
};




const DIMM_CLASS_ARRAY = ["dimm_grid", "dimm_pat_bag", "dimm_sticky", "div_slot_containers"];
const DIMM_STYLE_ARRAY = ["dimm_light", "dimm_dark"];

let dimm_mask       = null;
let dimm_mask_timer = null;
let dimm_start_called_with_hotspot_in_gutter;



let dimm_start_pat_bag         = function(_caller) { dimm_start(_caller, t_data.ZINDEX_PINNED_PANEL_ZERO, "dimm_pat_bag"       ,  "dimm_light", "fixed"    ); };
let dimm_start_grid            = function(_caller) { dimm_start(_caller, t_data.ZINDEX_TOOL_PANEL_ZERO  , "dimm_grid"          ,  "dimm_light", "fixed"    ); };
let dimm_start_sticky          = function(_caller) { dimm_start(_caller, t_data.ZINDEX_ABOVE_TOOLS      , "dimm_sticky"        ,  "dimm_dark" , "fixed"    ); };
let dimm_start_slot_containers = function(_caller) { dimm_start(_caller, t_data.ZINDEX_ABOVE_TOOLS      , "div_slot_containers",            "", ""         ); };
let dimm_start                 = function(                      _caller, zIndex                         , dimm_class=""        , dimm_style="", position="")
{

let log_this = LOG_MAP.T2_GRID;

if( log_this) log("dimm_start(zIndex=["+zIndex+"], dimm_class=["+dimm_class+"], dimm_style=["+dimm_style+"]) .. CALLED BY "+ _caller);

    if((typeof t_gutter === "undefined")) return;

    if(_caller) {
        dimm_start_called_with_hotspot_in_gutter = !!hotspotXY.gutter_urdl;
if( log_this) log("...%c dimm_start_called_with_hotspot_in_gutter=["+dimm_start_called_with_hotspot_in_gutter+"]", lf7);

        if(!dimm_start_called_with_hotspot_in_gutter)
            t_gutter.set_WINDOW_XY(h_x, h_y);
    }


    if(!dimm_mask) dimm_add();
    if(dimm_class && !has_el_class(dimm_mask, dimm_class)) set_el_class_removing(dimm_mask, dimm_class, DIMM_CLASS_ARRAY);
    if(dimm_style && !has_el_class(dimm_mask, dimm_style)) set_el_class_removing(dimm_mask, dimm_style, DIMM_STYLE_ARRAY);

if( log_this) log("...dimm_mask.className=["+dimm_mask.className+"]");


    if(zIndex) dimm_mask.style.zIndex = zIndex;



    if( position == "fixed")
    {
        dimm_mask.style.position = "fixed";
        dimm_mask.style.top      = "0";
        dimm_mask.style.left     = "0";

    }
    else if(position == "absolute") {

        dimm_mask.style.position = "absolute";
        dimm_mask.style.left     = window.scrollX +"px";
        dimm_mask.style.top      = window.scrollY +"px";
    }


    dimm_mask.style.display = "block";

    add_el_class(document.body, t_data.CSS_DIMMED);


    dimm_mask.style.width      = window.innerWidth +"px";

    if(!div_slot_containers_displayed() )
        dimm_mask.style.height = window.innerHeight+"px";



    if( dimm_mask.firstElementChild)
        dimm_mask.firstElementChild.style.width = w_W+"px";


};


let dimm_stop  = function(_caller="setTimeout")
{

let log_this = LOG_MAP.T2_GRID;

if( log_this) log("dimm_stop .. CALLED BY "+ _caller);
if( log_this) log_caller();

    if((typeof t_gutter === "undefined")) return;

    if(dimm_mask_timer) {
        clearTimeout( dimm_mask_timer );
 dimm_mask_timer = null;
    }


    if( dimm_mask ) {
        dimm_mask.style.display = "none";
        dimm_mask.innerHTML     = "";

        del_el_class(document.body, t_data.CSS_DIMMED);
    }


    t_clear_onModalMS(_caller);



    del_el_class(hotspot, t_data.CSS_HIDDEN);



if(log_this) log("...%c dimm_start_called_with_hotspot_in_gutter=["+dimm_start_called_with_hotspot_in_gutter+"]", lf7);
    if( dimm_start_called_with_hotspot_in_gutter )
    {
if(log_this) t_log.logSD1("HOTSPOT LEFT IN GUTTER %c"+_caller, lbH+lf8);

    }


    else if(dimm_start_called_with_hotspot_in_gutter != undefined)
    {

        if( t_gutter.is_hotspot_IN(hotspot, "DIMM STOP") )
        {
            let xy = t_gutter.get_WINDOW_XY();
            if( xy ) {
if(log_this) t_log.logSD2("HOTSPOT BACK TO WINDOW %c"+xy.x+" "+xy.y+" %c"+_caller, lbH+lf4, lbH+lf9);
                    t_tools_set_top_xy(xy.x, xy.y);
            }
        }


        else {
if(log_this) t_log.logSD3("HOTSPOT LEFT WHERE IT IS %c"+h_x+" "+h_y+" %c"+_caller, lbH+lf8, lbH+lf9);

        }

    }

};


let dimm_add = function()
{
let log_this = LOG_MAP.T3_LAYOUT;
if( log_this) log("dimm_add");

    if(dimm_mask) return;

    dimm_mask              = document.createElement("DIV");
    dimm_mask.id           = "dimm_mask";

    shadow_root.appendChild( dimm_mask );
};


let dimm_mask_displayed = function()
{
    if(!dimm_mask) return false;
    return (dimm_mask && (dimm_mask.style.display != "none"));
};


let div_slot_containers_displayed = function()
{
    return  dimm_mask                   && div_slot_containers
        &&  dimm_mask.firstElementChild
        && (dimm_mask.firstElementChild == div_slot_containers)
    ;
};


let dimm_mask_is = function(el)
{
    return (el == dimm_mask);
};





let T_SYNC_LAYOUT_DELAY = 500;
let t_sync_layout_timer = null;
let t_sync_layout_callers = "";

let t_sync_layout = function(_caller, delay=T_SYNC_LAYOUT_DELAY)
{

let log_this = LOG_MAP.EV7_DISPATCH;


    if(               t_sync_layout_timer ) {
        clearTimeout( t_sync_layout_timer );
  t_sync_layout_timer  = null;
    }

    t_sync_layout_callers += _caller;
if( log_this) log("%c t_sync_layout .. CALLED BY ["+t_sync_layout_callers+"]", lbF+lb7);

    if(delay) t_sync_layout_timer = setTimeout( t_sync_layout_handler, delay);
    else                                        t_sync_layout_handler();
};


let t_sync_layout_handler = function()
{

let   caller = "t_sync_layout_handler";
let log_this = LOG_MAP.EV7_DISPATCH || LOG_MAP.T3_LAYOUT;

if(log_this) log("%c"+caller+"%c called by "+t_sync_layout_callers+")", lbH+lf1, lbH+lf8);

    t_sync_layout_timer   = null;
    t_sync_layout_callers = "";



    t_sync_tool_clones_state( caller );




    if(!t_tools_loaded) t_load_TOOLS_MAP(caller);


    if( call_t_grid_IS_ON_GRID(caller) )
    {
if(log_this) log("- %c TOOLS ON GRID", lbH+lf1);
        t_grid.t_grid_onresize(caller);

        return;
    }


    if(onWork_EL) {
if(log_this) log("- POSTPONING .. %c EVENT HANDING IN PROGRESS: %c ["+get_n_lbl(onWork_EL)+"]", lbH+lf1, lbH+lf1);

        t_sync_layout(caller);
        return;
    }



    if(dom_tools_html && !t_cache_has_been_armed())
    {
        t_sync2_initial_tools_layout();

        return;
    }


    if( t_sync3_hotspot_hiding_in_gutter() )
    {

        return;
    }


    let first_tool = t_get_first_selected_tool_panel();
    if(!first_tool) {
if(log_this) log("- NOTHING TO LAYOUT .. %c NO UNPINED TOOLS SELECTED", lbH+lf4);

        t_save_update_post("NO SELECTED TOOL");
        return;
    }


    t_sync5_pivot_PANEL();



    if( t_sync6_some_tools_to_unhide(first_tool) )
    {
        return;

    }


    t_sync7_panel_magnified();


};



const HOTSPOT_STANDBY_X =  0;
const HOTSPOT_STANDBY_Y = 96;


let t_sync2_initial_tools_layout = function()
{

let   caller = "t_sync2_initial_tools_layout";
let log_this = LOG_MAP.EV7_DISPATCH || LOG_MAP.T3_LAYOUT;

if(log_this) log("%c"+caller, lbH+lf2);


    t_TOOL_SET_select();

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_1_INPUT, caller);



    call_t_grid_add_observer();



if(log_this) log_key_val_group("ONLOAD PATTERN CSV", {sel_csv, pat_csv, off_csv, bak_csv, bin_csv}, lf2);

    let  tmp_csv =    String( off_csv   );
    let    count = t_util.csv_count( off_csv   );
    for(let  pos = 1; pos <= count; ++pos) {
        let  pat = t_util.csv_get(tmp_csv ,  pos);
        csv_pattern_mov_to_off(       pat);
    }

if(log_this) log_key_val_group("[off_csv duplicates] REMOVED FROM OTHER BAGS", {sel_csv, pat_csv, off_csv, bak_csv, bin_csv}, lf2);

    t_sel_pat_bag_all();


    if(pivspot) t_tools_set_panel_xy(pivspot, pivotXY.x, pivotXY.y);

    t_raise_pivot_PANEL_delayed(T_RAISE_PIVOT_PANEL_DELAY_LONG, caller);

    t_toggle_pivot_PANEL_magnified( prop.get( t_data.PIVOT_MAGNIFIED ) );

    let position =  prop.get( t_data.TOOLS_SCROLL )  ? "absolute" : "fixed";
      t_tools_set_top_xy(HOTSPOT_STANDBY_X, HOTSPOT_STANDBY_Y, position);

    t_fly.t_fly_div_magnified_toggle(prop.get( t_data.FLY_DIV_MAGNIFIED ) );



if( log_this) log("%c ONLOAD: EVENT LISTENERS", lbH+lf2);
    t_layout_changed();



    t_sticky.t_sticky_SET_DIMMED(false, "ON LOAD");



    dom_tools_html.style.visibility = "visible";


};


let t_sync3_hotspot_hiding_in_gutter = function()
{

let   caller = "t_sync3_hotspot_hiding_in_gutter";
let log_this = LOG_MAP.EV7_DISPATCH || LOG_MAP.T3_LAYOUT;

if(log_this) log("%c"+caller, lbH+lf3);


    if(!dom_tools_html )
    {
log("%c...return false .. ![dom_tools_html]", lf3);

        return false;
    }


    h_x                   = hotspot.offsetLeft;
    h_y                   = hotspot.offsetTop;

    hotspotXY.gutter_urdl = t_gutter.get_XY_URDL(h_x, h_y, "LAYOUT CHANGED SYNC");
    t_gutter.set_CSS_URDL(hotring, hotspotXY.gutter_urdl);

    if( !hotspotXY.gutter_urdl )
    {
if(log_this) log("%c...return false .. NOT HIDING .. ![hotspot XY URDL]", lf3);

        return false;
    }


if(log_this) log("- %c HOTSPOT IN GUTTER: HIDING TOOL PANELS", lbH+lf3);

        let xy = { x:h_x , y:h_y };
if(log_this) log("...hotspot: FROM XY=[%c "+ xy.x  +" "+ xy.y +" %c]",lbH+lf3,lbA);

        xy.x = Math.max( -w_W, xy.x      );
        xy.y = Math.max( -w_H, xy.y      );
        xy.x = Math.min(       xy.x, w_W );
        xy.y = Math.min(       xy.y, w_H );
if(log_this) log("...hotspot: TO   XY=[%c "+ xy.x  +" "+ xy.y +" %c]",lbH+lf3,lbA);

        let position =  prop.get( t_data.TOOLS_SCROLL )  ? "absolute" : "fixed";

        t_tools_set_top_xy(xy.x, xy.y, position);

        t_save_update_post("HOTSPOT IN GUTTER");

    return true;

};


let t_sync5_pivot_PANEL = function()
{

let   caller = "t_sync5_pivot_PANEL";
let log_this = LOG_MAP.EV7_DISPATCH || LOG_MAP.T3_LAYOUT;

if(log_this) log("%c"+caller, lbH+lf5);

    let panel = pivot_PANEL;
if(log_this) log("%c pivot_PANEL %c"+get_n_lbl(panel), lbL+lf5, lbR+lf5);

    if(!t_tools_panel_is_selected(panel)) { panel = t_get_next_selected_tool_panel (pivot_PANEL); if(log_this) log("%c NEXT  %c "+get_n_lbl(panel)+"  ", lbH+lf5,lbR+lf3); }
    if(                          !panel ) { panel = t_get_prev_selected_tool_panel (pivot_PANEL); if(log_this) log("%c PREV  %c "+get_n_lbl(panel)+"  ", lbH+lf5,lbR+lf2); }
    if(                          !panel ) { panel = t_get_first_selected_tool_panel(           ); if(log_this) log("%c FIRST %c "+get_n_lbl(panel)+"  ", lbH+lf5,lbR+lf1); }

    if( panel )
    {
        t_set_pivot_PANEL             ( panel, "SYNC LAYOUT CURRENT [pivot_PANEL]");
        t_raise_pivot_PANEL           ( caller );
        t_toggle_pivot_PANEL_magnified( prop.get( t_data.PIVOT_MAGNIFIED ) );
    }
};



let t_sync6_some_tools_to_unhide = function(first_tool)
{

let   caller = "t_sync6_some_tools_to_unhide";
let log_this = LOG_MAP.EV7_DISPATCH || LOG_MAP.T3_LAYOUT;

if(log_this) log("%c"+caller, lbH+lf6);


if(log_this) log("%c first_tool %c "+get_n_lbl(first_tool)+"%c spreaded_tools.length: "+spreaded_tools.length
                 ,lbL+lf6      ,lbR+lf6                    ,lbH+lf6                                          );

    let map = t_tools_map_get(first_tool);
    let top_tool_l = map.x;
    let top_tool_t = map.y;
    let top_tool_w = map.w;
    let top_tool_h = map.h;

if(log_this) log(get_n_lbl(first_tool)+"%c XY=["+top_tool_l+" "+top_tool_t+"] %c WH=["+top_tool_w+" "+top_tool_h+"]"
                 ,                      lbL+lf6                              ,lbR+lf6                               );

    let bb_dx_dy = { t:0, l:0, r:0, b:0, dx:0, dy:0 };
    bb_dx_dy.t   = top_tool_t;
    bb_dx_dy.l   = top_tool_l;
    bb_dx_dy.b   = top_tool_t + top_tool_h;
    bb_dx_dy.r   = top_tool_l + top_tool_w;
    bb_dx_dy.dx  = w_W;
    bb_dx_dy.dy  = w_H;




if(log_this) log("....FROM BB %c TL "+ bb_dx_dy.t  +" "+ bb_dx_dy.l  +" %c BR "+ bb_dx_dy.b +" "+ bb_dx_dy.r +"%c DXY "+ bb_dx_dy.dx +" "+ bb_dx_dy.dy
                ,             lbL                                      ,lbC                                   ,lbR                                    );

    let gutter_w = h_W;
    let gutter_h = h_H;

    let view = { t:0, l:0, b:0, r:0 };
    view.t   = -gutter_w / 3;
    view.l   = -gutter_h / 3;
    view.r   =  w_W;
    view.b   =  w_H;

if(log_this) log("...VIEWPORT %c TL "+ view.t  +" "+ view.l  +" %c BR "+ view.b +" "+ view.r
                 ,            lbL                              ,lbR                         );

    let some_tools_to_unhide = t_sync6_collect_spreaded_tools_bounding_box(bb_dx_dy, view);


    if(spreaded_tools.length < 1)
    {
        bb_dx_dy.dx  = 0;
        bb_dx_dy.dy  = 0;

    }

if(log_this) log("......TO BB %c TL "+ bb_dx_dy.t  +" "+ bb_dx_dy.l  +" %c BR "+ bb_dx_dy.b +" "+ bb_dx_dy.r +"%c DXY "+ bb_dx_dy.dx +" "+ bb_dx_dy.dy
                ,             lbL                                      ,lbC                                   ,lbR                                    );


    if( some_tools_to_unhide )
    {
if(log_this) log(caller+": %c SOME TOOLS TO UNHIDE: %c "+some_tools_to_unhide, lbL, lbR);

        t_cache_armed_by(caller);
        t_cache_sync("Showing some tools");
        t_tools_set_top_xy(h_x, h_y);

        t_save_update_post("SOME TOOLS TO UNHIDE");
        return true;
    }


    if((bb_dx_dy.dx==0) && (bb_dx_dy.dy==0))
    {
if(log_this) log("- %c ALL TOOLS WITHIN VIEWPORT", lbH);

        t_toggle_pivot_PANEL_magnified( prop.get( t_data.PIVOT_MAGNIFIED ) );

        t_save_update_post("ALL TOOLS WITHIN VIEWPORT");
    }


    else {
if(log_this) log("- %c NO TOOLS WITHIN VIEWPORT: BOUNDING BOX: EXPANDED: %c "+t_bounding_box_toString(bb_dx_dy), lbH);

        let xy = t_util.get_el_xy(first_tool, caller);

        xy.x   = xy.x + bb_dx_dy.dx;
        xy.y   = xy.y + bb_dx_dy.dy;

        xy.x   = Math.max( -w_W, xy.x      );
        xy.y   = Math.max( -w_H, xy.y      );
        xy.x   = Math.min(       xy.x, w_W );
        xy.y   = Math.min(       xy.y, w_H );

if(log_this) log(                 "...hotspot: FROM %c XY "+  h_x +" "+  h_y, lbH);
if(log_this) log(                 "...hotspot: TO   %c XY "+ xy.x +" "+ xy.y, lbH);
if(log_this) log(caller+": %c CONFINE hotspot WITHIN VIEWPORT: t_tools_set_top_xy("+ xy.x  +" "+ xy.y +")", lbH);
        t_cache_armed_by(caller);
        t_cache_sync("Layout viewport");
        let position =  prop.get( t_data.TOOLS_SCROLL )  ? "absolute" : "fixed";
        t_tools_set_top_xy(xy.x, xy.y, position);

        t_save_update_post("CONFINE TO VIEWPORT");
    }

    return false;
};



let           spreaded_tools = [];

let t_sync6_collect_spreaded_tools_bounding_box = function(bb_dx_dy, view)
{
    let some_tools_to_unhide = "";
    spreaded_tools = [];
    for(let i=1; i < TOOL_panels.length; ++i)
    {
        let panel = TOOL_panels[i];
        if( panel && t_is_a_spreaded_tool(panel))
        {
            spreaded_tools.push(panel);

            if(panel.classList.contains(t_data.CSS_HIDDEN))
            {
                some_tools_to_unhide += panel.id+" ";

                del_el_class(panel, t_data.CSS_HIDDEN);
            }
            bb_dx_dy = t_sync6_expand_bounding_box(panel, bb_dx_dy, view);
        }
    }
    return some_tools_to_unhide;
};


let t_sync6_expand_bounding_box = function(panel, bb_dx_dy, view)
{
let   caller = "t_sync6_expand_bounding_box";
let log_this = LOG_MAP.T3_LAYOUT;





    let  xy = t_util.get_el_xy(    panel, caller);
    let map = t_tools_map_get(panel);


    map.w  = panel.offsetWidth;
    map.h  = panel.offsetHeight;
    let w = map.w;
    let h = map.h;

    let t  = xy.y;
    let l  = xy.x;
    let b  = t + parseInt(h);
    let r  = l + parseInt(w);


    let bb_changed = "";
    if( l < bb_dx_dy.l) { bb_dx_dy.l = l; bb_changed = " l"; }
    if( t < bb_dx_dy.t) { bb_dx_dy.t = t; bb_changed = " t"; }
    if( r > bb_dx_dy.r) { bb_dx_dy.r = r; bb_changed = " r"; }
    if( b > bb_dx_dy.b) { bb_dx_dy.b = b; bb_changed = " b"; }


    let dx = 0;
 if(r < view.l) dx = view.l - r;
 if(l > view.r) dx = view.r - l;


    let dy = 0;
 if(b < view.t) dy = view.t - b;
 if(t > view.b) dy = view.b - t;


    let el_dxy =          Math.abs(         dx) + Math.abs(         dy);
    let          bb_dxy = Math.abs(bb_dx_dy.dx) + Math.abs(bb_dx_dy.dy);
    let log_color = "color:#A33;";
    if( el_dxy < bb_dxy) {
        bb_dx_dy.dx = dx; bb_changed += " dx";
        bb_dx_dy.dy = dy; bb_changed += " dy";
        log_color = "background-color:#F22;";

    }

if(log_this) {

    log_key_val_group(caller+"( "+t_bounding_box_toString(bb_dx_dy)+" )"
                      , {   [get_n_lbl(panel)] : "tl "+         t +" "+ l           +" .. wh "+                   (r-l)+" "+(b-t)                   +" .. dxy "+          dx +" "+ dy
                          ,                 BB : "TL "+bb_dx_dy.t +" "+ bb_dx_dy.l  +" .. WH "+ (bb_dx_dy.r-bb_dx_dy.l)+" "+(bb_dx_dy.b-bb_dx_dy.t) +" .. DXY "+ bb_dx_dy.dx +" "+ bb_dx_dy.dy + " .. CHANGED ["+bb_changed+"]"
                          ,               view : "TL "+    view.t +" "+     view.l  +" .. WH "+ (    view.r-    view.l)+" "+(    view.b    -view.t)
                      }
                     , lf6, false);
}
    return bb_dx_dy;
};



let t_sync7_panel_magnified = function()
{

let   caller = "t_sync7_panel_magnified";
let log_this = LOG_MAP.EV7_DISPATCH || LOG_MAP.T3_LAYOUT;

if(log_this) log("%c"+caller, lbH+lf7);

    for(let i=0; i < TOOL_panels.length; ++i)
    {
        let                         panel = TOOL_panels[i];
        if(!panel) continue;
        if(t_is_panel_magnified(    panel ))
           t_layout_panel_magnified(panel , true);
    }
};


let t_bounding_box_toString = function(bb)
{
    return "TL=["+bb.t+" "+bb.l+"] BR=["+bb.b+" "+bb.r+"] dx_dy=["+bb.dx+" "+bb.dy+"]";
};


let t_pin_panel_at_XY = function(panel, x, y, position, zIndex)
{

let   caller = "t_pin_panel_at_XY";
let log_this = LOG_MAP.T0_STORE || LOG_MAP.T1_DOM_LOAD || LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"("+get_n_lbl(panel)+", ["+x+" "+y+"], position=["+position+"], zIndex=["+zIndex+"])");


    t_set_panel_at_XY(panel, x, y, zIndex);

    t_set_CSS_PINNED(panel, true);
};


let t_set_panel_at_XY = function(panel, x, y, position, zIndex)
{

let   caller = "t_set_panel_at_XY";
let log_this = LOG_MAP.T0_STORE || LOG_MAP.T1_DOM_LOAD || LOG_MAP.T3_LAYOUT;

if( log_this) log(caller+"("+get_n_lbl(panel)+", ["+x+" "+y+"], position=["+position+"], zIndex=["+zIndex+"])");


    if(position) panel.style.position = position;
    panel.style.left                  = x+"px"  ;
    panel.style.top                   = y+"px"  ;

    if( panel.style.display          == "none")
        panel.style.display           = "block";

    if(zIndex) panel.style.zIndex     = zIndex;


};




let t_is_a_tool_el = function(el, _caller)
{
let caller = "t_is_a_tool_el";
let log_this = LOG_MAP.EV0_LISTEN;

    if(!el) return   false;

    let result = "";
try {

    if(     t_seek.t_seeker_is_a_tool_el(el)                                  ) { result = el.id;                    }
    else if( el.id            &&  el.id.startsWith("cb_textArea")             ) { result = el.id;                    }

    else if( shadow_root && shadow_root.contains(el)                          ) { result = "A SHADOW ELEMENT";       }

    else {
        if     (   has_el_class(el,                        CSS_TOOLBAG_BUTTON)) { result = "A DOC TOOL";             }
        else if(   t_util.is_el_child_of_class   (el,      CSS_TOOLBAG_BUTTON)) { result = "A DOC TOOL CHILD";       }


        if(   result
           && t_is_an_embedded_doc_tool(el,log_this)
          ) {
if( log_this) log("%c "+t_util.get_id_or_tag(el)+" ["+CSS_EMBEDDED_DOC_TOOL+"]", lbH+lf8);

            result = "";
        }
    }
}
catch(ex) { log(caller+"("+get_n_lbl(el)+"):"+LF+ex); }

if( log_this) log("%c "+caller+"("+get_n_lbl(el)+") %c CALLED BY "+_caller+"%c ...return %c"+(result || "[]"),lbH, lbH, lbA, lbF);
if( log_this) console.dir(el);
    return result;
};


let is_a_tool_container = function(el)
{
    if(!el) return   false;
    let     result = false;
    if(el.parentNode.id == dom_tools_html.id) result =  true;

if(LOG_MAP.EV0_LISTEN) log("is_a_tool_container("+get_n_lbl(el)+"): ...return "+result);
    return result;
};


let is_a_movable_TOOL_CHILD = function(el)
{
let log_this = LOG_MAP.EV0_LISTEN;

    if(!el) return false;

    let rejected_reason = "";


    if     (                 t_isa_panel_pin(el)           ) rejected_reason = " .. (IS A PIN)";
    else if(!pat_bag                                       ) rejected_reason = " .. ([pat_bag] IS MISSSING)";
    else if(!pat_bag.contains(el)                          ) rejected_reason = " .. (NOT A [pat_bag] NODE )";

    else if(                 !el.className.includes("cc")  ) rejected_reason = " .. (IS A "+el.className+" SEL ITEM)";

    let result = (rejected_reason == "");

if(log_this) log("is_a_movable_TOOL_CHILD("+get_n_lbl(el)+"): %c...return "+result + rejected_reason, (result ? lb3 : lb8));
    return result;
};


let is_a_movable_panel = function(panel)
{
    if(!panel) return   false;
let log_this = LOG_MAP.EV0_LISTEN;

    let  reject_reason = "";

    if     (shadow_root   &&  !shadow_root.contains(panel)                            ) reject_reason = "NOT a [shadow_root] element";
    else if(dom_grid_html && dom_grid_html.contains(panel)                            ) reject_reason = "IS A [dom_grid_html] PANEL";

    else if(                 t_seek.t_seeker_is_a_tool_el( panel )                           ) reject_reason = panel.id;

    else if(                          dimm_mask_is( panel            )                ) reject_reason = panel.id;
    else if(                          dimm_mask_is( panel.parentNode )                ) reject_reason = panel.parentNode.id+" CHILD";

    else if(                                        panel.id.startsWith("cb_textArea")) reject_reason = panel.id;

    let result = (reject_reason == "");

if(log_this) log("%c is_a_movable_panel("+get_n_lbl(panel)+" "+panel.className+"): ...return "+result+" %c"+(reject_reason || panel.id), lb3,lbH+lfX[result ? 3:8]);
    return result;
};




let t_is_tool_deployed = function(el)
{
    if(!el) return false;
let log_this = LOG_MAP.T3_LAYOUT;

    let reject_reason = "";

    if     (el.classList.contains(t_data.CSS_HIDDEN)        || el.parentNode.classList.contains(t_data.CSS_HIDDEN       )) reject_reason = t_data.CSS_HIDDEN;
    else if(el.style.display   == "none"             || el.parentNode.style.display   == "none"            ) reject_reason = "display:none";
    else if(el.classList.contains(t_data.CSS_PINNED) || el.parentNode.classList.contains(t_data.CSS_PINNED)) reject_reason = t_data.CSS_PINNED;

    let result = (reject_reason == "");

if(log_this) log("%c t_is_tool_deployed("+get_n_lbl(el)+" "+el.className+"): ...return "+result+" %c "+reject_reason, lb7,lbF);
    return result;
};


let t_is_a_spreaded_tool = function(el)
{
let log_this = LOG_MAP.T3_LAYOUT;

    if(!el) return false;
    let reject_reason = "";


    if(el.classList.contains(t_data.CSS_PINNED) || el.parentNode.classList.contains( t_data.CSS_PINNED )) reject_reason = "PINNED";

    if(!t_tools_panel_is_selected(el))               reject_reason = "NOT SELECTED";

    let result = (reject_reason == "");

if(log_this) log("%c t_is_a_spreaded_tool("+get_n_lbl(el)+" "+el.className+"): ...return "+result+" %c "+reject_reason, lb7,lbF);
    return result;
};


let t_tools_panel_is_selected = function(panel)
{

let   caller = "t_tools_panel_is_selected";
let log_this = LOG_MAP.T2_GRID;



    let      map = panel? t_tools_map_get(panel):null;   let reject_reason = ""; let accept_reason; let  lfx = lf4;
    if     (!map                                         ) { reject_reason = "NO SUCH PANEL"; lfx = lf2; }
    else if(!map.selected) {
        let      tools_tier2  =  prop.get(t_data.TOOLS_TIER2);
        let is_a_tools_tier2  =  is_a_tools_el_tier(panel,2);

        if     (!tools_tier2 &&  is_a_tools_tier2)       { reject_reason =       "TIER2 TOOLS NOT SELECTED"; lfx = lf6; }
        else if( tools_tier2 && !is_a_tools_tier2)       { reject_reason = "NOT A TIER2 TOOL"              ; lfx = lf7; }
        else if( tools_tier2 &&  is_a_tools_tier2)       { accept_reason =  "IS A TIER2 TOOL"              ; lfx = lf7; }
        else                                             { reject_reason = "NOT SELECTED"                  ; lfx = lf0; }

        if(!reject_reason) accept_reason = ".. [tools_tier2 "+tools_tier2+"] .. [is_a_tools_tier2 "+is_a_tools_tier2+"]";
    }
    let selected = (reject_reason == "");
if( log_this && (reject_reason || accept_reason)) log(caller+" %c"+t_util.mPadStart(get_n_lbl(panel),18)+"%c"+t_util.mPadEnd(reject_reason || "SELECTED",15)+" "+(accept_reason || ""), lbH, lbH+lfx);
    return selected;
};


let t_get_next_selected_tool_panel = function(panel    ) { return t_get_near_selected_tool_panel(panel,  1); };
let t_get_prev_selected_tool_panel = function(panel    ) { return t_get_near_selected_tool_panel(panel, -1); };
let t_get_near_selected_tool_panel = function(panel,dir)
{
    let found_panel = false;

    let n_min = 1;
    let n_max = TOOL_panels.length;

    for(let n = n_min; n <= n_max; ++n)
    {
        let i = (dir > 0) ? n-1 : (n_max - n);
        let p = TOOL_panels[i];
        if(!found_panel) { found_panel = (p == panel); continue; }
        if(     t_tools_panel_is_selected(p         )
            &&  t_is_a_spreaded_tool     (p         )
        )
            return p;
    }
    return null;
};
let t_get_first_selected_tool_panel = function()
{
    for(let i=1; i< TOOL_panels.length; ++i) {
        let panel = TOOL_panels[i];
        if(    t_tools_panel_is_selected(panel)
            && t_is_a_spreaded_tool     (panel)
        )
            return panel;
    }
    return null;
};


let t_get_NW_NE_SE_SW_from_to = function(from_x,from_y, to_x,to_y)
{
    return ((from_y > to_y) ? "N" : "S")
        +  ((from_x > to_x) ? "W" : "E")
    ;
};


let t_trapped_dir_show = function(x,y)
{

    let nw_ne_se_sw = t_get_NW_NE_SE_SW_from_to(h_x, h_y, pivotXY.x, pivotXY.y);




    let rotate_className = "rotate_"+nw_ne_se_sw;

        set_el_class_removing(hotspot_c, rotate_className, t_sticky.CSS_ROTATE_XX);



        set_el_class_removing(pivspot_c, rotate_className, t_sticky.CSS_ROTATE_XX);



        let tools_trap_el = prop.get_EL(t_data.TOOLS_TRAP);
        if( tools_trap_el )
            set_el_class_removing(tools_trap_el, rotate_className, t_sticky.CSS_ROTATE_XX);




    let layout_className = "layout_"+nw_ne_se_sw;
    if(!has_el_class(hotring, layout_className))
    {
        del_el_class(hotring, t_sticky.CSS_LAYOUT_NE);
        del_el_class(hotring, t_sticky.CSS_LAYOUT_SE);
        del_el_class(hotring, t_sticky.CSS_LAYOUT_SW);
        del_el_class(hotring, t_sticky.CSS_LAYOUT_NW);

        add_el_class(hotring, layout_className);
    }


};


let t_set_CSS_PINNED = function(tool_el, pinned)
{

    if(pinned) {
        add_el_class(tool_el, t_data.CSS_PINNED      );
        del_el_class(tool_el, CSS_FULLY_SPREAD       );
    }
    else {
        del_el_class(tool_el, t_data.CSS_PINNED      );
        del_el_class(tool_el, t_data.CSS_BORDERING   );
    }


    if(pinned && has_el_class(tool_el, CSS_BUTTON_MAGNIFY))
        t_util.t_adjust_panel_transform_origin( tool_el );
};


let cache_PINNED_panels = function()
{
    let pinned_panels = [];
    for(const panel of TOOL_panels) {
        if(                        panel
           && !has_el_class(panel, t_data.CSS_HIDDEN)
           &&  has_el_class(panel, t_data.CSS_PINNED)
          )
            pinned_panels.push( panel );
    }
    t_view.t_view6_cache_PINNED_panels( pinned_panels );
};


let t_set_CSS_PIVOT_PANEL = function(tool_el, state)
{
    if(state) {
        add_el_class(tool_el, CSS_PIVOT_PANEL);
        del_el_class(tool_el, CSS_FULLY_SPREAD);
    }
    else {
        del_el_class(tool_el, CSS_PIVOT_PANEL);
    }
};


let t_set_CSS_FULLY_SPREAD = function(tool_el, state)
{
    if(state) {
        add_el_class(tool_el, CSS_FULLY_SPREAD);
    }
    else {
        del_el_class(tool_el, CSS_FULLY_SPREAD);
    }
};






let dom_scroll  = (function() {



const SCROLLED_INTO_VIEW     = "scrolled_into_view";
const SCROLLED_OVER_VIEW     = "scrolled_over_view";

const SCROLL_INTO_VIEW_DELAY = 500;
const SCROLL_RECENTER_DELAY  = 500;
const SCROLL_CONTAINER_DELAY = 500;

let t_scrollIntoView_EL;

let t_scroll_intoview_DONE_MS; let t_scroll_intoview_timer;
let t_scroll_recenter_DONE_MS; let t_scroll_recenter_timer;







const MAX_SCROLL_SMOOTH_DURATION = 20000;
const SCROLLED_ENOUGH                 =  16;
const SCROLL_DONE_COOLDOWN  =  250;
const WINDOW_SCROLLTO_BY_SCRIPT_DELAY = 500;

let scroll_end_timeout = null;
let scroll_last_scrollY   = 0;
let has_been_scrolled_by_script;
let onLong_press_scroll_freezed;
let sync_scroll_smooth_timeout;
let t_scroll_div_slot_containers_in_viewport_timeout;
let t_window_scrollTo_last_call_MS;




let has_scrolled;


let t_scroll_listener = function(e)
{

let caller = "t_scroll_listener";
let log_this = LOG_MAP.EV1_DOWN;

if(log_this || LOG_MAP.EV7_DISPATCH) t_fly.t_log_event_status_if_changed_filter(caller, "scroll", lf6);
    let scrolled_by_script = "";

    has_scrolled = (Math.abs(window.scrollY - onDown_SCROLL_XY.y) > SCROLLED_ENOUGH);


    if( onLong_press_scroll_freezed )
    {
        window.scrollTo(  onDown_SCROLL_XY.x,  onDown_SCROLL_XY.y);

        return;
    }


    if( div_slot_containers_displayed() )
    {
        if(!has_el_class(div_slot_containers, dom_scroll.SCROLLED_INTO_VIEW) )
        {
            scrolled_by_script += "WAITING FOR CONTAINERS INTO VIEW";

            let rect = div_slot_containers.getBoundingClientRect();
            div_slot_containers.on_grid_height = parseInt(rect.bottom - rect.top);

if( log_this) log("%c"+caller+"%c div_slot_containers.height %c"+div_slot_containers.on_grid_height, lbL, lbC, lbR);
        }
        else {

            if((window.scrollY + window.innerHeight) > div_slot_containers.on_grid_height)
            {
if( log_this) log(caller+": ...t_window_scrollTo(0, "+div_slot_containers.on_grid_height +"- "+window.innerHeight+")");

                add_el_class(div_slot_containers, dom_scroll.SCROLLED_OVER_VIEW);

                t_window_scrollTo(0, div_slot_containers.on_grid_height - window.innerHeight);
            }
            else {
                del_el_class(div_slot_containers, dom_scroll.SCROLLED_OVER_VIEW);
            }

            return;
        }
    }


    let scrolled_by_user   = "";
    let this_MS            = new Date().getTime();



    if( t_window_scrollTo_last_call_MS )
    {
        let elapsed = this_MS - t_window_scrollTo_last_call_MS;
        if( elapsed < WINDOW_SCROLLTO_BY_SCRIPT_DELAY) {
            scrolled_by_script += " .. WITHIN SCROLL_BY_SCRIPT DELAY OF "+WINDOW_SCROLLTO_BY_SCRIPT_DELAY+"ms";

if( log_this) log("%c"+caller+"%c WINDOW SCROLL %c ENDED "+elapsed+"ms AGO"
                  ,lbL+lf8    ,lbC+lf9         ,lbR+lf3);
        }


    }


    if( dom_scroll.t_scroll_intoview_DONE_WITHIN_SCRIPT_DELAY(this_MS) )
    {
        scrolled_by_script += " .. INTO VIEW";
    }


    if( dom_scroll.t_scroll_recenter_DONE_WITHIN_SCRIPT_DELAY(this_MS) )
    {
        scrolled_by_script += " .. RECENTER";
    }


    if( t_hide.dom_hide4_scroll_to_last_hidden_handled_recently(WINDOW_SCROLLTO_BY_SCRIPT_DELAY) )
    {
        scrolled_by_script += " .. TO LAST HIDDEN NODE";

    }


    if( !scrolled_by_script )
    {
        if( dom_scroll.t_scrollIntoViewIfNeeded_pending() ) {
if( log_this) log("%c SCROLLED BY USER %c CLEAR SCROLL INTO VIEW AND RECENTER", lbL+lf8, lbR+lf9);

            dom_scroll.t_scrollIntoViewIfNeeded( null );
        }

        if( t_hide.dom_hide4_scroll_to_last_hidden_is_pending() ) {
if( log_this) log("%c SCROLLED BY USER %c CLEAR SCROLL TO LAST HIDDEN HANDLER", lbL+lf8, lbR+lf9);

            t_hide.dom_hide4_scroll_to_last_hidden( null );
        }
    }



    if( t_sticky.t_sticky_EDITING() )
        t_sticky.t_sticky_EDIT_DONE();

    if( t_sticky.t_sticky_reorder_required_on_scroll() )
        t_sticky.t_sticky_reorder();

    t_window_getSelection_removeAllRanges();






if( log_this && scrolled_by_script) log("%c"+caller+" %c "+scrolled_by_script, lbb+lbL+lf8, lbb+lbR+lf3);
if( log_this && scrolled_by_user  ) log("%c"+caller+" %c "+scrolled_by_user  , lbb+lbL+lf7, lbb+lbR+lf3);
    scroll_listener_scroll_changed(e, scrolled_by_script);
};


let get_has_scrolled = function()
{
    return has_scrolled;
};


let clr_has_scrolled = function()
{
    has_scrolled = false;
};


let t_scroll_div_slot_containers_in_viewport = function(scrolled_by_script)
{


    if(t_scroll_div_slot_containers_in_viewport_timeout) return;


    if(!scrolled_by_script)
    {
        del_el_class(div_slot_containers, dom_scroll.SCROLLED_INTO_VIEW);
        add_el_class(div_slot_containers, dom_scroll.SCROLLED_OVER_VIEW);

        t_scroll_div_slot_containers_in_viewport_timeout
            = setTimeout(
                         function() {
                             t_scroll_div_slot_containers_in_viewport_timeout = null;

                             let scrollY_max = BOX_MARGIN + div_slot_containers.offsetHeight - window.innerHeight;
                             if(window.scrollY > scrollY_max)
                                 t_window_scrollTo(window.scrollX, scrollY_max, "instant");
                         }
                         , WINDOW_SCROLLTO_BY_SCRIPT_DELAY);
    }

};





let t_window_scrollTo = function(x, y, scrollBehavior)
{

    scrollBehavior =                         scrollBehavior
        || (prop.get(t_data.SCROLL_SMOOTH) ? "smooth"
            :                                "instant");
    set_scrollBehavior( scrollBehavior );


    x *= (body_zoom_percent  / 100);
    y *= (body_zoom_percent  / 100);
    window.scrollTo(x, y);




    if(sync_scroll_smooth_timeout) clearTimeout( sync_scroll_smooth_timeout );
    sync_scroll_smooth_timeout   =   setTimeout( sync_scroll_smooth, MAX_SCROLL_SMOOTH_DURATION);


    onMoveDXY.x = 0;
    onMoveDXY.y = 0;
};


let set_scrollBehavior = function(scrollBehavior)
{
    let html  = document.getElementsByTagName("HTML")[0];

    let state = (scrollBehavior == "smooth");

    set_el_class_on_off(html, t_data.SCROLL_SMOOTH, state);


};


let sync_scroll_smooth = function()
{

    sync_scroll_smooth_timeout = null;

    let html  = document.getElementsByTagName("HTML")[0];

    let state = prop.get( t_data.SCROLL_SMOOTH );

    set_el_class_on_off(html, t_data.SCROLL_SMOOTH, state);


};


let scroll_listener_scroll_changed = function(e, scrolled_by_script="")
{

let   caller = "scroll_listener_scroll_changed";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller +": ["+ window.scrollX +" "+ window.scrollY +"]"+ (scrolled_by_script ? " scrolled_by_script" : "") + (container_selected ? " container_selected=["+t_util.get_id_or_tag(container_selected)+" "+t_util.get_n_txt(container_selected)+"]" : ""));


    if(scrolled_by_script && !has_been_scrolled_by_script && (Math.abs(window.scrollY - onDown_SCROLL_XY.y) > SCROLLED_ENOUGH))
    {
        has_been_scrolled_by_script = "HAS SCROLLED .. abs("+(window.scrollY - onDown_SCROLL_XY.y)+") > "+ SCROLLED_ENOUGH;
    }

    t_set_has_moved(has_been_scrolled_by_script || caller);

    if(!t_seek.t_seeker_sync_is_pending() )
        t_seek.t_seeker_sync();


    if( div_slot_containers_displayed() )
    {

        if(dimm_mask.firstElementChild == div_slot_containers)
        {

            if( scrolled_by_script )
            {
if( log_this) logBIG(caller+": "+ scrolled_by_script +" .. SCROLL INTO VIEW", lf4);

                dom_scroll.t_scrollIntoViewIfNeeded_dimm_mask_container_selected( dimm_mask.firstElementChild );
            }

            else if( dom_scroll.t_scrollIntoViewIfNeeded_pending() )
            {
if( log_this) logBIG(caller+": "+ scrolled_by_script +" .. SCROLL INTO VIEW CANCELED", lf5);

                dom_scroll.t_scrollIntoViewIfNeeded_dimm_mask_container_selected( null );
            }
        }

    }

    if(container_selected)
        t_seek.t_seekzone7_show_container( container_selected );



    if( toolbar_thumb )
    {

        let thumb_p             = 100 * window.scrollY / t_util.getPageHeight();
        let thumb_p_str         = t_select.t_get_thumb_p_str(thumb_p);
        toolbar_thumb.innerHTML = thumb_p_str.replace(" ","&nbsp;");
    }


    if(!scroll_end_timeout)
    {



        scroll_end_timeout = setTimeout(scroll_check_handler, SCROLL_DONE_COOLDOWN);
    }

};


let scroll_check_handler     = function()
{

let   caller = "scroll_check_handler";
let log_this = LOG_MAP.T3_LAYOUT;

    scroll_end_timeout = null;

    let                this_scrollY  =      window.scrollY;
    let done_moving = (this_scrollY == scroll_last_scrollY);
    if( done_moving )
    {

        dom_scroll.t_scrollIntoView_EL_reset();



        t_clr_has_moved("scroll_check_handler");




if( log_this) log("%c TODO %c scroll_done_collect_nodes_in_view", lbb+lbL+lf2, lbb+lbR+lf8);


        t_store.t_store_set_value("window_scrollY", scroll_last_scrollY);



    }
    else {

        scroll_last_scrollY  = this_scrollY;
        scroll_end_timeout = setTimeout(scroll_check_handler, SCROLL_DONE_COOLDOWN);


    }
};


let t_scroll_not_done_yet = function()
{
    return (scroll_end_timeout != null);
};



let nodes_in_view_array         = [];


let scroll_done_collect_nodes_in_view = function(dir)
{

let   caller = "scroll_done_collect_nodes_in_view";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c TODO %c "+caller, lbb+lbL+lf2, lbb+lbR+lf8);

if( log_this) console.time(caller);


    let view_T = window.scrollY;
    let view_B = window.scrollY+ window.innerHeight;

if( log_this) log("...view_T=["+ view_T +"]");
if( log_this) log("...view_B=["+ view_B +"]");


    for(let i = 1; i <= nodes_in_view_array.length; ++i)
        del_el_class(   nodes_in_view_array[i], t_data.CSS_VIEWABLE);



    nodes_in_view_array = [];
    for(let slot = 1; slot < t_select.ccs.length; ++slot)
    {

        let num_max = t_select.t_select_get_slot_nodes_length(slot);
        if(!t_select.ccs[slot] || (num_max < 1)) continue;

        for(let num = 1; num <= num_max; ++num)
        {
            let       node    = t_select.ccs[slot].nodes[num-1];
            let       node_T  = t_util.getInPageTop( node );
            let       node_B  = node_T + node.offsetHeight;
            if(      (node_T >= view_T)
                  && (node_B <= view_B)
              ) {
                nodes_in_view_array.push( node );
                add_el_class(node, t_data.CSS_VIEWABLE);

if( log_this) log(". "+nodes_in_view_array.length+": slot["+slot+"] num["+num+"]");
            }
        }

    }

if( log_this) console.time(caller);
if( log_this) console.timeEnd(caller);
};



let get_has_been_scrolled_by_script = function()
{
    return has_been_scrolled_by_script;
};


let clr_has_been_scrolled_by_script = function()
{
    has_been_scrolled_by_script  = "";
};


let set_onLong_press_scroll_freezed = function(state)
{
    onLong_press_scroll_freezed = state;
};


let get_scroll_last_scrollY = function()
{
    return scroll_last_scrollY;
};



let t_scrollIntoViewIfNeeded = function(el, delay)
{
    let to_the_top = (onWork_EL == null);

    scrollIntoViewIfNeeded(el, delay, to_the_top);
};


let   scrollIntoViewIfNeeded = function(el, delay, to_the_top)
{

let   caller = "scrollIntoViewIfNeeded";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) log("%c "+caller+" %c "+t_util.get_id_or_tag(el)+"%c el.scrolledIntoViewHandled "+el.scrolledIntoViewHandled+"%c delay "+delay
                  ,lbL+lf4      ,lbR+lf4                       ,lbH+lfX[el.scrolledIntoViewHandled ? 5 : 6]                ,lbH+lf9         );



    t_scrollIntoViewIfNeeded_cancel(caller);

    t_scrollIntoView_EL                 = el;
    if(t_scrollIntoView_EL)
    {


            set_scrollBehavior( "instant" );
            t_scrollIntoView_EL.scrollIntoView({ block:"nearest", behavior:"auto" });
            sync_scroll_smooth();



        t_scrollIntoView_EL.to_the_top  = to_the_top;
        delete t_scrollIntoView_EL.scrolledIntoViewHandled;

        if( delay == undefined)   delay = SCROLL_INTO_VIEW_DELAY;

        if( delay ) t_scroll_intoview_timer = setTimeout(scrollIntoViewIfNeeded_handler, delay);
        else                                             scrollIntoViewIfNeeded_handler();
    }
    else {
        t_scroll_intoview_timer = null;
    }
};


let t_scrollIntoViewIfNeeded_pending = function()
{
    return (t_scroll_intoview_timer != null)
        || (t_scroll_recenter_timer != null)
    ;
};


let t_scrollIntoViewIfNeeded_cancel = function(_caller)
{

let   caller = "t_scrollIntoViewIfNeeded_cancel";
let log_this = LOG_MAP.EV0_LISTEN;



    if( t_scrollIntoView_EL ) {
        delete t_scrollIntoView_EL.scrolledIntoViewHandled;
        delete t_scrollIntoView_EL.to_the_top;
        t_scrollIntoView_EL = null;
    }

    if( t_scroll_intoview_timer )
    {
if( log_this) log(caller+": PENDING SCROLL INTERRUPTED BY "+ _caller);
        clearTimeout( t_scroll_intoview_timer );
    }

    if( t_scroll_recenter_timer )
    {
if( log_this) log(caller+": PENDING RECENTER INTERRUPTED BY "+ _caller);
        clearTimeout(t_scroll_recenter_timer);
        t_scroll_recenter_timer = null;
    }

    t_seek.t_seeker_move_above_XY_cancel(caller);

};



let scrollIntoView_was_needed;


let   scrollIntoViewIfNeeded_handler = function()
{

let   caller = "scrollIntoViewIfNeeded_handler";
let log_this = LOG_MAP.EV0_LISTEN;

    t_scroll_intoview_timer = null;
    if(!t_scrollIntoView_EL) return;

    let el = t_scrollIntoView_EL;
if( log_this) log("%c "+caller+" %c "+t_util.get_id_or_tag(el)+"%c el.scrolledIntoViewHandled "+el.scrolledIntoViewHandled
                  ,lbL+lf4      ,lbR+lf4                       ,lbH+lfX[el.scrolledIntoViewHandled ? 5 : 6]        );


    if( el.scrolledIntoViewHandled )
    {
        let      this_MS = new Date().getTime();
        let since_handled = this_MS - el.scrolledIntoViewHandled;
        let  just_handled = (since_handled < SCROLL_RECENTER_DELAY*3);

if( log_this) log("%c  just_handled=["+just_handled+"] "+parseInt(since_handled / 1000)+"s", lbH+lfX[just_handled ? 8:7]);

        if( just_handled ) return;
    }

    el.scrolledIntoViewHandled = new Date().getTime();
if( log_this) log("%c el.scrolledIntoViewHandled=["+el.scrolledIntoViewHandled+"]", lbH+lf6);



    let xy = scrollIntoViewIfNeeded_get_scrollXY( el );
    if(!xy) {
        delete el.to_the_top;

        return;
    }


    if((window.scrollX == xy.x) && (window.scrollY == xy.y))
    {


        scrollIntoView_was_needed = false;
if( log_this) log("%c scrollIntoView_was_needed=["+scrollIntoView_was_needed+"]", lbH+lf8);
    }


    else {
        scrollIntoView_was_needed = true;
if( log_this) log("%c scrollIntoView_was_needed=["+scrollIntoView_was_needed+"]", lbH+lf8);

if( log_this) t_fly.t_log_event_status(caller);
if( log_this) log("SCROLL INTO VIEW %c DX=["+window.scrollX+" "+t_data.SYMBOL_RIGHT_ARROW+" "+xy.x+"] %c DY=["+window.scrollY+" "+t_data.SYMBOL_RIGHT_ARROW+" "+xy.y+"]"
                  ,                 lbL+lf9                                                          ,lbR+lf9                                                    );


        t_scroll_intoview_DONE_MS = new Date().getTime();

        let scrollBehavior = prop.get( t_data.SCROLL_SMOOTH ) ? "smooth" : "instant";
        t_window_scrollTo(xy.x, xy.y, scrollBehavior);
    }



    if(scrollIntoView_was_needed && !t_scrollIntoView_EL.to_the_top)
    {
        if(!t_scroll_recenter_timer && prop.get(t_data.SHOW_SEEKZONE)) {
if( log_this) logBIG("RECENTERING");

            t_scroll_recenter_timer = setTimeout(scrollIntoViewIfNeeded_then_recenter_handler, SCROLL_RECENTER_DELAY);
        }

    }
    delete el.to_the_top;
};


let   scrollIntoViewIfNeeded_then_recenter_handler = function()
{

let   caller = "scrollIntoViewIfNeeded_then_recenter_handler";
let log_this = LOG_MAP.EV0_LISTEN;

if( log_this) log("%c "+caller+" %c "+t_util.get_id_or_tag(t_scrollIntoView_EL), lbL+lf6,lbR+lf6);


    if( t_seek.t_seeker_PU_is_looking_somewhere() )
        rearm_long_press_listener_onScrollIntoView();


    if( !t_scrollIntoView_EL) return;
    let el = t_scrollIntoView_EL;

    t_scroll_recenter_timer   = null;
    t_scroll_recenter_DONE_MS = new Date().getTime();

    let xy = t_util.get_el_xy(el, caller);
    if(!xy ) return;

    let e_W = el.clientWidth  || el.offsetWidth;
    let e_H = el.clientHeight || el.offsetHeight;

    xy.x    = xy.x
        +     e_W/2
        -     w_W/2
    ;

    xy.y    = xy.y
        +     e_H/2
        -     w_H/2
    ;



    if((window.scrollX != xy.x) || (window.scrollY != xy.y))
    {
        scrollIntoView_was_needed = true;
if( log_this) t_fly.t_log_event_status("SCROLL RECENTER  DX=["+window.scrollX+" .. "+xy.x+"] .. DY=["+window.scrollY+" .. "+xy.y+"]", lf6);
        if( onWork_EL )
        {

        }
        else {

            let scrollBehavior = prop.get( t_data.SCROLL_SMOOTH ) ? "smooth" : "instant";
            t_window_scrollTo(xy.x, xy.y, scrollBehavior);
        }
    }


    else {
        scrollIntoView_was_needed = false;
if( log_this) log("%c SCROLL RECENTER NOT NEEDED %c "+window.scrollX+" "+window.scrollY, lbb+lbH+lf6, lbb+lbH+lf6);

    }

};



let t_scrollIntoViewIfNeeded_get_scrollXY_with_margin = function(el)
{
    return scrollIntoViewIfNeeded_get_scrollXY_with_options({ container:el , with_margin:true });
};


let   scrollIntoViewIfNeeded_get_scrollXY_with_options = function({ container, with_margin=true })
{

let caller = "scrollIntoViewIfNeeded_get_scrollXY_with_options";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) t_fly.t_log_event_status(caller+"(container=["+t_util.get_id_or_tag(container)+"] , [with_margin "+with_margin+"])", lf5);



    w_W = window.innerWidth ;
    w_H = window.innerHeight;
    let view_rect
        = {   left   : window.scrollX       + (with_margin ? t_data.VIEWPORT_MARGIN.left   : 16)
            , top    : window.scrollY       + (with_margin ? t_data.VIEWPORT_MARGIN.top    : 16)
            , right  : window.scrollX + w_W - (with_margin ? t_data.VIEWPORT_MARGIN.right  : 32)
            , bottom : window.scrollY + w_H - (with_margin ? t_data.VIEWPORT_MARGIN.bottom : 32)
        };

    view_rect.height
        = view_rect.bottom
        - view_rect.top
    ;


    let xy = t_util.get_el_xy(container, caller);

    if(!xy) return null;

    let e_W = container.clientWidth  || container.offsetWidth;
    let e_H = container.clientHeight || container.offsetHeight;

    let el_rect
        = { left   : xy.x
        ,   top    : xy.y
        ,   right  : xy.x + e_W
        ,   bottom : xy.y + e_H
    };

    el_rect.height
        = el_rect.bottom
        - el_rect.top
    ;


    let added_seeker_height_atop = 0;
    if(t_seek.t_seeker_PU_is_active())
    {
        added_seeker_height_atop = t_seek.t_seeker_get_seeker_PU_height();

    }


    el_rect.seekTop
        =  el_rect.top
        -  added_seeker_height_atop
    ;
    let over_left      = (el_rect.left    < view_rect.left  );
    let over_top       = (el_rect.seekTop < view_rect.top   );
    let over_right     = (el_rect.right   > view_rect.right );
    let over_bottom    = (el_rect.bottom  > view_rect.bottom);
    let on_sentence    = has_el_class(container, t_sentence.CSS_SENTENCE_CONTAINER);

    let over_something
        = (over_top    ? "T":"")
        + (over_left   ? "L":"")
        + (over_right  ? "R":"")
        + (over_bottom ? "B":"");

    let may_go_left    = (el_rect.right  < window.innerWidth);
if(log_this) {
    log_key_val_group("to_the_top .. over_something=["+over_something+"]"
                      , {   container
                          , on_sentence
                          , added_seeker_height_atop
                          , el_rect
                          , e_H
                          , view_rect
                          , window_scrollY : window.scrollY
                          , over_something : ((over_top ? "T":"_")+(over_left ? "L":"_")+(over_right ? "R":"_")+(over_bottom ? "B":"_"))
                      }, lfX[over_something ? 7:8], false);
}



    if(!!!over_something) return null;



    let scrollX
        = (over_left  ) ? el_rect.left                         - (with_margin ? t_data.VIEWPORT_MARGIN.left   : 16)
        : (over_right ) ? el_rect.right   - window.innerWidth  + (with_margin ? t_data.VIEWPORT_MARGIN.right  : 32)
        : may_go_left   ?                          0
        :                                          window.scrollX;
    scrollX = Math.max(scrollX, 0);

    let scrollY
        = (on_sentence ) ? el_rect.seekTop                     - (with_margin ? t_data.VIEWPORT_MARGIN.top    : 16)
        : (over_top    ) ? el_rect.seekTop                     - (with_margin ? t_data.VIEWPORT_MARGIN.top    : 16)
        : (over_bottom ) ? el_rect.bottom - window.innerHeight + (with_margin ? t_data.VIEWPORT_MARGIN.bottom : 32)
        :                                          window.scrollY;
    scrollY = Math.max(scrollY, 0);



    if(container.to_the_top && over_bottom)
    {
        let scroll_more
            =  view_rect.height
            - (el_rect.height + added_seeker_height_atop);

if(log_this)
        log_key_val_group("to_the_top .. scroll_more=["+scroll_more+"]"
                          , {   container
                              , view_rect
                              , el_rect
                              , window_scrollY      : window.scrollY
                              , over_something      : ((over_top ? "T":"_")+(over_left ? "L":"_")+(over_right ? "R":"_")+(over_bottom ? "B":"_"))
                              , scrollY
                              , scroll_more
                              , scrollY_scroll_more : (scrollY + scroll_more)
                          }, lfX[over_something ? 7:8], false);


        scrollY += scroll_more;
    }

    let    result = { x : scrollX , y : scrollY };
    return result;
};


let   scrollIntoViewIfNeeded_get_scrollXY = function(el)
{
    return scrollIntoViewIfNeeded_get_scrollXY_with_options({ container:el , with_margin:false });
};



let t_scroll_recenter_DONE_WITHIN_SCRIPT_DELAY = function(this_MS)
{
    if(!t_scroll_recenter_DONE_MS ) return false;

    let elapsed = this_MS - t_scroll_recenter_DONE_MS;
    t_scroll_recenter_DONE_MS = 0;

    return elapsed < WINDOW_SCROLLTO_BY_SCRIPT_DELAY;
};


let t_scroll_intoview_DONE_WITHIN_SCRIPT_DELAY = function(this_MS)
{
    if(!t_scroll_intoview_DONE_MS ) return false;

    let elapsed = this_MS - t_scroll_intoview_DONE_MS;
    t_scroll_intoview_DONE_MS = 0;

    return elapsed < WINDOW_SCROLLTO_BY_SCRIPT_DELAY;
};




let t_scrollIntoViewIfNeeded_dimm_mask_container_selected_timer;

let el_to_mark_SCROLLED_INTO_VIEW;

let   t_scrollIntoViewIfNeeded_dimm_mask_container_selected = function(el)
{

let   caller = "t_scrollIntoViewIfNeeded_dimm_mask_container_selected";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c "+caller+" %c "+t_util.get_id_or_tag(el), lbL+lf4,lbR+lf4);


    el_to_mark_SCROLLED_INTO_VIEW = el;

    if(    t_scrollIntoViewIfNeeded_dimm_mask_container_selected_timer) clearTimeout( t_scrollIntoViewIfNeeded_dimm_mask_container_selected_timer );
    if(el) t_scrollIntoViewIfNeeded_dimm_mask_container_selected_timer =  setTimeout( scrollIntoViewIfNeeded_dimm_mask_container_selected_handler, SCROLL_CONTAINER_DELAY);
};


let   scrollIntoViewIfNeeded_dimm_mask_container_selected_handler = function()
{

let   caller = "scrollIntoViewIfNeeded_dimm_mask_container_selected_handler";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);



    let containers                      =  dimm_mask.firstElementChild;
if( log_this) t_log.console_dir("dimm_mask.firstElementChild", containers    );

    if(!containers                       ) return;
    if( containers != div_slot_containers) return;


    let                       container =  containers.firstElementChild;
if( log_this) t_log.console_dir("containers.firstElementChild",     container );


    while(container && !has_el_class(container , CSS_CONTAINER_SELECTED))
        container =                  container .  nextElementSibling;


if( log_this) t_log.console_dir("container", container);
    if(container &&  has_el_class(container, CSS_CONTAINER_SELECTED)) t_scrollIntoViewIfNeeded( container );

    t_scrollIntoViewIfNeeded_dimm_mask_container_selected_timer = null;
};



let t_scrollIntoView_EL_reset = function()
{

let   caller = "t_scrollIntoView_EL_reset";
let log_this = LOG_MAP.T3_LAYOUT;


    if(t_scrollIntoView_EL) delete t_scrollIntoView_EL.scrolledIntoViewHandled;

    if( el_to_mark_SCROLLED_INTO_VIEW )
    {
if( log_this) log("%c"+caller+" %c ["+t_util.get_id_or_tag(el_to_mark_SCROLLED_INTO_VIEW) +"] SCROLLED_INTO_VIEW DONE", lbb+lbL+lf8, lbb+lbR+lf3);

        del_el_class(el_to_mark_SCROLLED_INTO_VIEW, SCROLLED_OVER_VIEW);
        add_el_class(el_to_mark_SCROLLED_INTO_VIEW, SCROLLED_INTO_VIEW);

        el_to_mark_SCROLLED_INTO_VIEW = null;
    }
};


let t_scrollIntoView_was_needed = function()
{
    return scrollIntoView_was_needed;
};


let t_scrollIntoView_was_needed_reset = function()
{
    scrollIntoView_was_needed = false;
};



return { name : "dom_scroll"


    ,    clr_has_been_scrolled_by_script
    ,    get_has_scrolled
    ,    clr_has_scrolled
    ,    get_has_been_scrolled_by_script
    ,    get_scroll_last_scrollY
    ,    scroll_listener_scroll_changed
    ,    set_onLong_press_scroll_freezed
    ,    t_scroll_div_slot_containers_in_viewport
    ,    t_scroll_listener
    ,    t_scroll_not_done_yet
    ,    t_window_scrollTo

    ,    SCROLLED_INTO_VIEW
    ,    SCROLLED_OVER_VIEW

    ,    t_scrollIntoViewIfNeeded
    ,    t_scrollIntoViewIfNeeded_cancel
    ,    t_scrollIntoViewIfNeeded_dimm_mask_container_selected
    ,    t_scrollIntoViewIfNeeded_get_scrollXY_with_margin
    ,    t_scrollIntoViewIfNeeded_pending

    ,    t_scrollIntoView_EL
    ,    t_scrollIntoView_EL_reset

    ,    t_scrollIntoView_was_needed
    ,    t_scrollIntoView_was_needed_reset

    ,    t_scroll_intoview_DONE_WITHIN_SCRIPT_DELAY
    ,    t_scroll_recenter_DONE_WITHIN_SCRIPT_DELAY

};
}());






let t_get_event_status_object = function()
{
    let onSeekXYL = t_seek.t_seeker_get_onSeekXYL();
    let has_been_scrolled_by_script = dom_scroll.get_has_been_scrolled_by_script();

    return {              captured_by : (t_preventDefault_caller ? (t_preventDefault_caller ) : "" )
        ,                 consumed_by : (t_event_consumed_cause  ? (t_event_consumed_cause  ) : "" )
        ,              window_scrollY :                             window.scrollY
        , has_been_scrolled_by_script :                            (has_been_scrolled_by_script ?                      has_been_scrolled_by_script : "NO")
        ,                   has_moved :                            (has_moved                   ? has_moved.replace(":",":"+LF+t_data.SYMBOL_RIGHT_ARROW) : "NO")
        ,                   onSeekXYL : t_util.strip_CR_LF(onSeekXYL.label)+" XY=["+onSeekXYL.x+" "+onSeekXYL.y+"]"
        ,                 was_a_click :                            (was_a_click()               ? "YES" : "NO")
        ,          selection_progress :                            (get_SELECTION_PROGRESS()    ? "YES" : "NO")
    };
};


let t_get_tools_status_object = function()
{



    let tool_details = "";
    if( t_is_a_tool_el(onWork_EL, "log_get_tools_status_object") )
    {
        let sticky = t_sticky.t_sticky_get_onWork_STICKY();
        tool_details
            = (onWork_EL.tagName != "DIV") ? "["+ onWork_EL.textContent +"]"
            : (onWork_EL      == sticky  ) ? "A STICKY TOOL .. SEEK_NEXT "+ get_n_lbl( t_sticky.t_sticky_get_SEEK_NEXT() )
            :                                "A TOOL BAG"
        ;
    }
    else {
        tool_details  = "NOT A TOOL";
    }

    return { onDown_EL             : get_n_lbl(            onDown_EL )
        ,    onWork_EL             : get_n_lbl(            onWork_EL )
        ,    onWork_EL_last_used   : get_n_lbl( onWork_EL_last_used  )
        ,    onWork_PANEL          : get_n_lbl( onWork_PANEL         )+" .. MOVABLE CHILD ["+ get_n_lbl( onWork_MOVABLE_CHILD  )+"]"
        ,    onWork_MOVABLE_PANEL  : get_n_lbl( onWork_MOVABLE_PANEL )+" .. PIVOT PANEL ["+   get_n_lbl( pivot_PANEL           )+"]"
        ,    onWork_SEEK_TARGET      : t_seek.t_seeker_get_TOOL_label()
        ,    seeker_isOn_SLOT_EL   : t_seek.t_seeker_isOn_SLOT_EL()
        ,    tool_details
    };

};




const CSS_NOT_MOVED_ENOUGH = "not_moved_enough";



let t_add_NOT_MOVED_ENOUGH   = function()
{
    add_el_class(  hotspot   , CSS_NOT_MOVED_ENOUGH);
    drag_cursor.add_drag_cursor_CSS_NOT_MOVED_ENOUGH();
};


let t_del_NOT_MOVED_ENOUGH   = function()
{
    del_el_class(  hotspot   , CSS_NOT_MOVED_ENOUGH);
    drag_cursor.del_drag_cursor_CSS_NOT_MOVED_ENOUGH();
};





const CSS_MOVE_ON_COOLDOWN = "move_on_cooldown";

let move_on_cooldown_timer;


let t_add_MOVE_ON_COOLDOWN   = function(time_left)
{
    if( move_on_cooldown_timer ) return;

move_on_cooldown_timer =   setTimeout(t_del_MOVE_ON_COOLDOWN, time_left);
    add_el_class(  hotspot   , CSS_MOVE_ON_COOLDOWN);
    drag_cursor.add_drag_cursor_CSS_MOVE_ON_COOLDOWN();
};


let t_del_MOVE_ON_COOLDOWN = function()
{
    if(!move_on_cooldown_timer ) return;

let log_this = LOG_MAP.EV2_MOVE;

if(log_this) log("t_del_MOVE_ON_COOLDOWN");

    if( move_on_cooldown_timer) clearTimeout( move_on_cooldown_timer );
move_on_cooldown_timer = null;
    del_el_class(  hotspot   , CSS_MOVE_ON_COOLDOWN);
    drag_cursor.del_drag_cursor_CSS_MOVE_ON_COOLDOWN();

    zap_onMoveDXY();
};








const PATTERN_SEPARATOR     = "|";
const PATTERN_SEPARATOR_LEN = PATTERN_SEPARATOR.length;



let t_pattern_to_sel_text_words_option = function(pattern)
{

let caller = "t_pattern_to_sel_text_words_option";
let log_this = LOG_MAP.S2_SELECT;



    let len
        =   pattern.length;

    let result
        = { pattern
          , len
          , PATTERN_SEPARATOR
          , PATTERN_SEPARATOR_LEN
        };


    let sel_text     = pattern;
    let words_option = get_current_words_option();

    let    idx  = pattern.lastIndexOf(PATTERN_SEPARATOR);
    let    sfx  = (idx > 0) ? pattern.substring(idx+PATTERN_SEPARATOR_LEN) : "";
    switch(sfx) {
    case   "E": words_option = t_data.WORDS_EXACT    ; sel_text = sel_text.substring(0,len-PATTERN_SEPARATOR_LEN-1); break;
    case   "S": words_option = t_data.WORDS_SEGMENT  ; sel_text = sel_text.substring(0,len-PATTERN_SEPARATOR_LEN-1); break;
    case   "H": words_option = t_data.WORDS_HEAD_TAIL; sel_text = sel_text.substring(0,len-PATTERN_SEPARATOR_LEN-1); break;
    default   : sfx = "";
    }

    if(sfx) {
        result.idx      = idx;
        result.sfx      = sfx;
        result.sel_text = sel_text;
    }


    if(!sfx)
    {
        let     pattern_WORDS_EXACT
            =   pattern.startsWith("\\b(")
            &&  pattern.endsWith  ("\\b");



        let     pattern_WORDS_HEAD_TAIL
            =   pattern.startsWith("\\w*")
            &&  pattern.endsWith  ("\\w*");



        if(     pattern_WORDS_HEAD_TAIL) { words_option = t_data.WORDS_HEAD_TAIL; sel_text = pattern.substring(3,len-3); }

        else if(pattern_WORDS_EXACT    ) { words_option = t_data.WORDS_EXACT    ; sel_text = pattern.substring(2,len-2); }

        result.pattern_WORDS_EXACT     = pattern_WORDS_EXACT;

        result.pattern_WORDS_HEAD_TAIL = pattern_WORDS_HEAD_TAIL;
    }


    result.words_option = words_option;
    result.sel_text     = sel_text;


if( log_this) result.current_words_option = get_current_words_option();
if( log_this) result.CALLERS = t_log.get_callers();
if( log_this) log_key_val( caller+"("+pattern+"):  return [ "+sel_text+" , "+words_option+" ]"
                         , result
                         , lf3);

    return [ sel_text , words_option ];
};


let t_pattern_del_words_option_sfx = function(pattern)
{
    let expected_idx = pattern.length -1   -PATTERN_SEPARATOR_LEN ;
    let          idx = pattern.lastIndexOf( PATTERN_SEPARATOR    );
    if(         (idx < 0)
       ||       (idx != expected_idx)
      )
        return pattern;
    else
        return pattern.substring(0, pattern.length -PATTERN_SEPARATOR_LEN -1);
};


let t_pattern_del_words_extension = function(pattern)
{
    let proot = t_pattern_del_words_option_sfx(pattern);


    let plural = proot.endsWith("(s)?");


    let idx    = proot.indexOf("(");
    if( idx > 0) proot = proot.substring(0, idx);


    if( plural ) return proot+"s";
    else         return proot;
};


let pattern_fallback_to_current_words_option_sfx = function(pattern,words_option)
{
    if(pattern.lastIndexOf(PATTERN_SEPARATOR) == (pattern.length -PATTERN_SEPARATOR_LEN -1))
        return pattern;

    switch( words_option   ) {
    case    t_data.WORDS_EXACT    : return pattern +PATTERN_SEPARATOR +"E";
    case    t_data.WORDS_SEGMENT  : return pattern +PATTERN_SEPARATOR +"S";
    case    t_data.WORDS_HEAD_TAIL: return pattern +PATTERN_SEPARATOR +"H";
    default                       : return pattern;
    }
};


let t_words_regex_no_match = function(pattern, msg)
{

    let tools_filter = t_get_tool(t_data.WORDS_FILTER);
    let words_regex  = t_get_tool("words_regex");


    if( words_regex  ) words_regex.innerHTML = pattern;


    if( tools_filter ) set_el_class_removing(tools_filter, CSS_FG2, FGX_CLASSLIST);
    if( words_regex  ) set_el_class_removing(words_regex , CSS_FG2, FGX_CLASSLIST);


    if( tools_filter ) t_util.t_replace_initial_title(tools_filter             , pattern ? pattern : "NO MATCH");
    if( words_regex  ) t_util.t_replace_initial_title(words_regex.parentElement,     msg ?     msg : "NO MATCH");
};


let t_words_regex_reset = function(pattern)
{



    let tools_filter = t_get_tool(t_data.WORDS_FILTER);
    let words_regex  = t_get_tool("words_regex" );


    if( tools_filter ) set_el_class_removing(tools_filter, "", FGX_CLASSLIST);
    if( words_regex  ) set_el_class_removing( words_regex, "", FGX_CLASSLIST);


    if( tools_filter) t_util.t_restore_initial_title( tools_filter              );
    if( words_regex ) t_util.t_restore_initial_title( words_regex.parentElement );


    set_tool_id_value(t_data.WORDS_FILTER, t_pattern_del_words_option_sfx( pattern ));
};



let t_words_option_select = function(words_option)
{

let   caller = "t_words_option_select";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"("+words_option+") %c prop.get("+words_option+")=["+prop.get(words_option)+"]", lbH+lf5, lbH+lf3);


    switch( words_option )
    {
    case t_data.WORDS_OPCYCLE  : if(prop.get (words_option      ) && t_tools_loaded) words_option_cycle(); break;
    case t_data.WORDS_EXACT    :    prop.init(t_data.WORDS_EXACT,  true); prop.init(t_data.WORDS_SEGMENT  , false); prop.init(t_data.WORDS_HEAD_TAIL, false); break;
    case t_data.WORDS_SEGMENT  :    prop.init(t_data.WORDS_EXACT, false); prop.init(t_data.WORDS_SEGMENT  ,  true); prop.init(t_data.WORDS_HEAD_TAIL, false); break;
    default :
    case t_data.WORDS_HEAD_TAIL:    prop.init(t_data.WORDS_EXACT, false); prop.init(t_data.WORDS_SEGMENT  , false); prop.init(t_data.WORDS_HEAD_TAIL,  true); break;
    }

    words_option_sync();
};


let t_words_option_tooltip = function(innerHTML, tooltip)
{

    let tools_filter = t_get_tool(t_data.WORDS_FILTER);
    let words_regex  = t_get_tool("words_regex" );


    if( words_regex     ) words_regex.innerHTML = innerHTML;


    if( tools_filter    ) set_el_class_removing(tools_filter, CSS_FG0, FGX_CLASSLIST);
    if( words_regex     ) set_el_class_removing(words_regex , CSS_FG0, FGX_CLASSLIST);


    if(tooltip) {
        if( tools_filter) t_util.t_replace_initial_title( tools_filter             , tooltip);
        if( words_regex ) t_util.t_replace_initial_title( words_regex.parentElement, tooltip);
    }
    else {
        if( tools_filter) t_util.t_restore_initial_title( tools_filter              );
        if( words_regex ) t_util.t_restore_initial_title( words_regex.parentElement );
    }
};


let   words_option_sync = function()
{

    let el_tools_filter    = t_get_tool(t_data.WORDS_FILTER);
    let el_WORDS_EXACT     = prop.get_EL( t_data.WORDS_EXACT     );
    let el_WORDS_SEGMENT   = prop.get_EL( t_data.WORDS_SEGMENT   );
    let el_WORDS_HEAD_TAIL = prop.get_EL( t_data.WORDS_HEAD_TAIL );
    let el_WORDS_OPCYCLE   = prop.get_EL( t_data.WORDS_OPCYCLE   );

    if(   !el_tools_filter
       || !el_WORDS_EXACT
       || !el_WORDS_SEGMENT
       || !el_WORDS_HEAD_TAIL
      )
        return;


    let words_option = get_current_words_option();
    let cycling
        =     prop.get( t_data.WORDS_OPCYCLE );




    switch( words_option )
    {

    case t_data.WORDS_EXACT:
    el_WORDS_OPCYCLE.style.color = window.getComputedStyle( prop.get_EL( t_data.WORDS_EXACT     )).backgroundColor;
    break;

    case t_data.WORDS_SEGMENT:
    el_WORDS_OPCYCLE.style.color = window.getComputedStyle( prop.get_EL( t_data.WORDS_SEGMENT   )).backgroundColor;
    break;

    case t_data.WORDS_HEAD_TAIL:
    el_WORDS_OPCYCLE.style.color = window.getComputedStyle( prop.get_EL( t_data.WORDS_HEAD_TAIL )).backgroundColor;
    break;

    }


    if(!cycling ) el_WORDS_OPCYCLE.style.backgroundColor = "white";
    set_el_class_removing(el_WORDS_OPCYCLE, words_option, WORDS_CLASSLIST);



    if( words_filter_input ) {
        set_el_class_removing(words_filter_input, words_option  , WORDS_CLASSLIST);
        add_el_class         (words_filter_input, t_data.CSS_DATA_PATTERN);
    }


};

let t_set_el_pat_words_option = function(el, pat)
{
    let [ sel_text , words_option ] = t_pattern_to_sel_text_words_option( pat );

    set_el_class_removing(el, words_option  , WORDS_CLASSLIST);

    el.title = t_util.t_get_htmlEntities(sel_text) + t_data.LF + words_option;


};

const PATTERN_CYCLE_DELAY = 200;

let   words_option_cycle = function()
{

let   caller = "words_option_cycle";
let log_this = LOG_MAP.S2_SELECT;



    let last_cleared_pattern = t_slot.get_last_cleared_pattern();
if(log_this) logBIG(caller+": last_cleared_pattern=["+last_cleared_pattern+"]");



    let next_option
        = prop.get( t_data.WORDS_EXACT  ) ? t_data.WORDS_SEGMENT
        : prop.get( t_data.WORDS_SEGMENT) ? t_data.WORDS_HEAD_TAIL
        :                            t_data.WORDS_EXACT;
if(log_this) log("...next_option=["+next_option+"]");

    t_words_option_select( next_option );


    if(next_option != t_data.WORDS_EXACT)
    {
if(log_this) t_log.log_TR_SELECT_set("<em class='big'>CYCLING NEXT TO WORDS OPTION "+ words_options_symbol(next_option)+"</em>");
if(log_this) log              (                "CYCLING NEXT TO WORDS OPTION "+                      next_option         );

        prop_id_toggle(next_option);
    }


    else {
        t_clear( caller );
if(log_this) t_log.log_TR_SELECT_set("<em class='big'>CYCLING BACK TO WORDS OPTION "+ words_options_symbol(next_option)+"</em>");
if(log_this) log              (                "CYCLING BACK TO WORDS OPTION "+                      next_option         );

        t_sync_styles(caller);

        save5_wording();



        t_words_option_tooltip("...");
    }

    if( t_preventDefault_caller ) t_restoreDefault("t_data.WORDING CYCLE");
};



let WORDS_EXACT_SYMBOL       = "<em class='cc3'>&equiv;</em>";
let WORDS_SEGMENT_SYMBOL     = "<em class='cc4'>&sub;</em>"  ;
let WORDS_HEAD_TAIL_SYMBOL   = "<em class='cc5'>&isin;</em>" ;
let WORDS_OPCYCLE_SYMBOL     = "<em class='cc9'>\u27F3</em>" ;


let   words_options_symbol = function(option)
{
    switch(  option          ) {
        case t_data.WORDS_EXACT     : return WORDS_EXACT_SYMBOL     ;
        case t_data.WORDS_SEGMENT   : return WORDS_SEGMENT_SYMBOL   ;
        case t_data.WORDS_HEAD_TAIL : return WORDS_HEAD_TAIL_SYMBOL ;
        case t_data.WORDS_OPCYCLE   : return WORDS_OPCYCLE_SYMBOL   ;
        default                     : return "*** WRONG WORDS OPTION ***";
    }
};


let   get_current_words_option = function()
{
    return prop.get( t_data.WORDS_EXACT  ) ? t_data.WORDS_EXACT
        :  prop.get( t_data.WORDS_SEGMENT) ? t_data.WORDS_SEGMENT
        :                                    t_data.WORDS_HEAD_TAIL;
};






let container_selected;


let t_seek_set_container_selected = function(container, _caller)
{


    if(container_selected == container) return;

    if(container_selected) del_el_class(container_selected, CSS_CONTAINER_SELECTED);

    container_selected     = container;



    if(container_selected)
        t_seek.t_seekzone7_show_container( container_selected );



    if(container_selected)
    {
        add_el_class(container_selected, CSS_CONTAINER_SELECTED);
        t_seek.t_seekzone_set_selected();

        let xy = t_util.get_el_xy(container_selected, "t_seek_set_container_selected");
        if( xy )           container_selected.x = xy.x;
    }
    else {
        container_selected.x = 0;
        t_seek.t_seekzone_clr_selected();

    }


    if( prop.get(t_data.EDIT_OR_STAGE) )
        t_hide.dom_hide4_scroll_to_last_hidden( container );
};


let t_get_container_selected = function()
{
    return container_selected;
};


let t_clr_container_selected = function()
{
    if(!container_selected ) return;

    del_el_class(container_selected, CSS_CONTAINER_SELECTED);
    t_seek.t_seekzone_clr_selected();



    container_selected = null;


};


let t_set_touchedWord_startContainer = function()
{

    let caller = "t_set_touchedWord_startContainer";
let log_this   = LOG_MAP.EV3_UP;

    let  touchedWord_slot = t_select.get_touchedWord_slot();
if( log_this) log("%c"+caller+" %c FOR SELECTION RANGE "+t_util.get_id_or_tag(t_select.get_touchedWord_range_parent())+" %c "+       touchedWord_slot
                  ,lbb+lbL+lf3 ,lbb+lbC+lf3                                                         ,lbb+lbR+lfX[touchedWord_slot]);



    let slot = touchedWord_slot;
    let touched_container;
    for(let num=1; num <= t_select.ccs[slot].containers.length; ++num)
    {
        if( t_util.is_el_or_child_of_parent_el(t_select.get_touchedWord_range_parent(), t_select.ccs[slot].containers[num-1]) )
        {
            touched_container = t_select.ccs[slot].containers[num-1];

if( log_this) log("%c"+caller+" %c "+t_util.get_id_or_tag(touched_container)+" %c num "+num
                  ,lbb+lbL+lf3 ,lbb+lbC+lf3                             ,lbb+lbR+lf3 );
            break;
        }
    }


    if(touched_container)
    {
        t_seek_set_container_selected(touched_container, caller);
        dom_scroll.t_scrollIntoViewIfNeeded     (touched_container);
    }
    else {
if( log_this) log("%c"+caller+" %c NO [touched_container]"
                  ,lbb+lbL+lf3 ,lbb+lbR+lf2               );
    }

};




const DIMM_MASK_MARGIN = 32;

let div_slot_containers;
let button_PREV;
let button_NEXT;
let button_MONO;





let build_div_slot_containers = function()
{
    if( div_slot_containers ) return div_slot_containers;

    div_slot_containers    = document.createElement("DIV");
    div_slot_containers.id = "div_slot_containers";

    button_PREV            = t_slot_containers_get_button(CSS_BUTTON_PREV, t_data.SYMBOL_HEAVY_RIGHT_ARROW);


    button_NEXT            = t_slot_containers_get_button(CSS_BUTTON_NEXT, t_data.SYMBOL_HEAVY_RIGHT_ARROW);


    button_MONO            = t_slot_containers_get_button(CSS_BUTTON_MONO, t_data.SYMBOL_MENU             );
    button_MONO.title      = t_i18n.i18n_get(t_i18n.MONOSPACE);

    return div_slot_containers;
};


let t_slot_containers_display = function(slot)
{

let   caller = "t_slot_containers_display(slot "+slot+")";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);



if(log_this) log("...window [W H] = ["+w_H     +" "+ w_W                   +"]");


    if(!dimm_mask) dimm_add();
    dimm_mask.innerHTML = "";
    let       innerHTML = "";

    let    num_selected = t_select.ccs[slot].num_selected;
    let container_count = 0;
    let num_max = t_select.t_select_get_slot_nodes_length(slot);
    for(let num = 0;   num <= num_max; ++num)
    {

        let container = t_select.ccs[slot].containers[num-1];
        let  num_last = num;
        while(    ( num_last <  num_max)
               && (container == t_select.ccs[slot].containers[num_last])
             )
            num_last += 1;


        if( t_select.ccs[slot].containers[num-1] ) {

            container        = t_select.ccs[slot].containers[num-1];
            container_count += 1;


            let                      container_H = container.scrollHeight;
            let content_is_too_big = container_H >= (w_H * 0.9);




            let title_em
                = (container           .title) ? " <em>"+container           .title+"</em>"
                : !container.parentNode        ? " "
                :  container.parentNode.title  ? " <em>"+container.parentNode.title+"</em>"
                :                                         " ";

            let num_from_to
                = (num_last == num)            ? num : (num + (((num_last-num) > 1) ? " .. ":" and ") + num_last);

            let slot_num_selected
                = (num <= num_selected) && (num_selected <= num_last);

            let tooltip
                = t_data.SYMBOL_SCISSORS+" "+num_from_to+" "+t_i18n.i18n_get(t_i18n.COPY_PARAGRAPH_TO_CLIPBOARD);

            let div_class
                = "class_s_"+slot+"_"+num      + " note"+(container_count % 10)
                + (content_is_too_big          ? " content_is_too_big" : ""   )
                + (slot_num_selected           ? " container_selected" : ""   )
            ;

            let div_copy_content_innerHTML
                = content_is_too_big           ? (t_util.ellipsis(container.innerText, 512)  )
                : (container.tagName == "LI")  ? ("<p>"+container.innerHTML+"</p>" +LF)
                :                                (      container.outerHTML           )
            ;





            let css = "white-space:pre-line";



            let title_div = t_i18n.i18n_get( t_i18n.SCROLL_TO_THIS_PARAGRAPH );
            innerHTML
                += " <div class='"+  div_class              +"' style='"+css+"' title='"+title_div+"'>"+LF

                +                    DIV_MAGNIFY            +LF

                +  "  <div class='"+ CSS_BUTTON_COPY        +"' title='"+tooltip+"'>"+LF
                +  "  "            + container_count
                +  "  "            + t_data.SYMBOL_CLIPBOARD
                +  "   <em>"       + t_select.ccs[slot].pattern      +"</em>"
                +  "   <em>#"      + num_from_to            +"</em> <em>of "+ num_max +"</em>"
                +  "  </div>"                               +LF

                +  "  " + title_em                          +LF

                +  "  <div class='div_copy_content'>"       +LF
                +  "  "+div_copy_content_innerHTML          +LF
                +  "  </div>"                               +LF

                +  " </div>"                                +LF
            ;


        }
        num = num_last;
    }


    if(innerHTML) {

        dimm_start_slot_containers(caller);

        t_check_onModalMS(caller);


        let xy = t_gutter.get_GUTTER_XY();
        if( xy ) t_tools_set_top_xy(xy.x, xy.y);

        add_el_class(hotspot , t_data.CSS_HIDDEN);

        dom_scroll.t_window_scrollTo(0, 0);



        let pattern
            = t_pattern_del_words_option_sfx( t_select.ccs[slot].pattern );

        let patroot
            = t_pattern_del_words_extension( pattern );

        let tooltip
            = t_data.SYMBOL_SCISSORS+" "+t_i18n.i18n_get(t_i18n.COPY_ALL_PARAGRAPHS_TO_CLIPBOARD);

        let button_COPY_ALL_parent_div
            =  " <div     id='button_COPY_ALL_parent_div'>" +LF

            +                        DIV_MAGNIFY            +LF

            +  "  <div class='"    + CSS_BUTTON_COPY        +"' title='"+tooltip+"'>"+LF
            +  "  "                + t_data.SYMBOL_CLIPBOARD
            +  "   <em>"           + pattern +"</em>"
            +  "   <em>#1 to "     + num_max +"</em>"
            +  "  </div>"                                   +LF

            +  "  <div class='div_copy_content'>"
            +  "   "+ container_count+" Paragraphs containing <em class='cc"+slot+"'>"+              pattern +"</em><br>"+LF
            +  "   <a target='atilf' href='https://www.cnrtl.fr/definition/"+patroot+"'>&#x1F4D6; "+ patroot +" &#x1F4D6;</a>"
            +  "  </div>"+LF
            +  " </div>"+LF
        ;


        if(!div_slot_containers)
            build_div_slot_containers();



        div_slot_containers.innerHTML = "";

        div_slot_containers.insertAdjacentHTML("beforeend", button_COPY_ALL_parent_div);
        div_slot_containers.insertAdjacentHTML("beforeend", innerHTML                 );




        let v_W = window.innerWidth - DIMM_MASK_MARGIN;
        let v_H = t_util.getPageHeight();

        dimm_mask.style.position            = "absolute";
        dimm_mask.style.left                =      "0px";
        dimm_mask.style.top                 =      "0px";
        dimm_mask.style.width               =   v_W+"px";
        dimm_mask.style.height              =   v_H+"px";

if( log_this) log("dimm_mask XY=["+dimm_mask.style.left+" "+dimm_mask.style.top+"] WH=["+dimm_mask.style.width+" "+dimm_mask.style.height+"]");


        let x = 0;
        let y = 0;
        let w = v_W - x;

        div_slot_containers.style.position  =         "";
        div_slot_containers.style.left      =     x+"px";
        div_slot_containers.style.top       =     y+"px";
        div_slot_containers.style.width     =     w+"px";
        div_slot_containers.style.minHeight =   w_H+"px";

if( log_this) log("div_slot_containers XY=["+div_slot_containers.style.left+" "+div_slot_containers.style.top+"] WminH=["+div_slot_containers.style.width+" "+div_slot_containers.style.minHeight+"]");

        dimm_mask.appendChild( div_slot_containers );
        dimm_mask.appendChild( button_NEXT         );
        dimm_mask.appendChild( button_PREV         );
        dimm_mask.appendChild( button_MONO         );

        t_seek.t_seeker_PU_hide("instant");
    }

    dom_scroll.t_scrollIntoViewIfNeeded_dimm_mask_container_selected( div_slot_containers );
};


let t_slot_containers_get_button = function(className, content)
{
    let el         = document.createElement("EM");

    el.textContent = content;

    add_el_class(el, className);

    return el;
};



let      fullscreen_slot_container;
let last_fullscreen_slot_container;
let div_containers_columns;

let t_slot_container_set_fullscreen = function(clicked_target)
{

let caller = "t_slot_container_set_fullscreen";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) t_fly.t_log_event_status(caller+"("+(t_util.get_id_or_tag(clicked_target) || clicked_target)+")", lf8);


 let slot_container = clicked_target;
 if     (has_el_class(clicked_target     , CSS_BUTTON_MAGNIFY       )) slot_container = clicked_target.parentElement;
 else if(            (clicked_target    == fullscreen_slot_container)) slot_container = clicked_target;
 else if(has_el_class(clicked_target     , CSS_BUTTON_PREV          )) slot_container = fullscreen_slot_container.previousElementSibling || fullscreen_slot_container;
 else if(has_el_class(clicked_target     , CSS_BUTTON_NEXT          )) slot_container = fullscreen_slot_container.nextElementSibling     || fullscreen_slot_container;
 else if(has_el_class(clicked_target     , CSS_BUTTON_MONO          ))
    {
        let text_or_html =     !has_el_class(div_slot_containers, CSS_BUTTON_MONOSPACE);
if( log_this) log("...text_or_html=["+text_or_html+"]");

        t_util.set_el_class_on_off(div_slot_containers          , CSS_BUTTON_MONOSPACE, text_or_html);
        t_util.set_el_class_on_off(button_MONO                  , CSS_BUTTON_MONOSPACE, text_or_html);

        return;
    }


    if(clicked_target == fullscreen_slot_container)
    {
if(log_this) log("...fullscreen_slot_container UNCHANGED");

        return;
    }


    if(!slot_container) {
        last_fullscreen_slot_container = fullscreen_slot_container;

    }
    fullscreen_slot_container = slot_container;


    if(fullscreen_slot_container) {
        if(   (fullscreen_slot_container.on_grid_top < window.scrollY)
           || (fullscreen_slot_container.on_grid_top > window.scrollY + window.innerHeight)
          ) {

            dom_scroll.t_window_scrollTo(0, fullscreen_slot_container.on_grid_top - window.innerHeight / 4);
        }
    }


    if(!div_containers_columns)
    {
        let cs = window.getComputedStyle(div_slot_containers);

        div_containers_columns = cs.gridTemplateColumns.split(" ").length;
    }



    if(fullscreen_slot_container) {
        add_el_class(dimm_mask          , CSS_FULLSCREEN);
        add_el_class(div_slot_containers, CSS_FULLSCREEN);
    }
    else {
        del_el_class(dimm_mask          , CSS_FULLSCREEN);
        del_el_class(div_slot_containers, CSS_FULLSCREEN);
    }



    let slot_num_max = div_slot_containers.children.length;
    let fullscreen_slot_num = -1;
    for(let i=0; i < slot_num_max; ++i)
    {

        let child =  div_slot_containers.children[i];
        if( child == fullscreen_slot_container)
            fullscreen_slot_num = i;



        if( child == fullscreen_slot_container) {
            child.grid_x      = child.offsetLeft;
            child.grid_y      = child.offsetTop;

            add_el_class       (child, CSS_FULLSCREEN     );
            set_el_class_on_off(child, CSS_FULLSCREEN_PREV, (clicked_target == button_PREV));
            set_el_class_on_off(child, CSS_FULLSCREEN_NEXT, (clicked_target == button_NEXT));
        }


        else {

            del_el_class       (child, CSS_FULLSCREEN     );
            del_el_class       (child, CSS_FULLSCREEN_PREV);
            del_el_class       (child, CSS_FULLSCREEN_NEXT);


            if(fullscreen_slot_container || (child != last_fullscreen_slot_container))
            {
                del_el_class(child, CSS_FULLSCREEN_LAST );
                del_el_class(child, CSS_FULLSCREEN_LEFT );
                del_el_class(child, CSS_FULLSCREEN_RIGHT);
            }


            else {
                let first = ((i+1) % div_containers_columns) == 1;
                let last  = ((i+1) % div_containers_columns) == 0;
if(log_this) log("%c #"+(i+1)+" "+(first ? "first" : (last ? "last" : "center"))+" grid-column", lbH+(first ? lf1 : (last ? lfX[div_containers_columns] : lf8)));

                if     (first ) add_el_class(child, CSS_FULLSCREEN_LEFT );
                else if(last  ) add_el_class(child, CSS_FULLSCREEN_RIGHT);
 add_el_class(child, CSS_FULLSCREEN_LAST );
            }

        }


        child.style.display
            = (!fullscreen_slot_container || (child == fullscreen_slot_container))
            ? "block"
            : "none"
        ;

    }


    let display_prev = ((fullscreen_slot_num >= 0) && (fullscreen_slot_num > (0             ))) ? "inline" : "none";
    let display_next = ((fullscreen_slot_num >= 0) && (fullscreen_slot_num < (slot_num_max-1))) ? "inline" : "none";

    button_PREV.style.display = display_prev;
    button_NEXT.style.display = display_next;
    button_MONO.style.display = "inline";



    if(!fullscreen_slot_container && last_fullscreen_slot_container)
    {
        delete last_fullscreen_slot_container.scrolledIntoViewHandled;

        dom_scroll.t_scrollIntoViewIfNeeded(last_fullscreen_slot_container, 0);
    }



if( log_this)
    log_key_val(caller
                , {   div_containers_columns
                    ,    fullscreen_slot_num
                    ,           slot_num_max
                    ,           display_prev
                    ,           display_next
                });

};


let slot_container_magnified_0_to_9 = 2;
let t_slot_containers_magnify = function()
{


    for(let i=0; i<=9; ++i)
    {
        let className = "magnified_"+i;
        if(i == slot_container_magnified_0_to_9) add_el_class(div_slot_containers, className);
        else                                     del_el_class(div_slot_containers, className);
    }

};


let t_slot_containers_copy_to_clipboard_outerHTML = function(el) { t_slot_containers_copy_to_clipboard(el,  true); };
let t_slot_containers_copy_to_clipboard_innerHTML = function(el) { t_slot_containers_copy_to_clipboard(el, false); };
let t_slot_containers_copy_to_clipboard           = function(el, outer_or_inner)
{

    let caller = "t_slot_containers_copy_to_clipboard";
let log_this   = LOG_MAP.EV3_UP;



    if(    (el != div_slot_containers)
        && (el.parentElement.id == "button_COPY_ALL_parent_div")
      )
        el = dimm_mask.firstElementChild;



    let text_or_html = has_el_class(div_slot_containers, CSS_BUTTON_MONOSPACE);

    let copy_content
        = (outer_or_inner)
        ?  (text_or_html ? el.innerText : el.outerHTML)
        :  (text_or_html ? el.innerText : el.innerHTML)
    ;

if( log_this)
    log_key_val_group(    caller
                      , { outer_or_inner
                        , text_or_html
                        , el           : t_util.get_id_or_node_path_tail(el)
                        , copy_content : t_util.ellipsis(copy_content)
                        ,       length :                 copy_content.length
                        ,      callers : t_log.get_callers()
                      } , lf5, false);

    t_fly.t_fly_tooltip(t_data.SYMBOL_CLIPBOARD+" "+t_data.SYMBOL_LEFT_CHEVRON+" "+copy_content.length+" chars");

    t_util.t_copy_to_CLIPBOARD( copy_content );
};


let t_copy_innerHTML_to_clipboard = function(innerHTML)
{

let   caller = "t_copy_innerHTML_to_clipboard";
let log_this = LOG_MAP.T0_STORE;

if( log_this) log("%c"+caller+":"+LF+"%c"+(innerHTML ? innerHTML : "CLIPBOARD CLEARED"), lb3, lbF+lf3);


    if(!div_slot_containers)
        build_div_slot_containers();

    div_slot_containers.innerHTML = innerHTML;

    t_slot_containers_copy_to_clipboard_innerHTML( div_slot_containers );

    div_slot_containers.innerHTML = "";
};




let t_tools_hide_onDown_XY = function(hide_parent)
{

let   caller = "t_tools_hide_onDown_XY";
let log_this = (LOG_MAP.T3_LAYOUT || LOG_MAP.EV4_LONG_PRESS);

if( log_this) log(caller+"(hide_parent "+hide_parent+")");


    let range = t_select.get_range_from_XY(onDown_XY.x, onDown_XY.y);
if(log_this)t_log.console_dir("range",range);
    if(!range.startContainer )
        return "";

    let    container  = t_select.get_text_container( range.startContainer );
if(log_this)t_log.console_dir("container",container);
    if(   !container
       && (container == document.body)
       && (container == document.documentElement)
      )
        return "";


    if( hide_parent )
    {
        container = t_hide.get_node_hidden_parentElement( container );
if(log_this)t_log.console_dir("get_node_hidden_parentElement",container);

        if(!container) return "";
    }


    t_window_getSelection_removeAllRanges( caller );
    t_hide.dom_hide1_container_clicked(container, hide_parent);


    return "DOC CLICK .. HIDE CONTAINER ["+get_n_lbl(container)+"]";
};


let t_tools_hide_onDown_XY_parent = function()
{
    return t_tools_hide_onDown_XY( true );
};








let t_get_onWork_EL_slot = function()
{
    return get_EL_slot( onWork_EL );
};


let t_get_onWork_EL_num = function()
{
    let num
        = (     t_seek.t_seeker_is_a_tool_el  ( onWork_EL )
            || (onWork_EL.id.startsWith("thumb_p_"))
        )
        ?      t_select.get_last_highlighted_num()
        :      t_get_EL_num(onWork_EL, 0)
    ;


    return num;
};


let t_get_onWork_EL_container = function()
{
    let slot = t_get_onWork_EL_slot(); if(!slot) return null;
    let num  = t_get_onWork_EL_num (); if(!num ) return null;

    let container = t_select.ccs[slot].containers[num-1];
log("t_get_onWork_EL_container("+get_n_lbl(onWork_EL)+"): ...return ["+t_util.get_id_or_tag(container)+" "+t_util.get_n_txt(container) +"]");
    return container;
};


let get_EL_slot = function(el)
{

let   caller = "get_EL_slot";
let log_this = LOG_MAP.T6_SLOT;


    let slot = -1;

    if(!el) return slot;

    if( t_seek.t_seeker_is_a_tool_el( el ) )
    {
        slot    = t_select.get_last_selected_slot();
        if( slot < 0)
            slot = t_seek.t_seeker_get_last_seeked_slot_num().slot;

if( log_this) log("%c t_select.get_last_selected_slot() .. return ["+slot+"]", lbH+lf6);
    }
    else {

        let offset
            = el.id.startsWith("select"    ) ?  6
            : el.id.startsWith("thumb_p_"  ) ?  8
            : el.id.startsWith("thumb_s_"  ) ?  8
            :                                   0
        ;
        if( offset )
        {
            let ss  = el.id.substring( offset );
            let ccX =        parseInt( ss     );
            slot
                = isNaN(ccX    ) ?   0
                :      (ccX > 0) ? ccX
                :                   10;

if( log_this) log("offset=["+offset+"] .. el.id=["+el.id+"] .. ss=["+ss+"] .. ccX=["+ccX+"] .. slot=["+slot+"]");
        }
    }

if( log_this) log(caller+"("+get_n_lbl(el)+"): ...return ["+slot+"]");
    return slot;
};


let t_get_EL_num = function(el, num_default=0)
{
    if(!el) return num_default;

    let offset
        = el.id.startsWith("select"    ) ?  8
        : el.id.startsWith("thumb_p_"  ) ? 10
        : el.id.startsWith("thumb_s_"  ) ? 10
        :                                   0
    ;

    let num = parseInt( el.id.substring(offset) );

    if( isNaN(num) ) num = num_default;


    return num;
};


let t_get_used_slot_dir = function(from_slot, dir)
{
    let slot = from_slot;
    for(let step = 1; step <= t_select.SELECT_SLOT_MAX; ++step)
    {
        slot = (t_select.SELECT_SLOT_MAX + slot + dir) % t_select.SELECT_SLOT_MAX;

        if(slot == 0) slot = 10;

        let num_max = t_select.t_select_get_slot_nodes_length(slot);

        if(t_select.ccs[slot] && (num_max > 0)) break;
    }

    return slot;
};



const T_CLEAR_SLOT_SYNC_DELAY            = 500;
let   t_clear_slot_sync_timer            = null;
let   t_clear_slot_sync_cleared_patterns = "";


let t_clear_slot_sync = function(slot, pattern, delay=T_CLEAR_SLOT_SYNC_DELAY)
{

let   caller = "t_clear_slot_sync("+slot+", pattern=["+pattern+"])";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.T6_SLOT;

if( log_this) log("%c "+caller,lb6);
if( log_this) log_caller();


    if(t_clear_slot_sync_timer) {
        clearTimeout( t_clear_slot_sync_timer );
 t_clear_slot_sync_timer = null;

        if( delay ) {
            delay += 2 * T_CLEAR_SLOT_SYNC_DELAY;
        }
    }



    if((onWork_EL) && (slot == t_get_onWork_EL_slot()))
    {
        t_set_onWork_EL(null, caller);
        t_seek.t_seeker_set_TOOL(onWork_EL);

if( log_this) t_fly.t_log_event_status(caller, lbb+lf6);
    }



    t_clear_slot_sync_cleared_patterns += " "+pattern;

    mov_pat_span = t_select.t_get_pat_span_with_pattern(pat_bag, pattern);
    if(mov_pat_span)
        t_pat_bag_hover_div_accept(off_bag, true);

    t_clear_slot_sync_timer = setTimeout(t_clear_slot_sync_handler, T_CLEAR_SLOT_SYNC_DELAY);
};


let t_clear_slot_sync_cancel = function()
{

    if(!t_clear_slot_sync_timer) return;

    clearTimeout( t_clear_slot_sync_timer );
    t_clear_slot_sync_timer = null;
};


let t_clear_slot_sync_handler = function()
{

let   caller = "t_clear_slot_sync_handler: patterns=["+t_clear_slot_sync_cleared_patterns+"]";
let log_this = LOG_MAP.T6_SLOT;

if( log_this) log("%c "+caller,lb6);

    t_clear_slot_sync_timer = null;


    t_select.t_onPatternUpdate_quick   ("SOME CLEARED <em class='cc8'>"+ t_util.ellipsis_short(t_clear_slot_sync_cleared_patterns) +"</em>", caller);

    t_clear_slot_sync_cleared_patterns = "";
};



let   clear_clicked_slot = function(slot)
{

let   caller = "clear_clicked_slot("+slot+")";
let log_this = LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller);

    if(log_this)
        t_fly.t_log_transcript_event_bot( "<em class='big'>CLEAR CLICKED SLOT #"+slot+" .. onWork_EL.id=["+onWork_EL.id+"]</em>");

    t_slot.t_clear_slot(slot);
    t_select.t_onPatternUpdate("CLEARING SLOT <em>"+ slot +"</em>", caller);

    if( prop.get( t_data.WORDS_OPCYCLE ) )
    {
if( log_this) log("...words_opcycle POSTING words_option_cycle");

        setTimeout(words_option_cycle, PATTERN_CYCLE_DELAY);
    }
};


let   get_num_from_id_or_className_slot  = function(node, slot)
{
let   caller = "get_num_from_id_or_className_slot(node.id=["+node.id+"], slot=["+slot+"])";
let log_this = LOG_MAP.T6_SLOT;

    let num = 0;






    let      pfx;
    if     ((pfx = "thumb_p_"+slot+"_") && node.id       .startsWith(pfx)) num = parseInt( node.id       .substring(pfx.length) );
    else if((pfx = "thumb_s_"+slot+"_") && node.id       .startsWith(pfx)) num = parseInt( node.id       .substring(pfx.length) );
    else if((pfx = "class_s_"+slot+"_") && node.className.startsWith(pfx)) num = parseInt( node.className.substring(pfx.length) );
    else if((pfx =   "select"+slot+"_") && node.id       .startsWith(pfx)) num = parseInt( node.id       .substring(pfx.length) );

if( log_this) log(caller+": ...return "+((num != 0) ? num : "NOT A SLOT NUM"));
    return num;
};


let   get_slot_from_id_or_className  = function(node)
{

let   caller = "get_slot_from_id_or_className("+ get_n_lbl(node) +")";
let log_this = LOG_MAP.T6_SLOT;

if( log_this) log(caller);
if( log_this) log("...node.id.......=["+node.id        +"]");
if( log_this) log("...node.className=["+node.className +"]");

    let slot   = -1;




    if(      node.id       .startsWith("thumb_p_") ) { slot = parseInt( node.id       .substring(8) ); }
    else if( node.id       .startsWith("thumb_s_") ) { slot = parseInt( node.id       .substring(8) ); }
    else if( node.className.startsWith("class_s_") ) { slot = parseInt( node.className.substring(8) ); }


    else {
        if(!node.className.startsWith( "select" ) && node.parentElement) node = node.parentElement;
        if( node.className.startsWith( "select" ) ) {
            slot = parseInt(node.className.substring(6));
        }
    }

    let last_selected_slot = t_select.get_last_selected_slot();
    if(slot <= 0)
        slot = last_selected_slot;

    slot = ((slot >= 0              )
        &&  (slot <= t_select.SELECT_SLOT_MAX))
        ?    slot
        :    last_selected_slot
    ;

if( log_this) log("...return "+((slot != 0) ? slot : "NOT A SLOT"));
    return slot;
};








let bot_div;
let  fly_log;
let  pat_sort;
let  bag_log;

let off_bag;
let alt_bag;
let bak_bag;

let bag_rot;
let bagopen;

let mov_div;

let hov1;
let hov2;
let hov3;
let hov4;






let sel_csv = "";
let pat_csv = "";
let off_csv = "";
let alt_csv = "";
let bak_csv = "";
let bin_csv = "";




let set_sel_csv = function(_sel_csv) { sel_csv = _sel_csv; };
let set_pat_csv = function(_pat_csv) { pat_csv = _pat_csv; };
let set_off_csv = function(_off_csv) { off_csv = _off_csv; };



let add_sel_csv = function(pattern ) { sel_csv = t_util.csv_add(sel_csv, pattern); };





let t_build_bag_tools = function()
{

    if(!dom_tools_html) return;



    t_fly.t_fly_div_get();



    off_bag = document.createElement("DIV"  ); off_bag.id = "off_bag"; add_el_class( off_bag, CSS_EMPTY);
    t_util.set_el_caption(off_bag);




    alt_bag = document.createElement("DIV"  ); alt_bag.id = "alt_bag";
    t_util.set_el_caption(alt_bag);



    bak_bag = document.createElement("DIV"  ); bak_bag.id = "bak_bag";
    t_util.set_el_caption(bak_bag);




    bot_div  = document.createElement("DIV"); bot_div .id = "bot_div" ;
    bag_log  = document.createElement("DIV"); bag_log .id = "bag_log" ; add_el_class(bag_log, CSS_TXT_LOG);
    fly_log  = document.createElement("DIV"); fly_log .id = "fly_log" ;
    pat_sort = document.createElement("DIV"); pat_sort.id = "pat_sort";

    t_util.set_el_caption(fly_log);

    t_util.set_el_caption( pat_sort );

    bot_div.appendChild( bag_log  );
    bot_div.appendChild( fly_log  );
    bot_div.appendChild( pat_sort );


    bagopen  = document.createElement("DIV"); bagopen .id = "bagopen" ;
    bagopen.innerHTML = ""
            + "<span class='fg4'>"+ t_data.SYMBOL_RIGHT_ANGLE_BRACKET  +"</span>"
            + "<span class='fg6'>"+ t_data.SYMBOL_RIGHT_ANGLE_BRACKET  +"</span>"
            + "<span class='fg2'>"+ t_data.SYMBOL_RIGHT_ANGLE_BRACKET  +"</span>"
    ;

    t_util.set_el_caption(bagopen);


    bag_rot  = document.createElement("DIV"); bag_rot.id = "bag_rot" ;

    set_bag_rot_title("..."+t_i18n.i18n_get( t_i18n.BAGS_CONTENT ));






    mov_div = document.createElement("DIV"  ); mov_div.id = "mov_div" ;
    mov_div.style.display = "none";




    pat_bag.appendChild(off_bag);
    pat_bag.appendChild(alt_bag);
    pat_bag.appendChild(bak_bag);
    pat_bag.appendChild(bot_div);

    pat_bag.appendChild(bag_rot);
    pat_bag.appendChild(bagopen);

    pat_bag.appendChild(mov_div);




    hov1    = document.createElement("DIV" ); hov1.id    = "hov1"   ; hov1.innerText = t_data.SYMBOL_LOWER_RIGHT;
    hov2    = document.createElement("DIV" ); hov2.id    = "hov2"   ; hov2.innerText = t_data.SYMBOL_UPPER_LEFT;
    hov3    = document.createElement("DIV" ); hov3.id    = "hov3"   ; hov3.innerText = t_data.SYMBOL_LOWER_RIGHT;
    hov4    = document.createElement("DIV" ); hov4.id    = "hov4"   ; hov4.innerText = t_data.SYMBOL_UPPER_LEFT;

    hov1   .style.display = "none";
    hov2   .style.display = "none";
    hov3   .style.display = "none";
    hov4   .style.display = "none";

    pat_bag.appendChild(hov1   );
    pat_bag.appendChild(hov2   );
    pat_bag.appendChild(hov3   );
    pat_bag.appendChild(hov4   );

};


let   set_bag_rot_title = function(title)
{
    let count
        = t_util.csv_count(pat_csv)
        + t_util.csv_count(off_csv)
        + t_util.csv_count(alt_csv)
        + t_util.csv_count(bak_csv)
        + t_util.csv_count(bin_csv)
    ;

    let content
        = (pat_csv ? (LF + t_util.csv_count(pat_csv)+" PAT   "+pat_csv) : "")
        + (off_csv ? (LF + t_util.csv_count(off_csv)+" OFF   "+off_csv) : "")
        + (alt_csv ? (LF + t_util.csv_count(alt_csv)+" ALT   "+alt_csv) : "")
        + (bak_csv ? (LF + t_util.csv_count(bak_csv)+" BAK   "+bak_csv) : "")
        + (bin_csv ? (LF + t_util.csv_count(bin_csv)+" BIN   "+bin_csv) : "")
    ;

    let bag_rot_title
        = title
        + (count ? ("x"+count) : "")
        + (content || t_i18n.IS_EMPTY)
    ;




    t_util.set_el_caption(bag_rot, bag_rot_title);


    let words_bag_rot       = t_get_tool(t_data.WORDS_BAG_ROT);
    if( words_bag_rot       ) t_util.set_el_caption(words_bag_rot, bag_rot_title);


    let words_bag_rot_clone = get_doc_tool_diplayed_id_prefix(t_data.WORDS_BAG_ROT);
    if( words_bag_rot_clone ) t_util.set_el_caption(words_bag_rot_clone, bag_rot_title);


    if( t_fly.t_fly_tooltip_has_category( bag_rot.id   ) ) {
        t_fly.t_fly_tooltip_update(       bag_rot.title
                                  ,       bag_rot.id   );
    }

};


let t_sync_pat_buttons = function(_caller)
{

    if( pat_sort ) {
        prop.set("pat_sort",t_handle_1_pat_bag_sort_cycle_direction);
        let pat_user_set = (t_handle_1_pat_bag_sort_cycle_direction == 0);
        let sel_can_sort = (t_util.csv_count( sel_csv ) > 1);
        let sel_sorted   = sel_can_sort ? (               t_are_sel_sorted  ()) : (t_handle_1_pat_bag_sort_cycle_direction > 0);
        let sel_reversed = sel_can_sort ? (!sel_sorted && t_are_sel_reversed()) : (t_handle_1_pat_bag_sort_cycle_direction < 0);


        pat_sort.innerHTML
            = pat_user_set ? (" "+LF+ t_data.SYMBOL_CHECK_MARK    +LF+" ")
            : sel_sorted   ? ("A"+LF+ t_data.SYMBOL_DOWN          +LF+"Z")
            : sel_reversed ? ("Z"+LF+ t_data.SYMBOL_UP            +LF+"A")
            :                (        t_data.SYMBOL_UP_AND_DOWN_ARROW    )
        ;

        t_util.set_el_caption(  pat_sort
                       , ".. "+            t_i18n.i18n_get( t_i18n.CURRENTLY       )+" "
                       + (  pat_user_set ? t_i18n.i18n_get( t_i18n.AS_SET_BY_USER  )
                          : sel_sorted   ? t_i18n.i18n_get( t_i18n.SORTED_A_TO_Z   )
                          : sel_reversed ? t_i18n.i18n_get( t_i18n.REVERSED_Z_TO_A )
                          :                t_i18n.i18n_get( t_i18n.UNORDERED       ))
                    );

        set_el_class_on_off(pat_sort, t_data.CSS_CHECKED , (sel_sorted || sel_reversed));
        set_el_class_on_off(pat_sort, CSS_USER_SET,  pat_user_set               );
        set_el_class_on_off(pat_sort, CSS_SORT_OFF, !sel_can_sort               );

    }


    if( bag_rot )
    {
        if(!last_bag_move) last_bag_move = "BAGS CONTENT";


        let csv_count_pat_off =     t_util.csv_count(pat_csv) || t_util.csv_count(off_csv);
        let c                 =     t_util.csv_count(pat_csv)  ? 4 : 5;
        bag_rot.innerHTML
            = "<span class='fg"+c+"'>"+ csv_count_pat_off             +"</span>"
            + "<sup>"                 + t_data.SYMBOL_RIGHT_ARROW     +"</sup>"
            + "<span class='fg6'>"    + t_util.csv_count(alt_csv)     +"</span>"
            + "<sup>"                 + t_data.SYMBOL_RIGHT_ARROW     +"</sup>"
            + "<span class='fg2'>"    + t_util.csv_count(bak_csv)     +"</span>"

            + "<sub>"                 + t_data.SYMBOL_DOWN_LEFT_ARROW +"</sub>"
        ;
        let button = t_get_tool(t_data.WORDS_BAG_ROT);
        if( button ) {
            button.innerHTML = "<div>"+bag_rot.innerHTML+"</div>";

            t_sync_button_clone_innerHTML( button );
        }


    }

};


let t_sync_button_clone_innerHTML = function(button)
{


    let button_clone = get_doc_tool_diplayed_id_prefix(button.id);
    if( button_clone ) {

        button_clone.innerHTML = "<div>"+button.innerHTML+"</div>";
    }
};



let t_pat_bag_open_or_close = function(_caller)
{

    let caller = "t_pat_bag_open_or_close";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) logBIG(caller+" .. CALLED BY "+ _caller, lf4);
if( log_this && onWork_MOVABLE_CHILD) log("...onWork_MOVABLE_CHILD=["+get_n_lbl(onWork_MOVABLE_CHILD)+"]");
if( log_this) t_fly.t_log_event_status(caller, lbb+lf9);


    let no_change_msg       = "NO CHANGE: Panel "+ (has_el_class(pat_bag, CSS_OPEN_BAG) ? "OPENED" : "CLOSED")+"";
    let bagclose_msg                   = "Panel CLOSED: ON REQUEST"         ;
    let sel_none_off_some_msg          = "Panel OPENED: some to choose from";
    let sel_none_off_none_bak_none_msg = "Panel CLOSED: none to choose from";
    let sel_some_msg                   = "Panel CLOSED: some selection"     ;




    let sel_count = t_slot.get_slotted_pattern_count();
    let off_count = t_util.csv_count(off_csv);
    let alt_count = t_util.csv_count(alt_csv);
    let bak_count = t_util.csv_count(bak_csv);


    let pat_bag_is_opened              = has_el_class(pat_bag, CSS_OPEN_BAG);
    let pat_bag_onload                 = (onDown_EL == null);
    let bagopen_click                  = (onDown_EL == bagopen);


    let sel_none_off_some              = (!sel_count &&  off_count                            );
    let sel_off_alt_bak_none           = (!sel_count && !off_count && !alt_count && !bak_count);
    let sel_some                       = ( sel_count                                          );
    let sel_some_bak_none              = ( sel_count                             && !bak_count);

    let sel = " <em class='have cc"+ (sel_count ? 1 : 8)+"'>SEL "+ sel_count +"</em>";
    let off = " <em class='have cc"+ (off_count ? 5 : 8)+"'>OFF "+ off_count +"</em>";
    let bak = " <em class='have cc"+ (bak_count ? 2 : 8)+"'>BAK "+ bak_count +"</em>";



 let action;
    if(      pat_bag_is_opened && (pat_bag_onload || bagopen_click)) { action = bagclose_msg                  ; t_pat_bag_close(caller, action + sel + off + bak); }
    else if(!pat_bag_is_opened && sel_none_off_some                ) { action = sel_none_off_some_msg         ; t_pat_bag_open (caller, action + sel + off + bak); }
    else if( pat_bag_is_opened && bagopen_click                    ) { action = sel_some_msg                  ; t_pat_bag_close(caller, action + sel + off + bak); }
    else if( pat_bag_is_opened && sel_off_alt_bak_none             ) { action = sel_none_off_none_bak_none_msg; t_pat_bag_close(caller, action + sel + off + bak); }
    else                                                             { action = no_change_msg                 ;
        if(!has_el_class(pat_bag, CSS_OPEN_BAG))
            t_pat_bag_minHeight_track(_caller+" .. "+action);
    }

    if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_3_RESULT, action+ sel + off + bak);




if(log_this) {
    log_key_val_group( "bags action"
                       , {   pat_bag_is_opened
                           , sel_none_off_some
                           , sel_off_alt_bak_none
                           , sel_some
                           , sel_some_bak_none
                           , pat_bag_onload
                           , bagopen_click
                           , action
                       }
                       , lf8, false
                     );
}


};


let t_pat_bag_open  = function(_caller, msg="Pattern bag opened")
{

let caller   = "t_pat_bag_open";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c"+caller+"%c .. CALLED BY "+ _caller+" %c .. msg=["+msg+"]", lbH+lf1, lb0, lbF);
if(msg) if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_2_ACTION, msg);


    if(!has_el_class(pat_bag, CSS_OPEN_BAG))
    {
        if(log_this)
            t_fly.t_log_transcript_event_bot("<span style='color:red;'>"+t_data.SYMBOL_BLACK_CIRCLE+"</span>"
                +                      " <span>open_bag</span>"
                +                      " <em>"+msg+"</em>"
            );

        t_pat_bag_minHeight_clear("OPENING");
        add_el_class(pat_bag, CSS_OPEN_BAG);

        t_pat_bag_open_or_close_layout();



        t_cache_sync(msg);
    }

};



let T_PAT_BAG_CLOSE_DELAY            = 1000;
let T_PAT_BAG_CLOSE_RESCHEDULE_DELAY = 1000;
let t_pat_bag_close_timer;
let t_pat_bag_close_msg;

let t_pat_bag_close = function(_caller, msg="PATTERN BAG CLOSED")
{

let caller   = "t_pat_bag_close";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log(caller+"%c .. CALLED BY "+ _caller+" %c .. msg=["+t_util.strip_HTML(msg)+"]", lb0, lbF);
if(msg) if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_2_ACTION, msg);



    t_pat_bag_close_msg = msg;
    if(t_pat_bag_close_timer) clearTimeout( t_pat_bag_close_timer  );
    t_pat_bag_close_timer     = setTimeout( t_pat_bag_close_handler, T_PAT_BAG_CLOSE_DELAY);

};


let t_pat_bag_close_handler = function()
{

let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;


    t_pat_bag_close_timer = null;

    if( has_el_class(pat_bag, CSS_OPEN_BAG) )
    {

        let close_canceled
            = onWork_MOVABLE_CHILD
            ?  true
            :  false;

        if(close_canceled) {
            t_pat_bag_close_timer = setTimeout(t_pat_bag_close_handler, T_PAT_BAG_CLOSE_RESCHEDULE_DELAY);
        }


        else {
            t_pat_bag_minHeight_track("CLOSING");
            del_el_class(pat_bag, CSS_OPEN_BAG);


            t_pat_bag_closing();

            t_pat_bag_open_or_close_layout();



            t_cache_sync("t_pat_bag_close_handler");
        }


if(log_this) {
    let s_style = close_canceled ? "color:yellow" : "color:green";
    let t_style = close_canceled ? "color:yellow" : "text-decoration:line-through";
    let t_text  = close_canceled ? "kept open while moving child" : t_pat_bag_close_msg;
    t_fly.t_log_transcript_event_bot( "<span style='"+ s_style +";'>"+t_data.SYMBOL_BLACK_CIRCLE+"</span>"
        +                      " <span style='"+ t_style +";'>open_bag</span>"
        +                      " <em>"+          t_text  +"</em>"
    );
}

    }
};




const BAG_LAYOUT_DELAY = 250;

let t_pat_bag_open_or_close_layout_timeout;
let t_pat_bag_open_or_close_layout_time_ms;


let t_pat_bag_open_or_close_layout = function(delay=BAG_LAYOUT_DELAY)
{

let   caller = "t_pat_bag_open_or_close_layout";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c"+caller+"("+delay+")", lbH+lf1);


    let time_now = new Date().getTime();
    let time_ms  = time_now + delay;
    if( time_ms <= t_pat_bag_open_or_close_layout_time_ms) return;

    t_pat_bag_open_or_close_layout_time_ms = time_ms;


    if(t_pat_bag_open_or_close_layout_timeout)
    {
        clearTimeout(t_pat_bag_open_or_close_layout_timeout);
if( log_this) log("%c...calling viewport handler in "+(t_pat_bag_open_or_close_layout_time_ms-time_now)+" ms (POSTPONING)", lf2);
    }
    else {
if( log_this) log("%c...calling viewport handler in "+(t_pat_bag_open_or_close_layout_time_ms-time_now)+" ms (FIRST CALL)", lf8);
    }
    t_pat_bag_open_or_close_layout_timeout =     setTimeout(t_pat_bag_open_or_close_viewport_handler, delay);

};


let t_pat_bag_open_or_close_viewport_handler = function()
{

let   caller = "t_pat_bag_open_or_close_viewport_handler";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c"+caller, lbH+lf1);


    t_pat_bag_open_or_close_layout_timeout =  null;
if( log_this) t_pat_bag_open_or_close_viewport_log();

    let pat_bag_is_opened = has_el_class(pat_bag, CSS_OPEN_BAG);
    if(!pat_bag_is_opened)
    {
        if(pat_bag.capped_from_x && pat_bag.capped_from_y)
        {
            t_set_panel_at_XY(pat_bag, pat_bag.capped_from_x  , pat_bag.capped_from_y);

            t_view.t_view7_clr_panel_capped_from_xy(pat_bag);
        }
    }


    else {

        let xy = t_view.t_view5_move_panel_XY(pat_bag, pat_bag.offsetLeft, pat_bag.offsetTop);
        if( xy.capped ) {
            let pat_bag_is_pinned = pat_bag.classList.contains(t_data.CSS_PINNED);
            if( pat_bag_is_pinned ) {
                t_pin_panel_at_XY(pat_bag, xy.x, xy.y);
            }
            else {
                t_set_panel_at_XY(pat_bag, xy.x, xy.y);
            }
        }

    }


    let was_too_large = has_el_class(pat_bag,CSS_TOO_LARGE);

    t_layout_panel_magnified(pat_bag, t_is_panel_magnified(pat_bag));

    if(!was_too_large && has_el_class(pat_bag,CSS_TOO_LARGE))
    {
if(log_this) logBIG("TOO LARGE - RE-ADJUSTING");
        t_pat_bag_open_or_close_layout();
    }


    if(bag_rot.innerHTML)
    {



    }

};


let t_pat_bag_open_or_close_viewport_log = function()
{

    let caller = "...VIEWPORT HANDLER";



    let pat_bag_is_opened = has_el_class(pat_bag, CSS_OPEN_BAG);
    let pat_bag_is_pinned = pat_bag.classList.contains(t_data.CSS_PINNED);

    let pat_bag_state
        =     (pat_bag_is_pinned ? "PINNED" : "UNPINNED")
        + " "+(pat_bag_is_opened ? "OPENED" : "CLOSED"  );
    let lfs
        = pat_bag_is_opened
        ? lf5
        : lf6
    ;



    if(!pat_bag_is_opened) {
        if(pat_bag.capped_from_x || pat_bag.capped_from_y)
log("%c"+caller+": %c ["+pat_bag_state+"] %c CAPPED MOVED BACK FROM XY ["+pat_bag.capped_from_x+" "+pat_bag.capped_from_y+"]", lf1, lfs,lf5);
        else
log("%c"+caller+": %c ["+pat_bag_state+"] %c CAPPED FROM XY NOT SET", lf1, lfs, lf8);
    }


    let xy = t_view.t_view5_move_panel_XY(pat_bag, pat_bag.offsetLeft, pat_bag.offsetTop);
    if( xy ) {
        let       dx = Math.round(xy.x - pat_bag.offsetLeft);
        let       dy = Math.round(xy.y - pat_bag.offsetTop );

        let moving_dx = (dx == 0) ? "" : (" "+((dx > 0) ? "RIGHT" : "LEFT")+" "+dx+"px");
        let moving_dy = (dy == 0) ? "" : (" "+((dy > 0) ? "DOWN"  : "UP"  )+" "+dy+"px");

        if( xy.capped ) {
            if(pat_bag_is_pinned)
log("%c"+caller+": %c ["+pat_bag_state+"] %c PINNED TO ["+ moving_dx         +" "+moving_dy        +"]", lf1, lfs, lf4);
            else
log("%c"+caller+": %c ["+pat_bag_state+"] %c  MOVED TO ["+ moving_dx         +" "+moving_dy        +"]", lf1, lfs, lf3);
        }
        else {
log("%c"+caller+": %c ["+pat_bag_state+"] %c INSIDE AT ["+ pat_bag.offsetLeft+" "+pat_bag.offsetTop+"]", lf1, lfs, lf5);
        }
    }


};



let t_pat_bag_closing = function()
{

    add_el_class(pat_bag, CSS_CLOSING);
    setTimeout(function() { del_el_class(pat_bag, CSS_CLOSING); }, 5000);
};



let t_pat_bag_minHeight_track = function(_caller)
{

let   caller = "t_pat_bag_minHeight_track";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;




    let    cs  = window.getComputedStyle(pat_bag);
    let cur_h  = parseInt(           cs.height   );
    let min_h  = parseInt(pat_bag.style.minHeight) || 0;
    if( min_h == cur_h) return;

    pat_bag.style.minHeight = Math.max(min_h , cur_h)+"px";

if(log_this) {
    let lfx = (min_h == 0)     ? lf9
        :     (min_h <  cur_h) ? lf7
        :     (min_h == cur_h) ? lf5
        :                        lf8;
log("%c "+caller+"("+_caller+") %c height "+cs.height+"%c minHeight .. "+min_h+" "+t_data.SYMBOL_HEAVY_RIGHT_ARROW+" "+pat_bag.style.minHeight+" ", lbH, lbH+lf5, lbH+lfx);
}


};


let t_pat_bag_minHeight_clear = function(_caller)
{

let   caller = "t_pat_bag_minHeight_clear";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;




    if(pat_bag.style.minHeight)
    {
if(log_this) log("%c "+caller+"("+_caller+") %c CLEAR ["+pat_bag.style.minHeight+"]", lbH+lf1, lbH+lf2);

        pat_bag.style.minHeight = "";
    }
    else {
if(log_this) log("%c "+caller+"("+_caller+") %c CLEAR ["+pat_bag.style.minHeight+"]", lbH+lf1, lbH+lf8);

    }
};



let t_pat_bag_set_moving_item_label  = function(moving_item_label)
{
let   caller = "t_pat_bag_set_moving_item_label("+moving_item_label+")";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;
if( log_this) log(caller);

    if(moving_item_label) add_el_class(pat_bag, CSS_HAS_MOVING_CHILD);
    else                  del_el_class(pat_bag, CSS_HAS_MOVING_CHILD);

    let pat_bag_is_opened    = has_el_class(pat_bag, CSS_OPEN_BAG);

    if( (moving_item_label && !pat_bag_is_opened) )
        t_pat_bag_open(caller, "OPENED - MOVING ITEM "+moving_item_label);
};


let t_show_hov_1 = function(x,y) { if(typeof hov1 == "undefined") return; hov1.style.display = "inline-block"; hov1.style.left = x+"px"; hov1.style.top = y+"px"; };
let t_show_hov_2 = function(x,y) { if(typeof hov2 == "undefined") return; hov2.style.display = "inline-block"; hov2.style.left = x+"px"; hov2.style.top = y+"px"; };
let t_hide_hov   = function()
{
    if(typeof hov1 != "undefined") hov1.style.display = "none";
    if(typeof hov2 != "undefined") hov2.style.display = "none";
    if(typeof hov3 != "undefined") hov3.style.display = "none";
    if(typeof hov4 != "undefined") hov4.style.display = "none";
};



let t_hov_rect = function(moving_rect, hovered_rect)
{
    hov1.style.display= "block"; hov1.style.left = ( moving_rect.left )+"px"; hov1.style.top = ( moving_rect.top   )+"px";
    hov2.style.display= "block"; hov2.style.left = ( moving_rect.right)+"px"; hov2.style.top = ( moving_rect.bottom)+"px";
    hov3.style.display= "block"; hov3.style.left = (hovered_rect.left )+"px"; hov3.style.top = (hovered_rect.top   )+"px";
    hov4.style.display= "block"; hov4.style.left = (hovered_rect.right)+"px"; hov4.style.top = (hovered_rect.bottom)+"px";
};


let t_pat_bag_mov_div_is_xy_hovering_bag = function(x,y,hov_div)
{

    let mov_div_rect
        = { top    : y
        ,   left   : x
        ,   bottom : y                  + mov_div.offsetHeight
        ,   right  : x                  + mov_div.offsetWidth
    };



    let hov_div_top  = (hov_div == pat_bag) ? 0 : hov_div.offsetTop ;
    let hov_div_left = (hov_div == pat_bag) ? 0 : hov_div.offsetLeft;

    let hov_div_rect
        = { top    : hov_div_top
          , left   : hov_div_left
          , bottom : hov_div_top        + hov_div.offsetHeight
          , right  : hov_div_left       + hov_div.offsetWidth
    };

    let overlapping
        = !(   (mov_div_rect.right  < hov_div_rect.left  )
            || (mov_div_rect.left   > hov_div_rect.right )
            || (mov_div_rect.bottom < hov_div_rect.top   )
            || (mov_div_rect.top    > hov_div_rect.bottom)
        );

    if(overlapping || (hov_div == pat_bag))
        t_hov_rect(mov_div_rect, hov_div_rect);


    return overlapping;
};


let pat_bag_mov_div_get_dst_near_xy = function(x,y)
{


    let   p_w = pat_bag.offsetWidth ;
    let   p_h = pat_bag.offsetHeight;

    if(pat_bag_was_grid_whenGrabbed)
    {
        let w_32  = p_w  / 3 * 2;
        let w_3   = p_w  / 3;
        let o_top = off_bag.offsetTop;

        if     (x > w_32  ) return bak_bag;
        else if(x > w_3   ) return alt_bag;
        else if(y > o_top ) return off_bag;
        else                return pat_bag;
    }
    else {
        let h_4  = p_h / 4;
        let h_42 = p_h / 4 * 2;
        let h_43 = p_h / 4 * 3;

        if     (y <  h_4  ) return pat_bag;
        else if(y <  h_42 ) return off_bag;
        else if(y <  h_43 ) return alt_bag;
        else                return bak_bag;
    }

};


let t_pat_bag_hover_div_accept = function(div, at_bag_top)
{

let caller = "t_pat_bag_hover_div_accept";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;



    if(    (div != pat_bag)) {
        if((div.firstElementChild == mov_pat_span) &&  at_bag_top) return;
        if((div.lastElementChild  == mov_pat_span) && !at_bag_top) return;

    }
    mov_dst_div = div;
    mov_dst_div.at_bag_top = at_bag_top;


    let before_child
        = (mov_dst_div  == pat_bag) ? off_bag
        : (at_bag_top             ) ? mov_dst_div.firstElementChild
        :                             null
    ;

if(log_this) {

    let l_from
        = (mov_pat_span.parentNode == pat_bag) ? lf4
        : (mov_pat_span.parentNode == off_bag) ? lf5
        : (mov_pat_span.parentNode == bak_bag) ? lf2
        : (mov_pat_span.parentNode == alt_bag) ? lf6
        :                                        lf0;

    let l_to
        = (mov_dst_div             == pat_bag) ? lf4
        : (mov_dst_div             == off_bag) ? lf5
        : (mov_dst_div             == bak_bag) ? lf2
        : (mov_dst_div             == alt_bag) ? lf6
        :                                        lf0;

    let first_or_last = before_child  ?  "FIRST" : "LAST";
    let lfc           = before_child  ?    lf8   :  lf9  ;

    log("%c"+caller+"("+(at_bag_top ? "TOP" : "BOT")+") %c"+mov_pat_span.parentNode.id+"%c"+t_data.SYMBOL_RIGHT_ARROW+"%c"+mov_dst_div.id+"%c"+first_or_last
        ,lbH                                           ,lbL+l_from                     ,lbC                    ,lbR+l_to           ,lbH+lfc          );
}

    if     (mov_dst_div  == off_bag) off_bag.insertBefore( mov_pat_span, before_child);
    else if(mov_dst_div  == alt_bag) alt_bag.insertBefore( mov_pat_span, before_child);
    else if(mov_dst_div  == bak_bag) bak_bag.insertBefore( mov_pat_span, before_child);
    else if(mov_dst_div  == pat_bag) pat_bag.insertBefore( mov_pat_span, off_bag     );

    if     (mov_dst_div  == off_bag) reorder_pat_csv(at_bag_top);
    else if(mov_dst_div  == alt_bag) reorder_pat_csv(at_bag_top);
    else if(mov_dst_div  == bak_bag) reorder_pat_csv(at_bag_top);
    else if(mov_dst_div  == pat_bag) reorder_pat_csv(at_bag_top);

    t_pat_bag_open_or_close_layout();

};


let reorder_pat_csv = function(at_bag_top)
{

let caller = "reorder_pat_csv";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if(log_this) t_log.console_clear("reorder_pat_csv");



    let move_span = mov_pat_span.childNodes[2];
    let move_pat  = t_util.csv_unescape(move_span.getAttribute("data-pattern"))     ;


    pat_csv = t_util.csv_del(pat_csv, move_pat);
    off_csv = t_util.csv_del(off_csv, move_pat);
    alt_csv = t_util.csv_del(alt_csv, move_pat);
    bak_csv = t_util.csv_del(bak_csv, move_pat);
    bin_csv = t_util.csv_del(bin_csv, move_pat);


    if     (mov_dst_div == pat_bag) pat_csv = (at_bag_top ? t_util.csv_ins : t_util.csv_add) (pat_csv, move_pat);
    else if(mov_dst_div == off_bag) off_csv = (at_bag_top ? t_util.csv_ins : t_util.csv_add) (off_csv, move_pat);
    else if(mov_dst_div == alt_bag) alt_csv = (at_bag_top ? t_util.csv_ins : t_util.csv_add) (alt_csv, move_pat);
    else if(mov_dst_div == bak_bag) bak_csv = (at_bag_top ? t_util.csv_ins : t_util.csv_add) (bak_csv, move_pat);


    set_bag_rot_title("ORDERING:");


if( log_this) {
    log(caller+": %c at_bag_top "+at_bag_top, lbH+lfX[at_bag_top ? 4 :6]);

    let p_pfx = ( at_bag_top && (mov_dst_div == pat_bag)) ? t_data.SYMBOL_RIGHT_ARROW : "";
    let o_pfx = ( at_bag_top && (mov_dst_div == off_bag)) ? t_data.SYMBOL_RIGHT_ARROW : "";
    let a_pfx = ( at_bag_top && (mov_dst_div == alt_bag)) ? t_data.SYMBOL_RIGHT_ARROW : "";
    let b_pfx = ( at_bag_top && (mov_dst_div == bak_bag)) ? t_data.SYMBOL_RIGHT_ARROW : "";

    let p_sfx = (!at_bag_top && (mov_dst_div == pat_bag)) ? t_data.SYMBOL_LEFT_ARROW  : "";
    let o_sfx = (!at_bag_top && (mov_dst_div == off_bag)) ? t_data.SYMBOL_LEFT_ARROW  : "";
    let a_sfx = (!at_bag_top && (mov_dst_div == alt_bag)) ? t_data.SYMBOL_LEFT_ARROW  : "";
    let b_sfx = (!at_bag_top && (mov_dst_div == bak_bag)) ? t_data.SYMBOL_LEFT_ARROW  : "";

    log("%c pat_csv %c"+p_pfx+"%c"+ pat_csv +"%c"+ p_sfx, lf4,lbb+lb4, lbH+lf4,lbb+lb4);
    log("%c off_csv %c"+o_pfx+"%c"+ off_csv +"%c"+ o_sfx, lf5,lbb+lb5, lbH+lf5,lbb+lb5);
    log("%c alt_csv %c"+a_pfx+"%c"+ alt_csv +"%c"+ a_sfx, lf6,lbb+lb6, lbH+lf6,lbb+lb6);
    log("%c bak_csv %c"+b_pfx+"%c"+ bak_csv +"%c"+ b_sfx, lf7,lbb+lb7, lbH+lf7,lbb+lb7);
    log("%c bin_csv %c"+b_pfx+"%c"+ bin_csv +"%c"+ b_sfx, lf0,lbb+lb0, lbH+lf0,lbb+lb0);
}

};


let t_sel_pat_bag_all = function()
{

let caller = "t_sel_pat_bag_all";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c"+caller, lbH+lf1);


    if(off_csv) pat_csv = t_cat_csv1_csv2(pat_csv,off_csv);


    let   count = t_util.csv_count( pat_csv );
if( log_this) log("%c"+count+" patterns in [pat_csv] %c"+pat_csv, lbL+lf4, lbR+lf9);

    let     tmp_csv = String( pat_csv );
    let slotted_csv = "";
    let missing_csv = "";

    count   = t_util.csv_count( tmp_csv );
    for(let pos=1; pos<=count; ++pos)
    {

        let pattern = t_util.csv_get(tmp_csv, pos);

        if( !t_slot.get_slot_of_pattern(pattern) )
        {
            t_words_regex_reset(          pattern);

            call_check_TreeWalker("body", pattern);
        }


        if( !t_slot.get_slot_of_pattern(pattern) )
        {
if( log_this) log("%c"+pos+"%c NOT SLOTTED %c HIDE %c "+pattern, lbH+lfX[pos % 10], lbL+lf5, lbC+lf5, lbR+lf9);
            csv_pattern_mov_to_off( pattern );

            missing_csv = t_util.csv_add(missing_csv, pattern);
        }


        else if(t_slot.t_set_slot_of_pattern(pos, pattern))
        {
if( log_this) log("%c"+pos+"%c ... SLOTTED %c SHOW %c "+pattern, lbH+lfX[pos % 10], lbL+lf4, lbC+lf4, lbR+lf9);
            csv_pattern_mov_to_pat( pattern );

            slotted_csv = t_util.csv_add(slotted_csv, pattern);
        }


        else {
if( log_this) log("%c"+pos+"%c NOT   FOUND %c BACK %c "+pattern, lbH+lfX[pos % 10], lbL+lf2, lbC+lf2, lbR+lf9);
            csv_pattern_mov_to_bak( pattern );

            missing_csv = t_util.csv_add(missing_csv, pattern);
        }

    }



    let msg = "";

    let s_count = t_util.csv_count( slotted_csv );
    let b_count = t_util.csv_count( bak_csv );

    if(slotted_csv)
        msg
        =  " <em class='done cc9'>FOUND "+  s_count                       +"</em>"
        +  " <em class='have cc1'>"+        t_util.ellipsis_short( slotted_csv ) +"</em>"
    ;
    else
        msg
        =  " <em class='done cc9'>NO SELECTION</em>"
    ;

    if(missing_csv)
        msg
        += " .."
        +  " <em class='done cc8'>MISSED "+ b_count                       +"</em>"
        +  " <em class='have cc8'>"+        t_util.ellipsis_short( missing_csv ) +"</em>"
    ;


    if(t_util.csv_count( off_csv ) || t_util.csv_count( bak_csv ))
        t_pat_bag_open(caller, "OPEN BAGS WHEN NOT ALL SELECTED");


    t_select.t_onPatternUpdate(msg, caller);
};


let t_cat_csv1_csv2 = function(csv1,csv2)
{

    let csv1_only = "";
    let   count = t_util.csv_count( csv1 );
    for(let pos =1; pos<=count; ++pos)
    {
        let pattern = t_util.csv_get(csv1, pos);
        if(!t_util.csv_contains(csv2, pattern) )
            csv1_only = t_util.csv_add(csv1_only, pattern);
    }
    let csv = t_util.csv_cat(csv1_only, csv2);

    return csv;
};




let T_PAT_BAG_STATUS_DELAY = 1000;
let t_pat_bag_status_timer;

let t_pat_bag_status = function(delay=T_PAT_BAG_STATUS_DELAY)
{
    if(       t_pat_bag_status_timer) clearTimeout( t_pat_bag_status_timer);
    if(delay) t_pat_bag_status_timer  = setTimeout( t_pat_bag_status_handler, T_PAT_BAG_STATUS_DELAY);
    else                                            t_pat_bag_status_handler();
};


let t_pat_bag_status_handler = function()
{
    t_pat_bag_status_timer = null;

    t_pat_bag_status_set_innerText( t_pat_bag_status_get_status_line() );

    t_eval_wide_or_tall_panel( pat_bag );
};


let t_pat_bag_status_get_status_line = function()
{
    let empty = !t_slot.get_slotted_pattern_count();

    let s = t_util.csv_count(sel_csv);
    let p = t_util.csv_count(pat_csv);
    let o = t_util.csv_count(off_csv);
    let a = t_util.csv_count(alt_csv);
    let b = t_util.csv_count(bak_csv);

    let more
        =     s ? (" more")
        :         (""     )
    ;

    let selected
        = empty ? (    "None selected")
        :         (s+"/"+p+" selected");

    let can_do
        =  (o+b)? ((o+a+b)+" "+more+" to choose from")
        :         ("nothing " +more+" to choose from")

    ;

    let pat_bag_status
        = selected
        + LF +t_data.SYMBOL_RIGHT_ARROW + can_do

    ;

    return pat_bag_status;
};



let em_pixels;


let t_pat_bag_status_set_innerText = function(innerText)
{
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

    if(!em_pixels) {
        let    cs = window.getComputedStyle(fly_log);
        em_pixels = parseInt(cs.width) / 1.4;
    }

    let    l = innerText.indexOf(LF);
    let head = (l > 0) ? innerText.substring(0,l+1) : ""       ;
    let tail = (l > 0) ? innerText.substring(  l+1) : innerText;

    let  len = parseInt(bot_div.clientWidth / em_pixels);

    bag_log.innerText = head + tail;

    t_util.set_el_caption(bag_log, innerText);
    t_util.set_el_caption(pat_bag, innerText);

if(log_this) log("t_pat_bag_status_set_innerText: %c bot_div is "+len+" EM wide %c "+ t_util.strip_CR_LF(bag_log.innerText) +" ", lb8, lbH+lf4);
};



let t_pat_get_el_data_pattern = function(el)
{
    let data_pattern = t_util.csv_unescape(el.getAttribute("data-pattern"));

    return data_pattern;
};





let last_bag_move;


let t_handle_1_pat_bag = function(e_target)
{

let   caller = "t_handle_1_pat_bag";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c"+caller+"%c"+get_n_lbl(e_target), lf1, lbH+lf1);


    let pat_bag_is_on_standby = (onStandby_PANEL && (onStandby_PANEL.id == pat_bag.id));
    if( pat_bag_is_on_standby)
    {
        t_standby3_release( caller );
    }


    else if(e_target.id == "pat_sort")
    {
        t_handle_1_pat_bag_sort_cycle();
    }


    else if(   (e_target.id.includes("bag_rot"           ))
            || (e_target.id.includes(t_data.WORDS_BAG_ROT))
    ) {

        if(e_target.firstElementChild )
        {
            let button = (e_target.id == t_data.WORDS_BAG_ROT)
                ? e_target
                : t_get_tool(t_data.WORDS_BAG_ROT);

            button.firstElementChild.style.transform = "rotate3d(0,1,0,0.25turn) scale(0.8)";

            let bag_rot_clone = get_doc_tool_diplayed_id_prefix( button.id );
            if( bag_rot_clone ) bag_rot_clone.firstElementChild.style.transform = "rotate3d(0,1,0,0.25turn) scale(0.8)";


        }


        rot_move_all_pat_spans_to_off_bag();


        let is_pat_bag_selected = t_tools_panel_is_selected(pat_bag);
        let is_pat_bag_hidden   = has_el_class(             pat_bag, t_data.CSS_HIDDEN);
        let is_pat_bag_visible
            =   is_pat_bag_selected
            && !is_pat_bag_hidden;


        if( is_pat_bag_visible ) {
            t_handle_1_pat_bag_rotating( true);
            let      cs = window.getComputedStyle(off_bag);
            let      ms = t_util.string_to_ms(cs.animationDuration);


            setTimeout(function() {
                t_handle_1_pat_bag_rotation();
                t_handle_1_pat_bag_rotating(false);
            }, ms+200);
        }


        else {
            t_handle_1_pat_bag_rotation();
        }

    }


    else if(e_target.id == "fly_log")
    {
if( log_this) log("...[fly_log] CLICK");


        let state = has_el_class(e_target, t_data.CSS_CHECKED);
        t_fly.t_fly_log_set_state(state ? false : e_target.id+" checked");
    }

    else {
        t_pat_bag_stage_target( e_target );
    }
};


let rot_move_all_pat_spans_to_off_bag = function()
{
    t_select.t_collect_el_class_from_into("pat_span", pat_bag, pat_spans);

    for(let pat_span_index = pat_spans.length-1; pat_span_index >= 0; --pat_span_index)
    {
        if(                      !pat_spans[pat_span_index]) continue;
        off_bag.insertBefore(     pat_spans[pat_span_index], off_bag.firstElementChild);
        sync_pat_span_slot_class("", pat_spans[pat_span_index]);
    }
};





const STAGE1__PAT_CLICKED____________________THEN_TOGGLE_PAT     = { color:1 , level:"1", context:"PAT_CLICKED"                   , action:"TOGGLE_PAT"     };

const STAGE2__BAK_MANY_SEL_NONE__BAG_CLOSED__THEN_OPEN_BAG       = { color:2 , level:"2", context:"BAK_MANY_SEL_NONE__BAG_CLOSED" , action:"OPEN_BAG"       };
const STAGE3__BAK_SOME___________BAK_CLICKED_THEN_DUMP_BAK       = { color:3 , level:"3", context:"BAK_SOME___________BAK_CLICKED", action:"DUMP_BAK"       };
const STAGE3__ALT_SOME___________ALT_CLICKED_THEN_DUMP_ALT       = { color:3 , level:"3", context:"ALT_SOME___________ALT_CLICKED", action:"DUMP_ALT"       };
const STAGE4__BAK_NONE_SEL_SOME______________THEN_HIDE_SEL       = { color:5 , level:"5", context:"BAK_NONE_SEL_SOME"             , action:"HIDE_SEL"       };
const STAGE4__ALT_NONE_SEL_SOME______________THEN_HIDE_SEL       = { color:5 , level:"5", context:"ALT_NONE_SEL_SOME"             , action:"HIDE_SEL"       };

const STAGE2__OFF_MANY_SEL_NONE__BAG_CLOSED__THEN_OPEN_BAG       = { color:2 , level:"2", context:"OFF_MANY_SEL_NONE__BAG_CLOSED" , action:"OPEN_BAG"       };
const STAGE3__OFF_SOME___________OFF_CLICKED_THEN_DUMP_OFF       = { color:3 , level:"3", context:"OFF_SOME___________OFF_CLICKED", action:"DUMP_OFF"       };

const STAGE4__OFF_SOME___________BAG_OPENED__THEN_SHOW_OFF       = { color:4 , level:"4", context:"OFF_SOME___________BAG_OPENED" , action:"SHOW_OFF"       };
const STAGE4___________SEL_SOME__BAG_OPENED__THEN_SHOW_OFF       = { color:4 , level:"4", context:"_________SEL_SOME__BAG_OPENED" , action:"SHOW_OFF"       };

const STAGE5__OFF_NONE_SEL_SOME__BAG_CLOSED__THEN_HIDE_SEL       = { color:5 , level:"5", context:"OFF_NONE_SEL_SOME__BAG_CLOSED" , action:"HIDE_SEL"       };

const STAGE6__STANDBY_IDLE___________________THEN_STANDBY_ON     = { color:6 , level:"6", context:"STANDBY_IDLE"                  , action:"STANDBY_ON"     };
const STAGE7__STANDBY_CLOSED_________________THEN_STANDBY_OPENED = { color:7 , level:"7", context:"STANDBY_CLOSED"                , action:"STANDBY_OPENED" };
const STAGE8__STANDBY_OPENED_________________THEN_STANDBY_DONE   = { color:8 , level:"8", context:"STANDBY_OPENED"                , action:"STANDBY_DONE"   };


let t_pat_bag_stage_target = function(e_target)
{

let   caller = "t_pat_bag_stage_target("+get_n_lbl(e_target)+")";
let log_this = LOG_MAP.S0_PATTERN;

if( log_this) t_fly.t_log_event_status(caller, lf1);


    if(e_target.nodeType == Node.TEXT_NODE) e_target = e_target.parentElement;

    let            parent_div = t_util.get_el_parent_with_tag(e_target,"DIV");
    let pat_bag_is_on_standby = ((onStandby_PANEL != null ) && (onStandby_PANEL == e_target));
    let pat_bag_is_opened     = (        has_el_class( pat_bag, CSS_OPEN_BAG)              );

    let pattern_clicked       = (e_target.tagName == "EM") || e_target.id.startsWith( "pattern");
    let pat_bag_clicked       = (parent_div == pat_bag);
    let off_bag_clicked       = (parent_div == off_bag);
    let alt_bag_clicked       = (parent_div == alt_bag);
    let bak_bag_clicked       = (parent_div == bak_bag);
    let bot_div_clicked       = (parent_div == bot_div);


    let sel_csv_is_empty         = (           t_util.csv_count( sel_csv ) < 1             );
    let off_csv_one_or_more      = (           t_util.csv_count( off_csv ) > 0             );
    let off_csv_more_than_one    = (           t_util.csv_count( off_csv ) > 1             );
    let alt_csv_one_or_more      = (           t_util.csv_count( alt_csv ) > 0             );
    let alt_csv_more_than_one    = (           t_util.csv_count( alt_csv ) > 1             );
    let bak_csv_one_or_more      = (           t_util.csv_count( bak_csv ) > 0             );
    let bak_csv_more_than_one    = (           t_util.csv_count( bak_csv ) > 1             );




    let stage
        = (  pattern_clicked                                                     ) ? STAGE1__PAT_CLICKED____________________THEN_TOGGLE_PAT : (  bak_csv_more_than_one  &&  sel_csv_is_empty  &&  !pat_bag_is_opened ) ? STAGE2__BAK_MANY_SEL_NONE__BAG_CLOSED__THEN_OPEN_BAG
        : (  off_csv_more_than_one  &&  sel_csv_is_empty  &&  !pat_bag_is_opened ) ? STAGE2__OFF_MANY_SEL_NONE__BAG_CLOSED__THEN_OPEN_BAG


        : (  off_csv_one_or_more                          &&   off_bag_clicked   ) ? STAGE3__OFF_SOME___________OFF_CLICKED_THEN_DUMP_OFF
        : (  bak_csv_one_or_more                          &&   bak_bag_clicked   ) ? STAGE3__BAK_SOME___________BAK_CLICKED_THEN_DUMP_BAK
        : (  alt_csv_one_or_more                          &&   alt_bag_clicked   ) ? STAGE3__ALT_SOME___________ALT_CLICKED_THEN_DUMP_ALT


        : (  off_csv_one_or_more                          &&   pat_bag_is_opened ) ? STAGE4__OFF_SOME___________BAG_OPENED__THEN_SHOW_OFF
        : (                            !sel_csv_is_empty  &&   pat_bag_is_opened ) ? STAGE4___________SEL_SOME__BAG_OPENED__THEN_SHOW_OFF

        : ( !off_csv_one_or_more    && !sel_csv_is_empty  &&  !pat_bag_is_opened ) ? STAGE5__OFF_NONE_SEL_SOME__BAG_CLOSED__THEN_HIDE_SEL

        : ( !bak_csv_one_or_more    && !sel_csv_is_empty                         ) ? STAGE4__BAK_NONE_SEL_SOME______________THEN_HIDE_SEL

        : ( !alt_csv_one_or_more    && !sel_csv_is_empty                         ) ? STAGE4__ALT_NONE_SEL_SOME______________THEN_HIDE_SEL

        : ( !pat_bag_is_on_standby                        &&   pat_bag_clicked   ) ? STAGE6__STANDBY_IDLE___________________THEN_STANDBY_ON
        : ( !pat_bag_is_opened                                                   ) ? STAGE7__STANDBY_CLOSED_________________THEN_STANDBY_OPENED
        :                                                                            STAGE8__STANDBY_OPENED_________________THEN_STANDBY_DONE
    ;



        let  something_clicked
            =  pattern_clicked
            || bak_bag_clicked

            || off_bag_clicked
            || bot_div_clicked
        ;
    if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG))
        t_fly.t_log_stage(stage, something_clicked, pattern_clicked, e_target, parent_div);



    t_pat_bag_status_set_innerText(stage.level+" "+stage.context+" "+stage.action);



if( log_this) log("%c "+caller+" %c level %c "+stage.level   +" %c context %c "+stage.context+" %c action %c "+ stage.action
                  ,lbH+lbb+lf7  ,lbL     ,lbR+lfX[stage.color] ,lbL       ,lbR+lfX[stage.color],lbL      ,lbR+lfX[stage.color]);

if(log_this)
    log_key_val_group( "UI "+get_n_lbl(parent_div)
                       , {   pat_bag_is_on_standby
                           , pat_bag_is_opened
                           , pattern_clicked
                           , bak_bag_clicked
                           , alt_bag_clicked
                           , off_bag_clicked
                           , bot_div_clicked
                       }
                       , lf4
                       , true);

if(log_this)
    log_key_val_group( "CSV  pat_csv "+t_util.csv_count(pat_csv)+"   off_csv "+t_util.csv_count(off_csv)+"   alt_csv "+t_util.csv_count(alt_csv)+"   bak_csv "+t_util.csv_count(bak_csv)
                       , {   sel_csv_is_empty
                           , off_csv_one_or_more
                           , off_csv_more_than_one
                           , bak_csv_one_or_more
                           , bak_csv_more_than_one
                           , alt_csv_one_or_more
                           , alt_csv_more_than_one
                       }
                       , lf6
                       , true);


    switch(stage) {
    case STAGE1__PAT_CLICKED____________________THEN_TOGGLE_PAT     : pat_bag1_toggle_pat   (e_target); break;

    case STAGE2__BAK_MANY_SEL_NONE__BAG_CLOSED__THEN_OPEN_BAG       : pat_bag2_bag_open     ();         break;
    case STAGE2__OFF_MANY_SEL_NONE__BAG_CLOSED__THEN_OPEN_BAG       : pat_bag2_bag_open     ();         break;

    case STAGE3__OFF_SOME___________OFF_CLICKED_THEN_DUMP_OFF       : pat_bag3_dump_off     ();         break;
    case STAGE3__ALT_SOME___________ALT_CLICKED_THEN_DUMP_ALT       : pat_bag3_dump_alt     ();         break;
    case STAGE3__BAK_SOME___________BAK_CLICKED_THEN_DUMP_BAK       : pat_bag3_dump_bak     ();         break;

    case STAGE4__BAK_NONE_SEL_SOME______________THEN_HIDE_SEL       : pat_bag5_hide_sel     ();         break;
    case STAGE4__ALT_NONE_SEL_SOME______________THEN_HIDE_SEL       : pat_bag5_hide_sel     ();         break;

    case STAGE4__OFF_SOME___________BAG_OPENED__THEN_SHOW_OFF       : pat_bag4_show_off     ();         break;
    case STAGE4___________SEL_SOME__BAG_OPENED__THEN_SHOW_OFF       : pat_bag4_show_off     ();         break;

    case STAGE5__OFF_NONE_SEL_SOME__BAG_CLOSED__THEN_HIDE_SEL       : pat_bag5_hide_sel     ();         break;

    case STAGE6__STANDBY_IDLE___________________THEN_STANDBY_ON     : pat_bag6_standby      ();         break;
    case STAGE7__STANDBY_CLOSED_________________THEN_STANDBY_OPENED : pat_bag7_standby_open ();         break;
    case STAGE8__STANDBY_OPENED_________________THEN_STANDBY_DONE   : pat_bag8_standby_done ();         break;
    default:
    if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG))
    t_fly.t_log_stage_msg(t_fly.STAGE_2_ACTION, "<div class='cc2'>*** "+stage.level+" "+stage.context+" "+stage.action+"*** <em class='cc8'>"+caller+"</em></div>");
    break;
    }

};




const CSS_ROTATING = "rotating";


let t_handle_1_pat_bag_rotating = function(rotating)
{

let caller ="t_handle_1_pat_bag_rotating";
let log_this = LOG_MAP.S0_PATTERN;

if(log_this) log("%c"+caller+"("+rotating+")", lbH+(rotating ? lf4 : lf1));

    if(rotating) {
        t_bag_xywh_ongrid_save();

        add_el_class(pat_bag, CSS_ROTATING);
        add_el_class(off_bag, CSS_ROTATING);
        add_el_class(alt_bag, CSS_ROTATING);
        add_el_class(bak_bag, CSS_ROTATING);



        let xywh;


        xywh =  pat_bag.ongrid_xywh;
        pat_bag.style.width  = xywh.w+"px";
        pat_bag.style.height = xywh.h+"px";



        let paddingTop = has_el_class(pat_bag, CSS_OPEN_BAG) ? 0 : pat_bag.ongrid_padd.t;
        t_bag_xywh_ongrid_to_absolute(off_bag , 0);
        t_bag_xywh_ongrid_to_absolute(alt_bag , 0);
        t_bag_xywh_ongrid_to_absolute(bak_bag , paddingTop);


    }
    else {

        pat_bag.style.width  = ""; pat_bag.style.height = "";

        t_clear_bag_xywh(off_bag);
        t_clear_bag_xywh(alt_bag);
        t_clear_bag_xywh(bak_bag);



        del_el_class(pat_bag, CSS_ROTATING);
        del_el_class(off_bag, CSS_ROTATING);
        del_el_class(alt_bag, CSS_ROTATING);
        del_el_class(bak_bag, CSS_ROTATING);


    }
};


let t_handle_1_pat_bag_rotation = function()
{

let   caller = "t_handle_1_pat_bag_rotation";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller);
if( log_this || DOM_TOOLS_TAG) pattern_log_bag_csv(caller);



    let pat_csv_old = pat_csv;
    let off_csv_old = off_csv;
    let cleared_csv = t_select.t_clear_slot_all();
    pat_csv         = t_cat_csv1_csv2(pat_csv_old, off_csv_old);
    off_csv         = "";

if( log_this) log("...pat_csv_old=["+pat_csv_old+"]");
if( log_this) log("...off_csv_old=["+off_csv_old+"]");
if( log_this) log("...cleared_csv=["+cleared_csv+"]");

if( log_this) log("%c pat_csv %c["+pat_csv+"]",lbL+lf4, lbR);
if( log_this) log("%c alt_csv %c["+alt_csv+"]",lbL+lf6, lbR);
if( log_this) log("%c bak_csv %c["+bak_csv+"]",lbL+lf2, lbR);
if( log_this) log("%c bin_csv %c["+bin_csv+"]",lbL+lf2, lbR);


    let l_x = 8;
    let this_move;
    let tmp;
    let  to = t_data.SYMBOL_RIGHT_ARROW;
    let  bk = t_data.SYMBOL_LEFT_ARROW_HOOK;



    let pat_bag_only =  pat_csv && !alt_csv && !bak_csv;
    let alt_bag_only = !pat_csv &&  alt_csv && !bak_csv;
    let bak_bag_only = !pat_csv && !alt_csv &&  bak_csv;

    if     (pat_bag_only) { alt_csv = pat_csv; pat_csv = ""; this_move = "<span class='bg4'>PAT</span>"+to+"<span class='bg2'>ALT</span>"; }
    else if(alt_bag_only) { bak_csv = alt_csv; alt_csv = ""; this_move = "<span class='bg4'>ALT</span>"+to+"<span class='bg2'>BAK</span>"; }
    else if(bak_bag_only) { pat_csv = bak_csv; bak_csv = ""; this_move = "<span class='bg4'>BAK</span>"+to+"<span class='bg2'>PAT</span>"; }
    else {
 tmp = bak_csv;
       bak_csv = alt_csv;
                 alt_csv = pat_csv;
                           pat_csv = tmp;
this_move = "<span class='bg4'>PAT</span>"+to+"<span class='bg2'>BAK</span>"+to+"<span class='bg4'>ALT</span>"+bk;
    }

    last_bag_move = this_move;


    set_bag_rot_title( t_util.strip_HTML(this_move) );

    let lfx = lfX[l_x];
if(log_this) log("%c "+t_data.SDX[l_x]+" %c "+this_move, lbB+lfx, lbH+lfx);


    t_handle_1_pat_bag_rotation_update_UI( pat_csv );

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly("<pre class='cc7'>"+bag_rot.title+"</pre>");

};


let t_handle_1_pat_bag_rotation_update_UI = function(reselect_csv)
{

let   caller = "t_handle_1_pat_bag_rotation_update_UI";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log(caller);


    t_select.remove_pat_span_from_div( sel_bag );
    t_select.remove_pat_span_from_div( pat_bag );
    t_select.remove_pat_span_from_div( off_bag );
    t_select.remove_pat_span_from_div( alt_bag );
    t_select.remove_pat_span_from_div( bak_bag );

    pat_bag3_reselect( reselect_csv );

if( log_this) log("%c pat_csv %c["+pat_csv+"]",lbL+lf4, lbR);
if( log_this) log("%c alt_csv %c["+alt_csv+"]",lbL+lf3, lbR);
if( log_this) log("%c bak_csv %c["+bak_csv+"]",lbL+lf2, lbR);
if( log_this) log("%c bin_csv %c["+bin_csv+"]",lbL+lf2, lbR);
};



let t_bag_xywh_ongrid_save = function()
{

        let cs;
        cs = window.getComputedStyle(pat_bag); pat_bag.ongrid_xywh = { x:pat_bag.offsetLeft , y:pat_bag.offsetTop , w:parseInt(cs.width) , h:parseInt(cs.height) , pt:parseInt(cs.paddingTop) , pr:parseInt(cs.paddingRight) };
 pat_bag.ongrid_padd = { t:parseInt(cs.paddingTop) , r:parseInt(cs.paddingRight) };
        cs = window.getComputedStyle(alt_bag); alt_bag.ongrid_xywh = { x:alt_bag.offsetLeft , y:alt_bag.offsetTop , w:parseInt(cs.width) , h:parseInt(cs.height) };
        cs = window.getComputedStyle(bak_bag); bak_bag.ongrid_xywh = { x:bak_bag.offsetLeft , y:bak_bag.offsetTop , w:parseInt(cs.width) , h:parseInt(cs.height) };
        cs = window.getComputedStyle(off_bag); off_bag.ongrid_xywh = { x:off_bag.offsetLeft , y:off_bag.offsetTop , w:parseInt(cs.width) , h:parseInt(cs.height) };



        if( has_el_class(pat_bag, CSS_OPEN_BAG) )
        {
            let h_max = Math.max(off_bag.ongrid_xywh.h, alt_bag.ongrid_xywh.h);
            h_max     = Math.max(h_max                , bak_bag.ongrid_xywh.h);
            off_bag.ongrid_xywh.h = h_max;
            alt_bag.ongrid_xywh.h = h_max;
            bak_bag.ongrid_xywh.h = h_max;

            let y_min = Math.min(off_bag.ongrid_xywh.y, alt_bag.ongrid_xywh.y);
            y_min     = Math.min(y_min                , bak_bag.ongrid_xywh.y);
            off_bag.ongrid_xywh.y = y_min;
            alt_bag.ongrid_xywh.y = y_min;
            bak_bag.ongrid_xywh.y = y_min;
        }

};


let t_bag_xywh_ongrid_to_absolute = function(bag, paddingTop=0)
{
    if(!bag.ongrid_xywh) return;

    bag.style.left   = (             bag.ongrid_xywh.x)+"px";
    bag.style.top    = (paddingTop + bag.ongrid_xywh.y)+"px";
    bag.style.width  = (             bag.ongrid_xywh.w)+"px";
    bag.style.height = (             bag.ongrid_xywh.h)+"px";
};


let t_clear_bag_xywh = function(bag)
{

    bag.style.left   = "";
    bag.style.top    = "";
    bag.style.width  = "";
    bag.style.height = "";
};







let t_handle_1_pat_bag_sort_cycle_direction = 0;


let t_handle_1_pat_bag_sort_cycle = function(requested_direction)
{

let   caller = "t_handle_1_pat_bag_sort_cycle(requested_direction "+ requested_direction +")";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;



    let sel_can_sort = (t_util.csv_count( sel_csv ) > 1);
    let sel_sorted   = sel_can_sort &&                t_are_sel_sorted  ();
    let sel_reversed = sel_can_sort && !sel_sorted && t_are_sel_reversed();

    if( sel_can_sort )
    {

        requested_direction = parseInt(requested_direction);
        requested_direction
            = (requested_direction > 0) ?  1
            : (requested_direction < 0) ? -1
            :                              0;

        switch( requested_direction ) {


        case  1:
        t_handle_1_pat_bag_sort_cycle_direction = requested_direction;
        break;


        case -1: t_handle_1_pat_bag_sort_cycle_direction = requested_direction;
        break;


        default: {
            switch(  t_handle_1_pat_bag_sort_cycle_direction ) {
            default:
            case  0: t_handle_1_pat_bag_sort_cycle_direction = (sel_sorted   ? -1 :  1); break;
            case  1: t_handle_1_pat_bag_sort_cycle_direction = (sel_sorted   ?  0 : -1); break;
            case -1: t_handle_1_pat_bag_sort_cycle_direction = (sel_reversed ?  0 :  1); break;
            }
        }

        }

    }


if( log_this) {
    let lfs = (                            sel_sorted      ) ? lf5 : lf8;
    let lfr = (                            sel_reversed    ) ? lf6 : lf8;
    let lfd = (t_handle_1_pat_bag_sort_cycle_direction == -1) ? lf2
        :     (t_handle_1_pat_bag_sort_cycle_direction ==  1) ? lf5 : lf8;

    log("%c"+caller+": %c sorted "+sel_sorted+" %c reversed "+sel_reversed+" %c direction "+t_handle_1_pat_bag_sort_cycle_direction
        ,lf1          ,lbH+lfs                 ,lbH+lfr                     ,lbH+lfd);

}

    if(t_handle_1_pat_bag_sort_cycle_direction != 0)
    {
        if(     (!sel_sorted   && (t_handle_1_pat_bag_sort_cycle_direction > 0))
             || (!sel_reversed && (t_handle_1_pat_bag_sort_cycle_direction < 0))
          )
            pat_bag3_reselect();
    }
    else {
        t_sync_pat_buttons( caller );
    }
};



let pat_bag1_toggle_pat = function(e_target)
{

let   caller = "pat_bag1_toggle_pat";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;



    let e_target_pattern = t_pat_get_el_data_pattern( e_target );
    if(!e_target_pattern) {
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_1_INPUT, "<em class='cc0'>NO PATTERN TO TOGGLE</em>");
if(log_this) log(t_fly.STAGE_1_INPUT, "NO PATTERN TO TOGGLE");

        return;
    }
if( log_this) caller += "("+e_target_pattern+")";
if( log_this) pattern_log_bag_csv(caller);

    let matching_slot = t_slot.get_slot_matching_pattern( e_target_pattern );




    if(matching_slot) {

        let matching_pattern  = t_select.ccs[matching_slot].pattern;
        if( matching_pattern == e_target_pattern)
        {
if(log_this) log(caller+"%c HIDE TOGGLED PATTERN %c"+matching_pattern+"%c SLOT "+matching_slot, lbH+lf8, lbL+lf8, lbR);

            t_pat_bag1_hide_pattern(matching_pattern, t_data.SYMBOL_HID+" SEL <em class='cc"+matching_slot+"'>"+matching_pattern+"</em>");

            if( prop.get( t_data.WORDS_OPCYCLE ) )
                setTimeout(words_option_cycle, PATTERN_CYCLE_DELAY);
        }

        else {

if(log_this) log(caller+"%c HIDE ALL COLIDING THEN SHOW TOGGLED PATTERN %c"+e_target_pattern, lbH+lf5, lbH);

            t_pat_bag1_slot_pattern(e_target_pattern, t_data.SYMBOL_SEL+" <em class='cc1'>"+e_target_pattern+"</em>");

        }
    }

    else {
if(log_this) log(caller+"%c SHOW TOGGLED PATTERN %c"+e_target_pattern, lbH+lf5, lbH);
        t_pat_bag1_slot_pattern(    e_target_pattern, t_data.SYMBOL_SEL+" <em class='cc1'>"+e_target_pattern+"</em>");

    }

};


let t_pat_bag1_slot_pattern = function(pattern, msg)
{

let   caller = "t_pat_bag1_slot_pattern("+pattern+")";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c "+caller, lbb+lf4);


    let pattern_slot = t_slot.get_slot_of_pattern( pattern );

    pat_bag1_hide_patterns_coliding( pattern );

    if( pattern_slot )
        return;



    t_words_regex_reset(          pattern);

    call_check_TreeWalker("body", pattern);


    if(     t_slot.get_slot_of_pattern( pattern )) {
if(log_this) log("SHOW   [    SLOTTED PAT]");

        csv_pattern_mov_to_pat( pattern );

        t_select.t_onPatternUpdate(msg, caller);
    }


    else {
if(log_this) log("BACK   [NOT   FOUND PAT]");

        csv_pattern_mov_to_bak( pattern );

        t_select.t_onPatternUpdate(t_data.SYMBOL_BAK+" OFF <em class='cc8'>"+ t_util.ellipsis_short(pattern) +"</em>", caller);
    }

};


let   pat_bag1_hide_patterns_coliding = function(selected_pattern)
{

let   caller = "pat_bag1_hide_patterns_coliding";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;


    let   matching_slot;
    while(matching_slot = t_slot.get_slot_matching_pattern( selected_pattern ))
    {
        let matching_pattern = t_select.ccs[matching_slot].pattern;
if(log_this) log(caller+"%c HIDE COLIDING PATTERN %c"+matching_pattern+"%c SLOT "+matching_slot, lbH+lf7, lbL+lf7, lbR);

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG))
        t_fly.t_fly(t_data.SYMBOL_COLIDE+" <em class='cc4'>"+selected_pattern+"</em> "+t_data.SYMBOL_DISMISS+" <em class='cc4'>"+matching_pattern+"</em>");
        t_pat_bag1_hide_pattern(matching_pattern, t_data.SYMBOL_HID+" SEL <em class='cc"+matching_slot+"'>"+matching_pattern+"</em>");
    }
};


let t_pat_bag1_hide_pattern = function(pattern, msg)
{

let   caller = "t_pat_bag1_hide_pattern("+pattern+")";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c "+caller, lbb+lf5);

        csv_pattern_mov_to_off( pattern );

    let slot = t_slot.get_slot_of_pattern(pattern);
    if( slot ) {
        t_slot.t_clear_slot( slot );

        t_select.t_onPatternUpdate(msg, caller);
    }


    else {
if(log_this) log("HIDE   [NOT SLOTTED PAT]");

        t_select.t_onPatternUpdate(t_data.SYMBOL_HID+" not found <em class='cc8'>"+ t_util.ellipsis_short(pattern) +"</em>", caller);
    }

};


let t_pat_bag1_alt_pattern = function(pattern, msg)
{

let   caller = "t_pat_bag1_alt_pattern("+pattern+")";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c "+caller, lbb+lf6);


    let             slot = t_slot.get_slot_of_pattern(pattern);
    if(             slot) {
if(log_this) log("ALT    [    CLEARED PAT]");
        t_slot.t_clear_slot( slot );
        csv_pattern_mov_to_alt( pattern );

if( log_this) pattern_log_bag_csv(caller);
        t_select.t_onPatternUpdate(msg, caller);
    }


    else {
if(log_this) log("ALT    [NOT SLOTTED PAT]");
        csv_pattern_mov_to_alt( pattern );

        t_select.t_onPatternUpdate(t_data.SYMBOL_BAK+" OFF <em class='cc0'>"+ t_util.ellipsis_short(pattern) +"</em>", caller);
    }

};


let t_pat_bag1_back_pattern = function(pattern, msg)
{

let   caller = "t_pat_bag1_back_pattern("+pattern+")";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c "+caller, lbb+lf2);


    let             slot = t_slot.get_slot_of_pattern(pattern);
    if(             slot) {
        t_slot.t_clear_slot( slot );
if(log_this) log("BACK   [    CLEARED PAT]");
        csv_pattern_mov_to_bak( pattern );

        t_select.t_onPatternUpdate(msg, caller);
    }


    else {
if(log_this) log("BACK   [NOT SLOTTED PAT]");
        csv_pattern_mov_to_bak( pattern );

        t_select.t_onPatternUpdate(t_data.SYMBOL_BAK+" OFF <em class='cc0'>"+ t_util.ellipsis_short(pattern) +"</em>", caller);
    }

};




let pat_bag2_bag_open = function()
{

let   caller = "pat_bag2_bag_open";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

if( log_this) log("%c "+caller, lbb+lf2);

    t_pat_bag_open(caller, "Showing OFF selections");
};



let pat_bag3_dump_off = function()
{

let caller = "pat_bag3_dump_off";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf4);

    let tmp_csv  =    String( off_csv );
    let    count = t_util.csv_count( tmp_csv );
    let patterns = "";

    for(let pos = 1; pos <= count; ++pos)
    {

        let pattern = t_util.csv_get(tmp_csv, pos     );
        if(     t_slot.get_slot_of_pattern(   pattern )) {
if(log_this) log("TO PAT [    SLOTTED PAT]");
            csv_pattern_mov_to_pat(   pattern );
        }


        else {
if(log_this) log("TO ALT [NOT SLOTTED PAT]");
            csv_pattern_mov_to_alt(   pattern);

            patterns += pattern+" ";
        }

    }

    t_select.t_onPatternUpdate(t_data.SYMBOL_BAK+" "+count+" <em class='cc8'>"+ t_util.ellipsis_short(patterns) +"</em>", caller);
};


let pat_bag3_dump_alt = function()
{

let   caller = "pat_bag3_dump_alt";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf3);

    let tmp_csv  =    String( alt_csv );
    let    count = t_util.csv_count( tmp_csv );
    let patterns = "";

    for(let pos = 1; pos <= count; ++pos)
    {

        let pattern = t_util.csv_get(tmp_csv, pos     );
        if(     t_slot.get_slot_of_pattern(   pattern )) {
if(log_this) log("TO PAT [    SLOTTED PAT]");
            csv_pattern_mov_to_pat(   pattern );
        }


        else {
if(log_this) log("TO BAK [NOT SLOTTED PAT]");
            csv_pattern_mov_to_bak(   pattern);

            patterns += pattern+" ";
        }

    }

    t_select.t_onPatternUpdate(t_data.SYMBOL_BAK+" "+count+" <em class='cc8'>"+ t_util.ellipsis_short(patterns) +"</em>", caller);
};


let pat_bag3_dump_bak = function()
{

let   caller = "pat_bag3_dump_bak";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf3);

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly_all_csv(t_data.SYMBOL_CLEAR_BAK, "want");

    let tmp_csv  =    String( bak_csv );
    let    count = t_util.csv_count( tmp_csv );
    let patterns = "";
    for(let pos = 1; pos <= count; ++pos)
    {

        let pattern = t_util.csv_get(tmp_csv, pos     );
        if(     t_slot.get_slot_of_pattern(   pattern )) {
if(log_this) log("TO PAT [    SLOTTED PAT]");
            csv_pattern_mov_to_pat(   pattern );
        }


        else {
if(log_this) log("TO BIN [NOT SLOTTED PAT]");
            csv_pattern_mov_to_bin(   pattern);

            patterns += pattern+" ";
        }

    }

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly_all_csv(t_data.SYMBOL_CLEAR_BIN, "done");

    let dumping_action
        = " DUMPING ("+count+") <em class='cc2'>"+ t_util.ellipsis_short(patterns) +"</em> TO <em class='cc0'>bin</em>";
    t_select.t_onPatternUpdate(dumping_action, caller);
};


let t_pat_bag3_dump_all_csv = function()
{

let   caller = "t_pat_bag3_dump_all_csv";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf3);

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly_all_csv(t_data.SYMBOL_CLEAR_BAK, "want");

    let all_csv = t_util.csv_cat(pat_csv, off_csv);
    all_csv     = t_util.csv_cat(all_csv, alt_csv);
    all_csv     = t_util.csv_cat(all_csv, bak_csv);

    let tmp_csv  =    String( all_csv );
    let    count = t_util.csv_count( tmp_csv );
    let patterns = "";
    for(let pos = 1; pos <= count; ++pos)
    {

        let pattern = t_util.csv_get(tmp_csv, pos     );
        if(     t_slot.get_slot_of_pattern(   pattern )) {
if(log_this) log("TO PAT [    SLOTTED PAT]");
            csv_pattern_mov_to_pat(   pattern );
        }


        else {
if(log_this) log("TO BIN [NOT SLOTTED PAT]");
            csv_pattern_mov_to_bin(   pattern);

            patterns += pattern+" ";
        }

    }

if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly_all_csv(t_data.SYMBOL_CLEAR_BIN, "done");

    let dumping_action
        = " DUMPING ("+count+") <em class='cc2'>"+ t_util.ellipsis_short(patterns) +"</em> TO <em class='cc0'>bin</em>";
    t_select.t_onPatternUpdate_no_delay(dumping_action, caller);
};




const T_PAT_BAG3_RESELECT_DELAY = 1000;
let   t_pat_bag3_reselect_timer;


let t_pat_bag3_reselect_all = function()
{

let   caller = "t_pat_bag3_reselect_all";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf3);

    if(t_pat_bag3_reselect_timer) clearTimeout( t_pat_bag3_reselect_timer );
    t_pat_bag3_reselect_timer     = setTimeout( pat_bag3_reselect_handler, T_PAT_BAG3_RESELECT_DELAY);
};


let pat_bag3_reselect_handler = function()
{

let caller = "pat_bag3_reselect_handler";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf3);


    let reselected_csv = t_select.t_clear_slot_all();
if( log_this) t_util.csv_log(reselected_csv, "currently slotted");




        reselected_csv = t_util.csv_cat(reselected_csv, pat_csv);
        reselected_csv = t_util.csv_cat(reselected_csv, off_csv);
        reselected_csv = t_util.csv_cat(reselected_csv, bak_csv);
if( log_this) t_util.csv_log(reselected_csv, "bak_bag_too");


    pat_bag3_reselect( reselected_csv );
};


let pat_bag3_reselect = function(reselected_csv="NONE")
{

let caller = "pat_bag3_reselect";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller+": direction="+t_handle_1_pat_bag_sort_cycle_direction+"", lbB+lf3);


    if(reselected_csv == "NONE")
    {
        reselected_csv = t_select.t_clear_slot_all();
    }


    if(reselected_csv && (t_handle_1_pat_bag_sort_cycle_direction != 0))
    {
if( log_this) t_util.csv_log(reselected_csv, "reselected_csv");

        let    reverse = (t_handle_1_pat_bag_sort_cycle_direction < 0);
        reselected_csv = t_util.csv_sort(reselected_csv, reverse);

if( log_this) t_util.csv_log(reselected_csv, "(reverse="+reverse+")");
    }


    let count = Math.min(t_select.SELECT_SLOT_MAX, t_util.csv_count( reselected_csv ));
    if(reselected_csv)
    {
        for(let pos=1; pos<=count; ++pos)
        {
            let pattern = t_util.csv_get(reselected_csv, pos);

            t_pat_bag1_slot_pattern(pattern, t_data.SYMBOL_SEL+" <em class='cc1'>"+pattern+"</em>");
        }
    }

    let msg = (count ? count : "NO")+" SLOTTED SELECTION";
if( log_this) log(msg);



    t_select.t_onPatternUpdate_no_delay(msg, caller);

    t_eval_wide_or_tall_panel(sel_bag);
    t_eval_wide_or_tall_panel(pat_bag);
};


let pat_bag4_show_off = function()
{

let caller = "pat_bag4_show_off";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf4);

if( log_this) log("%c...NOT setting all bags to same top and height", lbH+lf2);

    t_handle_1_pat_bag_rotating(false);

    t_sel_pat_bag_all();
};


let pat_bag5_hide_sel = function()
{

let   caller = "pat_bag5_hide_sel";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf5);


    let tmp_csv  =           String( pat_csv );
    let   count  = t_util.csv_count( pat_csv );
    let patterns = "";

    for(let pos  = 1; pos <= count; ++pos)
    {

        let pattern = t_util.csv_get(tmp_csv, pos);
        off_csv     = t_util.csv_ins(off_csv, pattern);
        patterns   += pattern+" ";


    }
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_2_ACTION, t_data.SYMBOL_HID+" x"+count+" <em class='cc8'>"+ t_util.ellipsis_short(patterns) +"</em>");



    let cleared_csv = t_select.t_clear_slot_all();
if( log_this) log("...cleared_csv=["+cleared_csv+"]");



};


let pat_bag6_standby = function()
{

let   caller = "pat_bag6_standby";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf6);

    t_standby_bag_id( pat_bag.id );
};


let pat_bag7_standby_open = function()
{

let   caller = "pat_bag7_standby_open";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf7);


    t_pat_bag_open(caller, "Standby OPEN");
};


let pat_bag8_standby_done = function()
{

let   caller = "pat_bag8_standby_done";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c "+caller, lbB+lf8);


    t_pat_bag_close(caller, "Standby DONE");
};



let off_bag_rect;
let bak_bag_rect;
let alt_bag_rect;
let mov_pat_span;
let pat_bag_was_grid_whenGrabbed;


let pat_bag9_grab_child = function(parent_div)
{

let   caller = "pat_bag9_grab_child("+get_n_lbl(parent_div)+")";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV2_MOVE;

if( log_this) t_fly.t_log_event_status(caller, lf4);


    mov_div.style.display = "block";
    mov_div.style.zIndex  = onWork_EL.style.zIndex + 1;

    mov_div.style.backgroundColor
        = (parent_div == pat_bag) ? "yellow"
        : (parent_div == off_bag) ? "green"
        : (parent_div == alt_bag) ? "blue"
        :                           "red"
    ;

    mov_div.innerHTML     = onWork_EL.outerHTML;
    t_pat_bag_set_moving_item_label(mov_div.innerHTML);



    mov_pat_span = t_util.get_el_parent_with_tag(onWork_EL, "SPAN");


add_el_class(mov_pat_span, "moving");


    mov_src_div  = parent_div;
    mov_dst_div  = null;


    add_el_class(mov_src_div, CSS_MOV_SRC);


    pat_bag_was_grid_whenGrabbed = has_el_class(pat_bag, CSS_GRID_BAG);

    off_bag_rect
        = { top    : off_bag.offsetTop
          , left   : off_bag.offsetLeft
          , bottom : off_bag.offsetTop  + off_bag.offsetHeight
          , right  : off_bag.offsetLeft + off_bag.offsetWidth
        };

    alt_bag_rect
        = { top    : alt_bag.offsetTop
          , left   : alt_bag.offsetLeft
          , bottom : alt_bag.offsetTop  + alt_bag.offsetHeight
          , right  : alt_bag.offsetLeft + alt_bag.offsetWidth
        };

    bak_bag_rect
        = { top    : bak_bag.offsetTop
          , left   : bak_bag.offsetLeft
          , bottom : bak_bag.offsetTop  + bak_bag.offsetHeight
          , right  : bak_bag.offsetLeft + bak_bag.offsetWidth
        };



    dimm_start_pat_bag( caller );


    return mov_div;
};


let pat_bag9_grab_item_is_mov_div = function()
{
    return (onWork_EL == mov_div);

};


let pat_bag9_grab_item_mov_div_is_showing = function()
{
    return (mov_div && (mov_div.style.display != "none"));
};


let t_pat_bag9_get_bag_at_xy = function(e,x,y)
{
    let bag;

    let hovering_or_neardering = e.shiftKey;

    if( hovering_or_neardering )
        bag =  t_pat_bag_mov_div_is_xy_hovering_bag(x, y, off_bag) ? off_bag
            :  t_pat_bag_mov_div_is_xy_hovering_bag(x, y, alt_bag) ? alt_bag
            :  t_pat_bag_mov_div_is_xy_hovering_bag(x, y, bak_bag) ? bak_bag
            :                                                        pat_bag
        ;
    else
        bag = pat_bag_mov_div_get_dst_near_xy(x, y);

    add_el_class(bag, (hovering_or_neardering ? t_data.CSS_HOVERING : t_data.CSS_NEARING));


    return bag;
};



let pat_bag9_grab_item_mov_div_xy = function(e, div_x, div_y, bag_at_xy)
{



    let xy = get_event_XY(e);
    let  y = xy.y - pat_bag.offsetTop;
    if(pat_bag.scale) y /= pat_bag.scale;


    y     -= onWork_EL.offsetHeight * (behavior_TOUCH_ELSE_DESKTOP ? TOUCH_OFFSET_FACTOR : MOUSE_OFFSET_FACTOR);
    let at_bag_top
        =  (bag_at_xy != pat_bag)
        && (  Math.abs(    y - bag_at_xy.offsetTop                             )
            < Math.abs(        bag_at_xy.offsetTop + bag_at_xy.offsetHeight - y))
    ;

    if     (bag_at_xy == bak_bag) t_pat_bag_hover_div_accept( bak_bag, at_bag_top);
    else if(bag_at_xy == alt_bag) t_pat_bag_hover_div_accept( alt_bag, at_bag_top);
    else if(bag_at_xy == off_bag) t_pat_bag_hover_div_accept( off_bag, at_bag_top);
    else if(bag_at_xy == pat_bag) t_pat_bag_hover_div_accept( pat_bag            );
    else                          t_pat_bag_hover_div_accept( mov_src_div        );






    let el;
    el = pat_bag; del_el_class(el, t_data.CSS_HOVERING); del_el_class(el, t_data.CSS_NEARING); del_el_class(el, t_data.CSS_DIMMED);
    el = bak_bag; del_el_class(el, t_data.CSS_HOVERING); del_el_class(el, t_data.CSS_NEARING); del_el_class(el, t_data.CSS_DIMMED);
    el = alt_bag; del_el_class(el, t_data.CSS_HOVERING); del_el_class(el, t_data.CSS_NEARING); del_el_class(el, t_data.CSS_DIMMED);
    el = off_bag; del_el_class(el, t_data.CSS_HOVERING); del_el_class(el, t_data.CSS_NEARING); del_el_class(el, t_data.CSS_DIMMED);


    del_el_class(mov_dst_div, t_data.CSS_DIMMED);
    if(mov_dst_div != mov_src_div) {
        let hovering_or_nearing = onDown_SHIFT;
        add_el_class( mov_dst_div, (hovering_or_nearing ? t_data.CSS_HOVERING : t_data.CSS_NEARING));
        del_el_class( mov_div                           , CSS_GRAYED_OUT);
    }
    else {
        add_el_class( mov_div                           , CSS_GRAYED_OUT);
    }




    if     (mov_src_div == pat_bag) add_el_class(pat_bag, t_data.CSS_DIMMED);
    else if(mov_src_div == off_bag) add_el_class(off_bag, t_data.CSS_DIMMED);
    else if(mov_src_div == alt_bag) add_el_class(alt_bag, t_data.CSS_DIMMED);
    else if(mov_src_div == bak_bag) add_el_class(bak_bag, t_data.CSS_DIMMED);



    let mov_L = mov_pat_span.lastChild.offsetLeft;
    let mov_T = mov_pat_span.lastChild.offsetTop ;

    let bag_x = (bag_at_xy == pat_bag) ? 0 : bag_at_xy.offsetLeft;
    let bag_y = (bag_at_xy == pat_bag) ? 0 : bag_at_xy.offsetTop ;

    let mov_A = (bag_at_xy == mov_src_div);

    let mov_x = mov_A ? mov_L : bag_x + mov_L;
    let mov_y = mov_A ? mov_T : bag_y + mov_T;

    t_show_hov_1(mov_x, mov_y);
    t_show_hov_2(mov_x + mov_pat_span.lastChild.offsetWidth, mov_y + mov_pat_span.lastChild.offsetHeight);



    let dx   = 1.0 * (div_x - mov_x);
    let dy   = 1.0 * (div_y - mov_y);
    let left = mov_x + dx;
    let top  = mov_y + dy;

    mov_div.style.left = left +"px";
    mov_div.style.top  = top  +"px";

};


let pat_bag9_grab_item_mov_div_drop = function()
{

let   caller = "pat_bag9_grab_item_mov_div_drop";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV2_MOVE;

if( log_this) t_fly.t_log_event_status(caller, lf4);


    dimm_stop(caller);



    mov_div.style.display = "none";

    mov_div.innerHTML     = "";
    t_pat_bag_set_moving_item_label(mov_div.innerHTML);




    del_el_class(pat_bag     , CSS_MOV_SRC);
    del_el_class(off_bag     , CSS_MOV_SRC);
    del_el_class(alt_bag     , CSS_MOV_SRC);
    del_el_class(bak_bag     , CSS_MOV_SRC);
    del_el_class(mov_pat_span, CSS_MOV_SRC);

del_el_class(mov_pat_span, "moving");
    mov_pat_span = null;
    mov_src_div  = null;
    mov_dst_div  = null;


    t_hide_hov();



    del_el_class(mov_div, CSS_MOVING);

    del_el_class(bak_bag, t_data.CSS_HOVERING); del_el_class(bak_bag, t_data.CSS_NEARING); del_el_class(bak_bag, t_data.CSS_DIMMED);
    del_el_class(alt_bag, t_data.CSS_HOVERING); del_el_class(alt_bag, t_data.CSS_NEARING); del_el_class(alt_bag, t_data.CSS_DIMMED);
    del_el_class(off_bag, t_data.CSS_HOVERING); del_el_class(off_bag, t_data.CSS_NEARING); del_el_class(off_bag, t_data.CSS_DIMMED);
    del_el_class(pat_bag, t_data.CSS_HOVERING); del_el_class(pat_bag, t_data.CSS_NEARING); del_el_class(pat_bag, t_data.CSS_DIMMED);


    t_pat_bag_open_or_close(caller);
};


let t_pat_bag9_move_pattern_from_src_to_dst_div = function()
{


    let ccX
        = (mov_dst_div == pat_bag) ? "cc1"
        : (mov_dst_div == off_bag) ? "cc5"
        : (mov_dst_div == bak_bag) ? "cc2"
        : (mov_dst_div == alt_bag) ? "cc6"
        : "";

    let mov_pattern = t_pat_get_el_data_pattern( mov_div.firstElementChild );

    let moving_action
        = " MOVING <em class='cc9'>"    +            mov_pattern   +"</em>"
        +   " FROM <em class='"+ccX+"'>"+ get_n_lbl( mov_src_div ) +"</em>"
        +     " TO <em class='"+ccX+"'>"+ get_n_lbl( mov_dst_div ) +"</em>"
    ;
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_log_stage_msg(t_fly.STAGE_2_ACTION, moving_action);

    let msg = "MOVING";
    switch(mov_dst_div) {
        case pat_bag: msg = t_data.SYMBOL_SEL +" <em class='"+ccX+"'>"+mov_pattern+"</em>"; t_pat_bag1_slot_pattern(mov_pattern, msg); break;
        case off_bag: msg = t_data.SYMBOL_HID +" <em class='"+ccX+"'>"+mov_pattern+"</em>"; t_pat_bag1_hide_pattern(mov_pattern, msg); break;
        case alt_bag: msg = t_data.SYMBOL_ALT +" <em class='"+ccX+"'>"+mov_pattern+"</em>"; t_pat_bag1_alt_pattern (mov_pattern, msg); break;
        case bak_bag: msg = t_data.SYMBOL_BAK +" <em class='"+ccX+"'>"+mov_pattern+"</em>"; t_pat_bag1_back_pattern(mov_pattern, msg); break;
    }

    t_pat_bag_minHeight_clear("t_pat_bag9_move_pattern_from_src_to_dst_div");


    set_bag_rot_title( msg );

    return moving_action;
};




let t_are_sel_sorted = function()
{
    if(          !sel_csv      ) return false;
    if(t_util.csv_count( sel_csv ) < 2) return false;

    let    csv = t_util.csv_sort( sel_csv );
    return csv ==          sel_csv;
};


let t_are_sel_reversed = function()
{
    if(          !sel_csv      ) return false;
    if(t_util.csv_count( sel_csv ) < 2) return false;

    let    csv = t_util.csv_reverse( sel_csv );
    return csv ==             sel_csv;
};




let csv_pattern_mov_to_pat = function(pattern)
{

let caller = "csv_pattern_mov_to_pat";
let log_this = LOG_MAP.S0_PATTERN;


    off_csv = csv_pattern_del_from_bag(off_csv, pattern);
    alt_csv = csv_pattern_del_from_bag(alt_csv, pattern);
    bak_csv = csv_pattern_del_from_bag(bak_csv, pattern);
    bin_csv = csv_pattern_del_from_bag(bin_csv, pattern);
    if(t_util.csv_count(pat_csv) < t_select.SELECT_SLOT_MAX) {
        pat_csv = csv_pattern_add_into_bag(pat_csv, pattern, true);
    }
    else {
if(log_this) log("%c"+caller+"("+pattern+") %c overflow into %c alt_csv]", lbL+lf4, lbC, lbR+lf6);
        csv_pattern_mov_to_alt(pattern);
    }
if(log_this) pattern_log_bag_csv(caller+"("+pattern+")");
};


let csv_pattern_mov_to_off = function(pattern)
{

let caller = "csv_pattern_mov_to_off";
let log_this = LOG_MAP.S0_PATTERN;


    let by_user =  (mov_dst_div != null) ;
    alt_csv = csv_pattern_del_from_bag(alt_csv, pattern);
    bak_csv = csv_pattern_del_from_bag(bak_csv, pattern);
    bin_csv = csv_pattern_del_from_bag(bin_csv, pattern);

    if(t_util.csv_count(pat_csv) < t_select.SELECT_SLOT_MAX) {
        off_csv = csv_pattern_add_into_bag(off_csv, pattern, by_user);
    }
    else {
if(log_this) log("%c"+caller+"("+pattern+") %c overflow into %c alt_csv]", lbL+lf5, lbC, lbR+lf6);
        csv_pattern_mov_to_alt(pattern);
    }
if(log_this) pattern_log_bag_csv(caller+"("+pattern+")");
};


let csv_pattern_mov_to_alt = function(pattern)
{

let caller = "csv_pattern_mov_to_alt";
let log_this = LOG_MAP.S0_PATTERN;


    pat_csv = csv_pattern_del_from_bag(pat_csv, pattern);
    off_csv = csv_pattern_del_from_bag(off_csv, pattern);
    bak_csv = csv_pattern_del_from_bag(bak_csv, pattern);
    bin_csv = csv_pattern_del_from_bag(bin_csv, pattern);
    if(t_util.csv_count(alt_csv) < t_select.SELECT_SLOT_MAX) {
        alt_csv = csv_pattern_add_into_bag(alt_csv, pattern);
    }
    else {
if(log_this) log("%c"+caller+"("+pattern+") %c overflow into %c bak_csv]", lbL+lf6, lbC, lbR+lf2);
        csv_pattern_mov_to_bak(pattern);
    }
if(log_this) pattern_log_bag_csv(caller+"("+pattern+")");
};


let csv_pattern_mov_to_bak = function(pattern)
{

let caller = "csv_pattern_mov_to_bak";
let log_this = LOG_MAP.S0_PATTERN;


    pat_csv = csv_pattern_del_from_bag(pat_csv, pattern);
    off_csv = csv_pattern_del_from_bag(off_csv, pattern);
    alt_csv = csv_pattern_del_from_bag(alt_csv, pattern);
    bin_csv = csv_pattern_del_from_bag(bin_csv, pattern);
    if(t_util.csv_count(bak_csv) < t_select.SELECT_SLOT_MAX) {
        bak_csv = csv_pattern_add_into_bag(bak_csv, pattern);
    }
    else {
if(log_this) log("%c"+caller+"("+pattern+") %c overflow into %c bin_csv]", lbL+lf2, lbC, lbR+lf0);
        csv_pattern_mov_to_bin(pattern);
    }
if(log_this) pattern_log_bag_csv(caller+"("+pattern+")");
};


let csv_pattern_mov_to_bin = function(pattern)
{

let caller = "csv_pattern_mov_to_bin";
let log_this = LOG_MAP.S0_PATTERN;


    pat_csv = csv_pattern_del_from_bag(pat_csv, pattern);
    off_csv = csv_pattern_del_from_bag(off_csv, pattern);
    alt_csv = csv_pattern_del_from_bag(alt_csv, pattern);
    bak_csv = csv_pattern_del_from_bag(bak_csv, pattern);

    bin_csv = t_util.csv_add(bin_csv, pattern);
if(log_this) log("%c "+caller+"("+pattern+") %c t_util.csv_count(bin_csv)=["+t_util.csv_count(bin_csv)+"]%c["+bin_csv+"]", lbL+lf0, lbR+lf0, lf8);
if(log_this) pattern_log_bag_csv(caller+"("+pattern+")");
};



let csv_pattern_del_from_bag = function(csv,pattern)
{

let   caller = "csv_pattern_del_from_bag";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;

    let result = t_util.csv_del(csv, pattern);
if(log_this) {
    let l_n
        = (csv === pat_csv) ? lf4
        : (csv === off_csv) ? lf5
        : (csv === alt_csv) ? lf6
        : (csv === bak_csv) ? lf2
        : (csv === bin_csv) ? lf0
        :                     lf9
        ;

    let name
        = (csv === pat_csv) ? "pat_csv"
        : (csv === off_csv) ? "off_csv"
        : (csv === alt_csv) ? "alt_csv"
        : (csv === bak_csv) ? "bak_csv"
        : (csv === bin_csv) ? "bin_csv"
        :                     "XXX_csv"
        ;

    log(caller+"(%c"+name+"%c"+pattern+")%c"+ t_data.SYMBOL_RIGHT_ARROW+"%c"+result
        ,        lbL+l_n  ,lbR+l_n      ,lbA                     ,l_n+lbH   );
}

    return result;
};


let csv_pattern_add_into_bag = function(bag_csv, pattern, append_or_insert)
{

let   caller = "csv_pattern_add_into_bag";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT || LOG_MAP.EV5_TOOL_CB;



    let moving
        =                    mov_dst_div
        && (   ((pat_bag === mov_dst_div) && (bag_csv === pat_csv))
            || ((off_bag === mov_dst_div) && (bag_csv === off_csv))
            || ((alt_bag === mov_dst_div) && (bag_csv === alt_csv))
            || ((bak_bag === mov_dst_div) && (bag_csv === bak_csv)))
        &&                t_util.csv_contains(bag_csv,      pattern)
    ;



    if(typeof append_or_insert == "undefined")
        append_or_insert
            =  !mov_dst_div
            || !mov_dst_div.at_bag_top
    ;



if(log_this) {
    let l_n
        = (bag_csv === pat_csv) ? lf4
        : (bag_csv === off_csv) ? lf5
        : (bag_csv === bak_csv) ? lf2
        : (bag_csv === alt_csv) ? lf6
        : (bag_csv === bin_csv) ? lf0
        :                     lf9
    ;

    let bag_name
        = (bag_csv === pat_csv) ? "pat_csv"
        : (bag_csv === off_csv) ? "off_csv"
        : (bag_csv === bak_csv) ? "bak_csv"
        : (bag_csv === alt_csv) ? "alt_csv"
        : (bag_csv === bin_csv) ? "bin_csv"
        :                         "XXX_csv"
    ;

    let action
        = moving ? (append_or_insert ? "MOVE TO END" : "MOVE TO START")
        :          (append_or_insert ?      "APPEND" : "INSERT"       )
    ;

    let l_t
        =  (mov_dst_div)    ? lf9
        :                     lf8
    ;

    log("%c"+caller+"%c"+pattern+"%c"+bag_name+"%c"+action
        ,lbH        ,lbL+lf9     ,l_n+lbR      ,l_t+lbH   );
}


    if( moving ) {
        bag_csv    = t_util.csv_del(bag_csv, pattern);
    }



    bag_csv        = (append_or_insert ? t_util.csv_add : t_util.csv_ins) (bag_csv, pattern);


    return bag_csv;
};





let STORE_PATTERNS_CSV_DELAY = 2000;
let t_store_patterns_timer;


let t_onPatternUpdate_done = function()
{

let caller   = "t_onPatternUpdate_done";
let log_this = DOM_TOOLS_LOG || LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;
let tag_this = DOM_TOOLS_TAG || log_this;

if( log_this ) log(caller);

    if( t_just_loaded(caller, PREVENT_RELOAD_DELAY, tag_this) ) return;

    t_store_consider_page_items_worth_storing("SELECTION UPDATE");

    t_clear_slot_sync_cancel();

    t_store_patterns_csv();
    wording_3_CB_WORDS_RECYCLE_SYNC_NOW("PATTERNS UPDATED");

    t_pat_bag_open_or_close(caller);

    t_pat_bag_status();

    t_seek.t_seeker_sync_SEL_BACK  ( caller );
    t_sync_tool_clones_state( caller );
    t_sync_pat_buttons( caller );
};


let t_store_get_patterns_csv = function()
{

    let key, arr;

    try {
    key = "sel_arr"; arr = t_store.t_store_getItem(key); sel_csv = (arr == null) ? "" : JSON.parse(arr).join(",");
    key = "pat_arr"; arr = t_store.t_store_getItem(key); pat_csv = (arr == null) ? "" : JSON.parse(arr).join(",");
    key = "off_arr"; arr = t_store.t_store_getItem(key); off_csv = (arr == null) ? "" : JSON.parse(arr).join(",");
    key = "alt_arr"; arr = t_store.t_store_getItem(key); alt_csv = (arr == null) ? "" : JSON.parse(arr).join(",");
    key = "bak_arr"; arr = t_store.t_store_getItem(key); bak_csv = (arr == null) ? "" : JSON.parse(arr).join(",");
    key = "bin_arr"; arr = t_store.t_store_getItem(key); bin_csv = (arr == null) ? "" : JSON.parse(arr).join(",");
    }
    catch(ex) {
        let msg
            =    "*** "+ex
            +LF+ arr
            +LF+ "0123456789_123456789_123456789_123456789_123456789_123456789_"
            +LF+ "0_________1_________2_________3_________4_________5_________6";
        log("%c"+msg, lbF+lf2);
        t_fly.t_fly("<pre class='fg2'>"+ msg +"</pre>");
    }

    if(!pat_csv && (t_util.csv_count(off_csv)  > 0))
        pat_csv = off_csv;

    if( off_csv && (t_util.csv_count(off_csv) == t_util.csv_count(pat_csv)))
        off_csv = "";
};


let t_store_patterns_csv = function(delay=STORE_PATTERNS_CSV_DELAY)
{
    if(t_store_patterns_timer) clearTimeout( t_store_patterns_timer);
    t_store_patterns_timer   =   setTimeout(   store_patterns_handler, STORE_PATTERNS_CSV_DELAY);
};


let   store_patterns_handler = function()
{

let   caller = "store_patterns_handler";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.S2_SELECT;

if( log_this) log("%c"+caller, lbF+lb7);

    t_store_patterns_timer = null;

    if(!t_store_consider_page_items_worth_storing("SELECTION UPDATE") ) return;


    store_set_patterns_csv();


    set_bag_rot_title("SAVING:");
};


let   store_set_patterns_csv = function()
{
    let arr;

    arr = sel_csv ? JSON.stringify(sel_csv.split(",")) : ""; t_store.t_store_set_value("sel_arr", arr);
    arr = pat_csv ? JSON.stringify(pat_csv.split(",")) : ""; t_store.t_store_set_value("pat_arr", arr);
    arr = off_csv ? JSON.stringify(off_csv.split(",")) : ""; t_store.t_store_set_value("off_arr", arr);
    arr = alt_csv ? JSON.stringify(alt_csv.split(",")) : ""; t_store.t_store_set_value("alt_arr", arr);
    arr = bak_csv ? JSON.stringify(bak_csv.split(",")) : ""; t_store.t_store_set_value("bak_arr", arr);
    arr = bin_csv ? JSON.stringify(bin_csv.split(",")) : ""; t_store.t_store_set_value("bin_arr", arr);

};


let t_store_del_patterns_csv = function()
{
    t_store.t_store_set_value("sel_arr", "");
    t_store.t_store_set_value("pat_arr", "");
    t_store.t_store_set_value("off_arr", "");
    t_store.t_store_set_value("alt_arr", "");
    t_store.t_store_set_value("bak_arr", "");
    t_store.t_store_set_value("bin_arr", "");

};





let page_items_worth_storing;

let t_store_consider_page_items_worth_storing = function(reason)
{

let   caller = "t_store_consider_page_items_worth_storing";
let log_this = LOG_MAP.S0_PATTERN || LOG_MAP.T0_STORE;

if( log_this) log_caller();


    let has_document_wording_feature = is_a_DOM_LOAD_featured_function("t_store_patterns_csv");
    let pat_csv_count                = t_util.csv_count(pat_csv);
    let off_csv_count                = t_util.csv_count(off_csv);
    let alt_csv_count                = t_util.csv_count(alt_csv);
    let bak_csv_count                = t_util.csv_count(bak_csv);

    let has_pat_csv                  = has_document_wording_feature                                    ? pat_csv : "";
    let has_off_csv                  = has_document_wording_feature                                    ? off_csv : "";
    let has_alt_csv                  = has_document_wording_feature                                    ? alt_csv : "";
    let has_bak_csv                  = has_document_wording_feature                                    ? bak_csv : "";
    let hid_csv_count                = t_hide.get_node_to_hide_csv_count();
    let sticky_count                 = t_sticky.t_sticky_GET_COUNT();
    let hotspot_EDITING              = has_el_class(hotspot, t_data.DOM_EDITING);
    let hotspot_in_gutter            = t_gutter.is_hotspot_IN(hotspot, "WORTH STORING");
    let curr_state
        = {   has_pat_csv
            , has_off_csv
            , has_alt_csv
            , has_bak_csv
            , hotspot_EDITING
            , hotspot_in_gutter : (hotspot_in_gutter ? "YES" : "NO")
            , pat_csv_count
            , off_csv_count
            , alt_csv_count
            , bak_csv_count
            , hid_csv_count
            , sticky_count
            , has_document_wording_feature
        };


    let state_change = page_items_worth_storing ? t_page_item_get_state_change(curr_state) : "New evaluation";
    if(!state_change ) {
if( log_this) log("%c"+caller+"%c"+reason+"%c STORAGE UNCHANGED %c"+page_items_worth_storing, lbL+lf8, lbC+lf4, lbC+lf2, lbR+lf1);

        return page_items_worth_storing;
    }



    let pat_s     = (pat_csv_count > 1) ? "s" : "";
    let off_s     = (off_csv_count > 1) ? "s" : "";
    let alt_s     = (alt_csv_count > 1) ? "s" : "";
    let bak_s     = (bak_csv_count > 1) ? "s" : "";
    let hid_s     = (hid_csv_count > 1) ? "s" : "";
    let sticky_s  = (sticky_count  > 1) ? "s" : "";


    page_items_worth_storing
        =  has_pat_csv       ?            pat_csv_count     +" selection"    +pat_s+""+LF+   "in current bag ("+ "YELLOW)"+LF +t_util.strip_to_lines( pat_csv )
        :  has_off_csv       ?            off_csv_count     +" selection"    +off_s+""+LF+       "in off bag ("+  "GREEN)"+LF +t_util.strip_to_lines( off_csv )
        :  has_alt_csv       ?            alt_csv_count     +" selection"    +alt_s+""+LF+ "in alternate bag ("+   "BLUE)"+LF +t_util.strip_to_lines( alt_csv )
        :  has_bak_csv       ?            bak_csv_count     +" selection"    +bak_s+""+LF+    "in backup bag ("+    "RED)"+LF +t_util.strip_to_lines( bak_csv )
        :  hid_csv_count     ? "Hiding "+ hid_csv_count     +" Page Panel"   +hid_s
        :  sticky_count      ?            sticky_count      +" Personal Note"+sticky_s

        :  hotspot_EDITING   ? "Editing"
        : !hotspot_in_gutter ? t_i18n.i18n_get( t_i18n.MOVE_IN_GUTTER_TO_CLEAR_STORAGE )
        :                      ""
    ;


if( log_this) {
    log("page_items_worth_storing=["+page_items_worth_storing+"]");

    log_key_val( "curr_state .. "+reason+" .. "+state_change
                , curr_state
                , lf8
               );
}



    if(hotspot_c) hotspot_c.innerHTML = sticky_count ? "<span>"+sticky_count+"</span>" : "";


    if(!page_items_worth_storing )
        t_store.t_store_remove_shared_items("NO PAGE ITEMS WORTH STORING");

    else if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG))
        t_fly.t_fly_observerCB( page_items_worth_storing );



    t_store_show_all_page_items_removed();

    return page_items_worth_storing;
};


let prev_state;

let t_page_item_get_state_change = function(curr_state)
{

    if(!prev_state) {
        prev_state = curr_state;
        return "";
    }
    let state_change = "";
    Object.keys(curr_state).forEach(
        function(key) {
            let c_v  = curr_state[key];
            let p_v  = prev_state[key];

            if( c_v != p_v)
            {
                prev_state = curr_state;
                state_change += (state_change ? LF : "")+ key +" changed from ["+p_v+"] to ["+c_v+"]";
            }
        }
    );
    return state_change;
};



const CSS_PAGE_ITEMS_ALL_REMOVED   = "page_items_all_removed";
const CSS_PAGE_ITEMS_HAS_PAT_CSV   = "page_items_has_pat_csv";
const CSS_PAGE_ITEMS_HAS_BAK_CSV   = "page_items_has_bak_csv";
const CSS_PAGE_ITEMS_HAS_ALT_CSV   = "page_items_has_alt_csv";
const CSS_PAGE_ITEMS_HIDDEN_PANELS = "page_items_hidden_panels";
const CSS_PAGE_ITEMS_OFF_GUTTER    = "page_items_off_gutter";
const CSS_PAGE_ITEMS_ARRAY
    = [   CSS_PAGE_ITEMS_ALL_REMOVED
        , CSS_PAGE_ITEMS_HAS_PAT_CSV
        , CSS_PAGE_ITEMS_HAS_BAK_CSV
        , CSS_PAGE_ITEMS_HAS_ALT_CSV
        , CSS_PAGE_ITEMS_HIDDEN_PANELS
        , CSS_PAGE_ITEMS_OFF_GUTTER
    ];


let t_store_show_all_page_items_removed = function()
{

    let previously_all_removed
        = has_el_class(hotring, CSS_PAGE_ITEMS_ALL_REMOVED);


    if( hotring )
        hotring.title
            =  page_items_worth_storing
            ?  page_items_worth_storing
            :  t_i18n.i18n_get( t_i18n.ALL_PAGE_LOCAL_STORAGE_REMOVED)
    ;


    let s
        = page_items_worth_storing ? t_util.strip_CR_LF(page_items_worth_storing.toLowerCase()) : "";

    let hotspot_class
        = !s                      ? CSS_PAGE_ITEMS_ALL_REMOVED
        :  s.includes("green"   ) ? CSS_PAGE_ITEMS_HAS_PAT_CSV
        :  s.includes("red"     ) ? CSS_PAGE_ITEMS_HAS_BAK_CSV
        :  s.includes("blue"    ) ? CSS_PAGE_ITEMS_HAS_ALT_CSV
        :  s.includes("hiding"  ) ? CSS_PAGE_ITEMS_HIDDEN_PANELS
        :  s.includes("stor"    ) ? CSS_PAGE_ITEMS_OFF_GUTTER
        :                           ""
        ;


    set_el_class_removing(hotspot, hotspot_class  , CSS_PAGE_ITEMS_ARRAY);
    set_el_class_removing(hotring, hotspot_class  , CSS_PAGE_ITEMS_ARRAY);


    if(previously_all_removed && page_items_worth_storing)
        t_tools_save_all_settings(); };







let t_pattern1_sync_csv_from_ccs = function()
{

let   caller = "t_pattern1_sync_csv_from_ccs";
let log_this = LOG_MAP.S0_PATTERN;

if( log_this) logBIG(caller, lf4);
if( log_this) pattern_log_bag_csv(caller);



    let old_pat_csv = pat_csv;
    let old_off_csv = off_csv;

    set_sel_csv("");
    set_pat_csv("");
    set_off_csv("");

if( log_this) pattern_log_bag_csv("XXX");
    for(let slot = 1; slot <= t_select.SELECT_SLOT_MAX; ++slot)
    {
        if(           t_select.ccs[slot]
            &&        t_select.ccs[slot].nodes[0]
            &&        t_select.ccs[slot].nodes[0].textContent
        ) {

            let pat = t_select.ccs[slot].pattern;
            let w_o = t_select.ccs[slot].words_option;

            pat     = pattern_fallback_to_current_words_option_sfx(pat, w_o);

            csv_pattern_mov_to_pat( pat );
            add_sel_csv           ( pat );
        }
    }
if( log_this) pattern_log_bag_csv("...from [CCS] to [SEL and PAT]");


    let old_pat_count = t_util.csv_count( old_pat_csv );
    for(let       pos = 1; pos <=  old_pat_count; ++pos) {
        let       pat = t_util.csv_get(   old_pat_csv  ,   pos);

        if(!t_util.csv_contains(pat_csv, pat) )
            csv_pattern_mov_to_off(pat);
    }

if( log_this) pattern_log_bag_csv("...from [old_pat_csv] to [OFF]");


    let old_off_count = t_util.csv_count( old_off_csv );
    for(let       pos = 1; pos <=  old_off_count; ++pos) {
        let       pat = t_util.csv_get(   old_off_csv  ,   pos);

        if(!t_util.csv_contains(pat_csv, pat) )
            csv_pattern_mov_to_off(pat);
    }

if( log_this) pattern_log_bag_csv("...from [old_off_csv] to [OFF]");

};


let t_pattern2_set_sel_bag_innerHTML = function()
{
    let caller = "t_pattern2_set_sel_bag_innerHTML";
let log_this = LOG_MAP.S3_SLOT;

    if(!sel_bag) return;
    let sel_bag_innerHTML = "";

    for(let slot = 1; slot < t_select.ccs.length; ++slot) {
        if(       t_select.ccs[slot]
            &&    t_select.ccs[slot].nodes[0]
            &&    t_select.ccs[slot].nodes[0].textContent
        ) {
            sel_bag_innerHTML += get_sel_bag_pat_div(slot);
        }
    }

    if(sel_bag_innerHTML)
        sel_bag_innerHTML = "<span class='seeker_handle left'></span>"+ sel_bag_innerHTML;

if(log_this) log("%c "+caller+": sel_bag_innerHTML:%c<br>"+sel_bag_innerHTML, lbF+lb1, lb1);

    t_select.remove_pat_span_from_div( sel_bag );
    sel_bag.insertAdjacentHTML("beforeend", sel_bag_innerHTML);
};


const BAG_MAX_ELLIPSIS      = 7;
const BAG_MIN_ELLIPSIS      = Math.ceil(BAG_MAX_ELLIPSIS / 3);
let t_pattern2_get_sel_bag_thumbs_EM = function(slot, id_prefix)
{
    if(!t_select.ccs[slot]) return "";

    let thumbs_line = "";
    let       count = t_select.ccs[slot].nodes.length;

    for(let num = 1; num <= count; ++num)
    {

        if(    (        count <= BAG_MAX_ELLIPSIS )
            || (num <=           BAG_MIN_ELLIPSIS )
            || (num >= (count -  BAG_MIN_ELLIPSIS))
        ) {
            thumbs_line
                += "<em        id='"+id_prefix+"_" +slot  +"_"+ num  +"'"
                +  " data-thumb_p='"+ t_select.ccs[slot].get_num_thumb_p(num) +"'"

                +  ">"+                                        String(num)   +"</em>"
            ;
        }

        else if(num  == (BAG_MIN_ELLIPSIS+1)) {
            thumbs_line
                += "<em        id='"+id_prefix+"_"+slot+"_0'"
                +  " data-thumb_p=''"
                +  "        class='t_util.ellipsis'"
                +  "        title='"+t_data.SYMBOL_E+"'"
                +  ">"+              t_data.SYMBOL_E +"</em>"
            ;
        }
    }

    return thumbs_line;
};


let   pattern_log_bag_csv = function(_caller="")
{
    log("%c"+_caller+" %c CSV... %c"+t_data.SYMBOL_MENU, lbL, lbR, lbb+lf9);
    log("%c sel_csv %c"+t_util.csv_count( sel_csv )+"%c"+sel_csv, lbH+lf9, lbL+lf9, lbR+lf9);
    log("%c pat_csv %c"+t_util.csv_count( pat_csv )+"%c"+pat_csv, lbH+lf4, lbL+lf4, lbR+lf4);
    log("%c off_csv %c"+t_util.csv_count( off_csv )+"%c"+off_csv, lbH+lf5, lbL+lf5, lbR+lf5);
    log("%c alt_csv %c"+t_util.csv_count( alt_csv )+"%c"+alt_csv, lbH+lf6, lbL+lf6, lbR+lf6);
    log("%c bak_csv %c"+t_util.csv_count( bak_csv )+"%c"+bak_csv, lbH+lf2, lbL+lf2, lbR+lf2);
    log("%c bin_csv %c"+t_util.csv_count( bin_csv )+"%c"+bin_csv, lbH+lf0, lbL+lf0, lbR+lf0);

};




let pat_spans=[];

let pat_bag_innerHTML;
let off_bag_innerHTML;
let bak_bag_innerHTML;
let alt_bag_innerHTML;

let pat_moved_to_count;
let pat_inserted_count;
let pat_asserted_count;

let off_moved_to_count;
let off_inserted_count;
let off_asserted_count;

let alt_moved_to_count;
let alt_inserted_count;
let alt_asserted_count;

let bak_moved_to_count;
let bak_inserted_count;
let bak_asserted_count;

let bin_moved_to_count;


let t_pattern3_pat_off_alt_bak_innerHTML = function(_caller)
{

let   caller = "t_pattern3_pat_off_alt_bak_innerHTML";
let log_this = LOG_MAP.S0_PATTERN;

if( log_this) logBIG(caller, lf4);
if( log_this) pattern_log_bag_csv(caller);


    if(!pat_bag) return;

    let pat_bag_is_opened = has_el_class( pat_bag, "open_bag");



    pat_spans=[];
    let pat_count = t_select.t_collect_el_class_from_into("pat_span", pat_bag, pat_spans);
    let off_count = t_select.t_collect_el_class_from_into("pat_span", off_bag, pat_spans);
    let bak_count = t_select.t_collect_el_class_from_into("pat_span", bak_bag, pat_spans);
    let alt_count = t_select.t_collect_el_class_from_into("pat_span", alt_bag, pat_spans);

if(log_this) for(let i=0; i < pat_spans.length; ++i) log((i+1)+" %c["+pat_spans[i].innerText+"]", lbF+lbX[(i+1) % 10]);




    pat_bag_innerHTML = "";
    off_bag_innerHTML = "";
    bak_bag_innerHTML = "";
    alt_bag_innerHTML = "";

    pat_moved_to_count = 0;
    pat_inserted_count = 0;
    pat_asserted_count = 0;
    off_moved_to_count = 0;
    off_inserted_count = 0;
    off_asserted_count = 0;

    alt_moved_to_count = 0;
    alt_inserted_count = 0;
    alt_asserted_count = 0;

    bak_moved_to_count = 0;
    bak_inserted_count = 0;
    bak_asserted_count = 0;

    bin_moved_to_count = 0;


    pattern4_bin_remove_all_trashed_pat_spans();
    pattern5_bak_innerHTML();
    pattern6_alt_innerHTML();
    pattern7_pat_csv_to_bag();
    pattern8_off_bak_innerHTML();
    pattern9_adjust_pat_span_num();

    if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG))
    {
        let log_msg = "";


        log_msg += "<em class='cc"+(pat_bag_is_opened ? 9 : 8)+"'>PANEL "+(pat_bag_is_opened ? "OPENED" : "CLOSED")+"</em> ";



        log_msg                   += "<br>"+ t_data.SYMBOL_BAGGER+" <em class='done cc1'>HAVE</em>";

        if(!pat_count && !off_count && !alt_count && !bak_count) {
            log_msg               +=     " ALL BAGS EMPTY";
        }
        else {
            if(pat_count) log_msg += " <em class='bags cc1'>pat "+pat_count +"</em>";
            if(off_count) log_msg += " <em class='bags cc5'>off "+off_count +"</em>";
            if(alt_count) log_msg += " <em class='bags cc2'>alt "+bak_count +"</em>";
            if(bak_count) log_msg += " <em class='bags cc2'>bak "+bak_count +"</em>";
        }

        log_msg += t_select.t_get_docker_bag_msg("pat", pat_moved_to_count, pat_asserted_count, pat_inserted_count);
        log_msg += t_select.t_get_docker_bag_msg("off", off_moved_to_count, off_asserted_count, off_inserted_count);
        log_msg += t_select.t_get_docker_bag_msg("bak", bak_moved_to_count, bak_asserted_count, bak_inserted_count);
        log_msg += t_select.t_get_docker_bag_msg("alt", alt_moved_to_count, alt_asserted_count, alt_inserted_count);
        log_msg += t_select.t_get_docker_bag_msg("bin", bin_moved_to_count, 0                 , 0                 );

        t_fly.t_fly( log_msg );
    }

if(log_this && pat_bag_innerHTML) log("...pat_bag_innerHTML %c"+t_util.strip_HTML(pat_bag_innerHTML), lb1);
if(log_this && off_bag_innerHTML) log("...off_bag_innerHTML %c"+t_util.strip_HTML(off_bag_innerHTML), lb2);
if(log_this && bak_bag_innerHTML) log("...bak_bag_innerHTML %c"+t_util.strip_HTML(bak_bag_innerHTML), lb3);




    let needs_grid_bag
        = true

    ;

    if(has_el_class(pat_bag, "grid_bag") != needs_grid_bag)
    {
        set_el_class_on_off(pat_bag, "grid_bag", needs_grid_bag);

        t_fly.t_log_transcript_info("<span style='"+ (needs_grid_bag ? "color:red" : "color:green"                 ) +";'>"+t_data.SYMBOL_BLACK_CIRCLE+"</span>"
            +                 "<span style='"+ (needs_grid_bag ?          "" : "text-decoration:line-through") +";'>  grid_bag             </span>"
        );
    }



    let empty   = (t_util.csv_count(off_csv) == 0);
    set_el_class_on_off(off_bag, "empty", empty);




    if(pat_bag_innerHTML) pat_bag.insertAdjacentHTML("beforeend", pat_bag_innerHTML);
    if(off_bag_innerHTML) off_bag.insertAdjacentHTML("beforeend", off_bag_innerHTML);
    if(bak_bag_innerHTML) bak_bag.insertAdjacentHTML("beforeend", bak_bag_innerHTML);
    if(alt_bag_innerHTML) alt_bag.insertAdjacentHTML("beforeend", alt_bag_innerHTML);

    pat_bag.appendChild(off_bag);
    pat_bag.appendChild(bak_bag);
    pat_bag.appendChild(alt_bag);
    pat_bag.appendChild(bot_div);


if(log_this) {
    log(  "%c CSV...[SEL PAT OFF ALT BAK]"
          +"%c sel_csv "+t_util.csv_count( sel_csv )
          +"%c pat_csv "+t_util.csv_count( pat_csv )
          +"%c off_csv "+t_util.csv_count( off_csv )
          +"%c alt_csv "+t_util.csv_count( alt_csv )
          +"%c bak_csv "+t_util.csv_count( bak_csv )
          +"%c bin_csv "+t_util.csv_count( bin_csv )
          , lbH+lf9, lbH+lf9, lbH+lf4, lbH+lf5, lbH+lf6, lbH+lf2, lbH+lf0
       );

    log("%c sel_csv %c"+sel_csv, lbL+lf9,lbR+lf9);
    log("%c pat_csv %c"+pat_csv, lbL+lf1,lbR+lf1);
    log("%c off_csv %c"+off_csv, lbL+lf5,lbR+lf5);
    log("%c alt_csv %c"+alt_csv, lbL+lf6,lbR+lf6);
    log("%c bak_csv %c"+bak_csv, lbL+lf2,lbR+lf2);
    log("%c bin_csv %c"+bin_csv, lbL+lf0,lbR+lf0);
}

};



let   pattern4_bin_remove_all_trashed_pat_spans = function()
{
    for(let pos = 1; pos <= t_util.csv_count(bin_csv); ++pos)
    {
        let pat             = t_util.csv_get(bin_csv, pos);
        let pat_span_index  = t_select.t_get_pat_span_index(pat_spans, pat);
        if( pat_span_index >= 0) {

            let container   = pat_spans[pat_span_index].parentNode;
            if( container ) {
                container.removeChild( pat_spans[pat_span_index] );
                pat_spans[pat_span_index] = null;
                bin_moved_to_count += 1;
            }

        }
    }
};


let   pattern5_bak_innerHTML = function()
{
    for(let pos = 1; pos <= t_util.csv_count(bak_csv); ++pos)
    {
        let pat             = t_util.csv_get(bak_csv,    pos);
        let pat_span_index  = t_select.t_get_pat_span_index(pat_spans, pat);
        if( pat_span_index >= 0) {

            let container   = pat_spans[pat_span_index].parentNode;
            if( container  == bak_bag) {
                bak_asserted_count += 1;

            }


            else {
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly("MOVED TO <em class='cc2'>BAK</em> FROM <em class='cc9'>"+get_n_lbl(container)+"</em> ["+pat_spans[pat_span_index].innerText+"]");

                bak_moved_to_count += 1;
                bak_bag.appendChild( pat_spans[pat_span_index] );
            }


            sync_pat_span_slot_class(pat, pat_spans[pat_span_index]);

            pat_spans[pat_span_index] = null;

        }
        else {

            let num = t_util.mPadStart(pos,2).replace(" ","&nbsp;");
            let txt = t_util.ellipsis(t_util.t_get_htmlEntities(pat), 16);
            let css_class
                = "cc0"
                + ((mov_div.innerText == txt) ? " mov_src" : "")
            ;

            let line = t_select.t_get_pat_span_line(num, pat, css_class);


            bak_bag_innerHTML  += line;

            bak_inserted_count += 1;

        }
    }
};


let   pattern6_alt_innerHTML = function()
{
    for(let pos = 1; pos<= t_util.csv_count(alt_csv); ++pos)
    {
        let pat            = t_util.csv_get(alt_csv, pos);
        let pat_span_index = t_select.t_get_pat_span_index(pat_spans, pat);
        if( pat_span_index >= 0) {

            let container  = pat_spans[pat_span_index].parentNode;
            if( container == alt_bag) {
                alt_asserted_count += 1;

            }


            else {
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly("MOVED TO <em class='cc6'>ALT</em> FROM <em class='cc9'>"+get_n_lbl(container)+"</em> ["+pat_spans[pat_span_index].innerText+"]");

                alt_moved_to_count += 1;
                alt_bag.appendChild( pat_spans[pat_span_index] );
            }


            sync_pat_span_slot_class(pat, pat_spans[pat_span_index]);

            pat_spans[pat_span_index] = null;

        }
        else {

            let num = t_util.mPadStart(pos,2).replace(" ","&nbsp;");
            let txt = t_util.ellipsis(t_util.t_get_htmlEntities(pat), 16);
            let css_class
                = "cc0"
                + ((mov_div.innerText == txt) ? " mov_src" : "")
            ;

            let line = t_select.t_get_pat_span_line(num, pat, css_class);


            alt_bag_innerHTML  += line;
            alt_inserted_count += 1;


        }
    }
};


let   pattern7_pat_csv_to_bag = function()
{

let   caller = "pattern7_pat_csv_to_bag";
let log_this = LOG_MAP.S0_PATTERN;

if( log_this ) logBIG(caller, lf8);





if(log_this) {
    log(  "%c CSV...[SEL PAT OFF ALT BAK]"
          +"%c sel_csv "+t_util.csv_count( sel_csv )
          +"%c pat_csv "+t_util.csv_count( pat_csv )
          +"%c off_csv "+t_util.csv_count( off_csv )
          +"%c alt_csv "+t_util.csv_count( alt_csv )
          +"%c bak_csv "+t_util.csv_count( bak_csv )
          , lbH+lf9, lbH+lf9, lbH+lf4, lbH+lf5, lbH+lf6, lbH+lf2
       );

    log("%c sel_csv %c"+sel_csv, lbL+lf9,lbR+lf9);
    log("%c pat_csv %c"+pat_csv, lbL+lf1,lbR+lf1);
    log("%c off_csv %c"+off_csv, lbL+lf5,lbR+lf5);
    log("%c alt_csv %c"+alt_csv, lbL+lf6,lbR+lf6);
    log("%c bak_csv %c"+bak_csv, lbL+lf2,lbR+lf2);
    log("%c bin_csv %c"+bin_csv, lbL+lf8,lbR+lf8);
}

    for(let pos = 1; pos<= t_util.csv_count(pat_csv); ++pos)
    {

        let pat            = t_util.csv_get(pat_csv, pos);
        let pat_span_index = t_select.t_get_pat_span_index(pat_spans, pat);
        let pat_span       = pat_spans[pat_span_index];

        let in_off_csv     = t_util.csv_contains(off_csv, pat);
        let in_alt_csv     = t_util.csv_contains(alt_csv, pat);
        let in_bak_csv     = t_util.csv_contains(bak_csv, pat);


        let csv_belongs_to_bag;
        let container;
        let action;

        if(pat_span_index >= 0) {


            t_select.t_adjust_pat_span_words_option(pat_span, pat);



            container  = pat_span.parentNode;



            if( container == pat_bag)
            {
                csv_belongs_to_bag = !in_off_csv;
if( log_this)   action = "belongs to pat "+csv_belongs_to_bag;

                if(csv_belongs_to_bag)
                {
                    pat_asserted_count += 1;


                    pat_bag.insertBefore(pat_span, off_bag);
                }


                else {
                    off_moved_to_count += 1;
                    off_bag.appendChild( pat_span );
                }

            }


            else if( container == off_bag)
            {
                csv_belongs_to_bag =  in_off_csv;
if( log_this)       action = "belongs to off "+csv_belongs_to_bag;

                if(csv_belongs_to_bag)
                {
                    off_asserted_count += 1;
                }


                else {
                    pat_moved_to_count += 1;
                    pat_bag.insertBefore(pat_span, off_bag);
                }

            }


            else if( container == alt_bag)
            {

                if(in_off_csv) {
if( log_this)       action = "alt MOVED_TO off";
                    off_moved_to_count += 1;
                    off_bag.appendChild( pat_span );
                }


                else if(!in_alt_csv) {
if( log_this)       action = "alt MOVED_TO pat";
                    pat_moved_to_count += 1;
                    pat_bag.insertBefore(pat_span, off_bag);
                }

            }


            else if( container == bak_bag)
            {

                if(in_off_csv) {
if( log_this)       action = "bak MOVED_TO off";
                    off_moved_to_count += 1;
                    off_bag.appendChild( pat_span );
                }


                else if(!in_bak_csv) {
if( log_this)       action = "bak MOVED_TO pat";
                    pat_moved_to_count += 1;
                    pat_bag.insertBefore(pat_span, off_bag);
                }

            }


            else if( in_off_csv ) {
if( log_this)   action = "in_off_csv MOVED_TO off";

                off_moved_to_count += 1;
                off_bag.appendChild( pat_span );
            }


            else {
if( log_this) action = "not in_off_csv MOVE_TO pat";

                pat_moved_to_count += 1;
                pat_bag.insertBefore(pat_span, off_bag);
            }



            sync_pat_span_slot_class(pat, pat_span, in_off_csv);



            pat_spans[pat_span_index] = null;


        }
        else {

if( log_this) action = "new pat_span";
            let line_num = t_util.mPadStart(t_slot.get_slot_of_pattern(pat),2).replace(" ","&nbsp;");
            let txt = t_util.ellipsis(t_util.t_get_htmlEntities(pat), 16);
            let ccX = t_slot.get_slot_of_pattern( pat ) % 10;
            let css_class
                = ((in_off_csv              ) ? "cc0"      : "cc"+ccX)
                + ((mov_div.innerText == txt) ? " mov_src" : ""      )
            ;

            let line = t_select.t_get_pat_span_line(line_num, pat, css_class);


            if(in_off_csv) { off_bag_innerHTML += line; ++off_inserted_count; }



            else           { pat_bag_innerHTML += line; ++pat_inserted_count; }


        }

if( log_this)
    log_key_val_group( pat_span_index+" "+ action+" .. "+pat
                       , { pat_span_index
                         , in_off_csv
                         , in_alt_csv
                         , in_bak_csv
                         , container : container ? container.id : container
                       }, lfX[pat_span_index], true);


    }
};


let   pattern8_off_bak_innerHTML = function()
{

    for(let pat_span_index=0; pat_span_index < pat_spans.length; ++pat_span_index)
    {
        let pat_span =  pat_spans[pat_span_index];
        if( pat_span == null) continue;

        let el     = pat_span.childNodes[2];
        let el_pat = t_util.csv_unescape(el.getAttribute("data-pattern"));
        el_pat      = t_pattern_del_words_option_sfx(el_pat);


        if(t_util.csv_count(pat_csv) < t_select.SELECT_SLOT_MAX)
        {
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly("MOVED TO <em class='cc5'>OFF</em> <em class='cc8'>LOOSE</em> ["+pat_span.innerText+"]");

            csv_pattern_mov_to_off(el_pat);
            off_moved_to_count += 1;
            off_bag.appendChild( pat_span );
        }


        else {
if(LOG_MAP.EV8_FLOATLOG || prop.get(t_data.FLOATLOG)) t_fly.t_fly("MOVED TO <em class='cc8'>BAK</em> <em class='cc8'>LOOSE</em> ["+pat_span.innerText+"]");

            csv_pattern_mov_to_bak(el_pat);
            bak_moved_to_count += 1;
            bak_bag.appendChild( pat_span );
        }


        sync_pat_span_slot_class("", pat_span);

        pat_spans[pat_span_index] = null;
    }
};


let   pattern9_adjust_pat_span_num = function()
{
    pat_spans=[];
    t_select.t_collect_el_class_from_into("pat_span", pat_bag, pat_spans);
    for(let pat_span_index=0; pat_span_index < pat_spans.length; ++pat_span_index)
    {
        let pat_span = pat_spans[pat_span_index];
        let el       = pat_span.childNodes[2];
        let el_pat   = t_util.csv_unescape(el.getAttribute("data-pattern"));
        el_pat      = t_pattern_del_words_option_sfx(el_pat);
        let line_num = t_slot.get_slot_of_pattern(el_pat);

        let   num_em = pat_span.firstElementChild;
        num_em.innerHTML = t_util.mPadStart(line_num,2).replace(" ","&nbsp;");

    }

    pat_spans=[];
    t_select.t_collect_el_class_from_into("pat_span", off_bag, pat_spans);
    t_select.t_collect_el_class_from_into("pat_span", bak_bag, pat_spans);
    t_select.t_collect_el_class_from_into("pat_span", alt_bag, pat_spans);

    for(let pat_span_index=0; pat_span_index < pat_spans.length; ++pat_span_index)
    {
        let pat_span = pat_spans[pat_span_index];
        let line_num = t_util.get_child_num( pat_span );

        let   num_em = pat_span.firstElementChild;
        num_em.innerHTML = t_util.mPadStart(line_num,2).replace(" ","&nbsp;");


    }

};



let   sync_pat_span_slot_class = function(pat, pat_span, pat_off=true)
{
    let  el = pat_span.childNodes[2];


    let ccX = pat_off
        ?      0
        :     (t_slot.get_slot_of_pattern(pat) % 10);

    set_el_class_removing(el, "cc"+ccX, t_data.CCX_CLASSLIST);


};


let   get_sel_bag_pat_div = function(slot)
{
    let pat          = t_select.ccs[slot].pattern;

    let data_pattern = t_util.csv_escape(pat);



    let [ sel_text , words_option ] = t_pattern_to_sel_text_words_option( pat );
    let pat_less_sfx = sel_text;

    let txt          = t_util.ellipsis(t_util.t_get_htmlEntities(pat_less_sfx), 32);

    let title        = t_select.ccs[slot].toString();

    let className    = words_option+" "+t_data.CSS_DATA_PATTERN;


    return "<div class='pat_div t_select"+slot+"' title='"+title+"'>"
        +   "<em id='thumb_p_"+slot+"' class='"+className+"' data-pattern='"+data_pattern+"'>"+txt+"</em>"
        +   t_pattern2_get_sel_bag_thumbs_EM(slot, "thumb_p")
        +  "</div>"
    ;

};







let PULSE_BLACKLIST_ID_CSV = "tools_node";
const PULSE_IN_DURATION    = 500;
const PULSE_OUT_DURATION   = 500;

let pulsing_id     = "";
let pulsing_id_csv = "";



let pulse_id = function(id)
{
    let caller = "pulse_id("+id+")";
if(LOG_MAP.T3_LAYOUT) log(caller);

    if( t_util.csv_contains(PULSE_BLACKLIST_ID_CSV, id) ) {
if(LOG_MAP.T3_LAYOUT) log("...IGNORING BLACKLISTED ID");
        return;
    }
    let el;
    el     = t_get_tool(id);

    if(!el) id = pulse_id_get_alias(id);
    if(!id) return;

if(LOG_MAP.T3_LAYOUT) log(".id_alias=["+id+"]");
    el     = t_get_tool(id);

    if(!el ) return;
    if(id == pulsing_id) return;

    pulsing_id_csv = t_util.csv_add(pulsing_id_csv, id);


    pulse_id_start();

};


let pulse_id_get_alias = function(id)
{
    switch(id) {
        default               : return "";
        case        "bag_rot" : return "pat_bag";
        case        "pat_csv" : return "pat_bag";
        case   "words_filter" : return "sel_bag";
        case      "hotspotXY" : return "headsup";
        case "window_scrollY" : return "thumb_p";
    }
};



const PULSE_START_DELAY = 200;
let   pulse_id_timer    = null;


let pulse_id_start = function()
{
    if(pulse_id_timer) {
        clearTimeout( pulse_id_timer );
 pulse_id_timer = null;
    }

    set_el_class_on_off(hotwave, t_data.CSS_PULSING, true);

    if(!pulsing_id) pulse_id_timer = setTimeout(pulse_id_next_handler, PULSE_START_DELAY);
};



let HOTSPOT_HTML_IDLE       = "\u00BB;";

let pulse_id_next_handler = function()
{
    pulsing_id = t_util.csv_get(pulsing_id_csv, 1);
    if(!pulsing_id) {
        pulse_id_timer = null;
        set_el_class_on_off(hotwave, t_data.CSS_PULSING, false);
t_fly.t_fly(HOTSPOT_HTML_IDLE);
        return;
    }
    else {
        let count = t_util.csv_count(pulsing_id_csv);
t_fly.t_fly("<em class='cc"+count+"'>"+pulsing_id+"</em>");
    }


if(LOG_MAP.T3_LAYOUT) log(".pulse_id_next_handler: .. pulsing_id=["+pulsing_id+"]");

    pulsing_id_csv = t_util.csv_del(pulsing_id_csv, pulsing_id);

    t_set_id_class_on_off(pulsing_id, "pulse_in" , true );

    setTimeout(pulse_id_out_handler, PULSE_IN_DURATION);
};


let pulse_id_out_handler  = function()
{
    if(!pulsing_id) return;
if(LOG_MAP.T3_LAYOUT) log("..pulse_id_out_handler: pulsing_id=["+pulsing_id+"]");

    t_set_id_class_on_off(pulsing_id, "pulse_in"    , false);
    t_set_id_class_on_off(pulsing_id, "pulse_id_out", true );

    setTimeout(pulse_id_done_handler, PULSE_OUT_DURATION);
};


let pulse_id_done_handler = function()
{
    if(!pulsing_id) return;
if(LOG_MAP.T3_LAYOUT) log("...pulse_id_done_handler: pulsing_id=["+pulsing_id+"]");

    t_set_id_class_on_off(pulsing_id, "pulse_id_out", false);

    pulse_id_next_handler();
};





const MOVE_COOLDOWN_DURATION =  500;
const MOVE_COOLDOWN_SHORT    =  100;
let   move_cooldown_timer    = null;
let   move_cooldown_reason   =   "";


let move_cooldown_short = function(reason) { move_cooldown_start(reason, MOVE_COOLDOWN_SHORT ); };
let move_cooldown_start = function(reason, delay=MOVE_COOLDOWN_DURATION)
{

    onMoveDXY.x = 0;
    onMoveDXY.y = 0;

    if(move_cooldown_timer) clearTimeout(move_cooldown_timer);
    move_cooldown_timer   =   setTimeout(move_cooldown_handler, delay);
    move_cooldown_reason  =   reason;

    t_seek.t_seeker_set_CSS_ON_COOLDOWN(true);
};


let move_cooldown_handler = function()
{


    move_cooldown_timer  = null;
    move_cooldown_reason = "";
    t_clr_has_moved("move_cooldown_handler");

    t_seek.t_seeker_set_CSS_ON_COOLDOWN(false);
};


let move_cooldown_is_pending = function()
{
    return (move_cooldown_timer != null);
};


let move_cooldown_clear_pending = function()
{
    if(move_cooldown_timer) clearTimeout(move_cooldown_timer);
    move_cooldown_timer = null;
};





let       CSS_SLOW_REGROUP_DURATION = 1000;
let leave_CSS_SLOW_REGROUP_timer;


let enter_CSS_SLOW_REGROUP = function(_caller)
{

    if(!dom_tools_html) return;
    add_el_class(dom_tools_html, t_data.CSS_SLOW_REGROUP);

    if(leave_CSS_SLOW_REGROUP_timer) clearTimeout( leave_CSS_SLOW_REGROUP_timer );
    leave_CSS_SLOW_REGROUP_timer   =   setTimeout( leave_CSS_SLOW_REGROUP_handler, CSS_SLOW_REGROUP_DURATION);
};


let leave_CSS_SLOW_REGROUP_handler = function()
{

    leave_CSS_SLOW_REGROUP_timer = null;

    del_el_class(dom_tools_html, t_data.CSS_SLOW_REGROUP);
};


let leave_CSS_SLOW_REGROUP = function(_caller)
{

    if(!dom_tools_html) return;
    del_el_class(dom_tools_html, t_data.CSS_SLOW_REGROUP);

    if( leave_CSS_SLOW_REGROUP_timer ) {
        clearTimeout(leave_CSS_SLOW_REGROUP_timer);
        leave_CSS_SLOW_REGROUP_timer = null;
    }
};







let t_clone_1_DOC_SLIDER = function(panel, id, className)
{

    let box               = document.createElement("DIV");
    panel.appendChild( box );
    box.className         = "box cb_slider_cap toolbag_button "+className;


    let input             = document.createElement("INPUT");
    box.appendChild( input );
    input.type            = "checkbox";
    input.id              = id;
    input.name            = "check";
    input.className       = "cc2";


    let label0            = document.createElement("LABEL");
    box.appendChild( label0 );
    label0.htmlFor        = id;



    let label1            = document.createElement("LABEL");
    box.appendChild( label1 );
    label1.htmlFor        = id;

    t_clone_2_id_state_CB(id, false);
};


let t_clone_2_id_state_CB = function(id, checked)
{

let   caller = "t_clone_2_id_state_CB("+id+" , checked=["+checked+"])";
let log_this = LOG_MAP.T3_LAYOUT || LOG_MAP.EV5_TOOL_CB;



    let clone_el = document.getElementById(id);
    if(!clone_el ) return;

    let el_thumb = clone_el.labels ? clone_el.labels[0] : null;
    let el_track = clone_el.labels ? clone_el.labels[1] : null;

    if( el_thumb && el_track)
    {
        let                a =   id.split("_or_");
        if(a.length  != 2) a =   id.split("_"   );
        if(a.length  != 2) a = [ id      ,"OFF" ];
        if(a.length  == 2) {

            let label_ON  = a[0].toUpperCase();
            let label_OFF = a[1].toUpperCase();

if( log_this) log("%c"+id+"  "+checked+" %c ON..OFF=["+label_ON +".."+label_OFF+"]", lbL+lf3, lbR+lf5);
if( log_this) log(caller+": %c"+id      +" %c"+label_OFF                 +" %c"+label_ON
                  ,         lbb+lbH+lf9   ,lbH+(!checked ? lbb : "")+lf8   ,lbH+( checked ? lbb : "")+lf2);

            el_thumb.innerHTML = checked ? "<em class='bg8'>"+ label_ON  +"</em>" : "<em class='bg2'>"+ label_OFF +"</em>" ;
            el_track.innerHTML = checked ?                     label_OFF          :                     label_ON           ;

        }
        else {
if( log_this) log("%c"+caller+"%c *** no match with [cb_slider_cap] ID '_or_' naming separator feature", lbL, lbR+lf2);
        }
    }


    else {
if( log_this) log("%c"+caller+"%c ... not a [cb_slider_cap] .. thumb+track labels not found"           , lbL, lbR+lf8);
        t_clone_2_id_state_CB_PULSE(id, checked);
    }


    set_el_class_on_off(clone_el.parentElement, CSS_ON, checked);


};


let t_clone_2_id_state_CB_PULSE = function(input_id, checked)
{
    let       checkbox = document.getElementById(input_id);


    checkbox.checked = true;

    setTimeout( function() { t_prop_1_id_clone_OFF(checkbox); }, 2000);
};
let t_prop_1_id_clone_OFF = function(checkbox)
{
    checkbox.checked = false;
};


let t_clone_3_panel_id_bg_type_label = function(panel, id, bg, type, label)
{

let caller = "t_clone_3_panel_id_bg_type_label("+id+" , "+bg+" , "+type+")";
let log_this = LOG_MAP.T3_LAYOUT;



    let el;

    el = get_tool_clone(id);
    if( el ) {
if( log_this) log("%c"+caller+"%c TOOL ALREADY CLONED ["+id+"]", lbL+lf8, lbR+lf3);
        return null;
    }

    let title = id;

    el = get_tool_embedded(id);
    if( el ) {
if( log_this) log("%c"+caller+"%c TOOL ALREADY EMBEDDED ["+id+"]", lbL+lf8, lbR+lf4);
        type  = "span";
        title =  "placeholder for ["+id+"]";
    }

    label = t_util.underline_to_space(label || id);

    let tool_innerHTML
        = (type == "input")
        ?  (  "<input type='checkbox'     id='"+ id    +"' name='check' />"
            + "<label                    for='"+ id    +"'>"
            +  "<div class='small     middle'>"+ label +"</div>"
            + "</label>"
           )
        : (   "<"+type+" class='box_label'>"+ label +"</"+type+">");

    let div
        = document.createElement("DIV");

    let div_class
        = (type == "input")
        ? "box  cb_filled_pin "+ bg +" toolbag_button"
        : bg
        ;

    div.innerHTML
        =    "<div class='"+div_class+"' title='"+title+"'>"
        +     tool_innerHTML
        +    "</div>";

    panel.appendChild( div );

    el = div.firstElementChild.firstElementChild;

if( log_this) t_log.console_dir(caller+" ...return:", el);
    return  el;
};



let get_tool_clone = function(id)
{
    if(!id               ) return null;
    if( id.includes(" ") ) return null;
    let el
        = playground_clones_panel
        ? playground_clones_panel.querySelector("#"+id)
        : null;


    return el;
};



const MAX_EMBEDDED_TOOLS_ID = 32;


let get_doc_tool_diplayed_id_prefix = function(id_prefix)
{
    for(let i=0; i<MAX_EMBEDDED_TOOLS_ID; ++i)
    {
        let doc_tool = get_tool_embedded(id_prefix+(i ? ("_"+i): ""));
        if(!doc_tool ) break;
        let    buttons_pod = t_util.get_el_parent_with_class(doc_tool, CSS_BUTTONS_POD);
        if(    buttons_pod
               &&  buttons_pod.style.display
               && (buttons_pod.style.display != "none")
          ) {

            return doc_tool;
        }
    }
    return null;
};


let get_tool_embedded = function(id)
{
    if(!id               ) return null;
    if( id.includes(" ") ) return null;
    let el
        = document.querySelector("#"+id)
    ;


    return el;
};





const T_SYNC_TOOL_CLONES_DELAY = 500;

let   sync_tool_clones_timeout;

let t_sync_tool_clones_state = function(_caller)
{

let   caller = "t_sync_tool_clones_state";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log("%c"+caller+"%c CALLED BY "+ _caller, lbL+lf6,lbR+lf6);


    if(  sync_tool_clones_timeout) clearTimeout(sync_tool_clones_timeout);
    sync_tool_clones_timeout =      setTimeout (sync_tool_clones_handler, T_SYNC_TOOL_CLONES_DELAY);
};


let   sync_tool_clones_handler = function()
{

let   caller = "sync_tool_clones_handler";
let log_this = LOG_MAP.T3_LAYOUT;

if( log_this) log(caller);


    let id, el;

    id = "EV0_LISTEN"            ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV0_LISTEN     ? CSS_CC9 : CSS_CC8, t_data.CCX_CLASSLIST);
    id = "EV1_DOWN"              ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV1_DOWN       ? CSS_CC1 : CSS_CC8, t_data.CCX_CLASSLIST);
    id = "EV2_MOVE"              ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV2_MOVE       ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id = "EV3_UP"                ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV3_UP         ? CSS_CC3 : CSS_CC8, t_data.CCX_CLASSLIST);
    id = "EV4_LONG_PRESS"        ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV4_LONG_PRESS ? CSS_CC4 : CSS_CC8, t_data.CCX_CLASSLIST);
    id = "EV5_TOOL_CB"           ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV5_TOOL_CB    ? CSS_CC5 : CSS_CC8, t_data.CCX_CLASSLIST);
    id = "EV6_CHANGED"           ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV6_CHANGED    ? CSS_CC6 : CSS_CC8, t_data.CCX_CLASSLIST);
    id = "EV7_DISPATCH"          ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV7_DISPATCH   ? CSS_CC7 : CSS_CC8, t_data.CCX_CLASSLIST);
    id = "EV8_FLOATLOG"          ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.EV8_FLOATLOG   ? CSS_CC9 : CSS_CC8, t_data.CCX_CLASSLIST);

    id =  "S0_PATTERN"           ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.S0_PATTERN     ? CSS_CC1 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "S1_RANGE"             ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.S1_RANGE       ? CSS_CC1 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "S2_SELECT"            ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.S2_SELECT      ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "S3_SLOT"              ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.S3_SLOT        ? CSS_CC3 : CSS_CC8, t_data.CCX_CLASSLIST);

    id =  "T0_STORE"             ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T0_STORE       ? CSS_CC9 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "T1_DOM_LOAD"          ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T1_DOM_LOAD    ? CSS_CC1 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "T2_GRID"              ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T2_GRID        ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "T3_LAYOUT"            ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T3_LAYOUT      ? CSS_CC3 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "T4_PIVOT"             ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T4_PIVOT       ? CSS_CC4 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "T5_SPREAD"            ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T5_SPREAD      ? CSS_CC5 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "T6_SLOT"              ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T6_SLOT        ? CSS_CC6 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "T7_SHARE"             ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T7_SHARE       ? CSS_CC7 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  "T8_TOOLBAR"           ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.T8_TOOLBAR     ? CSS_CC0 : CSS_CC8, t_data.CCX_CLASSLIST);

    id =  "IPC_LOG"              ; if(el = document.getElementById(id)) set_el_class_removing(el, LOG_MAP.IPC_LOG        ? CSS_CC9 : CSS_CC8, t_data.CCX_CLASSLIST);

    id =  t_data.CONTAINERS_HI   ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC1 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.WORDS_EXACT     ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC3 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.WORDS_SEGMENT   ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC4 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.WORDS_HEAD_TAIL ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC5 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.WORDS_OPCYCLE   ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC9 : CSS_CC8, t_data.CCX_CLASSLIST);

    let id_array = get_words_drop_affix_array();
    for(let i=0; i < id_array.length; ++i)
    {
        id = id_array[i]         ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC9 : CSS_CC8, t_data.CCX_CLASSLIST);
    }

    id =  t_data.SCROLL_SMOOTH   ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);

    id =  t_data.SHOW_SEEKZONE   ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.PIN_SEEKSPOT    ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.LOG_SEEKSPOT    ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);

    id =  t_data.REMOVE_ADS      ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.SPLIT_WOT       ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.LINES_WOT       ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);

    id =  t_data.DENY_OR_ALLOW   ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.EDIT_OR_STAGE   ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.DOM_HIDE1_RESET ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.DOM_HIDE1_UNDO  ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.MASK_OR_HIDE    ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);
    id =  t_data.SITE_OR_PAGE    ; if(el = document.getElementById(id)) set_el_class_removing(el, prop.get(id)           ? CSS_CC2 : CSS_CC8, t_data.CCX_CLASSLIST);


    id = "dom_grid_headsup"      ; if(el = document.getElementById(id)) set_el_class(el, CSS_COLLAPSED, LOG_MAP.T2_GRID);
};





let SEEK_PAT_BAG_LOG = DOM_TOOLS_TAG;
const SEEK_NEXT_SLOT_NUM_DELAY          =  500;
const SEEK_NEXT_SCROLL_WAS_NEEDED_DELAY = 1000;

let   seek_next_slot_num_timeout;



let seek_pat_bag = function()
{

let   caller = "seek_pat_bag";
let log_this = SEEK_PAT_BAG_LOG;

if( log_this) t_log.console_clear(caller);


    let { slot , num }
        = t_seek.t_seeker_get_last_seeked_slot_num();
    if(!slot || (slot < 0)) {
        slot = 1;
        num  = 1;
    }

if( log_this) log("%c SEEKER ANIMATION: LAST SELECTED SLOT "+slot, lbH+lf1);


    let el;
    while(slot <= t_select.SELECT_SLOT_MAX)
    {
        if(t_select.t_select_get_slot_nodes_length(slot) >= 1)
        {
            let ccX       = slot % t_select.SELECT_SLOT_MAX;
            if( el = document.querySelector("."+t_select.SEL_CLASS_PREFIX + ccX))
                break;
        }
        slot += 1;
    }

    if(!el) return;


    let num_wrap_to = num;
    do {
        num = t_select.t_get_slot_num_next_wrap_to(slot, num, num_wrap_to);
    }
    while((num != num_wrap_to) && !t_select.t_is_slot_num_visible(slot,num));


    let cr = el.getBoundingClientRect();
    onDown_XY.x = cr.x;
    onDown_XY.y = cr.y;

    t_set_onWork_EL(el,caller);
    if(!onWork_EL) return;



    t_seek.t_seeker_onDown_1_INIT_CTRL_DEBOUNCE_INPUT(onWork_EL, onDown_XY);
    t_seek.t_seeker_onMove1_grab(caller);


    t_seek.t_seeker_set_PU_locked_on_screen(true);

    seek_next_slot_num_timeout = setTimeout(function() { seek_next_slot_num_handler({ slot , num }); }, 0);

};


let seek_next_slot_num_handler = function({slot , num , num_wrap_to})
{

let   caller = "seek_next_slot_num_handler";
let log_this = SEEK_PAT_BAG_LOG;



    if(!seek_next_slot_num_timeout) {
if(log_this) log("%c SEEKER ANIMATION CANCELED BEFORE NUM "+num, lbH+lf3);

        return;
    }


    let       num_max = t_select.t_select_get_slot_nodes_length(slot);
    if( num > num_max)
        num = 1;

    if( num_wrap_to && (num == num_wrap_to))
    {
        if(num_max <= 1) return;

        let delay = 0;
        setTimeout(
                   function() {
                       t_seek.t_seeker_onMove3_ON_SLOT_NUM(slot, num);

                       t_seek.t_seeker_set_PU_locked_on_screen(false);
                   }
                   , delay
                  );


        t_set_onWork_EL(null, caller);
        t_seek.t_seekzone5_hide();

        return;
    }

    num_wrap_to = num_wrap_to || num;

    let scrollIntoView_was_needed = dom_scroll.t_scrollIntoView_was_needed();


if(log_this)
    log_key_val_group(caller+"(slot "+slot+" .. num "+num+" → "+num_wrap_to+")"
                      ,{       slot
                       ,       num
                       ,       num_wrap_to
                       ,       scrollIntoView_was_needed
                      },   lfX[scrollIntoView_was_needed ? 3:8]
                      , true);



    t_seek.t_seeker_onMove3_ON_SLOT_NUM(slot, num);

    do {
        num = t_select.t_get_slot_num_next_wrap_to(slot, num+1, num_wrap_to);
    }
    while((num != num_wrap_to) && !t_select.t_is_slot_num_visible(slot,num));

    let delay = scrollIntoView_was_needed
        ?        SEEK_NEXT_SCROLL_WAS_NEEDED_DELAY
        :        SEEK_NEXT_SLOT_NUM_DELAY
    ;
    dom_scroll.t_scrollIntoView_was_needed_reset();

    if( prop.get(t_data.SCROLL_SMOOTH) )
        delay *= 2;

    seek_next_slot_num_timeout = setTimeout(function() { seek_next_slot_num_handler({slot, num, num_wrap_to}); }, delay);

};


let seek_next_slot_num_cancel = function()
{
let log_this = SEEK_PAT_BAG_LOG;

    if(!seek_next_slot_num_timeout )
        return;

if(log_this) log("%c SEEKER ANIMATION CANCELING", lf2);
    seek_next_slot_num_timeout = null;

    t_seek.t_seeker_set_PU_locked_on_screen(false);
};





let snapshot_mail_body;



let t_take_SNAPSHOT = function(dom_load_id, snapshot_id, e_target=undefined)
{

let   caller = "t_take_SNAPSHOT";
let log_this = DOM_TOOLS_TAG;

if( log_this) t_log.console_clear(caller);


    let snapshot_key = "SNAPSHOT"+ ((snapshot_id && (snapshot_id != "undefined")) ? "_"+snapshot_id : "");

if( log_this) log("%c"+caller+"%c"+dom_load_id+"%c"+snapshot_key+")"
                  ,lbL+lf7    ,lbC+lf7         ,lbR+lf7             );


    snapshot_mail_body = dom_share.t_share2_MAILTO_UI(e_target);
    if( snapshot_mail_body )
    {
if( log_this) log("%c"+snapshot_mail_body, lf7);

        t_store.t_store_set_value(snapshot_key, snapshot_mail_body);
    }
    else {
        log("%c"+caller+"%c No "+snapshot_key+" to export to",lbL+lf6, lbR+lf2);

    }

};


let t_load_SNAPSHOT = function(dom_load_id, snapshot_id)
{

let   caller = "t_load_SNAPSHOT";
let log_this = DOM_TOOLS_TAG;




    let snapshot_key = "SNAPSHOT"+ ((snapshot_id && (snapshot_id != "undefined")) ? "_"+snapshot_id : "");

if( log_this) log("%c"+caller+"%c"+dom_load_id+"%c"+snapshot_key+")"
                  ,lbL+lf6    ,lbC+lf6         ,lbR+lf6             );


    snapshot_mail_body = t_store.t_store_getItem(snapshot_key, "page");
    if( snapshot_mail_body )
    {
if( log_this) log("%c"+snapshot_mail_body, lf6);

        dom_share.t_share4_IMPORT_TEXT(snapshot_mail_body);
    }
    else {
        log("%c"+caller+"%c No "+snapshot_key+" to import from",lbL+lf6, lbR+lf2);
        dom_share.t_share4_IMPORT_TEXT("{}");

    }

};


let t_void_SNAPSHOT = function()
{

let   caller = "t_void_SNAPSHOT";
let log_this = DOM_TOOLS_TAG;

if( log_this) t_log.console_clear(caller);
if( log_this) log("%c"+caller,lbH+lf0);


    t_store.t_store_remove_shared_items("IMPORT [empty] SNAPSHOT FROM THE VOID");

    t_hide_hotspot(0);
    dom_share.t_share4_IMPORT_TEXT("{}");

};


let t_show_SNAPSHOT = function()
{


    if(!snapshot_mail_body) {
        t_fly.t_fly("snapshot_mail_body is empty");
    }
    else {
        t_util.t_copy_to_CLIPBOARD(snapshot_mail_body);
        t_fly.t_fly("SNAPSHOT HAS BEEN COPIED TO THE CLIPBOARD");
        t_fly.t_fly( snapshot_mail_body );
    }
};






















const DRAG_CURSOR_JS_ID       = "drag_cursor" ;
const DRAG_CURSOR_JS_TAG      = DRAG_CURSOR_JS_ID +" (220221:19h:37)";

let drag_cursor  = (function() {
"use strict";


const CSS_DRAG_CURSOR_DIV_ONLOAD       = "onload";
const     DRAG_CURSOR_DIV_ONLOAD_DELAY =  1000;
let       drag_cursor_div;





let mouseUP_display_state = true;


let set_mouseUP_display_state = function(state=true)
{
    mouseUP_display_state = state;

    if(state) show_drag_cursor();

    if(state) t_CURSOR_add_MOVE_LISTENER();
    else      t_CURSOR_del_MOVE_LISTENER();
};

let get_mouseUP_display_state = function() { return mouseUP_display_state; };

let show_drag_cursor = function()
{

    if(!drag_cursor_div) {
        drag_cursor_div = document.createElement("DIV");

        drag_cursor_div.id                    =     "drag_cursor";
        drag_cursor_div.style.pointerEvents   =            "none";
        drag_cursor_div.style.position        =           "fixed";
        drag_cursor_div.style.margin          =             "0px";
        drag_cursor_div.style.padding         =            "16px";
        drag_cursor_div.style.backgroundColor =            "#FF0";
        drag_cursor_div.style.border          =  "3px solid #000";
        drag_cursor_div.style.borderRadius    = "1em 0em 1em 1em";
        drag_cursor_div.style.zIndex          =      "2147483647";
        drag_cursor_div.style.opacity         =             "0.5";

        document.documentElement.appendChild( drag_cursor_div );
    }
    if( drag_cursor_div.style.display != "block")
    {

        if(typeof dom_sentence_event != "undefined")
        {
            drag_cursor_div.classList.add( CSS_DRAG_CURSOR_DIV_ONLOAD );
            drag_cursor_div.style.left    = (window.innerWidth  / 2)+"px";
            drag_cursor_div.style.top     = (window.innerHeight / 2)+"px";

        }

        drag_cursor_div.style.display  = "block";
    }
};


let move_drag_cursor = function(e)
{
    if(!drag_cursor_div                         ) return;
    if(!drag_cursor_div.style.display == "block") return;

    if(                  drag_cursor_div.classList.contains( CSS_DRAG_CURSOR_DIV_ONLOAD ))
        setTimeout(() => drag_cursor_div.classList.remove  ( CSS_DRAG_CURSOR_DIV_ONLOAD ), DRAG_CURSOR_DIV_ONLOAD_DELAY);

    let      xy = t_util.get_event_XY(e);
    let offset_x = drag_cursor_div.className
        ? drag_cursor_div.offsetWidth / 2
        : drag_cursor_div.offsetWidth;
    drag_cursor_div.style.left    = (xy.x - offset_x)+"px";
    drag_cursor_div.style.top     = (xy.y           )+"px";
};

let hide_drag_cursor                     = function() { if(drag_cursor_div) drag_cursor_div.style.display = "none"; };
let add_drag_cursor_CSS_NOT_MOVED_ENOUGH = function() { if(drag_cursor_div) drag_cursor_div.classList.add   (CSS_NOT_MOVED_ENOUGH); };
let del_drag_cursor_CSS_NOT_MOVED_ENOUGH = function() { if(drag_cursor_div) drag_cursor_div.classList.remove(CSS_NOT_MOVED_ENOUGH); };
let add_drag_cursor_CSS_MOVE_ON_COOLDOWN = function() { if(drag_cursor_div) drag_cursor_div.classList.add   (CSS_MOVE_ON_COOLDOWN); };
let del_drag_cursor_CSS_MOVE_ON_COOLDOWN = function() { if(drag_cursor_div) drag_cursor_div.classList.remove(CSS_MOVE_ON_COOLDOWN); };


return { name : "drag_cursor"
    ,    set_mouseUP_display_state
    ,    get_mouseUP_display_state
    ,    show_drag_cursor
    ,    hide_drag_cursor
    ,    move_drag_cursor
    ,    add_drag_cursor_CSS_MOVE_ON_COOLDOWN
    ,    add_drag_cursor_CSS_NOT_MOVED_ENOUGH
    ,    del_drag_cursor_CSS_MOVE_ON_COOLDOWN
    ,    del_drag_cursor_CSS_NOT_MOVED_ENOUGH
};
}());







let t_store_set_state = function(label,state)
{
    if(          state != undefined)
    {
        if(      state) localStorage.setItem   (label, "true");
        else            localStorage.removeItem(label        );
        return !!state;
    }
    else {
        return          localStorage.getItem   (label        );
    }
};



return { name : "dom_tools"
    , logging : function(state) { return DOM_TOOLS_LOG = t_store_set_state("DOM_TOOLS_LOG",state); }
    , tagging : function(state) { return DOM_TOOLS_TAG = t_store_set_state("DOM_TOOLS_TAG",state); }
    , t_tools_IMPORT


    ,    CSS_BACK
    ,    CSS_BUTTONS_POD
    ,    CSS_CLOSEPIN
    ,    CSS_CONTAINER_SELECTED
    ,    CSS_DISABLED
    ,    CSS_FADING
    ,    CSS_FLOATLOG
    ,    CSS_MAGNIFIED
    ,    CSS_ON_COOLDOWN
    ,    CSS_PAUSE_ANIMATION
    ,    CSS_REMOVING
    ,    CSS_STACKING
    ,    CSS_TOOLBAG_BUTTON
    ,    CSS_TOOLTIP



    ,    LONG_PRESS_ARM
    ,    DIR_GRAB
    ,    DIR_NUM_NEXT
    ,    DIR_NUM_PREV
    ,    DIR_SLOT_NEXT
    ,    DIR_SLOT_PREV

    ,    MOVED_ENOUGH


    , ...dom_scroll
    , t_has_scrolled        : dom_scroll.get_has_scrolled
    , t_scroll_is_scrolling : dom_scroll.t_scroll_not_done_yet



    ,    t_get_all_csv               : function() { return [ pat_csv, off_csv, alt_csv, bak_csv, bin_csv ]; }
    ,    t_get_pat_csv               : function() { return   pat_csv; }
    ,    t_get_off_csv               : function() { return   off_csv; }
    ,    t_get_alt_csv               : function() { return   alt_csv; }
    ,    t_get_bak_csv               : function() { return   bak_csv; }
    ,    t_get_bin_csv               : function() { return   bin_csv; }

    ,    t_get_body_zoom_percent     : function() { return body_zoom_percent;                }
    ,    t_get_dimm_mask             : function() { return dimm_mask;                        }
    ,    t_get_fly_log               : function() { return     fly_log;                      }
    ,    t_get_has_moved             : function() { return has_moved;                        }
    ,    t_get_onDown_EL             : function() { return onDown_EL;                        }
    ,    t_get_onDown_MS             : function() { return onDown_MS;                        }
    ,    t_get_onWork_EL             : function() { return onWork_EL;                        }
    ,    t_get_onWork_EL_last_used   : function() { return onWork_EL_last_used;              }
    ,    t_get_onWork_MOVABLE_CHILD  : function() { return onWork_MOVABLE_CHILD ;            }
    ,    t_get_onWork_MOVABLE_PANEL  : function() { return onWork_MOVABLE_PANEL;             }
    ,    t_get_onWork_PANEL          : function() { return onWork_PANEL;                     }
    ,    t_get_onWork_SEEK_TOOL      : function() { return t_seek.t_seeker_get_TOOL_label(); }
    ,    t_get_pivot_PANEL           : function() { return pivot_PANEL;                      }
    ,    t_get_shadow_root           : function() { return shadow_root;                      }
    ,    t_get_transcript1           : function() { return transcript1;                      }
    ,    t_get_transcript2           : function() { return transcript2;                      }
    ,    t_tools_IN_WEBVIEW          : function() { return  IN_WEBVIEW;                      }
    ,    t_is_a_handled_tool         : function(e_target) { return ((get_EL_slot(e_target) > 0) || t_is_an_embedded_doc_tool(e_target)); }

    ,    add_sel_csv
    ,    csv_pattern_mov_to_off
    ,    csv_pattern_mov_to_pat
    ,    del_page_and_tool_pointermove_listeners
    ,    get_onDown_SELECTION
    ,    t_get_tool
    ,    get_tool_clone
    ,    pulse_id
    ,    set_off_csv
    ,    set_pat_csv
    ,    set_sel_csv

    ,    t_TOOLS_panels_reload
    ,    t_add_closepin_on_panel
    ,    t_add_input_listener
    ,    t_add_tool_pointermove_listener
    ,    t_blur
    ,    t_cache_armed_by
    ,    t_cache_wph_WH
    ,    t_clear_slot_sync
    ,    t_clr_container_selected
    ,    t_copy_innerHTML_to_clipboard
    ,    t_del_pin_css_on_panel
    ,    t_dimm_mask_displayed        : dimm_mask_displayed
    ,    t_dimm_should_postpone
    ,    t_dimm_start                 : dimm_start
    ,    t_dimm_start_sticky          : dimm_start_sticky
    ,    t_dimm_stop                  : dimm_stop
    ,    t_dom_tools_html_appendChild
    ,    t_dom_tools_html_set_el_class_on_off
    ,    t_focus
    ,    t_get_EL_num
    ,    t_get_consumed_by_table
    ,    t_get_container_selected
    ,    t_get_current_sel_text
    ,    t_get_event_status_object
    ,    t_get_onDown_SCROLL_XY
    ,    t_get_onDown_SEL_TEXT
    ,    t_get_onDown_XY
    ,    t_get_onWork_EL_container
    ,    t_get_onWork_EL_num
    ,    t_get_onWork_EL_slot
    ,    t_get_shadow_tool
    ,    t_get_tools_status_object
    ,    t_handle_1_pat_bag_rotation_update_UI
    ,    t_is_a_click                 : function(e) { return is_a_click(e); }
    ,    t_is_a_drag                  : function(e) { return                   is_a_drag (e); }
    ,    t_is_a_quick_drag
    ,    t_is_a_tool_el
    ,    t_is_panel_magnified
    ,    t_just_loaded
    ,    t_load
    ,    t_load_BEHAVIOR
    ,    t_load_TOOLS_MAP
    ,    t_log_clr_status
    ,    t_onPatternUpdate_done
    ,    t_onclick_target_handle_scroll_to_slot_num
    ,    t_pat_bag1_hide_pattern
    ,    t_pat_bag_open
    ,    t_pattern2_get_sel_bag_thumbs_EM
    ,    t_pattern_del_words_extension
    ,    t_pattern_del_words_option_sfx
    ,    t_pattern_to_sel_text_words_option
    ,    t_pin_panel_at_XY
    ,    t_reload
    ,    t_save_update_post
    ,    t_seek_set_container_selected
    ,    t_set_CSS_PINNED
    ,    t_set_el_pat_words_option
    ,    t_set_id_class_on_off
    ,    t_set_onWork_EL
    ,    t_slot_containers_copy_to_clipboard_innerHTML
    ,    t_some_tool_clicked
    ,    t_store_consider_page_items_worth_storing
    ,    t_store_get_patterns_csv
    ,    t_sync_tool_clones_state
    ,    t_sync_wording
    ,    t_toggle_panel_magnified
    ,    t_tools_get_map
    ,    t_tools_map_get
    ,    t_tools_panel_is_selected
    ,    t_unload
    ,    t_update_TOOLS_MAP_GEOMETRY
    ,    t_was_a_click                : was_a_click
    ,    t_was_a_misclick             : was_a_misclick
    ,    t_window_getSelection_removeAllRanges
    ,    t_words_option_select
    ,    t_words_option_tooltip
    ,    t_words_regex_no_match
    ,    t_words_regex_reset
    ,    t_is_bouncing_e_type

    , t_pattern1_sync_csv_from_ccs
    , t_pattern2_set_sel_bag_innerHTML
    , t_pattern3_pat_off_alt_bak_innerHTML
    , t_store_del_patterns_csv


    , t_log_event_status            : (typeof dom_fly  == "undefined") ? null : dom_fly.t_log_event_status
    , t_log_event_status_get        : (typeof dom_fly  == "undefined") ? null : dom_fly.t_log_event_status_get
    , t_log_event_status_if_changed : (typeof dom_fly  == "undefined") ? null : dom_fly.t_log_event_status_if_changed
    , t_log_tools_status_get        : (typeof dom_fly  == "undefined") ? null : dom_fly.t_log_tools_status_get
    , t_seeker_isOn_SLOT_EL         : (typeof dom_seek == "undefined") ? null : dom_seek.t_seeker_isOn_SLOT_EL


    , add_listener_capture_active
    , behavior_TOUCH_ELSE_DESKTOP
    , get_onMoveDXY
    , remove_listener_capture_active
    , set_onDown_XY
    , t_CURSOR_del_MOVE_LISTENER
    , t_pat_bag3_dump_all_csv
    , t_preventDefault
    , wording_3_CB_WORDS_RECYCLE
    , zap_onMoveDXY


    , are_p1_p2_in_same_quadrant_and_p2_in_corner
    , is_a_tool_container
    , is_pannel_in_hotspot_quadrant
    , t_del_clearpin_on_panel
    , t_del_closepin_on_panel
    , t_del_push_pin_on_panel
    , t_del_scalepin_on_panel
    , t_get_TOOL_panel_idx_not_pinned_first
    , t_get_TOOL_panel_idx_not_pinned_last
    , t_has_clearpin_on_panel
    , t_has_closepin_on_panel
    , t_has_scalepin_on_panel
    , t_input_2_focus_words_filter_input
    , t_is_tool_deployed
    , t_override_USER_OPTION
    , t_set_spread_ratio_up_to_panel
    , t_set_touchedWord_startContainer
    , t_spread_log
    , was_a_too_quick_last_result
    , post_focus_to


    , del_long_press_listener
    , t_dump_csv_and_sticky : function()
    {
        pat_bag5_hide_sel();
        t_pat_bag3_dump_all_csv();
        t_sticky.t_sticky_unpin_all();
        t_sticky.t_sticky_STORE_NOW();
    }
    , prop_id_toggle
    , seek_pat_bag


    , t_tools_panel_select

    , t_event_add_e_consumed_by
    , t_event_clr_consumed
    , t_event_has_been_consumed
    , t_event_set_e_consumed_by
    , t_handle_1_pat_bag
    , t_hide_hotspot
    , t_layout_changed
    , t_load_SNAPSHOT
    , t_show_SNAPSHOT
    , t_show_hotspot
    , t_take_SNAPSHOT
    , t_void_SNAPSHOT

    , t_clear
    , t_handle_1_pat_bag_sort_cycle
    , t_pat_bag3_reselect_all
    , t_pat_bag_close
    , t_sel_pat_bag_all
    , t_tools_hide
    , t_tools_set_hotspot_xy
    , t_tools_show
    , sync_csv            : function(                 ) { pattern_log_bag_csv("t_handle_1_pat_bag_rotation_update_UI"); t_handle_1_pat_bag_rotation_update_UI( pat_csv ); }
    , sync_rot            : function(                 ) { pattern_log_bag_csv("t_handle_1_pat_bag_rotation"); t_handle_1_pat_bag_rotation(); }
    , t_clear_slot_all    : function(                 ) { t_select.t_clear_slot_all(); }
    , t_log_csv           : function(_caller="console") { pattern_log_bag_csv     (_caller); }
    , t_log_status        : function(_caller="console") { t_fly.t_log_event_status(_caller); }
    , t_pat_bag3_reselect : function(                 ) { pat_bag3_reselect(); }
    , t_reselect          : function(                 ) { pat_bag3_reselect( pat_csv ); }
    , log_hotspotXY       : function(                 ) { log(hotspotXY); }

    , hotring_pressed     : function(state) { set_el_class_on_off(hotring       , t_data.CSS_PRESSED, state); }
    , dom_tools_pressed   : function(state) { set_el_class_on_off(dom_tools_html, t_data.CSS_PRESSED, state); }


    , get_onDown_SHIFT    : function()  { return onDown_SHIFT; }
    , get_onDown_CTRL     : function()  { return onDown_CTRL ; }
    , get_onDown_ALT      : function()  { return onDown_ALT  ; }
    , t_get_mouselong_press_consumed_by


    , t_add_NOT_MOVED_ENOUGH
    , t_del_NOT_MOVED_ENOUGH
    , t_add_MOVE_ON_COOLDOWN
    , t_del_MOVE_ON_COOLDOWN


, TOOL_SET
, dimm_mask_displayed
, div_slot_containers_displayed
, hotspot
, load5_STORAGE_hotspot
, t_IS_ON_GRID_observerCB
, t_MASK_OR_HIDE_changed
, t_click_panel_pin_CB
, t_drag_hotspot_xy_delay
, t_flash_unpinned_panels
, t_is_a_tools_id_tier
, t_outline_viewport_top_containers
, t_raise_pivot_PANEL
, t_raise_pivot_PANEL_layout
, t_sync_layout
, t_sync_styles
, t_sync_tools_position
, t_sync_tools_tier2
, t_tools_pointermove_drag_hotspot
, t_tools_sync_top_xy

, move_drag_cursor              : drag_cursor.move_drag_cursor
, get_mouseUP_display_state     : drag_cursor.get_mouseUP_display_state
, show_drag_cursor              : drag_cursor.show_drag_cursor
, hide_drag_cursor              : drag_cursor.hide_drag_cursor

};


}());





let IPC_SCRIPT_ID    = DOM_TOOLS_JS_ID;
let IPC_EXTENSION_ID = "background_js";

let IPC_LOG          = dom_log.LOG_MAP.IPC_LOG;
let IPC_LOG_COLOR    = dom_log.lb6;
let IPC_MSG_COLOR    = dom_log.lbF+IPC_LOG_COLOR;
let IPC_LBA_COLOR    = dom_log.lbA;
let IPC_LBF_COLOR    = dom_log.lbF;
let IPC_LBH_COLOR    = dom_log.lbH;
let IPC_LF5_COLOR    = dom_log.lf5;
let IPC_LB0_COLOR    = dom_log.lb0;


let t_handle_ipc_message = function(ipc)
{
"use strict";
let log_this = IPC_LOG;
if( log_this) console.log("%c "+IPC_SCRIPT_ID+" %c t_handle_ipc_message(ipc)"                        , IPC_LOG_COLOR, IPC_LBA_COLOR);


    if((typeof ipc.start != "undefined"))
    {
        if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c EXTENSION INSTRUCTION DETECTED"            , IPC_LOG_COLOR, IPC_LBF_COLOR);

        let script_loaded = t_ipc_handle_start(ipc.start);

        if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c TOOLS LOADED AND WAITING "+script_loaded   , IPC_LOG_COLOR, IPC_LBF_COLOR);
    }


    else if(typeof ipc.theme != "undefined")
    {
        t_ipc_handle_theme( ipc.theme );
    }

};


let t_ipc_handle_start = function(start)
{
"use strict";
let log_this = IPC_LOG;
    if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c t_ipc_handle_start("+start+")"                 , IPC_LOG_COLOR, IPC_LBA_COLOR);

    if(start == "ON")
    {
        if(!dom_ipc.t_ipc_is_IPC_SCRIPT_loaded() )
        {
            if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c LOADING "                              , IPC_LOG_COLOR, IPC_LBF_COLOR);

            dom_tools.t_load();
            let script_loaded = ((typeof DOM_TOOLS_CSS_TAG != "undefined") && DOM_TOOLS_CSS_TAG);

if(log_this) console.log("...DOM_TOOLS_CSS_TAG=["+ DOM_TOOLS_CSS_TAG +"]");
if(log_this) console.log(".......script_loaded=["+ script_loaded     +"]");
            return script_loaded;
        }
        else {


            let dom_tools_html =   dom_tools.t_get_tool("dom_tools_html");
            if( dom_tools_html && (dom_tools_html.style.visibility == "hidden"))
            {
                if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c RELOADING "                        , IPC_LOG_COLOR, IPC_LBF_COLOR);
                dom_tools.t_reload();
            }

            else {
                if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c ALREADY LOADED .. RE-SENDING "+dom_tools.TOOLS4_DEPLOYED    , IPC_LOG_COLOR, IPC_LBF_COLOR);
                let ipc
                    = { dom_tools_t_load : dom_tools.TOOLS4_DEPLOYED
                      ,           caller : DOM_TOOLS_JS_TAG+".t_ipc_handle_start"
                    };
                dom_ipc.t_ipc_SEND( ipc );
            }

            return true;
        }
    }


    else {
        if( dom_ipc.t_ipc_is_IPC_SCRIPT_loaded() )
        {
            if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c UNLOADING "                            , IPC_LOG_COLOR, IPC_LBF_COLOR);

            dom_tools.t_unload();
        }
        else {
            if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c NOT YET LOADED"                        , IPC_LOG_COLOR, IPC_LBF_COLOR);

            dom_ipc.t_wait_for_startup_message_from_extension( DOM_TOOLS_JS_ID );
        }

        return true;
    }

};


let t_ipc_handle_theme = function(theme)
{
"use strict";
let log_this = IPC_LOG;
if(log_this) console.log("%c "+IPC_SCRIPT_ID+" %c t_ipc_handle_theme("+theme+")"                 , IPC_LOG_COLOR, IPC_LBA_COLOR);

    let t_theme = "theme_"+theme.toUpperCase();
if(log_this) console.log("%c "+DOM_LOAD_ID+" calling dom_load", IPC_LBH_COLOR+IPC_LF5_COLOR.lf5);
    dom_tools.prop_id_toggle( t_theme );
};




if(IPC_LOG) console.log("%c "+DOM_TOOLS_JS_ID+" LOADING DONE ", IPC_LBH_COLOR+IPC_LF5_COLOR.lf5);

let extension_signature
    = document.body.attributes[IPC_EXTENSION_ID]
    ? document.body.attributes[IPC_EXTENSION_ID].textContent
    : "";
if(IPC_LOG) console.log("%c["+IPC_EXTENSION_ID+"]%c = %c"+extension_signature, IPC_MSG_COLOR, IPC_LBA_COLOR, IPC_LBF_COLOR+IPC_LB0_COLOR);

if(IPC_LOG) console.log("%c "+DOM_TOOLS_JS_ID+" calling t_load", IPC_LBH_COLOR+IPC_LF5_COLOR.lf5);


dom_tools.t_load();




/*INLINE}}}*/
//@ sourceURL=dom_tools.js
`
 .replace(/\\/g,"\\\\")
)
 .replace(/%u/g,"\\u")
;
/*}}}*/

/** LOADER */
/* DATA STRING LITERALS {{{*/
/*{{{*/
/* @see script/dom_log.js */
const lbA  = "background-color:inherit;   color:inherit;";

const lbF  = "font-size:120%; font-weight:500; border:2px solid white;";
const lbb  = "font-size:150%; font-weight:900; margin:0 0 0 0;";
const lbB  = "font-size:300%; font-weight:900; margin:0 0 0 0;";
const lbS  = "font-size:800%; font-weight:900; margin:0 0 0 0;";

const lbH  = "font-weight:900; line-height:1.5em; border:1px solid gray; margin:   0 1ex 1ex   0; padding:0 .5em 0 .5em; border-radius:1em 1em 1em 1em; background:linear-gradient(to bottom, #000 0%, #223 50%, #000 100%);";
const lbL  = "font-weight:900; line-height:1.5em; border:1px solid gray; margin:   0   0   0 1ex; padding:0 .5em 0 .5em; border-radius:1em   0   0 1em; background:linear-gradient(to   left, #333 0%           ,#445 100%);";
const lbR  = "font-weight:900; line-height:1.5em; border:1px solid gray; margin:   0 1ex   0   0; padding:0 .5em 0 .5em; border-radius:  0 1em 1em   0; background:linear-gradient(to  right, #333 0%           ,#544 100%);";
const lbC  = "font-weight:900; line-height:1.5em; border:1px solid gray; margin:   0   0   0   0; padding:0 .5em 0 .5em; border-radius:  0   0   0   0;";

const lb1  = "background-color:#964B00; color:black;";
const lb2  = "background-color:#FF0000; color:black;";
const lb3  = "background-color:#FFA500; color:black;";
const lb4  = "background-color:#FFFF00; color:black;";
const lb5  = "background-color:#9ACD32; color:black;";
const lb6  = "background-color:#6495ED; color:black;";
const lb7  = "background-color:#EE82EE; color:black;";
const lb8  = "background-color:#A0A0A0; color:black;";
const lb9  = "background-color:#FFFFFF; color:black;";
const lb0  = "background-color:#000000; color:gray;";
const lbX = [ lb0 ,lb1 ,lb2 ,lb3 ,lb4 ,lb5 ,lb6 ,lb7 ,lb8 ,lb9 ];

const lf1  = "color:#964B00;";
const lf2  = "color:#FF0000;";
const lf3  = "color:#FFA500;";
const lf4  = "color:#FFFF00;";
const lf5  = "color:#9ACD32;";
const lf6  = "color:#6495ED;";
const lf7  = "color:#EE82EE;";
const lf8  = "color:#A0A0A0;";
const lf9  = "color:#FFFFFF;";
const lf0  = "color:#000000;";
const lfX = [ lf0 ,lf1 ,lf2 ,lf3 ,lf4 ,lf5 ,lf6 ,lf7 ,lf8 ,lf9 ];

/*}}}*/
/*➔ dom_load {{{*/
let dom_load = function() /* eslint-disable-line complexity */
{
let log_this = IPC_LOG;
if( log_this) console.log(DOM_LOAD_ID+": LOADING DATA");
if( log_this) console.log(DOM_LOAD_ID+": document.contentType=["+document.contentType+"]");
/*{{{
}}}*/
/*
let csp = document.querySelectorAll("[http-equiv='Content-Security-Policy']")[0];
if( csp ) {
    console.log("%c"+csp.content, "font-size:200%; background-color:navy");
    csp.httpEquiv = "Content-Security-Policy";
    csp.content   = "default-src 'self' 'unsafe-inline' http://* https://* file://* data://*";
}
*/

    let dom_load_success = true; /* the optimist at work */
    try {
if( log_this) console.log(DOM_LOAD_ID+": LOADING DATA .. try");
if( log_this) window.addEventListener("error", load_onerror, false);

        if(    dom_load_success && !load_html  ( "dom_tools_html" , dom_tools_html_data ) ) dom_load_success = false;

        if(    dom_load_success && document.contentType.includes("XXXxml") ) {
            if(dom_load_success && !load_css_pi( DOM_HOST_CSS_ID  , dom_host_css_data   ) ) dom_load_success = false;
            if(dom_load_success && !load_css_pi( DOM_TOOLS_CSS_ID , dom_tools_css_data  ) ) dom_load_success = false;
        }
        else {
            if(dom_load_success && !load_css   ( DOM_HOST_CSS_ID  , dom_host_css_data   ) ) dom_load_success = false;
            if(dom_load_success && !load_css   ( DOM_GRID_CSS_ID  , dom_grid_css_data   ) ) dom_load_success = false;
            if(dom_load_success && !load_css   ( DOM_TOOLS_CSS_ID , dom_tools_css_data  ) ) dom_load_success = false;
        }

        if(    dom_load_success && !load_js    ( "dom_data_js"    , dom_data_js_data    ) ) dom_load_success = false;

        if(    dom_load_success && !load_js    ( "dom_log_js"     , dom_log_js_data     ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_popup_js"   , dom_popup_js_data   ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_util_js"    , dom_util_js_data    ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_i18n_js"    , dom_i18n_js_data    ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_prop_js"    , dom_prop_js_data    ) ) dom_load_success = false;

        if(    dom_load_success && !load_js    ( "dom_store_js"   , dom_store_js_data   ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_fly_js"     , dom_fly_js_data     ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_wording_js" , dom_wording_js_data ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_select_js"  , dom_select_js_data  ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_slot_js"    , dom_slot_js_data    ) ) dom_load_success = false;

        if(    dom_load_success && !load_js    ( "dom_hide_js"    , dom_hide_js_data    ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_view_js"    , dom_view_js_data    ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_sticky_js"  , dom_sticky_js_data  ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_seek_js"    , dom_seek_js_data    ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_share_js"   , dom_share_js_data   ) ) dom_load_success = false;

        /*......................*/  load_js    ( "dom_details_js" , dom_details_js_data ) ;  /* POSSIBLY PRELOADED */
        /*......................*/  load_js    ( "dom_wot_js"     , dom_wot_js_data     ) ;  /* POSSIBLY PRELOADED */
        if(    dom_load_success && !load_js    ( "dom_sentence_js", dom_sentence_js_data) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_grid_js"    , dom_grid_js_data    ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_gutter_js"  , dom_gutter_js_data  ) ) dom_load_success = false;

        if(    dom_load_success && !load_js    ( "dom_ipc_js"     , dom_ipc_js_data     ) ) dom_load_success = false;
        if(    dom_load_success && !load_js    ( "dom_tools_js"   , dom_tools_js_data   ) ) dom_load_success = false;
    }
    catch(ex) {
if( log_this) console.log(DOM_LOAD_ID+": LOADING DATA .. catch");
        console.dir(ex);
        dom_load_success = false;
    }
    finally {
if( log_this) console.log(DOM_LOAD_ID+": LOADING DATA .. finally");
if( log_this) window.removeEventListener("error", load_onerror, false);
    }
if( log_this) console.log(DOM_LOAD_ID+": LOADING DATA .. [dom_load_success = "+dom_load_success+"]");
    return dom_load_success;
};
/*}}}*/
/*… load_onerror {{{*/
let load_onerror_count = 0;
let load_onerror = function(e)
{
    console.log("%c "+DOM_LOAD_TAG      +" %c * load_onerror #"+(++load_onerror_count)
                ,"background-color:#111",  "background-color:#500"                    );
    console.dir( e  );

    if( e.error          ) try { console.log("e.error..."+ e.error  ); } catch(ex) { console.log(ex); }
    if( e.message        ) try { console.log("e.message."+ e.message); } catch(ex) { console.log(ex); }
    if( e.name           ) try { console.log("e.name...."+ e.name   ); } catch(ex) { console.log(ex); }
    if( e.type != "error") try { console.log("e.type...."+ e.type   ); } catch(ex) { console.log(ex); }
    if( e.target         ) try { console.log(              e.target ); } catch(ex) { console.log(ex); }
};
/*}}}*/
/*… dom_check_scheme_arg {{{*/
/*{{{*/
const DOM_DATA_LENGTH_MIN = 100;
const TOOLS2_SANITY_CHECK_FAILED = "TOOLS SANITY CHECK FAILED";

/*}}}*/
let dom_check_scheme_arg = function(caller, scheme_id, scheme_arg)
{
let log_this = IPC_LOG;
    let is_file    =             scheme_arg.startsWith("file:");
    let is_content = !is_file || scheme_arg.startsWith("data:");

    /* unchecked content */
    if( !is_content ) {
if( log_this) console.log("__"+caller+": %c "+scheme_id+" = "+scheme_arg, lf5);
        return true;
    }

if( log_this) console.log("__"+caller+": %c "+scheme_id+" = "+scheme_arg.length+" bytes", lf5);

    if(scheme_arg.length > DOM_DATA_LENGTH_MIN) {
        return true;
    }
    else {
console.log("%c *** "+TOOLS2_SANITY_CHECK_FAILED+"%c on %c"+scheme_id+" ", lbb+lbL+lf2, lbL+lf8, lbR+lf3);

        /* share failure diagnostic */
        if(typeof send_IPC != "undefined")
        {
            let msg = DOM_LOAD_ID+": \""+scheme_id+"\" "+TOOLS2_SANITY_CHECK_FAILED;
            let ipc = { t_load:msg, caller:DOM_LOAD_TAG };
            send_IPC( ipc );
        }

        return false;
    }
};
/*}}}*/
/*… load_js {{{*/
let load_js = function(id, scheme_arg) {
    if( !dom_check_scheme_arg("load_js", id, scheme_arg) ) { console.log("%c"+id+" %c BAD SCHEME ARG",lbL+lf2, lbR+lf2); return false; }
    if( document.getElementById(id)                      ) { console.log("%c"+id+" %c already loaded",lbL+lf3, lbR+lf3); return false; }
    let el           = document.createElement("script");
    el.id            = id;

    el.src           = scheme_arg;
    el.type          = "text/javascript";
    el.charset       = "utf-8";
    el.async         = false;
    el.defer         = true;
    el.addEventListener("error", load_onerror);

    document.getElementsByTagName("head")[0].appendChild(el);

    return true;
};
/*}}}*/
/*… load_css {{{*/
let load_css = function(id, scheme_arg) {
    if( !dom_check_scheme_arg("load_css", id, scheme_arg) ) { console.log("%c"+id+" %c BAD SCHEME ARG",lbL+lf2, lbR+lf2); return false; }
    if( document.getElementById(          id            ) ) { console.log("%c"+id+" %c already loaded",lbL+lf3, lbR+lf3); return false; }
    let el           = document.createElement("link");
    el.id            = id;

    el.href          = scheme_arg;
    el.type          = "text/css";
    el.charset       = "utf-8";
    el.rel           = "stylesheet";
    el.addEventListener("error", load_onerror);

    document.getElementsByTagName("head")[0].appendChild(el);

    return true;
};
/*}}}*/
/*… load_css_pi {{{*/
let load_css_pi = function(id, scheme_arg) {
    if( !dom_check_scheme_arg("load_css_pi", id, scheme_arg) ) { console.log("%c"+id+" %c BAD SCHEME ARG",lbL+lf2, lbR+lf2); return false; }
    if( document.getElementById(             id            ) ) { console.log("%c"+id+" %c already loaded",lbL+lf3, lbR+lf3); return false; }
    let el           = document.createProcessingInstruction("xml-stylesheet", "href='"+ scheme_arg +"' type='text/css'");
    el.id            = id;

    el.charset       = "utf-8";
    el.addEventListener("error", load_onerror);

    document.insertBefore(el, document.firstChild);

    return true;
};
/*}}}*/
/*… load_html {{{*/
let load_html = function(id, html) {
    if( !dom_check_scheme_arg("load_html", id, html) ) { console.log("%c"+id+" %c BAD SCHEME ARG",lbL+lf2, lbR+lf2); return false; }
    if( document.getElementById(           id      ) ) { console.log("%c"+id+" %c already loaded",lbL+lf3, lbR+lf3); return false; }
    let el           = document.createElement("DIV");
    el.id            = id;

    el.charset       = "utf-8";
    el.innerHTML     = unescape(html);
    el.style.display = "none";
    el.addEventListener("error", load_onerror);

    document.body.appendChild (el);

    return true;
};
/*}}}*/
/*… get_el_sheet_first_rule_text_content {{{*/
let get_el_sheet_first_rule_text_content = function(el)
{
    let tag = "";
    try {
        if( el) {
            let txt = el.sheet.cssRules[0].cssText;
            let x_1 = txt.indexOf    ('"'); /* eslint-disable-line quotes */
            let x_2 = txt.lastIndexOf('"'); /* eslint-disable-line quotes */
            txt     = txt.substring(x_1+1, x_2);
            tag     = txt.includes(el.id) ? "SHEET: "+txt : "";
        }
    }
    catch(ex) {
        console.log("%c get_el_sheet_first_rule_text_content("+el.id+"):"+ ex, lbH+lf2);
    }
    return tag;
};
/*}}}*/
/*}}}*/

/** IPC */
/*{{{*/
/*{{{*/
let IPC_LOG          = true;
let IPC_EXTENSION_ID = "background_js";
let IPC_SCRIPT_ID    = DOM_LOAD_ID;
let IPC_LOG_COLOR    = lb4;
let IPC_MSG_COLOR    = lbF+IPC_LOG_COLOR;
/*}}}*/
/*… t_handle_ipc_message {{{*/
let t_handle_ipc_message = function(ipc)
{
let log_this = IPC_LOG;
if( log_this) console.log("%c "+IPC_SCRIPT_ID+" %c t_handle_ipc_message(ipc)"                        , IPC_LOG_COLOR, lbA);

    /* 1/3 - ALREADY LOADED {{{*/
    if( dom_ipc.t_ipc_is_IPC_SCRIPT_loaded() )
    {
if( log_this) console.log("%c "+IPC_SCRIPT_ID+" %c SCRIPT ALREADY LOADED"                            , IPC_LOG_COLOR, lbF);

        return true;
    }
    /*}}}*/
    /* 2/3 - NOT STARTED BY IPC MESSAGE {{{*/
    if(    (typeof ipc.start == "undefined")
        || (       ipc.start != "ON"       )
    ) {
if( log_this) console.log("%c "+IPC_SCRIPT_ID+" %c NOT STARTED BY IPC MESSAGE "                      , IPC_LOG_COLOR, lbF);

        dom_ipc.t_wait_for_startup_message_from_extension( IPC_SCRIPT_ID );
        return false;
    }
    /*}}}*/
    /* 3/3 - HANDLE A START UP MESSAGE .. (stop listening and load script) {{{*/
if( log_this) console.log("%c "+IPC_SCRIPT_ID+" %c STARTED BY IPC MESSAGE "                          , IPC_LOG_COLOR, lbF);

    /* STOP LISTENING IPC MESSAGES */
    if(dom_ipc.t_ipc_listener_id)
    {
        dom_ipc.t_ipc_del_message_listener();
        dom_ipc.t_ipc_del_MutationObserver();
        dom_ipc.t_ipc_listener_id = null;

    }
    /* AND LOAD SCRIPT */
if( log_this) console.log("%c "+DOM_LOAD_ID+" calling "+DOM_LOAD_TAG, lbH+lf5);

    if( dom_load(DOM_LOAD_ID) )
    {
        if( dom_ipc.t_ipc_is_IPC_SCRIPT_loaded() )
            dom_ipc.t_wait_for_startup_message_from_extension( IPC_SCRIPT_ID );

    }
    /*}}}*/
    return false;
};

/*}}}*/
/*}}}*/

/* STAND-ALONE OR EXTENSION */
/*{{{*/
/*… IPC_check_extension_signature {{{*/
let           extension_signature = "";
let IPC_check_extension_signature = function()
{
let log_this = IPC_LOG;
    /* BODY-ATTR [IPC_EXTENSION_ID] .. (a body attribute set by a browser extension) {{{*/
    if(typeof document.body.attributes[IPC_EXTENSION_ID] != "undefined")
    {
        let         lxx = "font-size:800%; color:#6495ED;";
        let SYMBOL_GEAR = "\u2699";
if( log_this) console.log("%c"+SYMBOL_GEAR+" %c"+IPC_SCRIPT_ID+" %c EXTENSION SIGNATURE DETECTED", lxx, IPC_LOG_COLOR, lbF);

        extension_signature = document.body.attributes[IPC_EXTENSION_ID].textContent;

if( log_this) console.log("%c["+IPC_EXTENSION_ID+"]%c = %c"+extension_signature, IPC_MSG_COLOR, lbA, lbF+lb0);
    }
    /*}}}*/
    /* EXTENSION SIGNATURE DETECTED .. (wait for a startup-message) {{{*/
    if(extension_signature)
    {
        if(typeof dom_ipc == "undefined")
        {
            dom_load(DOM_LOAD_ID);
        }
        else {
            let ipc = dom_ipc.t_get_IPC( extension_signature );
            t_handle_ipc_message(ipc);
        }
    }
    /*}}}*/
    /* EXTENSION SIGNATURE NOT FOUND .. (stand-alone instant load) {{{*/
    else {
if( log_this) console.log("%c "+IPC_SCRIPT_ID+" %c NO EXTENSION DETECTED: STAND-ALONE INSTANT LOAD " , IPC_LOG_COLOR        , lbF);
        if     (typeof   t_load != "undefined") { if( log_this) console.log("%c "+DOM_LOAD_ID+" calling %c   t_load"        , lbH+lf5, lbH+lf6);   t_load(DOM_LOAD_ID); }
        else if(typeof dom_load != "undefined") { if( log_this) console.log("%c "+DOM_LOAD_ID+" calling %c "+DOM_LOAD_TAG+"", lbH+lf5, lbH+lf7); dom_load(DOM_LOAD_ID); }
        else                                                    console.log("%c "+DOM_LOAD_ID+" %c t_load and dom_load are both undefined",IPC_LOG_COLOR,lbF+lb2);
    }
    /*}}}*/
};
/*}}}*/

    if(IPC_LOG) console.log("%c "+DOM_LOAD_ID+" LOADING DONE ", lbH+lf5);
    if(IPC_LOG) console.log("%c "+DOM_LOAD_ID+" %c ...setTimeout(IPC_check_extension_signature, 2000) ", IPC_LOG_COLOR,lbF+lb0);
/*{{{
let calling_IPC_check_extension_signature
    =  (typeof   t_load == "undefined")
    && (typeof dom_load == "undefined");
console.log("%c "+DOM_LOAD_ID+" %c          t_load: "+((typeof   t_load        == "undefined") ? "DEFINED" : "UNDEFINED"), lbH+lf5, lbH+lf5);
console.log("%c "+DOM_LOAD_ID+" %c        dom_load: "+((typeof dom_load        == "undefined") ? "DEFINED" : "UNDEFINED"), lbH+lf5, lbH+lf6);
console.log("%c "+DOM_LOAD_ID+" %c DOM_TOOLS_JS_ID: "+((typeof DOM_TOOLS_JS_ID == 'undefined') ? "DEFINED" : "UNDEFINED"), lbH+lf5, lbH+lf7);
console.log("%c "+DOM_LOAD_ID+" %c calling_IPC_check_extension_signature=["+calling_IPC_check_extension_signature+"]"    , lbH+lf5, lbH+lf3);
if( calling_IPC_check_extension_signature )
    console.log("calling IPC_check_extension_signature:");
}}}*/
    setTimeout(IPC_check_extension_signature, 1000);

/*}}}*/
return null;
})();

/*{{{
"┌─────────────────────────────────────────────────────────────────────────────┐
"│                                                                             │
:e  $BROWSEEXT/SplitterExtension/manifest.json

:e  $BROWSEEXT/SplitterExtension/javascript/background.js
:e  $BROWSEEXT/SplitterExtension/javascript/content.js
:e             $RPROFILES/script/dom_sentence.js
:e             $RPROFILES/script/stub/dom_sentence_event.js
:e             $RPROFILES/script/stub/dom_scroll.js
:e             $RPROFILES/script/stub/dom_sentence_util.js
:e             $RPROFILES/script/stub/dom_log.js
:e             $RPROFILES/stylesheet/dom_host.css

:e             $RPROFILES/script/dom_select.js
:e             $RPROFILES/script/dom_util.js
:e             $RPROFILES/script/dom_log.js

:e             $RPROFILES/script/splitter.js
"...           $RPROFILES/script/dom_load.js
"│                                                                             │
"└─────────────────────────────────────────────────────────────────────────────┘
}}}*/
